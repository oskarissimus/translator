#
msgid ""
msgstr ""
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "chapters.a_bit_more_about_strings.title"
msgstr "Trochę więcej o łańcuchach znaków"

msgid "chapters.boolean operators.title"
msgstr "Operatory logiczne"

msgid "chapters.dictionaries.title"
msgstr "Słowniki"

msgid "chapters.for_loops.title"
msgstr "Pętle for"

msgid "chapters.functions.title"
msgstr "Funkcje"

msgid "chapters.if_statements.title"
msgstr "Instrukcje warunkowe"

msgid "chapters.lists.title"
msgstr "Listy"

msgid "chapters.nested_loops.title"
msgstr "Zagnieżdżone pętle"

msgid "chapters.string_basics.title"
msgstr "Podstawy łańcuchów znaków"

msgid "chapters.the_shell.title"
msgstr "Powłoka systemowa"

msgid "chapters.tic_tac_toe_project.title"
msgstr "Projekt gry w kółko i krzyżyk"

msgid "chapters.variables.title"
msgstr "Zmienne"


msgid "frontend.are_you_sure"
msgstr "Czy na pewno?"

msgid "frontend.ask_for_help"
msgstr "Poproś o pomoc"

msgid "frontend.assessment"
msgstr "Ocena"

msgid "frontend.assessment_description"
msgstr ""
"Gdy uruchomisz kod, który nie przechodzi obecnego kroku, ta sekcja *czasami*"
" wyjaśni co jest nie tak."

msgid "frontend.assessment_lint"
msgstr "Znaleziono następujące ogólne problemy w twoim kodzie:"

msgid "frontend.assessment_passed_tests"
msgstr "Plusy są takie, że twój kod przeszedł ${num} testy/ów!"

msgid "frontend.cancel"
msgstr "Anuluj"

msgid "frontend.chat_on_slack"
msgstr "Czatuj na Slacku"

msgid "frontend.click_for_error_details"
msgstr "Kliknij, aby zobaczyć szczegóły błędu"

msgid "frontend.click_to_expand"
msgstr "Kliknij, aby rozwinąć"

msgid "frontend.contact_directly"
msgstr "Alternatywnie możesz skontaktować się z nami bezpośrednio:"

msgid "frontend.copy_warning"
msgstr ""
"**STOP!**\n"
"\n"
"Postaraj się unikać kopiowania kodu. Będziesz lepiej uczyć się, przyswajać i pamiętać, jeśli wpiszesz kod samodzielnie.\n"
"\n"
"Kiedy kopiowanie jest odpowiednie, będzie przycisk, który ułatwi to zadanie. Jeśli nie ma przycisku, postaraj się wpisywać kod.\n"
"\n"
"Cóż, nie będziemy cię zmuszać. Skopiuj, jeśli naprawdę chcesz."

msgid "frontend.copying_solution_not_allowed"
msgstr "Kopiowanie z obszaru podpowiedzi/rozwiązania nie jest dozwolone!"

msgid "frontend.current_page"
msgstr "(obecna strona)"

msgid "frontend.description"
msgstr "Opis"

msgid "frontend.developer_mode"
msgstr "Tryb deweloperski"

msgid "frontend.developer_mode_description"
msgstr "Aktywuje przyciski „Cofnij krok” i „Pomiń krok”."

msgid "frontend.did_you_mean"
msgstr "Czy miałeś na myśli..."

msgid "frontend.error_has_been_reported"
msgstr "Błąd został zgłoszony."

msgid "frontend.error_traceback"
msgstr "Traceback błędu:"

msgid "frontend.exercise_requirement"
msgstr ""
"Ten krok to ćwiczenie. Musisz wymyślić kod, który da poprawny wynik. Możliwe"
" są wiele różnych poprawnych odpowiedzi."

msgid "frontend.exercise_stdin"
msgstr ""
"Twój program musi otrzymać dane wejściowe od użytkownika poprzez funkcję "
"„input()”. Podczas testowania poprawności różne dane wejściowe użytkownika "
"zostaną zasymulowane."

msgid "frontend.feedback"
msgstr "Opinia"

msgid "frontend.feedback_email_placeholder"
msgstr "Email (opcjonalnie)"

msgid "frontend.function_exercise"
msgstr ""
"Zdefiniuj funkcję, zaczynając od:\n"
"\n"
"${header}\n"
"\n"
"Następnie wypełnij wcięte ciało własną implementacją.\n"
"\n"
"Funkcja będzie wywołana z różnymi argumentami, aby przetestować, czy generalnie działa. Możesz także sam wywołać funkcję, aby ją przetestować podczas pracy, ale nie wpłynie to na ocenę."

msgid "frontend.function_exercise_goal"
msgstr "Twoja funkcja musi `${print_or_return}` poprawny wynik."

msgid "frontend.get_another_hint"
msgstr "Uzyskaj kolejną podpowiedź"

msgid "frontend.get_hint"
msgstr "Uzyskaj podpowiedź"

msgid "frontend.give_feedback"
msgstr "Przekaż opinię"

msgid "frontend.give_feedback_from_menu"
msgstr "Przekaż opinię z menu w lewym górnym rogu."

msgid "frontend.give_feedback_instructions"
msgstr ""
"Powiedz nam, co lubisz lub czego nie lubisz! Jeśli zgłaszasz błąd, podaj szczegółowy opis problemu:\n"
"\n"
"- Co robiłeś przed i kiedy problem się pojawił?\n"
"- Jakie kroki można podjąć, aby go odtworzyć?\n"
"- Co obserwujesz i co według ciebie powinno się stać zamiast tego?"

msgid "frontend.hidden_solution_instructions"
msgstr ""
"Powyżej znajduje się przykładowe rozwiązanie, ale jest ukryte. Klikaj "
"przycisk „Odsłoń” wielokrotnie, aby odsłaniać rozwiązanie kawałek po "
"kawałku. Postaraj się zatrzymać, kiedy pomyślisz, że odsłoniłeś "
"wystarczająco i możesz sam uzupełnić pozostałe luki. Następnie wpisz "
"rozwiązanie w edytorze i uruchom je. Twoje rozwiązanie nie musi być takie "
"samo jak powyżej."

msgid "frontend.hints_and_solution"
msgstr "Podpowiedzi i Rozwiązanie"

msgid "frontend.hints_progress"
msgstr "Pokazane ${numHints} z ${totalHints} podpowiedzi"

msgid "frontend.internal_error_start"
msgstr "Ups, coś poszło nie tak! ${maybeErrorReported} Oto co możesz zrobić:"

msgid "frontend.loading_wait"
msgstr "Ładowanie..."

msgid "frontend.login_or_sign_up"
msgstr "Zaloguj się / Zarejestruj"

msgid "frontend.new"
msgstr "Nowy"

msgid "frontend.next"
msgstr "Dalej"

msgid "frontend.no"
msgstr "Nie"

msgid "frontend.no_hints_available"
msgstr ""
"Do tego kroku nie ma żadnych podpowiedzi. Spróbuj ponownie przeczytać "
"instrukcje i wymagania. Nadal możesz sprawdzić rozwiązanie, jeśli jesteś "
"naprawdę zablokowany."

msgid "frontend.no_input_variables"
msgstr "To ćwiczenie nie ma zmiennych wejściowych."

msgid "frontend.non_function_exercise"
msgstr ""
"Twój kod *musi* zacząć się od przypisania wartości do zmiennych wejściowych, np:\n"
"\n"
"${inputs}\n"
"\n"
"Wartości to tylko przykłady, możesz wybrać inne. Twój kod zostanie automatycznie przetestowany z różnymi wartościami, aby sprawdzić, czy działa w ogólności."

msgid "frontend.ok"
msgstr "OK"

msgid "frontend.open_github_issue"
msgstr "Otwórz issue na GitHubie"

msgid "frontend.output_prediction_correct"
msgstr "Poprawnie!"

msgid "frontend.output_prediction_error_choice"
msgstr "Błąd"

msgid "frontend.output_prediction_question"
msgstr "Jak myślisz, jaki będzie wynik?"

msgid "frontend.output_prediction_wrong_once"
msgstr "Ups, to nie jest prawidłowa odpowiedź. Możesz spróbować jeszcze raz!"

msgid "frontend.output_prediction_wrong_twice"
msgstr "Niestety, zła odpowiedź. Spróbuj ponownie następnym razem!"

msgid "frontend.parsons_solution_instructions"
msgstr ""
"Powyżej znajduje się przykładowe rozwiązanie z nieuporządkowanymi liniami. "
"Możesz je przeciągać, aby je posortować. Znalezienie poprawnej kolejności "
"zależy od ciebie, nie powiemy ci, czy masz rację. Eksperymentowanie i "
"uruchamianie częściowych rozwiązań w edytorze może ci pomóc to rozgryźć. "
"Nadal musisz wpisać poprawne rozwiązanie w edytorze i uruchomić je, aby "
"kontynuować."

msgid "frontend.previous"
msgstr "Wstecz"

msgid "frontend.program_in_text"
msgstr ""
"Dokładny kod, który musisz uruchomić, jest pokazany w tekście powyżej."

msgid "frontend.question_wizard"
msgstr "Kreator Pytań"

msgid "frontend.question_wizard_expected_output"
msgstr ""
"Dobrze, teraz wpisz poniżej wynik, którego oczekujesz/chcesz otrzymać od swojego programu. Co by wyświetlił, gdyby działał poprawnie? Jeśli nie ma nic wyświetlać, dodaj do swojego kodu kilka wywołań funkcji `print()`, aby wyświetlił coś użytecznego.\n"
"\n"
"When you're done, click 'Run' again to generate your question."

msgid "frontend.question_wizard_intro"
msgstr ""
"Jeśli potrzebujesz pomocy, istnieje wiele stron takich jak [Stack Overflow](https://stackoverflow.com/) i [reddit](https://www.reddit.com/r/learnpython/), gdzie możesz zadawać pytania. To narzędzie pomoże ci napisać dobrej jakości pytanie, które prawdopodobnie uzyska odpowiedzi.\n"
"\n"
"Wpisz i uruchom swój kod po prawej stronie. Jeśli nie masz żadnego kodu, bo nie wiesz od czego zacząć, obawiam się, że to narzędzie nie może ci pomóc. Nadal możesz prosić o pomoc, ale warto najpierw przeczytać [Jakich pytań należy unikać?](https://stackoverflow.com/help/dont-ask)\n"
"\n"
"Jeśli twoje pytanie dotyczy serwerów (np. Django lub Flask), żądań sieciowych, baz danych lub pakietu, który nie może być zaimportowany tutaj, to narzędzie nie będzie działać. Jednak tylko dlatego, że twój obecny kod *obejmuje* te rzeczy, nie oznacza, że o to chodzi w twoim pytaniu. Jeśli masz ogólny problem z Pythonem/programowaniem/logiką, wyizoluj go. Python z Django to wciąż Python. Jeśli nie możesz tego zrobić, przeczytaj [Jak stworzyć Minimalny, Powtarzalny Przykład](https://stackoverflow.com/help/minimal-reproducible-example) przed zadaniem pytania."

msgid "frontend.refresh_and_try_again"
msgstr "Odśwież stronę i spróbuj ponownie."

msgid "frontend.repeated_frames_description"
msgstr "${name} w linii ${lineno} (${count} razy)"

msgid "frontend.requirements"
msgstr "Wymagania"

msgid "frontend.requirements_description"
msgstr ""
"Musisz uruchomić kod zgodnie z instrukcjami powyżej. Na wypadek, gdyby te "
"nie były wystarczająco jasne, oto pewne dodatkowe wyjaśnienia:"

msgid "frontend.reveal"
msgstr "Odsłoń"

msgid "frontend.reverse_step"
msgstr "Cofnij krok"

msgid "frontend.run"
msgstr "Uruchom"

msgid "frontend.send_email_to"
msgstr "Email"

msgid "frontend.settings"
msgstr "Ustawienia"

msgid "frontend.show_shuffled_solution"
msgstr "Pokaż pomieszane rozwiązanie"

msgid "frontend.show_solution"
msgstr "Pokaż rozwiązanie"

msgid "frontend.show_unscrambled_solution"
msgstr "Pokaż niepomieszane rozwiązanie"

msgid "frontend.sign_out"
msgstr "Wyloguj"

msgid "frontend.similar_frames_skipped"
msgstr "Pominięte podobne ramki:"

msgid "frontend.skip_step"
msgstr "Pomiń krok"

msgid "frontend.stop"
msgstr "Zatrzymaj"

msgid "frontend.submit"
msgstr "Zatwierdź"

msgid "frontend.table_of_contents"
msgstr "Spis treści"

msgid "frontend.title"
msgstr "Tytuł"

msgid "frontend.toc_instructions"
msgstr ""
"Poniżej znajdują się linki do różnych stron kursu. Możesz zacząć od dowolnego miejsca i iść w dowolnej kolejności, a Twój postęp na każdej stronie będzie rejestrowany.\n"
"\n"
"Jeśli jesteś całkowicie nowy w programowaniu, lub masz wątpliwości, po prostu zacznij od początku i klikaj Następny, gdy skończysz każdą stronę."

msgid "frontend.try_running_code_again"
msgstr "Spróbuj uruchomić kod ponownie."

msgid "frontend.try_using_different_browser"
msgstr "Spróbuj użyć innej przeglądarki."

msgid "frontend.verbatim"
msgstr ""
"Ten krok ma tylko jedną poprawną odpowiedź. Musisz uruchomić dokładnie "
"poprawny kod, więc sprawdź dokładnie swoją pisownię. Tylko kilka rodzajów "
"szczegółów (takich jak spacje w niektórych miejscach) zostanie "
"zignorowanych, ponieważ nie robią one różnicy dla programu."

msgid "frontend.yes"
msgstr "Tak"

msgid "linting_messages.pyflakes.ImportShadowedByLoopVar.message_format"
msgstr ""
"**Import `{0}` jest przesłonięty przez zmienną pętli**\n"
"\n"
"Należy zmienić nazwę zmiennej pętli `{0}`, ponieważ przedefiniowuje ona wcześniej zaimportowany moduł `{0}`.\n"
"Wybierz inną nazwę zmiennej pętli, aby uniknąć tego błędu."

msgid "linting_messages.pyflakes.ImportStarNotPermitted.message_format"
msgstr ""
"**Import przy użyciu `*` **\n"
"\n"
"Użycie konstrukcji `from {0} import *` powoduje zaimportowanie wszystkiego z modułu `{0}` do bieżącej przestrzeni nazw.\n"
"Tworzy to wiele niewidocznych, nieznanych zmiennych.\n"
"Utrudnia to czytanie i rozumienie kodu oraz ustalenie skąd pochodzą poszczególne elementy.\n"
"\n"
"Unikaj tego rodzaju importu i zamiast tego dokładnie zaimportuj tylko te nazwy, których potrzebujesz."

msgid "linting_messages.pyflakes.IsLiteral.message_format"
msgstr ""
"**Porównanie `is` z literałem**\n"
"\n"
"Użyto operatora `is`/`is not` do porównania z literałem (np. ciąg znaków lub liczba).\n"
"Zamiast tego powinno się użyć operatora `==` / `!=`.\n"
"\n"
"Operator `is` sprawdza, czy dwie wyrażenia odnoszą się do dokładnie tego samego obiektu.\n"
"Rzadko chcesz go używać, zwłaszcza w przypadku podstawowych typów danych, takich jak ciągi znaków i liczby.\n"
"W takich przypadkach wydaje się, że czasami działa (np. dla małych liczb) i tajemniczo\n"
"zawodzi przy innych okazjach."

msgid "linting_messages.pyflakes.MultiValueRepeatedKeyLiteral.message_format"
msgstr ""
"**Klucz słownika `{0}` został powtórzony z różnymi wartościami**\n"
"\n"
"Słownik nie może mieć wielu wpisów dla tego samego klucza.\n"
"Sprawdź ponownie swój kod i zmień powtarzający się klucz na coś unikalnego."

msgid "linting_messages.pyflakes.RedefinedWhileUnused.message_format"
msgstr ""
"**Przedefiniowano `{0}` bez jego użycia**\n"
"\n"
"Zdefiniowałeś `{0}` w linii `{1}`, ale zanim go użyłeś, zdefiniowałeś go ponownie,\n"
"nadpisując oryginalną definicję.\n"
"\n"
"Ogólnie twoje funkcje i klasy powinny mieć różne nazwy.\n"
"Sprawdź, czy używasz wszystkiego co zdefiniowałeś, np. czy wywołałeś swoje funkcje."

msgid "linting_messages.pyflakes.UnusedImport.message_format"
msgstr ""
"**Niewykorzystany import `{0}`**\n"
"\n"
"Zaimportowałeś `{0}`, ale go nie użyłeś. Czy zapomniałeś go użyć?\n"
"Może użyłeś w jego miejsce błędnej zmiennej? Jeśli nie potrzebujesz importu, po prostu go usuń."

msgid "linting_messages.pyflakes.UnusedVariable.message_format"
msgstr ""
"**Niewykorzystana zmienna `{0}`**\n"
"\n"
"Zdefiniowałeś zmienną `{0}`, ale nigdy jej nie użyłeś. Czy zapomniałeś jej użyć?\n"
"Może użyłeś w jej miejsce błędnej zmiennej? Jeśli nie potrzebujesz jej, po prostu ją usuń."


msgid "misc_terms.blank_result"
msgstr "<pusto>"

msgid "misc_terms.case_sensitive"
msgstr ""
"Python jest wrażliwy na wielkość liter (ang. *case sensitive*)! Oznacza to, że małe i wielkie "
"litery są ważne i ich zmiana zmienia znaczenie programu. Ciągi znaków "
"`'hello'` i `'Hello'` są różne, podobnie jak nazwy zmiennych `word` i "
"`Word`."

msgid "misc_terms.code_should_start_like"
msgstr ""
"Twój kod powinien zaczynać się tak:\n"
"\n"
"{expected_start}\n"

msgid "misc_terms.copy_button"
msgstr "Kopiuj"

msgid "misc_terms.disallowed_default_label"
msgstr "więcej niż {max_count} {label}"

msgid "misc_terms.disallowed_default_message"
msgstr ""
"Brawo, znalazłeś rozwiązanie! Jednakże, dla tego ćwiczenia i twojej nauki, "
"nie wolno ci używać {label}."

msgid "misc_terms.expected_mode_birdseye"
msgstr "Mając swój kod w edytorze, kliknij przycisk `birdseye`."

msgid "misc_terms.expected_mode_pythontutor"
msgstr "Mając swój kod w edytorze, kliknij przycisk Python Tutor."

msgid "misc_terms.expected_mode_shell"
msgstr "Wpisz swój kod bezpośrednio w shell po `>>>` i wciśnij Enter."

msgid "misc_terms.expected_mode_snoop"
msgstr "Mając swój kod w edytorze, kliknij przycisk `snoop`."

msgid "misc_terms.incorrect_mode"
msgstr "Kod jest poprawny, ale nie został uruchomiony zgodnie z instrukcją."

msgid "misc_terms.invalid_inputs"
msgstr ""
"Wartości twoich zmiennych wejściowych są niepoprawne, spróbuj użyć wartości "
"podobnych do przykładu."

msgid "misc_terms.must_define_function"
msgstr "Musisz zdefiniować funkcję `{function_name}`"

msgid "misc_terms.no_more_test_inputs"
msgstr ""
"Nie ma więcej testowych danych wejściowych - rozwiązanie powinno się już "
"zakończyć"

msgid "misc_terms.not_a_function"
msgstr "`{function_name}` nie jest funkcją."

msgid "misc_terms.q_wiz_debugger"
msgstr ""
"Świetnie, że używasz debugera! Rozwiązanie problemu samodzielnie jest "
"idealne. Jeśli nie możesz, użyj przycisku 'Run', aby wygenerować pytanie."

msgid "misc_terms.q_wiz_final_message"
msgstr ""
"\n"
"Świetnie! Oto kilka końcowych wskazówek:\n"
"\n"
"- Upewnij się, że wynik pokazuje problem, który masz, a nie coś innego.\n"
"- Zredukuj swój kod do **minimalnego** przykładu. Usuń wszelki kod, który nie jest bezpośrednio związany z problemem.\n"
"- Przeprowadź swój kod przez debugery `snoop`, `birdseye` i Python Tutor, aby zrozumieć, co robi.\n"
"- Poszukaj rozwiązania swojego problemu w internecie.\n"
"- Przeczytaj [Jak zadać dobre pytanie?](https://stackoverflow.com/help/how-to-ask)\n"
"\n"
"Jeśli jesteś naprawdę gotowy, skopiuj i wklej poniższe na stronę z pytaniem,\n"
"i zastąp pierwszą linię opisem swojego problemu.\n"
"\n"
"Możesz nadal zmieniać swój kod lub oczekiwany wynik i kliknąć Run ponownie, aby wygenerować pytanie na nowo.\n"
"\n"
"    __copyable__\n"
"    *Wyjaśnij, co próbujesz zrobić i dlaczego*\n"
"\n"
"    Oto mój kod:\n"
"\n"
"{}\n"
"\n"
"    To jest wynik:\n"
"\n"
"{}\n"
"\n"
"    Oczekiwany wynik to:\n"
"\n"
"{}\n"

msgid "misc_terms.q_wiz_input_and_add"
msgstr ""
"i dodaj\n"
"\n"
"    {list_line}\n"
"\n"
"na początku twojego kodu."

msgid "misc_terms.q_wiz_input_message_start"
msgstr ""
"`input()` utrudnia zadawanie pytań i udzielanie odpowiedzi dotyczących kodu."
" Zastąp wywołania funkcji input łańcuchami znaków, tak aby każdy mógł "
"natychmiast uruchomić kod oraz otrzymać te same wyniki."

msgid "misc_terms.q_wiz_input_replace_with"
msgstr ""
"Zastąp:\n"
"\n"
"{original_lines}\n"
"\n"
"tym:\n"
"\n"
"{replaced_lines}"

msgid "misc_terms.q_wiz_no_output"
msgstr ""
"Twój kod nic nie wyświetlił. Dodaj kilka wywołań `print()`, tak aby chociaż "
"coś zostało wyświetlone. Użyj kodu, aby pokazać czytelnikom dokładnie, gdzie"
" jest problem."

msgid "misc_terms.q_wiz_same_as_expected_output"
msgstr ""
"Twój wynik jest taki sam jak oczekiwany! Jeśli problem nadal istnieje, "
"dopasuj swój kod i/lub oczekiwany wynik, tak aby te dwa wyniki się nie "
"zgadzały. Wyraźnie pokaż, co by było inaczej, gdyby kod działał tak, jak "
"chcesz."

msgid "misc_terms.signature_should_be"
msgstr ""
"Sygnatura powinna wyglądać:\n"
"\n"
"    def {function_name}{needed_signature}:\n"
"\n"
"nie:\n"
"\n"
"    def {function_name}{actual_signature}:"

msgid "misc_terms.string_spaces_differ"
msgstr ""
"Sprawdź, czy ciągi znaków w twoim kodzie mają poprawne spacje. Na przykład, "
"`'Hello'` różni się od `'Hello '` ze względu na spację na końcu."

msgid "misc_terms.syntax_error_at_line"
msgstr "w linii"

msgid "misc_terms.when_it_should_output"
msgstr "gdy powinno wyświetlić:"

msgid "misc_terms.which_is_correct"
msgstr "co jest poprawne!"

msgid "misc_terms.your_code_outputs"
msgstr "Twój kod wypisuje:"

msgid "misc_terms.your_code_outputs_given_values"
msgstr ""
"Biorąc pod uwagę te wartości:\n"
"\n"
"{given_values}\n"
"\n"
"twój kod wypisuje:"

msgid "output_predictions.Error"
msgstr "Błąd"

msgid "pages.AddingStrings.steps.final_text.text"
msgstr ""
"Brawo! Każde z poniższych rozwiązań jest poprawne:\n"
"\n"
"__code0__"

msgid "pages.AddingStrings.steps.hello_world_concat.text"
msgstr ""
"Łańcuchy znaków można łączyć za pomocą '+', jednak oznacza to coś zupełnie innego niż dodawanie liczb. Na przykład, spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.AddingStrings.steps.hello_world_space.hints.0.text"
msgstr "Spacja to znak tak samo jak każdy inny, np. 'o' lub 'w'."

msgid "pages.AddingStrings.steps.hello_world_space.hints.1.text"
msgstr "Znak spacji musi znajdować się gdzieś wewnątrz cudzysłowów."

msgid ""
"pages.AddingStrings.steps.hello_world_space.messages.literal_answer.text"
msgstr "Wciąż musisz dodać dwa lub więcej łańcuchy znaków do siebie."

msgid "pages.AddingStrings.steps.hello_world_space.requirements"
msgstr ""
"Użyj '+', aby dodać dwa lub więcej łańcuchów znaków do siebie, tak aby "
"wynikiem było łańcuch `'hello world'`."

msgid "pages.AddingStrings.steps.hello_world_space.text"
msgstr ""
"Możesz zauważyć, że `+` łączy dwa łańcuchy znaków jeden po drugim. Technicznie jest to nazywane konkatenacją.\n"
"\n"
"Oto ćwiczenie: zmień nieznacznie poprzedni kod, tak aby wynikiem była łańcuch `'hello world'`, czyli ze spacją między słowami.\n"
"\n"
"Przy okazji, jeśli utkniesz, możesz kliknąć ikonę żarówki w prawym dolnym rogu, aby uzyskać podpowiedź."

msgid "pages.AddingStrings.title"
msgstr "Łączenie łańcuchów znaków"

msgid "pages.BasicForLoopExercises.steps.final_text.text"
msgstr ""
"Robimy naprawdę duże postępy! Rozwiązujesz problemy i piszesz nowy kod!\n"
"Przed nami jeszcze ciekawsze rzeczy."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_1.hints.0.text"
msgstr ""
"Powinieneś użyć tylko jednego `print`, ponieważ każdy print wypisuje w nowej"
" linii."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_1.hints.1.text"
msgstr "Będziesz musiał użyć `+`."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_1.text"
msgstr ""
"Czas na ćwiczenia! Zmodyfikuj ten program:\n"
"\n"
"__code0__\n"
"\n"
"aby zamiast tego wyświetlił:\n"
"\n"
"    __no_auto_translate__\n"
"    ---W\n"
"    ---o\n"
"    ---r\n"
"    ---l\n"
"    ---d"

msgid "pages.BasicForLoopExercises.steps.loop_exercise_2.hints.0.text"
msgstr ""
"Na chwilę zapomnij o pętlach. Jak byś napisał program, który wypisze `name` "
" 3 razy?"

msgid "pages.BasicForLoopExercises.steps.loop_exercise_2.hints.1.text"
msgstr ""
"Rozwiązanie wygląda bardzo podobnie do innych programów, które widzieliśmy w"
" tej sekcji."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_2.hints.2.text"
msgstr ""
"Pętla for stworzy zmienną taką jak `character`, ale program nie musi jej "
"wykorzystywać."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_2.text"
msgstr ""
"Świetnie! Napisz teraz program, który wypisze `name` tyle razy, ile ma liter. Na przykład dla `name = 'Amy'`, program powinien wypisać:\n"
"\n"
"    __no_auto_translate__\n"
"    Amy\n"
"    Amy\n"
"    Amy\n"
"\n"
"Dla `name = 'World'`, powinien program powinien wypisać:\n"
"\n"
"    __no_auto_translate__\n"
"    World\n"
"    World\n"
"    World\n"
"    World\n"
"    World\n"
"\n"
"Pamiętaj, że możesz ustawić jakąkolwiek wartość zmiennej `name` w pierwszej linii. Jedynie kod znajdujący się poniżej będzie sprawdzony."

msgid "pages.BasicForLoopExercises.title"
msgstr "Podstawowe ćwiczenia z pętlą for"

msgid "pages.BasicTerminology.steps.final_text.text"
msgstr ""
"Oto słowa, które powinieneś znać:\n"
"\n"
"***Wyrażenie*** (ang. expression) to fragment kodu, który ma wartość. Na przykład, w tej linii kodu:\n"
"\n"
"    __no_auto_translate__\n"
"    sentence = 'Hello ' + name\n"
"\n"
"mamy trzy wyrażenia:\n"
"\n"
"1. `'Hello '`\n"
"2. `name`\n"
"3. `'Hello ' + name`\n"
"\n"
"Natomiast pełna linia `sentence = ...` to ***instrukcja*** (ang. statement). To polecenie, które mówi komputerowi, by wykonał akcję. Samo w sobie nie ma wartości. Oznacza to na przykład, że nie można dodawać do siebie instrukcji. Ten kod jest błędny:\n"
"\n"
"    (word = 'Hello') + (name = 'Bob')\n"
"\n"
"Konkretnie, instrukcja taka jak `sentence = ...` w której zmiennej przypisywana jest wartość, nazywana jest ***przypisaniem*** (ang. assignment) - wartość jest *przypisana do* zmiennej.\n"
"\n"
"Program to lista instrukcji, które są wykonane w kolejności. Pętla `for` to *złożona instrukcja* (ang. compound statement), co oznacza, że posiada ciało, zawierające inne instrukcje. Większość instrukcji będzie również zawierać wyrażenia, i wyrażenia mogą zawierać inne, mniejsze wyrażenia, ale wyrażenia nie mogą zawierać instrukcji.\n"
"\n"
"Proces obliczania wartości wyrażenia nazywa się ***ewaluacją*** (ang. evaluation) - zauważ, jak niemal zawiera słowo 'wartość' (ang. value). Komputer *ewaluuje* `1 + 2`, by uzyskać wartość `3`.\n"
"\n"
"Proces wykonywania pętli nazywa się ***iteracją*** (ang. iteration). Kod taki jak `for char in 'Hello':` *iteruje po* (ang. iterating over) łańcuchu znaków `'Hello'`. Fakt, że jest to możliwe, oznacza, że łańcuchy znaków są *iterowalne* (ang. iterable). W przeciwieństwie do tego, liczby nie są iterowalne, co Python powie ci dosłownie, jeśli spróbujesz wykonać `for char in 3:`. Każde wykonanie pętli to *jedna iteracja*, więc w tym przykładzie będzie ich 5."

msgid "pages.BasicTerminology.title"
msgstr "Podstawowe pojęcia"
msgid "pages.BuildingNewLists.steps.double_numbers.hints.0.text"
msgstr "Pamiętaj, że możesz mnożyć liczby używając `*`."

msgid "pages.BuildingNewLists.steps.double_numbers.hints.1.text"
msgstr ""
"Ten program jest strukturalnie bardzo podobny do programów, które pisałeś, "
"budując łańcuchy znaków znak po znaku."

msgid "pages.BuildingNewLists.steps.double_numbers.hints.2.text"
msgstr ""
"Utwórz nową listę, a następnie zbuduj ją element po elemencie w pętli for."

msgid "pages.BuildingNewLists.steps.double_numbers.hints.3.text"
msgstr "Zacznij od pustej listy."

msgid "pages.BuildingNewLists.steps.double_numbers.hints.4.text"
msgstr "Możesz utworzyć listę z jednym elementem `x`, po prostu pisząc `[x]`."

msgid "pages.BuildingNewLists.steps.double_numbers.hints.5.text"
msgstr ""
"Możesz dodać element do listy, dodając listę zawierającą jeden element."

msgid "pages.BuildingNewLists.steps.double_numbers.text"
msgstr ""
"Listy i łańcuchy znaków mają wiele wspólnego.\n"
"Na przykład, możesz dodać dwie listy, aby połączyć je w nową listę.\n"
"Możesz także utworzyć pustą listę, która nie ma żadnych elementów.\n"
"Sprawdź to sam:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Z tą wiedzą, napisz program, który bierze listę liczb\n"
"i wyświetla listę, w której każda liczba została podwojona. Na przykład, mając:\n"
"\n"
"__code1__\n"
"\n"
"wypisałby:\n"
"\n"
"__code2__"

msgid "pages.BuildingNewLists.steps.filter_numbers.disallowed.0.message"
msgstr ""
"Brawo, to jest poprawne! Jednak powinieneś użyć `.append()` zamiast `+=`."

msgid "pages.BuildingNewLists.steps.filter_numbers.hints.0.text"
msgstr "To jest bardzo podobne do poprzedniego ćwiczenia."

msgid "pages.BuildingNewLists.steps.filter_numbers.hints.1.text"
msgstr ""
"Różnica polega na tym, że czasami powinieneś pominąć dodawanie do nowej "
"listy."

msgid "pages.BuildingNewLists.steps.filter_numbers.hints.2.text"
msgstr "Użyj instrukcji `if`."

msgid "pages.BuildingNewLists.steps.filter_numbers.hints.3.text"
msgstr ""
"Użyj operatora porównania, aby przetestować, czy liczba jest wystarczająco "
"duża, aby ją dodać."

msgid "pages.BuildingNewLists.steps.filter_numbers.text"
msgstr ""
"Świetnie!\n"
"\n"
"Gdy chcesz dodać pojedynczy element na koniec listy, zamiast:\n"
"\n"
"__code0__\n"
"\n"
"częściej pisze się:\n"
"\n"
"__code1__\n"
"\n"
"Nie ma naprawdę dużej różnicy między tymi dwoma sposobami, ale `.append`\n"
"będzie bardziej znajomy i czytelny dla większości osób.\n"
"\n"
"Teraz użyj `.append`, aby napisać program, który bierze listę liczb i\n"
"wyświetla nową listę zawierającą tylko te liczby, które są większe niż 5.\n"
"\n"
"Na przykład, mając:\n"
"\n"
"__code2__\n"
"\n"
"wypisałby:\n"
"\n"
"__code3__"

msgid "pages.BuildingNewLists.steps.final_text.text"
msgstr "Fantastycznie! Robimy duże postępy."

msgid "pages.BuildingNewLists.title"
msgstr "Budowanie nowych list"

msgid "pages.BuildingUpStrings.steps.empty_string.text"
msgstr ""
"Ostatni znak w `name` jest dodawany do `line` tylko na końcu pętli, po tym jak `print(line)` już zostało wykonane po raz ostatni. Więc ten znak i pełna `name` nigdy nie zostają wydrukowane na dole trójkąta. Jeśli jesteś zdezorientowany, spróbuj umieścić `print(line)` zarówno przed, jak i po `line = line + char`.\n"
"\n"
"Zróbmy coś z tymi znakami `-` na wyjściu. Możesz już być w stanie zgadnąć jak.\n"
"\n"
"*Pusty łańcuch* (ang. empty string) to łańcuch nie zawierający w ogóle znaków.\n"
"Jest zapisany jako para apostrofów otaczających nic: `''`.\n"
"To jest jak zero, tylko że dla łańcuchów znaków.\n"
"Dodanie go do innego łańcucha daje ci po prostu niezmieniony drugi łańcuch,\n"
"tak samo jak `0 + 5` to po prostu `5`.\n"
"\n"
"Spróbuj tego w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.BuildingUpStrings.steps.final_text.text"
msgstr ""
"Czyż to nie jest piękne?\n"
"\n"
"Wzór rozpoczęcia od czegoś pustego i budowania tego w pętli `for` jest *bardzo* częsty\n"
"i będziesz miał z tym dużo praktyki. Niektóre początkowe puste wartości to\n"
"`''`, `0` i `[]` - pusta lista, o której wkrótce się dowiesz."

msgid ""
"pages.BuildingUpStrings.steps.hello_plus_equals.output_prediction_choices.0"
msgstr ""
"Hello\n"
"Hello"

msgid ""
"pages.BuildingUpStrings.steps.hello_plus_equals.output_prediction_choices.1"
msgstr ""
"Hello\n"
"Hello!"

msgid ""
"pages.BuildingUpStrings.steps.hello_plus_equals.output_prediction_choices.2"
msgstr ""
"Hello!\n"
"Hello!"

msgid "pages.BuildingUpStrings.steps.hello_plus_equals.text"
msgstr ""
"Zanim przyjrzymy się kilku pętlom, musimy szybko poznać kolejne pojęcie. Spójrz na ten program:\n"
"\n"
"__program_indented__\n"
"\n"
"Co myślisz, robi linia `hello = hello + '!'`? Uruchom program, aby się dowiedzieć."

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.0"
msgstr ""
"-\n"
"W\n"
"-\n"
"o\n"
"-\n"
"r\n"
"-\n"
"l\n"
"-\n"
"d"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.1"
msgstr ""
"-W\n"
"-o\n"
"-r\n"
"-l\n"
"-d"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.2"
msgstr "-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.3"
msgstr "-W-o-r-l-d"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.4"
msgstr ""
"-W\n"
"-Wo\n"
"-Wor\n"
"-Worl\n"
"-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.5"
msgstr ""
"-World\n"
"-Worl\n"
"-Wor\n"
"-Wo\n"
"-W"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.6"
msgstr ""
"-World\n"
"-World\n"
"-World\n"
"-World\n"
"-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.7"
msgstr ""
"-World\n"
"--World\n"
"---World\n"
"----World\n"
"-----World"

msgid "pages.BuildingUpStrings.steps.name_triangle.text"
msgstr ""
"Pythonowi nie przeszkadza, że `hello` znajduje się zarówno po lewej, jak i prawej stronie `=`, po prostu robi to, co zawsze by zrobił, gdyby zmienne były inne: oblicza `hello + '!'`, co w tym przypadku jest `'Hello' + '!'`, co daje `'Hello!'`, i to staje się nową wartością `hello`. Jeśli to pomoże, możesz myśleć o tej linii jako podzielonej na dwa kroki:\n"
"\n"
"__code0__\n"
"\n"
"lub:\n"
"\n"
"__code1__\n"
"\n"
"To jest bardzo użyteczne w pętli. Wypróbuj ten program:\n"
"\n"
"__program_indented__"

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.0.text"
msgstr ""
"Najpierw upewnij się, że nie pracujesz na uszkodzonej wersji poprzedniego "
"programu na tej stronie."

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.1.text"
msgstr "Czyli `line = line + char` powinno być przed `print(line)`."

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.2.text"
msgstr "Poza tym musisz dokonać tylko jednej ***malutkiej*** zmiany."

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.3.text"
msgstr "Chcemy pozbyć się `-`. Więc po prostu to zrób. Dosłownie."

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.4.text"
msgstr "Użyj pustego łańcucha!"

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.text"
msgstr ""
"Nie myl pustego łańcucha z `' '`, który jest niepustym łańcuchem zawierającym jeden znak: spację.\n"
"\n"
"Teraz napraw oryginalny program, aby pozbyć się tych linii w wyjściu, tak aby\n"
"dla `name = 'World'` wydrukowało:\n"
"\n"
"    __no_auto_translate__\n"
"    W\n"
"    Wo\n"
"    Wor\n"
"    Worl\n"
"    World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle_missing_last_line.output_prediction_choices.0"
msgstr ""
"-W\n"
"-Wo\n"
"-Wor\n"
"-Worl\n"
"-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle_missing_last_line.output_prediction_choices.1"
msgstr ""
"-Wo\n"
"-Wor\n"
"-Worl\n"
"-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle_missing_last_line.output_prediction_choices.2"
msgstr ""
"-\n"
"-W\n"
"-Wo\n"
"-Wor\n"
"-Worl"

msgid "pages.BuildingUpStrings.steps.name_triangle_missing_last_line.text"
msgstr ""
"Poświęć czas, aby całkowicie zrozumieć ten program. Robi coś w rodzaju:\n"
"\n"
"    line = '-'\n"
"\n"
"    char = 'W'\n"
"    line = line + char\n"
"         = '-' + 'W'\n"
"         = '-W'\n"
"    print('-W')\n"
"\n"
"    char = 'o'\n"
"    line = line + char\n"
"         = '-W' + 'o'\n"
"         = '-Wo'\n"
"    print('-Wo')\n"
"\n"
"    char = 'r'\n"
"    line = line + char\n"
"         = '-Wo' + 'r'\n"
"         = '-Wor'\n"
"    print('-Wor')\n"
"\n"
"    ...\n"
"\n"
"Szczegóły są ważne. Co się stanie, jeśli zamienisz ostatnie dwie linie i uruchomisz ten program zamiast tego?\n"
"\n"
"__program_indented__"

msgid "pages.BuildingUpStrings.title"
msgstr "Budowanie łańcuchów tekstowych"

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.0.text"
msgstr ""
"Pierwsza litera powinna mieć 0 spacji przed nią, druga litera powinna mieć 1"
" spację przed nią, trzecia powinna mieć 2, itd."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.1.text"
msgstr ""
"Powinieneś trzymać spacje w zmiennej i budować je w pętli, jak wcześniej."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.2.text"
msgstr ""
"Różnica polega na tym, że musisz wydrukować litery jednocześnie z "
"zbudowaniem spacji."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.3.text"
msgstr "Innymi słowy, potrzebujesz pojedynczej pętli, która robi to i to."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.4.text"
msgstr "Ciało pętli musi wydrukować spacje i litery, a także dodać spację."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.5.text"
msgstr ""
"Ponieważ pierwsza litera nie powinna mieć spacji przed nią, musisz dodać "
"spację po wydrukowaniu litery."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.messages.add_space_first.text"
msgstr ""
"Prawie tam! Masz jedną spację za dużo przed każdą literą.\n"
"Upewnij się, że pierwszy raz gdy twoja pętla wywoła `print`\n"
"twoja zmienna, która będzie zawierać spacje, jest pustym ciągiem.\n"
"Sprawdź kolejność swojego kodu."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.text"
msgstr ""
"Cudownie! Naprawdę Łapiesz to!\n"
"\n"
"Jeśli chcesz, możesz zrobić jeden dodatkowy opcjonalny bonusowy wyzwanie poniżej.\n"
"Jeśli nie, możesz po prostu kontynuować do [następnej strony](#BasicTerminology) teraz.\n"
"Możesz wrócić i zrobić to później, jeśli chcesz.\n"
"\n"
"Spróbuj napisać program, który wyświetli podaną `name` w przekątnej linii, na przykład:\n"
"\n"
"    W\n"
"     o\n"
"      r\n"
"       l\n"
"        d"


msgid "pages.BuildingUpStringsExercises.steps.final_text.text"
msgstr "Wow, nic Cię nie powstrzyma!"

msgid "pages.BuildingUpStringsExercises.steps.name_box.disallowed.0.message"
msgstr ""
"Dobra robota, to rozwiązanie jest poprawne! Jednak można je ulepszyć.\n"
"Wystarczy użyć jednej pętli - użycie więcej jest nieefektywne.\n"
"Możesz ponownie użyć zmiennej zawierającej linię z `-` i `+`."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.0.text"
msgstr ""
"Zrobiłeś już wszystkie trudne rzeczy w poprzednim ćwiczeniu. Teraz to tylko "
"proste dodawanie łańcuchów."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.1.text"
msgstr ""
"Potrzebujesz tylko jednej pętli for - tej używanej do tworzenia linii "
"myślników z poprzedniego ćwiczenia."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.2.text"
msgstr ""
"Nie próbuj zrobić wszystkiego naraz. Podziel problem na mniejsze, łatwiejsze"
" podproblemy."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.3.text"
msgstr ""
"Spróbuj napisać program, który wyświetla:\n"
"\n"
"    -----\n"
"    World\n"
"    -----"

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.4.text"
msgstr ""
"Ponieważ musisz wydrukować trzy oddzielne linie tekstu, będziesz musiał "
"zadzwonić `print()` trzy razy."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.5.text"
msgstr ""
"Spróbuj napisać program, który wyświetla:\n"
"\n"
"    |World|"

msgid "pages.BuildingUpStringsExercises.steps.name_box.text"
msgstr ""
"Fantastycznie!\n"
"\n"
"Przy okazji, gdy nie potrzebujesz używać zmiennej, powszechną konwencją jest nazwanie tej zmiennej `_` (podkreślenie), na przykład `for _ in name:`. Nie zmienia to działania programu, ale jest pomocne dla czytelników.\n"
"\n"
"Zróbmy to bardziej wyszukane. Rozszerz swój program, aby narysować ramkę wokół nazwy, taką jak tutaj:\n"
"\n"
"    +-----+\n"
"    |World|\n"
"    +-----+"

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.disallowed.0.message"
msgstr ""
"Dobra robota, to rozwiązanie jest poprawne!\n"
"I użyłeś pętli zagnieżdżonej (pętli wewnątrz pętli), której jeszcze nie omawialiśmy!\n"
"Jednakże w tym przypadku pętla zagnieżdżona jest nieefektywna.\n"
"Możesz utworzyć zmienną zawierającą spacje i wykorzystać to w każdej linii."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.hints.0.text"
msgstr "Będziesz potrzebować dwóch oddzielnych pętli for nad `name`."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.hints.1.text"
msgstr ""
"Każda linia z wyjątkiem pierwszej i ostatniej ma te same znaki w środku. To "
"znaczy, że możesz coś wykorzystać ponownie."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.hints.2.text"
msgstr "Stwórz zmienną zawierającą spacje w środku i używaj jej wiele razy."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.hints.3.text"
msgstr ""
"Użyj jednej pętli, aby stworzyć wiele spacji, i drugiej pętli, aby "
"wydrukować wiele linii używając wcześniej stworzonych spacji."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.text"
msgstr ""
"Coraz lepiej Ci idzie! Wygląda na to, że potrzebujesz większego wyzwania... może zamiast umieszczać nazwę w ramce, sama nazwa powinna być ramką? Napisz program, który wyświetla to:\n"
"\n"
"    +World+\n"
"    W     W\n"
"    o     o\n"
"    r     r\n"
"    l     l\n"
"    d     d\n"
"    +World+"

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.0.text"
msgstr ""
"Rozwiązanie jest bardzo podobne do oryginalnego programu trójkąta, wystarczy"
" zrobić jedną małą zmianę."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.1.text"
msgstr ""
"Chcesz nadal dodawać po jednym znaku do `line`, to tylko kwestia tego, gdzie"
" dodajesz go."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.2.text"
msgstr "Chcesz, aby linie były odwrócone, więc musisz odwrócić coś."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.3.text"
msgstr "Potrzebujesz dodać znak przed ciągiem, zamiast po."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.4.text"
msgstr ""
"3 + 7 to to samo co 7 + 3. Tak samo dla wszystkich liczb. Czy to samo "
"dotyczy ciągów znaków?"

msgid "pages.BuildingUpStringsExercises.steps.name_triangle_backwards.text"
msgstr ""
"Świetnie! Teraz zmodyfikuj program tak, aby każda linia była odwrócona, na przykład tak:\n"
"\n"
"    __no_auto_translate__\n"
"    W\n"
"    oW\n"
"    roW\n"
"    lroW\n"
"    dlroW"

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_spaced.hints.0.text"
msgstr "Będziesz potrzebować użyć jednego `+` więcej."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_spaced.hints.1.text"
msgstr ""
"Będziesz potrzebować użyć ciągu składającego się z jednej spacji: `' '`."

msgid "pages.BuildingUpStringsExercises.steps.name_triangle_spaced.text"
msgstr ""
"Zmodyfikuj ten program:\n"
"\n"
"__code0__\n"
"\n"
"aby dodać spację po każdej literze w trójkącie, tak aby wyglądało to tak:\n"
"\n"
"    W\n"
"    W o\n"
"    W o r\n"
"    W o r l\n"
"    W o r l d"

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.hints.0.text"
msgstr "Spójrz na program w kształcie trójkąta w poszukiwaniu inspiracji."

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.hints.1.text"
msgstr ""
"Spójrz na program, w którym wydrukowałeś `name` raz dla każdego znaku w "
"poszukiwaniu inspiracji."

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.hints.2.text"
msgstr ""
"Będziesz musiał zbudować łańcuch myślników (`-`) dodając po jednym znaku na "
"raz."

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.hints.3.text"
msgstr ""
"Pętla for stworzy zmienną, taką jak `char`, ale program nie musi jej używać."

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.text"
msgstr ""
"Wspaniale!\n"
"\n"
"Kod taki jak:\n"
"\n"
"__code0__\n"
"\n"
"jest tak powszechny w Pythonie, że można go skrócić. Oznacza to samo:\n"
"\n"
"__code1__\n"
"\n"
"Zwróć uwagę, że nie ma skrótu dla `line = char + line`.\n"
"\n"
"Teraz użyj `+=` i pętli for, aby napisać własny program, który wydrukuje `name` podkreślone, jak tutaj:\n"
"\n"
"    World\n"
"    -----\n"
"\n"
"Powinien być jeden `-` dla każdej litery w `name`."

msgid "pages.BuildingUpStringsExercises.title"
msgstr "Ćwiczenia: Budowanie łańcuchów znaków"

msgid "pages.CallingFunctionsTerminology.steps.final_text.text"
msgstr ""
"Słowo 'atrybut' w komunikacie o błędzie odnosi się do użycia `.` - błąd "
"pochodzi właściwie tylko z `word.append`, nawet bez wywołania."

msgid "pages.CallingFunctionsTerminology.steps.introducing_callable.text"
msgstr ""
"Wyrażenie takie jak `len(things)` lub `print(things)` to ***wywołanie*** funkcji (ang. function call), - gdy to piszesz, ***wywołujesz*** funkcję `len` lub `print`. Fakt, że jest to możliwe, oznacza, że funkcje są ***wywoływalne*** (ang. callable):\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.len_of_none.text"
msgstr ""
"`None` to specjalna wartość 'null', która nie może zrobić nic ciekawego. To powszechny symbol zastępczy reprezentujący brak realnej, użytecznej wartości. Funkcje, które nie chcą niczego zwracać, domyślnie zwracają `None`. Jeśli widzisz komunikat o błędzie dotyczący `None` lub `NoneType`, często oznacza to, że przypisałeś coś niewłaściwego do zmiennej:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.methods_of_str.text"
msgstr ""
"***Metoda*** to funkcja należąca do typu, którą można wywołać na wszystkich wartościach tego typu, używając `.`. Na przykład `upper` i `lower` to metody ciągów znaków, które są wywoływane z użyciem np. `word.upper()`:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.no_append_for_str.text"
msgstr ""
"Kolejnym przykładem jest to, że `append` to metoda list. Ale nie możesz użyć `.upper` na liście ani `.append` na ciągu znaków:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.not_callable.text"
msgstr ""
"Większość rzeczy nie jest wywoływalna, więc próba ich wywołania spowoduje błąd:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.print_functions.text"
msgstr ""
"Nadszedł czas, by poszerzyć twoje słownictwo jeszcze bardziej.\n"
"\n"
"`print` i `len` to ***funkcje***. Zobacz sam:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.print_returns_none.text"
msgstr ""
"W wywołaniu `len(things)`, `things` to ***argument***. Czasami spotkasz się też ze słowem ***parametr***, które oznacza w zasadzie to samo co argument. To trochę jakbyś przekazywał argument funkcji - konkretnie mówimy, że argument `things` jest *przekazywany* do `len`, a `len` *akceptuje* lub *odbiera* argument.\n"
"\n"
"`len(things)` wyliczy się do liczby, takiej jak 3, w takim przypadku mówimy, że `len` ***zwrócił*** 3.\n"
"\n"
"Wszystkie wywołania muszą coś zwrócić... nawet jeśli to nic. Na przykład, zadaniem funkcji `print` jest wyświetlenie czegoś na ekranie, a nie zwracanie użytecznej wartości. Dlatego zwraca coś bezużytecznego zamiast tego:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.title"
msgstr "Terminologia: Wywoływanie funkcji i metod"

msgid "pages.CallingFunctionsWithinFunctions.steps.final_text.text"
msgstr ""
"`birdseye` pokazuje tylko jedną ramkę (wywołanie funkcji) na raz. Najpierw widać ramkę globalną.\n"
"Na dole jest wywołanie `print_twice`. Kliknij na małą niebieską strzałkę aby przejść\n"
"do tej ramki, a potem kliknij na następną, aby wejść do `print_many`."

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.print_twice_call_print_many.text"
msgstr ""
"Ciało funkcji może zawierać wszystko, w tym wywołania funkcji. Zresztą już to zrobiliśmy wywołując\n"
"print. Wywołanie naszej własnej funkcji niczym się nie różni - nasze funkcje mogą się wzajemnie wywoływać!\n"
"\n"
"Na przykład, możemy zaimplementować `print_twice` przy użyciu `print_many`:\n"
"\n"
"__program_indented__"

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.see_stack_in_birdseye.requirements"
msgstr "Uruchom ten sam program co powyżej, ale z `birdseye`."

msgid "pages.CallingFunctionsWithinFunctions.steps.see_stack_in_birdseye.text"
msgstr ""
"Za każdym razem, gdy funkcja jest wywołana, tworzona jest nowa *ramka* (ang. frame), która zawiera lokalne wartości zmiennych\n"
"w tym wywołaniu i inne informacje o tym, co się obecnie dzieje.\n"
"Gdy wywołanie funkcji się kończy, ramka jest usuwana.\n"
"\n"
"Można to zobaczyć w Python Tutor po prawej stronie pod \"Frames\". Na górze jest Globalna ramka,\n"
"główna ramka, w której działa cały program. Klikając Dalej, nowe ramki się pojawiają\n"
"i potem znikają. W każdej z nich można zobaczyć wartości zmiennych.\n"
"\n"
"Na koniec, uruchom program z `birdseye`."

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.see_stack_in_pythontutor.requirements"
msgstr "Uruchom ten sam program co powyżej, ale z Python Tutor."

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.see_stack_in_pythontutor.text"
msgstr ""
"`snoop` rozpoczyna każde wywołanie funkcji od:\n"
"\n"
"1. Nowego poziomu wcięcia w logach.\n"
"2. `>>> Call to <nazwa funkcji>`\n"
"3. Wartości argumentów.\n"
"4. Linii nagłówka funkcji.\n"
"\n"
"Kończy wywołanie z `<<< Return value from <nazwa funkcji>`. Niedługo dowiemy się więcej o wartościach zwracanych.\n"
"\n"
"Teraz uruchom program ponownie z Python Tutor."

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.see_stack_in_snoop.requirements"
msgstr "Uruchom ten sam program co powyżej, ale z `snoop`."

msgid "pages.CallingFunctionsWithinFunctions.steps.see_stack_in_snoop.text"
msgstr ""
"Jest ważne aby dobrze zrozumieć co się tutaj dzieje i wiedzieć jak\n"
"badać wywołania funkcji, więc spróbujemy to zrobić w naszych debuggerach.\n"
"\n"
"Najpierw, uruchom program ponownie z `snoop`."

msgid "pages.CallingFunctionsWithinFunctions.title"
msgstr "Wywoływanie Funkcji w Funkcjach"

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.0.text"
msgstr "Ile przekątnych jest na planszy?"

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.1.text"
msgstr ""
"Które wpisy z trzech sublist tworzą każdą przekątną? Jak możesz uzyskać "
"dostęp do tych wpisów?"

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.2.text"
msgstr "Każda lista zawsze ma 3 wpisy, więc nie ma potrzeby użycia pętli."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.3.text"
msgstr ""
"Są dwa problemy do rozwiązania tutaj: sprawdzenie wygranej na konkretnej "
"przekątnej oraz połączenie sprawdzeń dla każdej przekątnej."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.4.text"
msgstr "Jeden problem można rozwiązać używając `and`, inny używając `or`."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.5.text"
msgstr ""
"Wiele podobieństw ma funkcja `all_equal`. Możesz nawet użyć tej funkcji do "
"pomocy! Ale wtedy musisz zawrzeć jej definicję."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.6.text"
msgstr ""
"Podobnie jak `all_equal`, sprawdź, czy 3 wpisy na przekątnej są równoważne "
"sobie, np. używając `and`."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.7.text"
msgstr "Sprawdź obie przekątne razem, używając `or`."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.text"
msgstr ""
"Jeśli przeczytać to pobieżnie od lewej do prawej, możesz pomyśleć, że:\n"
"\n"
"__code0__\n"
"\n"
"jest równoważne z\n"
"\n"
"__code1__\n"
"\n"
"ale tak naprawdę równoważne jest z\n"
"\n"
"__code2__\n"
"\n"
"To dlatego, że `and` ma wyższy priorytet niż `or`.\n"
"To jest ważne, ponieważ pierwsza interpretacja redukuje się do `True and False` co jest `False`, podczas gdy druga\n"
"interpretacja redukuje się do `True or False` co jest `True`!\n"
"Możesz wypróbować obie opcje z nawiasami w konsoli, aby się przekonać.\n"
"\n"
"**Morał jest taki, aby być szczególnie ostrożnym łącząc operatory.** Albo dodaj nawiasy dla bezpieczeństwa, albo\n"
"podziel swoje wyrażenie na mniejsze części i przypisz każdą część do zmiennej.\n"
"To uczyni twój kod czytelny, zrozumiały i jednoznaczny, oraz uchroni cię przed bolesnymi błędami.\n"
"\n"
"Czas na ćwiczenie. Załóżmy, że piszesz program do gry w kółko i krzyżyk. Jeśli nigdy nie słyszałeś o kółko i krzyżyk, możesz przeczytać zasady\n"
"i zagrać kilka gier [tutaj](https://gametable.org/games/tic-tac-toe/).\n"
"\n"
"Musimy sprawdzić, czy ktoś wygrał grę. Nasza funkcja `all_equal` już w tym pomaga sprawdzając rzędy.\n"
"\n"
"Napisz funkcję do sprawdzania, czy ktoś wygrał grę poprzez umieszczenie 3 tych samych elementów na jednej z linii przekątnych.\n"
"Plansza jest podana jako zagnieżdżona lista `board` z 3 sublistami, każda sublista zawiera 3 ciągi znaków, reprezentujące rząd. Na przykład:\n"
"\n"
"__code3__\n"
"\n"
"Funkcja powinna zwrócić typ booleanowski: `True` jeśli jedna z przekątnych posiada 3 te same elementy, `False` w przeciwnym wypadku.\n"
"Kliknij przycisk Kopiuj, aby rozpocząć z poniższym kodem.\n"
"Dostarczyliśmy kilka testów dla ciebie, twoim zadaniem jest zastąpić `...` twoim kodem.\n"
"\n"
"    __copyable__\n"
"__code4__"

msgid "pages.CombiningAndAndOr.steps.CombiningAndOr.text"
msgstr ""
"Jeśli używasz operatów `and` (i) oraz `or` (lub) w jednym wyrażeniu, jest to całkiem jak łączenie `*` oraz `+`.\n"
"Operatory są wykonywane w określonej kolejności.\n"
"\n"
"Na przykład, wypróbuj poniższy kod w konsoli.\n"
"Czego się spodziewasz?\n"
"\n"
"__program_indented__"

msgid "pages.CombiningAndAndOr.steps.final_text.text"
msgstr ""
"Brawo! To było trudne. Oto kilka możliwych rozwiązań:\n"
"\n"
"__code0__\n"
"\n"
"lub:\n"
"\n"
"__code1__"

msgid "pages.CombiningAndAndOr.title"
msgstr "Łączenie `and` i `or`"

msgid "pages.CombiningCompoundStatements.steps.final_text.text"
msgstr ""
"Zauważ, że ciało instrukcji `if` (4 linie) jest wcięte jak zwykle, podczas gdy ciało\n"
"pętli `for` (1 linia) jest wcięte o dodatkowe 4 spacje w każdej linii, aby pokazać, że\n"
"te linie są wewnątrz pętli `for`. Strukturę całego programu można zobaczyć\n"
"po prostu patrząc na wcięcia.\n"
"\n"
"Alternatywnie, możesz umieścić `if` w środku `for`:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Te dwa programy dają dokładnie ten sam wynik. Jednak pierwszy z nich jest bardziej wydajny, ponieważ\n"
"iteruje po łańcuchu tylko wtedy, gdy jest to potrzebne, ponieważ gdy `excited = False` nic się nie zmienia."

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.0"
msgstr "Hello World"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.2"
msgstr "Hello World!!!!!!!!!!!"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.3"
msgstr "!!!!!!!!!!!Hello World"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.4"
msgstr "Hello World!"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.5"
msgstr "!Hello World"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.6"
msgstr "!Hello World!"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.7"
msgstr "H!e!l!l!o! !W!o!r!l!d!"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.8"
msgstr "!H!e!l!l!o! !W!o!r!l!d"

msgid "pages.CombiningCompoundStatements.steps.for_inside_if.text"
msgstr ""
"Instrukcje złożone takie jak pętle `for` i instrukcje warunkowe `if` mają ciała, które są listą\n"
"wnętrznych instrukcji. Te wewnętrzne instrukcje mogą być czymkolwiek, włącznie z innymi złożonymi instrukcjami.\n"
"Spróbuj tego przykładu pętli `for` wewnątrz instrukcji `if`, gdy chcesz pokazać,\n"
"że jesteś *naprawdę* podekscytowany:\n"
"\n"
"__program_indented__"

msgid "pages.CombiningCompoundStatements.title"
msgstr "Łączenie instrukcji złożonych"

msgid "pages.DefiningFunctions.steps.change_function_name.hints.0.text"
msgstr ""
"Musisz zmienić nazwę w nagłówku definicji funkcji, ale to nie wszystko."

msgid "pages.DefiningFunctions.steps.change_function_name.hints.1.text"
msgstr ""
"Jeśli zmienisz tylko nazwę w nagłówku definicji funkcji, co się stanie?"

msgid "pages.DefiningFunctions.steps.change_function_name.hints.2.text"
msgstr "Otrzymasz błąd. Spójrz na komunikat. Co Ci mówi? Skąd pochodzi błąd?"

msgid "pages.DefiningFunctions.steps.change_function_name.hints.3.text"
msgstr ""
"Jeśli twoja funkcja nazywa się `say_hello`, co oznacza `greet(\"Alice\")`?"

msgid "pages.DefiningFunctions.steps.change_function_name.hints.4.text"
msgstr "Musisz zmienić dokładnie 3 linijki programu."

msgid "pages.DefiningFunctions.steps.change_function_name.hints.5.text"
msgstr "W każdej linijce, którą zmieniasz, zmień dokładnie jedno słowo."

msgid "pages.DefiningFunctions.steps.change_function_name.hints.6.text"
msgstr ""
"Nie ruszaj treści funkcji. Powinna ona nadal zawierać `print(\"Jak się "
"masz?\")`."

msgid "pages.DefiningFunctions.steps.change_function_name.hints.7.text"
msgstr ""
"Nadal powinieneś(aś) wywołać funkcję dwukrotnie po jej zdefiniowaniu, z "
"argumentami `\"Alice\"` i `\"Bob\"`."

msgid "pages.DefiningFunctions.steps.change_function_name.text"
msgstr ""
"Zwróć uwagę, jak zmieniło się wyjście programu. `How are you?` jest wyświetlane dwukrotnie. Możesz myśleć o całym programie jako o czymś\n"
"równoważnym do tego:\n"
"\n"
"__code0__\n"
"\n"
"To pokazuje jedną z najbardziej użytecznych rzeczy odnośnie funkcji. Pozwalają one wielokrotnie używać tego samego kodu bez\n"
"konieczności powtarzania się. To jak pisanie programu wewnątrz programu.\n"
"\n"
"Linia nagłówka definicji funkcji zawsze zawiera te części:\n"
"\n"
"1. Specjalne słowo kluczowe `def`, po którym następuje spacja.\n"
"2. Nazwa funkcji. Jest to jak nazwa zmiennej - możesz wybrać nazwę, którą chcesz, ale istnieją pewne ograniczenia,\n"
"np. nie może zawierać spacji.\n"
"3. Para nawiasów `(` i `)`\n"
"4. Zero lub więcej nazw parametrów pomiędzy nawiasami, oddzielonych przecinkami, jeśli jest ich więcej niż jeden. Tutaj mamy\n"
"jeden parametr o nazwie `name`.\n"
"5. Dwukropek `:`\n"
"\n"
"Zróbmy kilka prostych ćwiczeń. Zmień nazwę funkcji z `greet` na `say_hello`.\n"
"Upewnij się, że cały program nadal działa jak przedtem, ale nie zmieniaj niczego innego."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.0.text"
msgstr ""
"Musisz zmienić nazwę parametru w nagłówku definicji funkcji, ale to nie "
"wszystko."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.1.text"
msgstr ""
"Jeśli zmienisz tylko nazwę parametru w nagłówku definicji funkcji, co się "
"stanie?"

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.2.text"
msgstr "Otrzymasz błąd. Spójrz na komunikat. Co Ci mówi? Skąd pochodzi błąd?"

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.3.text"
msgstr ""
"Jeśli parametr nazywa się `person_name`, co oznacza `print(f\"Hello "
"{name}!\")`?"

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.4.text"
msgstr "Musisz zmienić dokładnie 2 linijki programu."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.5.text"
msgstr "W każdej linijce, którą zmieniasz, zmień dokładnie jedno słowo."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.6.text"
msgstr ""
"Nie ruszaj części po definicji funkcji, tzn. `say_hello(\"Alice\")` i "
"`say_hello(\"Bob\")`."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.7.text"
msgstr ""
"W treści funkcji powinieneś(aś) nadal mieć dwie instrukcje, w tym "
"`print(\"Jak się masz?\")`."

msgid "pages.DefiningFunctions.steps.change_parameter_name.text"
msgstr ""
"Dobrze! Teraz wykonaj podobne ćwiczenie: zmień nazwę parametru z `name` na "
"`person_name`."

msgid "pages.DefiningFunctions.steps.define_greet.text"
msgstr ""
"Zobaczyłeś(aś) już, jak wywoływać funkcje takie jak `print()` i `len()`. Teraz nauczysz się pisać własne\n"
"funkcje, z których możesz korzystać Ty lub ktokolwiek inny. Jest to bardzo ważne, kiedy mamy do czynienia z programami które są większe i bardziej skomplikowane.\n"
"\n"
"Oto prosty przykład:\n"
"\n"
"__program_indented__\n"
"\n"
"To definiuje funkcję o nazwie `greet`, która akceptuje jeden parametr. Poniżej definicji wywołujemy funkcję dwukrotnie.\n"
"Uruchom kod, aby zobaczyć co się stanie."

msgid "pages.DefiningFunctions.steps.final_text.text"
msgstr "Doskonale! Teraz masz solidne podstawy definiowania funkcji."

msgid "pages.DefiningFunctions.steps.how_are_you.output_prediction_choices.0"
msgstr ""
"Hello Alice!\n"
"How are you?\n"
"Hello Bob!\n"
"How are you?"

msgid "pages.DefiningFunctions.steps.how_are_you.output_prediction_choices.1"
msgstr ""
"Hello Alice!\n"
"Hello Bob!\n"
"How are you?"

msgid "pages.DefiningFunctions.steps.how_are_you.output_prediction_choices.2"
msgstr ""
"Hello Alice!\n"
"How are you?\n"
"Hello Bob!"

msgid "pages.DefiningFunctions.steps.how_are_you.requirements"
msgstr ""
"Dodaj `print(\"How are you?\")` po `print(f\"Hello {name}!\")` z takim samym wcięciem.\n"
"Zachowaj dwa wywołania `greet` po definicji jak są."

msgid "pages.DefiningFunctions.steps.how_are_you.text"
msgstr ""
"Definicja funkcji to instrukcja złożona (ang. compound statement). Podobnie jak `if` i `for`, ma linię nagłówkową, po której następuje wcięty blok\n"
"zawierający jedną lub więcej instrukcji.\n"
"\n"
"Dodaj kolejną instrukcję do funkcji, aby wyglądała ona tak:\n"
"\n"
"__code0__\n"
"\n"
"Następnie uruchom program ponownie."

msgid "pages.DefiningFunctions.steps.print_many.output_prediction_choices.2"
msgstr ""
"Hello\n"
"Hello\n"
"Hello"

msgid "pages.DefiningFunctions.steps.print_many.output_prediction_choices.3"
msgstr "Hello"

msgid "pages.DefiningFunctions.steps.print_many.output_prediction_choices.4"
msgstr ""
"H\n"
"e\n"
"l\n"
"l\n"
"o"

msgid "pages.DefiningFunctions.steps.print_many.text"
msgstr ""
"Funkcje mogą mieć wiele parametrów. Tutaj jest przykład:\n"
"\n"
"__program_indented__"

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.0.text"
msgstr ""
"Nie ma tu żadnych szczególnych zagadek, chodzi tylko o przestrzeganie "
"receptury na definiowanie funkcji."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.1.text"
msgstr "Upewnij się, że masz wszystkie części funkcji wymienione powyżej."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.2.text"
msgstr "To obejmuje `def`, `()`, i `:`."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.3.text"
msgstr "Upewnij się, że twoja funkcja nazywa się `print_twice`."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.4.text"
msgstr ""
"Upewnij się, że przyjmuje ona jeden parametr o nazwie `x` pomiędzy nawiasami"
" `()`."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.5.text"
msgstr "Spójrz na inne funkcje zdefiniowane powyżej, aby uzyskać pomoc."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.6.text"
msgstr "Użyj parametru wewnątrz treści funkcji."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.7.text"
msgstr "Upewnij się, że treść jest wcięta."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.8.text"
msgstr "Treść powinna zawierać dwie instrukcje lub bardzo prostą pętlę."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.9.text"
msgstr ""
"Upewnij się, że nie wywołujesz `print_twice` wewnątrz treści funkcji "
"`print_twice`. Sprawdź swoje wcięcia."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.requirements"
msgstr ""
"Napisz program definiujący funkcję o nazwie `print_twice` zgodnie z opisem "
"powyżej."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.text"
msgstr ""
"Świetnie!\n"
"\n"
"Teraz napisz własną funkcję o nazwie `print_twice`, która przyjmuje jeden argument `x` i drukuje ten argument dwukrotnie\n"
"na dwóch liniach.\n"
"\n"
"Na przykład, `print_twice(\"Hello\")` powinno wyjść:\n"
"\n"
"__code0__\n"
"\n"
"Możesz przetestować swoją funkcję, wywołując ją po definicji funkcji, ale nie jest to wymagane."

msgid "pages.DefiningFunctions.steps.swap_parameters.hints.0.text"
msgstr ""
"Jedyna zmiana w definicji funkcji powinna dotyczyć zamiany miejscami "
"parametrów, zgodnie z instrukcją, nic więcej."

msgid "pages.DefiningFunctions.steps.swap_parameters.hints.1.text"
msgstr "Musisz naprawić wywołanie `print_many`."

msgid "pages.DefiningFunctions.steps.swap_parameters.hints.2.text"
msgstr ""
"Jeśli funkcja jest zdefiniowana jako `def print_many(n, thing)`, co oznacza "
"`print_many(\"Hello\", 3)`?"

msgid "pages.DefiningFunctions.steps.swap_parameters.hints.3.text"
msgstr "Nadal chcemy, aby `thing = \"Hello\"` i `n = 3`."

msgid "pages.DefiningFunctions.steps.swap_parameters.text"
msgstr ""
"Zauważ przecinki używane do oddzielania parametrów w definicji funkcji i argumentów w wywołaniu funkcji,\n"
"oraz podobieństwo między definicją a wywołaniem:\n"
"\n"
"    def print_many(thing, n):\n"
"                     ^    ^\n"
"                     |    |\n"
"      print_many(\"Hello\", 3)\n"
"\n"
"Więc wywołanie `print_many(\"Hello\", 3)` jest jak uruchomienie:\n"
"\n"
"__code0__\n"
"\n"
"Teraz kolejne proste ćwiczenie. Zamień miejscami parametry w nagłówku definicji funkcji, aby było:\n"
"\n"
"__code1__\n"
"\n"
"Jeśli to zrobisz i nic więcej, otrzymasz błąd. Napraw resztę programu, aby zachowywał się jak wcześniej.\n"
"*Nie zmieniaj treści funkcji*."

msgid "pages.DefiningFunctions.title"
msgstr "Definiowanie funkcji"

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.hints.0.text"
msgstr ""
"Remember that we previously had `for item in cart` in the function, but "
"`cart` is no longer an argument."

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.hints.1.text"
msgstr ""
"Now `quantities` is the only argument that defines what the customer is "
"buying."

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.hints.2.text"
msgstr ""
"You need to iterate over the keys of `quantities` instead. Remember that "
"'iterate' here means 'loop over' with a `for` loop."

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.hints.3.text"
msgstr "You can use `.keys()`, but you don't have to."

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.text"
msgstr ""
"Now you can use this to modify our function on the previous page to remove the `cart` argument:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.DictionaryKeysAndValues.steps.english_to_french.hints.0.text"
msgstr "You will need to iterate (loop) over the dictionary."

msgid "pages.DictionaryKeysAndValues.steps.english_to_french.hints.1.text"
msgstr ""
"You need to print both the key (English word) and the value (French word) of"
" each dictionary entry."

msgid "pages.DictionaryKeysAndValues.steps.english_to_french.hints.2.text"
msgstr "You can get the value using the key in the same way as always."

msgid "pages.DictionaryKeysAndValues.steps.english_to_french.text"
msgstr ""
"That looks nice! We've fully solved the problem of adding up the total cost.\n"
"\n"
"Coming back to our first example: write a function\n"
"which prints out each word in an English-to-French dictionary and its translation, labeling them with their languages.\n"
"Here's your starting code:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"For example, the last line of code above should print:\n"
"\n"
"    English: apple\n"
"    French: pomme\n"
"    ---\n"
"    English: box\n"
"    French: boite\n"
"    ---"

msgid "pages.DictionaryKeysAndValues.steps.english_to_german.hints.0.text"
msgstr ""
"This is still very similar to the previous exercise, nothing special yet."

msgid "pages.DictionaryKeysAndValues.steps.english_to_german.hints.1.text"
msgstr ""
"You can reuse your previous solution, just add another argument and a tiny "
"bit of code inside."

msgid "pages.DictionaryKeysAndValues.steps.english_to_german.hints.2.text"
msgstr "You now have to print one dictionary key and two dictionary values."

msgid "pages.DictionaryKeysAndValues.steps.english_to_german.text"
msgstr ""
"Great! Now let's add a German dictionary as well:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"That should print:\n"
"\n"
"    English: apple\n"
"    French: pomme\n"
"    German: apfel\n"
"    ---\n"
"    English: box\n"
"    French: boite\n"
"    German: kasten\n"
"    ---\n"
"\n"
"The two dictionaries will always have the same keys, just different values."

msgid "pages.DictionaryKeysAndValues.steps.final_text.text"
msgstr ""
"Congratulations! You've reached the end of the course so far. More is on the"
" way!"

msgid "pages.DictionaryKeysAndValues.steps.introducing_keys.requirements"
msgstr "Run `print(quantities.keys())` where `quantities` is a dictionary."

msgid "pages.DictionaryKeysAndValues.steps.introducing_keys.text"
msgstr ""
"Copy this code into the editor:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Then change `print(quantities)` to `print(quantities.keys())`, and run the whole program."

msgid "pages.DictionaryKeysAndValues.steps.keys_are_iterable.text"
msgstr ""
"The `.keys()` method of `dict` does basically what you'd expect. You can iterate over the value it returns\n"
"just like you'd iterate over a list:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.DictionaryKeysAndValues.steps.keys_are_iterable2.requirements"
msgstr ""
"Run the same code as the previous step, but without `.keys()`. after "
"`quantities`, so the middle line is `for key in quantities:`"

msgid "pages.DictionaryKeysAndValues.steps.keys_are_iterable2.text"
msgstr ""
"Actually, you don't even need `.keys()`. Iterating directly over a dictionary automatically iterates over its keys.\n"
"Sometimes it's nice to write `.keys()` to make your code more readable, but you don't have to.\n"
"Remove the `.keys()` and run the code again."

msgid "pages.DictionaryKeysAndValues.steps.nested_dictionaries.text"
msgstr ""
"Beautiful! There's a pattern emerging here. The two languages could be merged into one big nested dictionary:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.DictionaryKeysAndValues.title"
msgstr "Iterating over Dictionary Keys"

msgid "pages.EqualsVsIs.steps.final_text.text"
msgstr ""
"Teraz `list1 is list2` to `True`, ponieważ *jest tylko jedna lista*, i obie zmienne\n"
"`list1` i `list2` odnoszą się do tej samej listy. `list1.append(4)` dodaje do jednej listy\n"
"i wynik można zobaczyć zarówno w `print(list1)`, jak i w `print(list2)`, ponieważ obie linie\n"
"są teraz po prostu różnymi sposobami wypisywania tej samej listy.\n"
"\n"
"Polecam uruchomić obie wersje z Python Tutor, aby zobaczyć, jak wizualizuje on różnicę.\n"
"W drugim przypadku obie zmienne mają strzałki wskazujące na jeden obiekt listy.\n"
"\n"
"`list2 = list1` nie tworzy wiecznego połączenia między zmiennymi. Jeśli przypiszesz nową wartość\n"
"*którejkolwiek* z zmiennych, np. `list1 = [7, 8, 9]`, druga zmienna nie będzie miała wpływu\n"
"i nadal będzie wskazywać na pierwotną listę.\n"
"\n"
"Najprościej - przypisanie takie jak:\n"
"\n"
"    list2 = <wyrażenie>\n"
"\n"
"oznacza 'spraw, by zmienna `list2` odnosiła się do tego, do czego zewaluuje się `<wyrażenie>`'.\n"
"Wartość nie jest kopiowana, co pozwala na to, że obie zmienne mogą wskazywać na tę samą listę.\n"
"Ale jak już wcześniej nauczyliśmy się, `list2` nie pamięta `<wyrażenie>`, tylko wartość.\n"
"Zmienna nie wie o innych zmiennych.\n"
"\n"
"Możesz skopiować listę za pomocą metody `copy`:\n"
"\n"
"__code0__\n"
"\n"
"To spowoduje, że program znów będzie się zachowywał jak pierwsza wersja.\n"
"\n"
"Jeśli napotkasz taki rodzaj problemu i nadal będziesz mieć trudności z zrozumieniem tych spraw, przeczytaj esej [Fakty i mity na temat nazw i wartości w Pythonie](https://nedbatchelder.com/text/names.html)."

msgid "pages.EqualsVsIs.steps.same_list.requirements"
msgstr ""
"Uruchom ten sam program co powyżej, ale zastąp *drugie* `[1, 2, 3]` przez "
"`list1`."

msgid "pages.EqualsVsIs.steps.same_list.text"
msgstr ""
"Ten program jest dość prosty i w większości składa się z rzeczy, które już znasz.\n"
"Tworzymy dwie zmienne, które odnoszą się do list.\n"
"Listy mają te same elementy, więc są one równe: `list1 == list2` to `True`.\n"
"\n"
"Ale jest tu nowy operator porównania: `is`. Tutaj `list1 is list2` to `False`.\n"
"Oznacza to, że mimo że dwie listy są równe,\n"
"są to nadal dwie oddzielne, odrębne, indywidualne listy.\n"
"W rezultacie, gdy dodajesz 4 do `list1`, zmienia się tylko `list1`.\n"
"\n"
"Teraz zmień `list2 = [1, 2, 3]` na `list2 = list1` i zobacz, jakie to robi różnice."

msgid "pages.EqualsVsIs.steps.two_separate_lists.text"
msgstr ""
"Nadszedł czas, aby nauczyć się niektórych szczegółów technicznych, które są często źle rozumiane i prowadzą do błędów.\n"
"Uruchom ten program:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.EqualsVsIs.title"
msgstr "`==` vs `is` i posiadanie wielu nazw dla jednej wartości"

msgid "pages.FunctionsAndMethodsForLists.steps.append_vs_concatenate.text"
msgstr ""
"Przyjrzyjmy się, jak pracować z listami. Załóżmy, że mamy listę `nums = [1, 2, 3]`. Możemy użyć:\n"
"\n"
"- **`append`**: Dodaje element na końcu listy. `nums.append(4)` zmienia listę na `[1, 2, 3, 4]`.\n"
"- **`len`**: Zwraca liczbę elementów. `len(nums)` wynosi `3`.\n"
"- **`range`**: `range(n)` to obiekt podobny do listy liczb od `0` do `n - 1`. Oznacza to, że zawiera `n` liczb. W szczególności, `range(len(nums))` jest jak `[0, 1, 2]`, które są indeksami każdego elementu w `nums`.\n"
"- **`[]` (indeksowanie)**: Pobiera wartość o danym indeksie. `nums[0]` to `1`, `nums[1]` to `2`, `nums[2]` to `3`.\n"
"- **`+`**: Konkatenacja list. `nums + [4, 5]` to `[1, 2, 3, 4, 5]`.\n"
"\n"
"Zauważ, że `nums.append(4)` modyfikuje istniejącą listę `nums`, podczas gdy `nums + [4, 5]` tego nie robi.\n"
"Aby zachować wartość `nums + [4, 5]`, można ją przypisać do *nowej zmiennej*.\n"
"Uruchom następujący kod:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.FunctionsAndMethodsForLists.steps.final_text.text"
msgstr "Świetna robota!"

msgid "pages.FunctionsAndMethodsForLists.steps.index_predict_exercise.text"
msgstr ""
"**`index`**: Znajduje pierwszy element o podanej wartości w liście i zwraca jego indeks\n"
"\n"
"__code0__\n"
"\n"
"Jeżeli podanej wartości nie ma w liście, interpreter zwróci błąd. Uruchom poniższy kod w shellu:\n"
"\n"
"__program_indented__"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno mieć dokładnie trzy instrukcje: `x = ['a', 'b', "
"'c']`, `y = ` po której następuje jedna linia dokładnie skopiowana z listy, "
"oraz `print(y)`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.1.text"
msgstr "Które linie kodu tworzą nową listę zamiast modyfikować?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.2.text"
msgstr "`x` to lista. Każdy element `x` to łańcuch znaków."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.3.text"
msgstr ""
"Możesz dodawać listy do siebie, możesz dodawać łańcuchy znaków do siebie, "
"ale nie możesz dodawać łańcucha znaków do listy."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.4.text"
msgstr "Jak zrobić listę zawierającą jeden element?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.requirements"
msgstr ""
"Skopiuj trzy powyższe linie, a następnie zastąp "
"`(wstaw_jedną_linię_z_powyżej)` dokładnie jedną linią z długiej listy linii "
"wcześniejszych. Musisz wybrać poprawną linię, jest tylko jedna właściwa "
"odpowiedź. Wpisz linię dokładnie. Nie zastępuj części `y = `, powinna być "
"tam przed linią, którą wpiszesz, w tej samej linii."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.text"
msgstr ""
"Świetnie!\n"
"\n"
"Możesz zdać sobie sprawę, że praca z ostatnim elementem za pomocą `x[len(x) - 1]` jest nieco kłopotliwa.\n"
"To samo można osiągnąć przez `x[-1]`.\n"
"Podobnie, przedostatni element `x[len(x) - 2]` można zapisać jako `x[-2]`, i tak dalej.\n"
"Python pozwala nam także liczyć indeks do tyłu, zaczynając od ostatniego elementu z `-1`:\n"
"\n"
"| Indeks     | Pierwszy el. | Drugi el.   | Trzeci el.  | ... | Przedostatni el. | Ostatni el.  |\n"
"|-----------|---------------|--------------|--------------|-----|-------------------|---------------|\n"
"| Do przodu  | `0`           | `1`          | `2`          | ... | `len(x) - 2`      |`len(x) - 1`   |\n"
"| Do tyłu    | `-len(x)`     |`-len(x) + 1` |`-len(x) + 2` | ... | `-2`              |  `-1`         |\n"
"\n"
"Następne ćwiczenie:\n"
"\n"
"Tym razem, zamiast modyfikować listę `x`, utworzysz nową listę `y`:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"`y` powinno być takie samo jak `x`, ale powinno mieć też pierwszy element powtórzony na końcu.\n"
"Dlatego program wydrukuje `['a', 'b', 'c', 'a']`."

msgid "pages.FunctionsAndMethodsForLists.steps.pop_predict_exercise.text"
msgstr ""
"**`pop`**: Usuwa i zwraca element o danym *indeksie* używając składni\n"
"\n"
"__code0__\n"
"\n"
"Bez argumentu, tzn. po prostu `some_list.pop()`, usunie i zwróci ostatni element.\n"
"Powoduje błąd, jeśli `index` nie jest prawidłowym indeksem `some_list`. Na przykład uruchom ten program:\n"
"\n"
"__program_indented__"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno mieć dokładnie trzy instrukcje: `x = ['a', 'b', "
"'c']`, jedna linia dokładnie skopiowana z listy (bez dodatków), oraz "
"`print(x)`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.1.text"
msgstr "Przesunięcie pierwszego elementu na koniec wymaga dwóch rzeczy."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.2.text"
msgstr "Usunięcie pierwszego elementu..."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.3.text"
msgstr "i dodanie go na koniec."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.4.text"
msgstr "Które funkcje/metody możesz użyć do tego?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.5.text"
msgstr "Pamiętaj, że pierwszy indeks to 0."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.requirements"
msgstr ""
"Skopiuj trzy powyższe linie, a następnie zastąp "
"`(wstaw_jedną_linię_z_powyżej)` dokładnie jedną linią z długiej listy tuż "
"przed tym. Musisz wybrać poprawną linię, jest tylko jedna właściwa "
"odpowiedź. Wpisz linię dokładnie."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.text"
msgstr ""
"Teraz rozwiążesz cztery krótkie ćwiczenia związane z tymi pojęciami.\n"
"Poniżej znajduje się lista poprawnych i niepoprawnych linii kodu wymieszanych ze sobą.\n"
"Każde nadchodzące ćwiczenie ma rozwiązanie, które zawiera dokładnie jedną z poniższych linii,\n"
"a ty musisz znaleźć poprawną linię z listy.\n"
"\n"
"__code0__\n"
"\n"
"Oto niekompletny program:\n"
"\n"
"    __copyable__\n"
"__code1__\n"
"\n"
"Zastąp środkową linię jedną linią z powyższej listy. Ostateczny program powinien zmodyfikować `x` tak, aby przenieść pierwszy element na koniec, tak aby drukował `['b', 'c', 'a']`."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno mieć dokładnie trzy instrukcje: `x = [1, 2, 0, "
"3]`, jedna linia dokładnie skopiowana z listy (bez dodatków), oraz "
"`print(x)`."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.1.text"
msgstr "Co robi `x.remove(0)`?"

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.2.text"
msgstr "Usuwa element!"

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.3.text"
msgstr "Która funkcja/metoda może także usunąć element?"

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.4.text"
msgstr ""
"Inna funkcja/metoda nie może po prostu dostać informacji 'usuń 0', "
"potrzebuje innego rodzaju informacji."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.5.text"
msgstr "Dokładniej, musi wiedzieć, gdzie jest 0."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.6.text"
msgstr "Która funkcja/metoda dostarcza tego rodzaju informacji?"

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.requirements"
msgstr ""
"Skopiuj trzy powyższe linie, a następnie zastąp `x.remove(0)` dokładnie "
"jedną linią z długiej listy linii wcześniejszych. Linia, którą wybierzesz, "
"powinna mieć ten sam efekt co `x.remove(0)`, tak żeby program wydrukował "
"`[1, 2, 3]`."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.text"
msgstr ""
"Świetna robota. Teraz ostatnie ćwiczenie:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Zastąp środkową linię `x.remove(0)` jedną linią z listy, która robi to samo."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_predict_exercise.text"
msgstr ""
"**`remove`**: Usuwa pierwsze wystąpienie podanej *wartości* za pomocą składni\n"
"\n"
"__code0__\n"
"\n"
"Powoduje błąd, jeśli wartość nie znajduje się na liście. Na przykład uruchom ten program:\n"
"\n"
"__program_indented__"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno mieć dokładnie trzy instrukcje: `x = ['a', 'b', "
"'c']`, jedna linia dokładnie skopiowana z listy (bez dodatków), oraz "
"`print(x)`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.1.text"
msgstr "Musisz pobrać wartość pierwszego elementu w `x`..."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.2.text"
msgstr "i przypisać tę wartość do ostatniej pozycji w `x`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.3.text"
msgstr "Jak przypisujesz wartość na konkretnym indeksie na liście?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.4.text"
msgstr "Jakie są indeksy pierwszego i ostatniego elementu w `x`?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.requirements"
msgstr ""
"Skopiuj trzy powyższe linie, a następnie zastąp "
"`(wstaw_jedną_linię_z_powyżej)` dokładnie jedną linią z poprzedniej długiej "
"listy. Musisz wybrać poprawną linię, jest tylko jedna właściwa odpowiedź. "
"Wpisz linię dokładnie."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.text"
msgstr ""
"Dobra robota. W kolejnym ćwiczeniu, zacznij od tego samego niekompletnego programu:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Wybierz linię kodu z listy, która nadpisuje ostatni element `x` pierwszym elementem,\n"
"tak aby drukowało `['a', 'b', 'a']`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_predict.text"
msgstr ""
"Jak widać, `+` nie modyfikuje `nums`, ale `append` tak.\n"
"\n"
"Oto kilka nowych rzeczy.\n"
"\n"
"**`przypisanie wartości do elementu`**: Ustawia wartość o danym indeksie (zastępując wartość, która była tam wcześniej) za pomocą składni\n"
"\n"
"__code0__\n"
"\n"
"Jeśli `index` nie jest prawidłowym indeksem `some_list`, interpreter zwróci błąd. Na przykład uruchom ten program:\n"
"\n"
"__program_indented__"

msgid "pages.FunctionsAndMethodsForLists.title"
msgstr "Funkcje i metody dla list"

msgid "pages.GettingElementsAtPosition.steps.final_text.text"
msgstr ""
"Jeśli nadal nie czujesz się komfortowo z funkcją `range` i/lub `len`, poćwicz i eksperymentuj z nimi przez chwilę.\n"
"Oto kilka prostych ćwiczeń, które możesz spróbować wykonać samodzielnie, jeśli chcesz.\n"
"\n"
"- Wypisz liczby od `1` do `100` włącznie.\n"
"- Wypisz swoje imię 100 razy.\n"
"- Wypisz każde słowo z listy `words` oprócz ostatniego.\n"
"- Wypisz każde słowo z `words` w odwrotnej kolejności, czyli wypisz ostatnie słowo, potem przedostatnie słowo itp.\n"
"- Powróć do bonusowego problemu na końcu strony [Wprowadzenie do List](#IntroducingLists),\n"
"niezależnie od tego, czy go rozwiązałeś. Jest teraz znacznie łatwiejsze z `range` i `len`!\n"
"\n"
"Gdy będziesz gotowy, kontynuuj na następną stronę, gdzie czeka na ciebie coś trochę bardziej wymagającego."

msgid "pages.GettingElementsAtPosition.steps.index_error.program"
msgstr "words[4]"

msgid "pages.GettingElementsAtPosition.steps.index_error.requirements"
msgstr "Uruchom coś takiego jak `words[3]`, ale zastąp `3` większą liczbą."

msgid "pages.GettingElementsAtPosition.steps.index_error.text"
msgstr ""
"Ogólnie rzecz biorąc, możesz pobrać element na miejscu `i` używając `words[i]`. Operacja ta nazywa się *indeksowanie*, a miejsce to *indeks*.\n"
"\n"
"Prawdopodobnie zauważyłeś, że pierwszy indeks to 0, a nie 1. W programowaniu liczenie zaczyna się od 0. To wydaje się dziwne, ale tak właśnie działa większość języków programowania i ogólnie uznaje się to za lepsze.\n"
"\n"
"To również oznacza, że ostatni indeks w tej liście 4 elementów to 3. Co się stanie, jeśli spróbujesz uzyskać indeks większy niż ten?"

msgid "pages.GettingElementsAtPosition.steps.indices_out_of_bounds.text"
msgstr "Teraz spróbuj `__program__` w konsoli."

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.0"
msgstr ""
"This\n"
"is\n"
"a\n"
"list"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.2"
msgstr ""
"0\n"
"This\n"
"1\n"
"is\n"
"2\n"
"a\n"
"3\n"
"list"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.3"
msgstr ""
"This\n"
"0\n"
"is\n"
"1\n"
"a\n"
"2\n"
"list\n"
"3"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.4"
msgstr ""
"0\n"
"1\n"
"2\n"
"3\n"
"This\n"
"is\n"
"a\n"
"list"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.5"
msgstr ""
"This\n"
"is\n"
"a\n"
"list\n"
"0\n"
"1\n"
"2\n"
"3"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"indices = [0, 1, 2, 3]\n"
"\n"
"for index in indices:\n"
"    print(index)\n"
"    print(words[index])"

msgid "pages.GettingElementsAtPosition.steps.introducing_len_and_range.text"
msgstr ""
"I oto jest. `words[4]` oraz reszta nie istnieje, więc próba ich uzyskania skończy się błędem.\n"
"Ten pierwszy program jest trochę powtarzalny. Ulepszmy go za pomocą listy i pętli!\n"
"\n"
"__program_indented__"

msgid "pages.GettingElementsAtPosition.steps.introducing_subscripting.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"\n"
"print(words[0])\n"
"print(words[1])\n"
"print(words[2])\n"
"print(words[3])"

msgid "pages.GettingElementsAtPosition.steps.introducing_subscripting.text"
msgstr ""
"Pętla jest świetna, ale często chcesz po prostu pobrać pojedynczy element z listy na znanym miejscu.\n"
"Oto jak:\n"
"\n"
"__program_indented__"

msgid ""
"pages.GettingElementsAtPosition.steps.print_indices_and_words.hints.0.text"
msgstr "Pamiętaj, że wcześniej użyliśmy `range(4)`."

msgid ""
"pages.GettingElementsAtPosition.steps.print_indices_and_words.hints.1.text"
msgstr ""
"Tym razem powinno to działać dla dowolnej listy. Co jeśli lista ma 5 "
"elementów albo 10?"

msgid ""
"pages.GettingElementsAtPosition.steps.print_indices_and_words.hints.2.text"
msgstr "Połącz dwie funkcje, których się nauczyłeś!"

msgid "pages.GettingElementsAtPosition.steps.print_indices_and_words.text"
msgstr ""
"Zatem ogólnie rzecz biorąc, prawidłowe indeksy to:\n"
"\n"
"__code0__\n"
"\n"
"Teraz możemy naprawić program z wcześniej tak, aby działał z dowolną listą. Uzupełnij `...`:\n"
"\n"
"    __copyable__\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"\n"
"    for index in ...:\n"
"        print(index)\n"
"        print(words[index])\n"
"\n"
"Dla podanej wartości przykładowej `words` program powinien wypisać:\n"
"\n"
"    0\n"
"    This\n"
"    1\n"
"    is\n"
"    2\n"
"    a\n"
"    3\n"
"    list"

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.0.text"
msgstr ""
"Aby uzyskać dostęp do ostatniego elementu listy, potrzebujesz indeksu "
"ostatniej pozycji."

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.1.text"
msgstr ""
"Jeśli lista ma 2 elementy, pierwszy element znajduje się na indeksie 0, więc"
" ostatni element jest na indeksie 1."

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.2.text"
msgstr ""
"Podobnie, gdyby lista miała 3 elementy, ostatni element byłby na indeksie 2."

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.3.text"
msgstr "Czy widzisz wzór pomiędzy tymi numerami? Jak możesz to wyrazić?"

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.4.text"
msgstr ""
"Czy potrafisz wymyślić ogólne rozwiązanie, które działa na każdym rozmiarze?"

msgid "pages.GettingElementsAtPosition.steps.print_last_element.text"
msgstr ""
"Ćwiczenie: dla dowolnej niepustej listy `words`, wydrukuj ostatni element. Na przykład, jeśli\n"
"\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"\n"
"twój program powinien wydrukować `list`."

msgid ""
"pages.GettingElementsAtPosition.steps.printing_the_range.output_prediction_choices.4"
msgstr ""
"This\n"
"is\n"
"a\n"
"list"

msgid "pages.GettingElementsAtPosition.steps.printing_the_range.text"
msgstr ""
"Jak widzisz, wynik jest taki sam. Spróbuj tego:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.GettingElementsAtPosition.steps.range_almost_the_same_as_list.text"
msgstr ""
"`range(4)` to to samo, co `[0, 1, 2, 3]` ... prawie. Spróbuj `__program__` w"
" konsoli."

msgid "pages.GettingElementsAtPosition.steps.range_len.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"indices = range(4)\n"
"\n"
"for index in indices:\n"
"    print(index)\n"
"    print(words[index])"

msgid "pages.GettingElementsAtPosition.steps.range_len.requirements"
msgstr ""
"Uruchom ten sam program z poprzedniego kroku, ale zamień drugą linię "
"`indices = [0, 1, 2, 3]` na `indices = range(4)`."

msgid "pages.GettingElementsAtPosition.steps.range_len.text"
msgstr ""
"To wygląda nieco lepiej, ale wypisywanie `[0, 1, 2, ...]` to nie jest najlepsze rozwiązanie, szczególnie, gdy lista jest długa.\n"
"Istnieje przydatna funkcja `range`, która zrobi to za ciebie. Zamień `[0, 1, 2, 3]` na `range(4)`,\n"
"czyli `indices = range(4)`."

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.0"
msgstr "range(4)"

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.1"
msgstr "range(0, 4)"

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.2"
msgstr "list(range(4))"

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.3"
msgstr "list(range(0, 4))"

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.4"
msgstr "range(0, 1, 2, 3)"

msgid "pages.GettingElementsAtPosition.steps.range_versus_list.text"
msgstr ""
"To jest może być zaskakujące. Jeśli jesteś ciekawy, `0` reprezentuje początek zakresu.\n"
"`0` to domyślny początek, więc `range(4)` jest równy `range(0, 4)`.\n"
"`4` to koniec zakresu, ale koniec jest zawsze wykluczony, więc ostatnia wartość to `3`.\n"
"Jeśli teraz jesteś zdezorientowany, nie martw się.\n"
"\n"
"Istnieje dobry powód, dla którego `range(4)` nie jest właściwie listą - sprawia, że programy działają szybciej i są bardziej wydajne.\n"
"W tej chwili nie warto tego bardziej wyjaśniać.\n"
"\n"
"Ale łatwo możesz to przekonwertować na listę: spróbuj `__program__` w konsoli."

msgid "pages.GettingElementsAtPosition.steps.using_len_first_time.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"print(len(words))"

msgid "pages.GettingElementsAtPosition.steps.using_len_first_time.text"
msgstr ""
"To tylko demonstracja, żebyś mógł zobaczyć zakres w bardziej znajomej formie.\n"
"Nigdy właściwie nie powinieneś tego robić.\n"
"\n"
"Jeśli czujesz się przytłoczony, nie martw się! Wszystko, co musisz wiedzieć, to że `range(n)`\n"
"jest bardzo podobne do listy:\n"
"\n"
"__code0__\n"
"\n"
"Tak przy okazji, możesz uzyskać liczbę elementów listy (często nazywaną *długością*) używając funkcji `len`.\n"
"Spróbuj to, uruchamiając ten kod:\n"
"\n"
"    __copyable__\n"
"__code1__"

msgid "pages.GettingElementsAtPosition.title"
msgstr "Pobieranie elementów, `range()`, i `len()`"

msgid "pages.GettingElementsAtPositionExercises.steps.final_text.text"
msgstr "Fantastycznie! Zrób sobie przerwę, zasłużyłeś na to!"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.0.text"
msgstr ""
"Będziesz musiał spojrzeć na wszystkie możliwe indeksy `things` i sprawdzić, "
"który z nich jest odpowiedzią."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.1.text"
msgstr ""
"Aby przejrzeć wszystkie możliwe indeksy, będziesz potrzebował pętli po "
"`range(len(things))`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.2.text"
msgstr "Aby sprawdzić, czy indeks jest odpowiedzią, będziesz musiał użyć:"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.3.text"
msgstr "- `if`"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.4.text"
msgstr "- indeksu w subskrypcie"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.5.text"
msgstr "- `==`"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.6.text"
msgstr ""
"Ponieważ szukasz pierwszego indeksu, musisz zatrzymać pętlę, gdy go "
"znajdziesz."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.7.text"
msgstr "Niedawno nauczyłeś się, jak zatrzymać pętlę w połowie."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.8.text"
msgstr "Potrzebujesz użyć `break`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.messages.all_indices.text"
msgstr ""
"Jesteś prawie na miejscu! Jednak to drukuje wszystkie indeksy,\n"
" nie tylko pierwszy."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.messages.last_index.text"
msgstr ""
"Jesteś prawie na miejscu! Jednak to drukuje *ostatni* indeks,\n"
" nie pierwszy."

msgid "pages.GettingElementsAtPositionExercises.steps.index_exercise.text"
msgstr ""
"Zakładając, że masz listę `things` oraz wartość `to_find`,\n"
"wydrukuj pierwszy indeks `to_find` na liście, tzn. najmniejszą liczbę `i` taką, że\n"
"`things[i]` jest `to_find`. Na przykład, dla\n"
"\n"
"    __no_auto_translate__\n"
"    things = ['on', 'the', 'way', 'to', 'the', 'store']\n"
"    to_find = 'the'\n"
"\n"
"twój program powinien wydrukować `1`.\n"
"\n"
"Możesz założyć, że `to_find` pojawia się przynajmniej raz."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.0.text"
msgstr ""
"Czy eksperymentowałeś z indeksowaniem i `len()` ze stringami w shellu?"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.1.text"
msgstr ""
"Na moment zapomnij o pętlach. Jak byś wydrukował tylko pierwszą linię, która"
" zawiera pierwszy znak każdego z dwóch stringów?"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.2.text"
msgstr ""
"W drugiej linii chcesz wydrukować drugi znak każdego stringa, i tak dalej."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.3.text"
msgstr "Będziesz potrzebować pętli `for`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.4.text"
msgstr "Będziesz potrzebować indeksowania (subskrypcji)."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.5.text"
msgstr "Będziesz potrzebować `range`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.6.text"
msgstr "Będziesz potrzebować `len`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.7.text"
msgstr "Będziesz potrzebować `+`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.8.text"
msgstr "Będziesz musiał zindeksować oba stringi."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.9.text"
msgstr ""
"Będziesz musiał przekazać ten sam indeks do obu stringów za każdym razem, "
"aby pobierać odpowiadające sobie znaki."

msgid "pages.GettingElementsAtPositionExercises.steps.zip_exercise.text"
msgstr ""
"Świetnie!\n"
"\n"
"Tak na marginesie, indeksowanie i `len()` również działają na stringach. Wypróbuj je w shellu.\n"
"\n"
"Oto kolejne ćwiczenie. Mając dwa stringi o równych długościach, np:\n"
"\n"
"    __no_auto_translate__\n"
"    string1 = 'Hello'\n"
"    string2 = 'World'\n"
"\n"
"wydrukuj je pionowo, obok siebie, z odstępem między każdą parą znaków:\n"
"\n"
"    H W\n"
"    e o\n"
"    l r\n"
"    l l\n"
"    o d"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.0.text"
msgstr ""
"Rozwiązanie ma tę samą ogólną strukturę i kluczowe elementy co poprzednie "
"rozwiązanie, jednak jest znacznie dłuższe i będzie wymagać kilku dodatkowych"
" pomysłów i części."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.1.text"
msgstr ""
"W szczególności powinno nadal zawierać coś w stylu:\n"
"\n"
"__code0__"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.2.text"
msgstr ""
"Co powinno się znaleźć w `range()`? Ani `len(string1)`, ani `len(string2)` "
"nie są wystarczająco dobre."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.3.text"
msgstr "Chcesz iteracji pętli dla każdego znaku w dłuższym stringu."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.4.text"
msgstr "To oznacza, że potrzebujesz `range(<długość najdłuższego stringu>)`"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.5.text"
msgstr ""
"Innymi słowy, potrzebujesz znaleźć większą z dwóch wartości `len(string1)` i"
" `len(string2)`. Już wykonałeś podobne ćwiczenie."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.6.text"
msgstr ""
"Kiedy już rozwiążesz kwestię pętli `for i in range(...)`, `i` czasami będzie"
" za duże, żeby było ważnym indeksem dla obu stringów. Będziesz musiał "
"sprawdzić, czy nie jest za duże przed indeksowaniem."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.7.text"
msgstr ""
"Pamiętaj, że największy ważny indeks dla `string1` to `len(string1) - 1`. "
"`len(string1)` jest za duże."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.8.text"
msgstr ""
"Będziesz potrzebować dwóch instrukcji `if`, jednej dla każdego stringu."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.9.text"
msgstr ""
"Będziesz musiał ustawić np. `char1 = ' '` gdy `string1[i]` nie jest ważny."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.text"
msgstr ""
"Niesamowite!\n"
"\n"
"Twoje rozwiązanie prawdopodobnie wyglądało mniej więcej tak:\n"
"\n"
"__code0__\n"
"\n"
"To nie działa zbyt dobrze, jeśli stringi mają różne długości.\n"
"W rzeczywistości, błędy pojawiają się na różne sposoby w zależności od tego, czy `string1` czy `string2` jest dłuższy.\n"
"Twoje kolejne wyzwanie polega na rozwiązaniu tego problemu poprzez wypełnienie 'brakujących' znaków spacjami.\n"
"\n"
"Na przykład, dla:\n"
"\n"
"    __no_auto_translate__\n"
"    string1 = 'Goodbye'\n"
"    string2 = 'World'\n"
"\n"
"wypisz:\n"
"\n"
"    G W\n"
"    o o\n"
"    o r\n"
"    d l\n"
"    b d\n"
"    y\n"
"    e\n"
"\n"
"i dla:\n"
"\n"
"    __no_auto_translate__\n"
"    string1 = 'Hello'\n"
"    string2 = 'Elizabeth'\n"
"\n"
"wypisz:\n"
"\n"
"    H E\n"
"    e l\n"
"    l i\n"
"    l z\n"
"    o a\n"
"      b\n"
"      e\n"
"      t\n"
"      h"

msgid "pages.GettingElementsAtPositionExercises.title"
msgstr "Ćwiczenia z `range()` i `len()`"

msgid "pages.HowToFindInformationWithGoogleAndMore.steps.dir_list.text"
msgstr ""
"Świetnie!\n"
"\n"
"Może być również przydatne wyszukiwanie takich rzeczy jak \"python list tutorial\", na przykład gdy:\n"
"\n"
"- Wyszukiwanie konkretnej metody się nie powiodło i chcesz ją znaleźć ręcznie.\n"
"- Nadal masz wątpliwości dotyczące list po tym kursie.\n"
"- Minęło trochę czasu odkąd uczyłeś się o listach i potrzebujesz przypomnienia.\n"
"- Zmagasz się z rozwiązaniem problemu z listami i musisz wrócić do podstaw i wzmocnić swoje podstawy.\n"
"\n"
"Są również sposoby na znalezienie informacji bez googlowania. Spróbuj `__program__` w konsoli."

msgid "pages.HowToFindInformationWithGoogleAndMore.steps.final_text.text"
msgstr ""
"`dir()` zwraca listę atrybutów argumentu, które są przeważnie metodami. "
"Wiele z nich zaczyna się od `__` , które na razie możesz zignorować - "
"przewiń do końca listy, a zobaczysz kilka znajomych metod."

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.hints.0.text"
msgstr "Użyj słów 'python' i 'lista' w zapytaniu wyszukiwania."

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.hints.1.text"
msgstr ""
"Zamiast umieszczać wartość na początku lub na końcu, chcemy ją umieścić "
"____________?"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.hints.2.text"
msgstr "'w środku' lub 'na indeksie' lub 'w określonej pozycji'"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.hints.3.text"
msgstr "'python dodaj wartość na indeksie'"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.requirements"
msgstr ""
"Uruchom kod podobny do trzech powyższych linii, ale zmień `nums.append(9)` na odpowiednie wywołanie funkcji/metody,\n"
"aby umieścić 9 zaraz po drugim elemencie (2 w przykładzie `nums = [1, 2, 3, 4, 5]`) zamiast na końcu.\n"
"Istnieje tylko jedna poprawna odpowiedź na to, co powinna być środkowa linia.\n"
"Musisz przeszukać internet, aby dowiedzieć się, jakiej funkcji/metody użyć i jak jej używać."

msgid "pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.text"
msgstr ""
"Dobrze ci poszło! Zróbmy jeszcze jedno zadanie. Rozważ ten program:\n"
"\n"
"__code0__\n"
"\n"
"To zmieni `nums`, tak że wypisze:\n"
"\n"
"__code1__\n"
"\n"
"Ale załóżmy, że nie chcesz, aby 9 było na końcu, chcesz by znalazła się między drugim a trzecim elementem, aby wynik był:\n"
"\n"
"__code2__\n"
"\n"
"Zastąp środkową linię `nums.append(9)` odpowiednim wywołaniem funkcji/metody, aby to osiągnąć."

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.hints.0.text"
msgstr "Użyj słów 'python' i 'lista' w zapytaniu wyszukiwania."

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.hints.1.text"
msgstr ""
"Jednym słowem, co jest szczególnego w `91` na liście `[21, 55, 4, 91, 62, "
"49]`?"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.hints.2.text"
msgstr "'największy' lub 'największa'"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.hints.3.text"
msgstr "'python największa wartość na liście'"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.requirements"
msgstr ""
"Uruchom kod podobny do `sum([21, 55, 4, 91, 62, 49])`, ale zastąp `sum` nazwą innej konkretnej funkcji.\n"
"Istnieje tylko jedna poprawna odpowiedź na to, jaka funkcja powinna zostać użyta. Musisz przeszukać internet,\n"
"aby dowiedzieć się, której użyć. Jest to powszechnie używana wbudowana funkcja w Pythonie."

msgid "pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.text"
msgstr ""
"Przydatne jest znać funkcje, które właśnie omówiliśmy, ale nie jest łatwo je wszystkie zapamiętać, a jest ich jeszcze więcej. Ważniejszą umiejętnością jest potrafić wyszukać informacje. Na przykład, oto kilka typowych sposobów jak byś mógł wyszukać wyżej wymienione funkcje w Google, jeśli zapomniałeś ich nazw:\n"
"\n"
"- `append`\n"
"    - python dodaj element do listy\n"
"    - python dodaj element na końcu listy\n"
"- `len`\n"
"    - python rozmiar listy\n"
"    - python liczba elementów na liście\n"
"    - python ile znaków w ciągu\n"
"- `sum`\n"
"    - python dodaj listę liczb\n"
"    - python suma liczb\n"
"- `in`\n"
"    - python sprawdź czy lista zawiera wartość\n"
"    - python sprawdź czy lista ma element\n"
"- `index`\n"
"    - python znajdź pozycję elementu\n"
"    - python uzyskaj indeks wartości\n"
"\n"
"Ćwiczymy teraz tę umiejętność. Znajdź funkcję/metodę, która zwraca wartość na liście, która jest większa niż jakakolwiek inna wartość. Na przykład, podana lista `[21, 55, 4, 91, 62, 49]`, powinna zwrócić `91`. Powinieneś napisać odpowiedź w konsoli jako pojedyncze, małe wyrażenie. Na przykład, jeśli szukałbyś funkcji `sum`, moglibyśmy napisać `sum([21, 55, 4, 91, 62, 49])`. Nie rozwiązuj tego ręcznie za pomocą pętli. Zauważ, że funkcja, której szukasz, nie była wcześniej tutaj wspomniana."

msgid "pages.HowToFindInformationWithGoogleAndMore.title"
msgstr "Jak szukać informacji z pomocą Google, i nie tylko"

msgid "pages.IfAndElse.steps.capitalise.hints.0.text"
msgstr ""
"Nauczyłeś się wszystkich narzędzi, których potrzebujesz. Wierzę w Ciebie! "
"Szukaj inspiracji w poprzednich programach."

msgid "pages.IfAndElse.steps.capitalise.hints.1.text"
msgstr "Będziesz potrzebować pętli, aby zbudować nowe zdanie znak po znaku."

msgid "pages.IfAndElse.steps.capitalise.hints.2.text"
msgstr ""
"Będziesz potrzebował `if/else`, aby zdecydować, czy dodać wielką literę, czy"
" małą."

msgid "pages.IfAndElse.steps.capitalise.hints.3.text"
msgstr ""
"Twoje `if/else` musi wykonać różne bloki kodu w zależności od iteracji "
"pętli, w której się znajduje."

msgid "pages.IfAndElse.steps.capitalise.hints.4.text"
msgstr ""
"To oznacza, że warunek Twojego `if` musi być zmienną, która zmienia się "
"wewnątrz pętli."

msgid "pages.IfAndElse.steps.capitalise.hints.5.text"
msgstr ""
"W pierwszej iteracji potrzebujesz wielkiej litery. W kolejnych iteracjach "
"potrzebujesz małej litery."

msgid "pages.IfAndElse.steps.capitalise.text"
msgstr ""
"Czas na wyzwanie!\n"
"\n"
"Napisz program, który, mając dany ciąg `sentence`, wydrukuje zmodyfikowaną wersję z\n"
"tymi samymi literami, gdzie pierwsza litera jest wielka, a reszta małe.\n"
"Na przykład, wynik powinien być `Hello world`, niezależnie czy wejście `sentence = 'hello world'`\n"
"czy `'HELLO WORLD'`."

msgid "pages.IfAndElse.steps.else_full_stop.hints.0.text"
msgstr ""
"Nie zmieniaj niczego, co jest już tam, dodaj tylko trochę więcej kodu."

msgid "pages.IfAndElse.steps.else_full_stop.hints.1.text"
msgstr ""
"`else` musi znajdować się bezpośrednio po ciele `if`, z niczym pomiędzy."

msgid "pages.IfAndElse.steps.else_full_stop.hints.2.text"
msgstr ""
"`sentence += char` musi zostać wykonane zarówno, gdy `excited` jest `True`, "
"jak i `False`."

msgid "pages.IfAndElse.steps.else_full_stop.hints.3.text"
msgstr ""
"Mógłbyś mieć kopię `sentence += char` zarówno w bloku `if`, jak i `else`, "
"ale jest lepszy sposób."

msgid "pages.IfAndElse.steps.else_full_stop.hints.4.text"
msgstr "Użyj `else`, aby przypisać inną wartość dla `char`."

msgid "pages.IfAndElse.steps.else_full_stop.hints.5.text"
msgstr ""
"Jeśli `excited` jest `False`, wtedy `char` powinien być `'.'` zamiast `'!'`."

msgid "pages.IfAndElse.steps.else_full_stop.text"
msgstr ""
"Jeśli `excited` ma wartość prawda, to `char` zostało zdefiniowane i wszystko działa poprawnie. W przeciwnym razie\n"
"`char` nigdy nie zostaje przypisane wartość, więc próba użycia go w `sentence += char` kończy się niepowodzeniem.\n"
"\n"
"Napraw to, dodając klauzulę `else` do `if`, tak aby jeśłi `excited` jest nieprawdziwe, kropka (`.`)\n"
"została dodana na końcu zdania zamiast wykrzyknika (`!`)."

msgid "pages.IfAndElse.steps.final_text.text"
msgstr ""
"Doskonale! Zatrzymaj się na chwilę i ciesz się z tego, co osiągnąłeś. Czy "
"czujesz, że Twój mózg rośnie?"

msgid "pages.IfAndElse.steps.first_if_else.text"
msgstr ""
"Instrukcja `if` może opcjonalnie mieć część `else`. Uruchom ten przykład:\n"
"\n"
"__program_indented__"

msgid "pages.IfAndElse.steps.first_if_else_false.requirements"
msgstr ""
"Uruchom ten sam program z poprzedniego kroku, ale zastąp `True` na `False`, "
"więc `condition = False`."

msgid "pages.IfAndElse.steps.first_if_else_false.text"
msgstr ""
"Teraz zmień pierwszą linię na `condition = False` i uruchom to ponownie."

msgid "pages.IfAndElse.steps.if_upper_else_lower.text"
msgstr ""
"Pomyśl o `else` jako o sformułowaniu 'w przeciwnym razie'. Oznacza to, że jeśli warunek w `if` jest fałszywy, to zostanie wykonany kod w `else`. Bez względu na to, czy warunek jest prawdziwy czy fałszywy, dokładnie jeden z dwóch bloków zostanie wykonany.\n"
"\n"
"Oto bardziej interesujący przykład do uruchomienia:\n"
"\n"
"__program_indented__"

msgid "pages.IfAndElse.steps.if_upper_else_lower_false.requirements"
msgstr ""
"Uruchom ten sam program z poprzedniego kroku, ale zastąp `True` na `False`, "
"więc `excited = False`."

msgid "pages.IfAndElse.steps.if_upper_else_lower_false.text"
msgstr ""
"`sentence.upper()` to nowy rodzaj wyrażenia, z którym się jeszcze nie spotkaliśmy. Chodzi o to, że `sentence` to ciąg znaków i ciągi znaków mają różne *metody*, które pozwalają wygodnie obliczać nowe wartości, w tym `upper` i `lower`. Nazwy odnoszą się do wielkich liter (uppercase) i małych liter (lowercase). `'Hello World'.upper()` zwraca `'HELLO WORLD'`. Nie zmienia to jednak zawartości `sentence`, więc musisz przypisać nową wartość ponownie za pomocą `sentence = sentence.upper()`.\n"
"\n"
"Teraz zmień `excited` na `False` i uruchom to ponownie."

msgid "pages.IfAndElse.steps.spongebob.hints.0.text"
msgstr ""
"To podobne do poprzedniego ćwiczenia. Różnica polega na tym, kiedy i gdzie "
"ustawiasz zmienną warunkową."

msgid "pages.IfAndElse.steps.spongebob.hints.1.text"
msgstr ""
"Będziesz potrzebować zmiennej typu boolean, która zmienia się z każdą "
"iteracją."

msgid "pages.IfAndElse.steps.spongebob.hints.2.text"
msgstr ""
"Najpierw napisz mały program, który bierze zmienną typu boolean i odwraca "
"ją, np. jeśli zmienna jest `True`, staje się `False` i odwrotnie, jeśli "
"zaczyna sie od `False`, zmienia się na `True`. Bez pętli, tylko z `if/else`."

msgid "pages.IfAndElse.steps.spongebob.hints.3.text"
msgstr ""
"Będziesz musiał użyć tej zmiennej w warunku `if` oraz przypisać do tej samej"
" zmiennej w ciele."

msgid "pages.IfAndElse.steps.spongebob.hints.4.text"
msgstr ""
"Połącz to odwracające `if/else` z tym, które wybiera wielką lub małą literę."

msgid "pages.IfAndElse.steps.spongebob.text"
msgstr ""
"Wspaniale!!!\n"
"\n"
"Jeszcze jedno ćwiczenie, a potem możesz się zrelaksować.\n"
"\n"
"Napisz program, który wypisuje `sentence` w sposób kpiący, np.:\n"
"\n"
"    OnE MoRe eXeRcIsE, aNd tHeN YoU CaN ReLaX.\n"
"\n"
"Co drugi znak powinien być małą literą, reszta wielkimi literami."

msgid "pages.IfAndElse.steps.undefined_char.output_prediction_choices.0"
msgstr "Hello World"

msgid "pages.IfAndElse.steps.undefined_char.output_prediction_choices.1"
msgstr "Hello World!"

msgid "pages.IfAndElse.steps.undefined_char.requirements"
msgstr ""
"Skopiuj program powyżej. Uruchom go tak, jak jest jeśli chcesz. Następnie "
"zmień `excited = True` na `excited = False` i uruchom to ponownie."

msgid "pages.IfAndElse.steps.undefined_char.text"
msgstr ""
"Oto zepsuty program:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Czy widzisz problem? Jeśli uruchomisz ten kod, wszystko wydaje się być w porządku. Co może pójść nie tak?\n"
"\n"
"Odpowiedzi poniżej! Czy już to rozgryzłeś?\n"
"\n"
"Co się dzieje, jeśli zmienisz `excited` na `False`?"

msgid "pages.IfAndElse.title"
msgstr "`if` i `else`"

msgid "pages.Indentation.steps.final_text.text"
msgstr ""
"Kiedy używasz wcięć, powinieneś zawsze wciąć o 4 spacje. Wprawdzie każde "
"spójne wcięcie jest akceptowalne, ale 4 spacje to konwencja, której "
"przestrzega prawie każdy. Zauważ, że edytor na ogół ci to ułatwia. "
"Na przykład, jeśli naciśniesz klawisz 'Tab' na klawiaturze w edytorze, "
"zostaną wstawione 4 spacje."

msgid "pages.Indentation.steps.mismatched_indentations.program"
msgstr ""
"for character in name:\n"
"    print(character)\n"
"  print('---')"

msgid "pages.Indentation.steps.mismatched_indentations.text"
msgstr ""
"Ponieważ `print('---')` nie jest wcięte, nie jest częścią ciała pętli. Oznacza to, że jest wykonywane tylko raz, po zakończeniu całej pętli. Obydwa programy są poprawne, po prostu robią różne rzeczy.\n"
"\n"
"Poniższy program jest niepoprawny. Obie linie w ciele pętli są wcięte, ale o różnych ilościach. Pierwsza linia zaczyna się od 4 spacji, druga linia zaczyna się od 2. Spróbuj go uruchomić.\n"
"\n"
"__program_indented__"

msgid "pages.Indentation.steps.missing_indentation.program"
msgstr ""
"for character in name:\n"
"print(character)"

msgid "pages.Indentation.steps.missing_indentation.text"
msgstr ""
"Ta pętla przykładowa:\n"
"\n"
"__code0__\n"
"\n"
"działa, ale zazwyczaj jest (i powinna) być napisana tak:\n"
"\n"
"__code1__\n"
"\n"
"Konkretnie, kod do powtórzenia (znany jako *ciało*) zaczyna się w nowej linii po dwukropku (`:`), i musi być *wcięty*, tzn. mieć kilka spacji przed nim. Kod poniżej bez wcięcia jest nieprawidłowy, uruchom go, aby przekonać się sam:\n"
"\n"
"__program_indented__"

msgid "pages.Indentation.steps.one_indented_line.text"
msgstr ""
"Są dwie linie z wcięciem, więc obie są częścią ciała, więc `---` zostanie wydrukowane po każdym znaku. Teraz spróbuj uruchomić ten sam kod bez wcięcia w ostatniej linii:\n"
"\n"
"__code0__"

msgid "pages.Indentation.steps.two_indented_lines.text"
msgstr ""
"Spacje są wymagane, aby powiedzieć Pythonowi, które linie kodu należą do ciała pętli for. Jest to kluczowe, kiedy pętla zawiera kilka linii, co często ma miejsce. Na przykład, uruchom ten kod:\n"
"\n"
"__code0__"

msgid "pages.Indentation.title"
msgstr "Wcięcia"

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.0.text"
msgstr "`input()` zawsze zwraca string."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.1.text"
msgstr "String wyglądający jak liczba wciąż jest stringiem, a nie liczbą."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.2.text"
msgstr "W `super_secret_number = 7`, `7` to liczba, a nie string."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.3.text"
msgstr "To sprawia, że `super_secret_number` też jest liczbą."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.4.text"
msgstr "String nie może być równy liczbie."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.5.text"
msgstr ""
"Aby sprawdzić, czy dwie wartości są równe, upewnij się najpierw, że są tego "
"samego typu."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.6.text"
msgstr ""
"Więc aby porównać liczbę i string, najpierw przekonwertuj liczbę na string "
"lub przekonwertuj string na liczbę."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.7.text"
msgstr ""
"Nauczyłeś się, jak przekształcać pomiędzy stringami a liczbami na "
"poprzedniej stronie."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.8.text"
msgstr ""
"Użyj `int()` do konwersji na liczbę całkowitą (naturalną) lub `str()` do "
"konwersji na string."

msgid "pages.InteractiveProgramsWithInput.steps.convert_input_to_int.text"
msgstr ""
"Cokolwiek wpisałeś (nie licząc wciśnięcia Entera na końcu) jest zwracane z funkcji `input()` jako string.\n"
"\n"
"Zasadnicze jest zrozumienie, że `input()` ***zawsze zwraca string***, bez względu na to, co użytkownik wpisał.\n"
"To do Ciebie należy konwersja tego stringa na typ, którego potrzebujesz.\n"
"Zapominanie o tym szczególe jest częstym źródłem zamieszania w błędach.\n"
"\n"
"Na przykład, ten program na pierwszy rzut oka wygląda dobrze, ale jeśli go wypróbujesz, zobaczysz, że właściwie nie działa:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Popraw program tak, aby gdy użytkownik wprowadzi wartość `super_secret_number` (`7` w tym przykładzie)\n"
"program wydrukował `Amazing! Are you psychic?` jak się spodziewamy.\n"
"Powinien działać, gdy `super_secret_number` jest dowolną liczbą całkowitą (`int`)."

msgid "pages.InteractiveProgramsWithInput.steps.final_text.text"
msgstr ""
"Świetnie!\n"
"\n"
"Są dwie główne poprawki, które by tu zadziałały. Możesz przekonwertować wejście na liczbę:\n"
"\n"
"__code0__\n"
"\n"
"lub przekonwertować poprawną odpowiedź na string:\n"
"\n"
"__code1__\n"
"\n"
"Ważną różnicą między tymi dwoma podejściami jest to, że pierwsze podejście spowoduje wyświetlenie błędu,\n"
"jeśli użytkownik wpisze coś, co nie jest liczbą, co może być, albo i nie, tym, czego chcesz."

msgid "pages.InteractiveProgramsWithInput.steps.first_input.text"
msgstr ""
"Programy, które dotychczas napisaliśmy, nie są interaktywne.\n"
"Aby stworzyć naszą interaktywną grę w kółko i krzyżyk, będziemy potrzebować metody odbierania danych wejściowych od graczy.\n"
"Python pozwala na to za pomocą wbudowanej funkcji `input`. Uruchom ten program:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Gdy uruchomisz `name = input()`, program faktycznie zatrzymuje się i czeka, aż coś wpiszesz w powłoce i naciśniesz Enter,\n"
"więc musisz to zrobić, aby mógł się zakończyć."

msgid "pages.InteractiveProgramsWithInput.title"
msgstr "Interaktywne programy z `input()`"


msgid "pages.IntroducingAnd.steps.AndExercise.hints.0.text"
msgstr ""
"Jeśli masz coś takiego jak `x < 0 and x > 100`, to jesteś na złym tropie. To"
" będzie `False` dla *każdej* wartości `x`!"

msgid "pages.IntroducingAnd.steps.AndExercise.hints.1.text"
msgstr ""
"Rozwiązanie z `and` różni się na wiele sposobów od rozwiązania z `or`."

msgid "pages.IntroducingAnd.steps.AndExercise.hints.2.text"
msgstr ""
"Nasze rozwiązanie z `or` najpierw określa, czy `x` jest nieprawidłowym "
"procentem, w przeciwnym razie zakłada ważność. Używając `and` to zrobi "
"odwrotnie."

msgid "pages.IntroducingAnd.steps.AndExercise.hints.3.text"
msgstr "Będziesz musiał odwrócić instrukcje `return` odpowiednio."

msgid "pages.IntroducingAnd.steps.AndExercise.hints.4.text"
msgstr "Będziesz musiał również zmienić operatory porównania."

msgid "pages.IntroducingAnd.steps.AndExercise.text"
msgstr ""
"Ćwiczmy teraz. Wcześniej napisaliśmy funkcję `is_valid_percentage` używając `or`. Oto przykład\n"
"rozwiązania:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Przepisz tę funkcję używając `and`."

msgid "pages.IntroducingAnd.steps.FalseAndFalse.text"
msgstr ""
"W końcu, spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.0.text"
msgstr "Lista będzie zawsze miała 3 elementy."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.1.text"
msgstr "To oznacza, że nie musisz używać pętli."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.2.text"
msgstr "Pamiętaj, że możesz uzyskać pierwszy element używając `row[0]`."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.3.text"
msgstr ""
"Pierwszy element, drugi element i trzeci element muszą być takie same."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.4.text"
msgstr ""
"To oznacza, że pierwszy element powinien być równy drugiemu elementowi oraz "
"trzeciemu elementowi."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.text"
msgstr ""
"Świetnie! Oto jedno z możliwych rozwiązań:\n"
"\n"
"__code0__\n"
"\n"
"Tak jak wcześniej, możemy to rozwiązanie uprościć:\n"
"\n"
"__code1__\n"
"\n"
"Jest inny sposób, aby to jeszcze bardziej ulepszyć, nazywa się to łączeniem porównań (ang. _comparison chaining_). Każdy warunek taki jak:\n"
"\n"
"__code2__\n"
"\n"
"może być skrócony przez usunięcie dodatkowego `and b`:\n"
"\n"
"__code3__\n"
"\n"
"To działa dla wszystkich operatorów porównania, włączając `==`, i nawet można używać różnych operatorów.\n"
"Więc rozwiązanie można uprościć do:\n"
"\n"
"__code4__\n"
"\n"
"Kolejne ćwiczenie: mając listę trzech elementów, sprawdź czy wszystkie trzy elementy są takie same.\n"
"\n"
"    __copyable__\n"
"__code5__"

msgid "pages.IntroducingAnd.steps.TrueAndFalse.text"
msgstr ""
"Dobrze, teraz spróbuj:\n"
"\n"
"__program_indented__\n"
"\n"
"Czego się spodziewasz?"

msgid "pages.IntroducingAnd.steps.TrueAndTrue.text"
msgstr ""
"Inny operatorem logicznym w Pythonie jest `and`.\n"
"Wyrażenie `A and B` jest `True` tylko jeżeli zarówno `A` i `B` są `True`. W przeciwnym przypadku jest `False`.\n"
"Spróbuj w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingAnd.steps.final_text.text"
msgstr ""
"Dobra robota. Istnieje wiele możliwych prawidłowych rozwiązań tutaj:\n"
"\n"
"__code0__\n"
"\n"
"lub używając ponownie łańcucha porównań:\n"
"\n"
"__code1__\n"
"\n"
"lub sprawdzając, czy równa się liście zawierającej trzy razy pierwszy element:\n"
"\n"
"__code2__"

msgid "pages.IntroducingAnd.title"
msgstr "Wprowadzenie `and`"

msgid "pages.IntroducingBirdseye.steps.birdseye_loop_example.text"
msgstr ""
"Inne narzędzia pokazują, jak kod wykonuje się linia po linii oraz jakie są wartości zmiennych, `birdseye` pokazuje wartość każdego wyrażenia w programie. Pozwala to zobaczyć, jak skomplikowane wyrażenie jest rozbijane na mniejsze podwyrażenia\n"
"i jakie są ich wartości.\n"
"\n"
"Najedź kursorem na różne wyrażenia w ramkach w ostatniej linii programu.\n"
"Gdy każda ramka jest podświetlona, wartość zostaje pokazana na dole ekranu. Po kliknięciu na ramkę zostaje ona przymocowana do panelu, dzięki czemu możesz zobaczyć kilka wartości wyrażeń na raz i swobodnie poruszać kursorem.\n"
"\n"
"W tym przypadku `birdseye` pokazuje, że wyrażenie:\n"
"\n"
"__code0__\n"
"\n"
"jest rozbijane na\n"
"\n"
"__code1__\n"
"\n"
"a nie na\n"
"\n"
"__code2__\n"
"\n"
"Innymi słowy, Python przestrzega zwykłej kolejności operacji w matematyce, a nie po prostu oceniając od lewej do prawej.\n"
"\n"
"Zauważ, że istnieją wyrażenia, które `birdseye` nie umieszcza w ramkach. W tym przypadku `2`, `3`, `4`, `5` i `print` to także wyrażenia, ale ich wartości są oczywiste i umieszczenie ich w ramkach tylko by je zaśmiecało.\n"
"\n"
"Oto bardziej skomplikowany przykład do wypróbowania:\n"
"\n"
"    __copyable__\n"
"__code3__"

msgid "pages.IntroducingBirdseye.steps.final_text.text"
msgstr ""
"Zauważ, że:\n"
"\n"
"1. Obok pętli for jest para strzałek. Kliknij je, aby nawigować przez pętlę w czasie i zobaczyć, co działo się w różnych iteracjach.\n"
"2. Kod, który nie został wykonany w iteracji z powodu `if`, jest wyszarzony. Wyrażenia w środku nie mają wartości, ponieważ nie zostały ocenione.\n"
"3. Wartości zapisane dla wyrażeń `vowels` i `consonants` zależą od tego, na którą ramkę patrzysz. W linijkach po pętli zawierają wszystkie litery, ale wewnątrz pętli mają tylko niektóre, i dokładnie ile, zależy od tego, która iteracja jest aktualnie wyświetlana.\n"
"4. W `vowels.append(letter)`, widzisz, jakie były wartości tych zmiennych *w tym momencie*. Oznacza to, że `letter` zaraz zostanie dołączony do `vowels`, ale to jeszcze się nie stało, więc `vowels` nie zawiera jeszcze `letter`."

msgid "pages.IntroducingBirdseye.steps.first_birdseye_example.text"
msgstr ""
"Widziałeś już `snoop` i Python Tutor. futurecoder jest wyposażony jeszcze w jedno narzędzie do analizowania programów w trakcie ich działania, nazywane `birdseye`.\n"
"\n"
"Oto przykładowy program do uruchomienia. Skopiuj go do edytora i kliknij przycisk `birdseye`. Spowoduje to otwarcie nowej karty przeglądarki z wizualizacją.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingBirdseye.title"
msgstr "Zrozumienie Programów przy Pomocy `birdseye`"

msgid ""
"pages.IntroducingDictionaries.steps.dict_access.special_messages.bad_french_value.text"
msgstr ""
"Oops, you need to set `french = {'apple': 'pomme', 'box': 'boite'}` before "
"we can continue."

msgid "pages.IntroducingDictionaries.steps.dict_access.text"
msgstr ""
"`french` is a dictionary with two key-value pairs:\n"
"\n"
"- `'apple': 'pomme'` where `'apple'` is the key and `'pomme'` is the value.\n"
"- `'box': 'boite'` where `'box'` is the key and `'boite'` is the value.\n"
"\n"
"Like lists, a comma (`,`) is used to separate items (key-value pairs) from each other. A colon (`:`) separates the keys from the values.\n"
"Note that curly brackets (`{}`) are used to create the dictionary instead of the square brackets (`[]`) used when writing lists.\n"
"\n"
"Remember that with lists, you get values based on their *index*, i.e. their position in the list.\n"
"So if `words = ['apple', 'box']`, then `words[0]` is `'apple'` and `words[1]` is `'box'`.\n"
"Try this in the shell:\n"
"\n"
"__program_indented__"

msgid ""
"pages.IntroducingDictionaries.steps.dict_access2.special_messages.bad_french_value.text"
msgstr ""
"Oops, you need to set `french = {'apple': 'pomme', 'box': 'boite'}` before "
"we can continue."

msgid "pages.IntroducingDictionaries.steps.dict_access2.text"
msgstr ""
"That doesn't work because the position of items in a dictionary usually doesn't matter.\n"
"You don't usually care what's the 2nd or 5th or 100th word of the dictionary,\n"
"you just want to find a specific word like 'apple'. So try that instead:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingDictionaries.steps.dict_access3.requirements"
msgstr ""
"Run the same code as the previous step (`french['apple']`) in the shell, but"
" replace `'apple'` with `'box'`."

msgid ""
"pages.IntroducingDictionaries.steps.dict_access3.special_messages.bad_french_value.text"
msgstr ""
"Oops, you need to set `french = {'apple': 'pomme', 'box': 'boite'}` before "
"we can continue."

msgid "pages.IntroducingDictionaries.steps.dict_access3.text"
msgstr ""
"That's better!\n"
"\n"
"Now run a similar line in the shell to look up the translation for `'box'`."

msgid ""
"pages.IntroducingDictionaries.steps.dict_access4.special_messages.bad_french_value.text"
msgstr ""
"Oops, you need to set `french = {'apple': 'pomme', 'box': 'boite'}` before "
"we can continue."

msgid "pages.IntroducingDictionaries.steps.dict_access4.text"
msgstr ""
"And now you know both Python and French!\n"
"\n"
"Now let's translate from French to English:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingDictionaries.steps.final_text.text"
msgstr ""
"Sorry, you can't do that either. You can only look up a key to get its value, not the other way around.\n"
"The dictionary `french` only has 2 keys: `'apple'` and `'box'`. `'pomme'` is a value, not a key.\n"
"We'll soon learn why you can't just look up values directly, and what you can do about it.\n"
"\n"
"Note that both `french[0]` and `french['pomme']` raised the same type of error: a `KeyError`.\n"
"This error means that the provided key (`0` or `'pomme'` in this case) wasn't found in the dictionary.\n"
"It's not that `french[0]` isn't *allowed*, it's just that it means the same thing as always:\n"
"find the value associated with the key `0`. In this case it finds that no such key exists.\n"
"But `0` *could* be a key, because many types of keys are allowed, including strings and numbers."

msgid "pages.IntroducingDictionaries.steps.first_dict.text"
msgstr ""
"We've seen several types: `str`, `int`, `float`, `bool`, and `list`.\n"
"Only one of these types can contain multiple values: `list`.\n"
"Now we're going to learn about another container type: `dict`, short for ***dictionary***.\n"
"\n"
"Think of the familiar kind of dictionary where you look up a word to find its definition or a translation in another language.\n"
"Dictionaries in Python are similar, but more general. You look up a *key* (e.g. a word) to get the associated *value* (e.g. a definition or translation).\n"
"\n"
"For example, here's a little dictionary translating English words to French:\n"
"\n"
"__code0__\n"
"\n"
"Run the line above in the shell."

msgid "pages.IntroducingDictionaries.title"
msgstr "Introducing Dictionaries"

msgid "pages.IntroducingElif.steps.dna_example.text"
msgstr ""
"Szybka lekcja biologii! Większość komórek w twoim ciele zawiera pełny kod genetyczny w DNA.\n"
"Składa się on z nici zbudowanych z molekularnych jednostek zwanych nukleobazami, które występują w czterech rodzajach:\n"
"Adenina, Cytozyna, Guanina i Tymina, czyli w skrócie ACGT.\n"
"Część pojedynczej nici może wyglądać na przykład tak:\n"
"\n"
"    AGTAGCGTCCTTAGTTACAGGATGGCTTAT...\n"
"\n"
"Będzie ona sparowana z inną nicią, gdzie A jest zastępowane przez T i odwrotnie,\n"
"a C jest zastępowane przez G i odwrotnie, np.:\n"
"\n"
"    TCATCGCAGGAATCAATGTCCTACCGAATA...\n"
"\n"
"Dwie nici są 'zamykane' razem w słynną strukturę podwójnej helisy,\n"
"łącząc się poprzez pasujące pary A-T i C-G. Te połączenia są istotne w kopiowaniu DNA, gdy\n"
"komórki się dzielą i rozmnażają. Podwójna helisa jest rozpinana, a kod jest przepisywany\n"
"na jego przeciwną wersję, aby utworzyć kopię.\n"
"\n"
"Zamierzamy powtórzyć ten proces. Spróbujmy napisać podobny program, jak ten, który właśnie napisaliśmy:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingElif.steps.dna_example_with_elif.requirements"
msgstr ""
"Skopiuj program z pierwszego kroku na tej stronie, ale zamień 4 bloki `if` na kombinację bloków `if` i `elif` stąd.\n"
"Innymi słowy, zamień każde z ostatnich trzech `if` na `elif`, ale pozostaw pierwszy `if` bez zmian."

msgid "pages.IntroducingElif.steps.dna_example_with_elif.text"
msgstr ""
"Świetnie! Naśladowałeś właśnie to, co robią twoje komórki na co dzień.\n"
"\n"
"`if` wewnątrz `else` można zastąpić pojedynczym słowem kluczowym `elif`. Na przykład,\n"
"poprzedni kod można zmienić na:\n"
"\n"
"__code0__"

msgid "pages.IntroducingElif.steps.dna_example_with_else.hints.0.text"
msgstr ""
"Zmień:\n"
"\n"
"__code0__\n"
"\n"
"aby wyglądało jak poprawiony fragment. To tylko mała zmiana, wykonaj ją bez kopiowania i wklejania."

msgid "pages.IntroducingElif.steps.dna_example_with_else.hints.1.text"
msgstr "Teraz dokonaj tej samej zmiany w kodzie zamieniającym G i C."

msgid "pages.IntroducingElif.steps.dna_example_with_else.text"
msgstr ""
"Ojej, to nie do końca działa. `T` zostaje zamienione na `A`, ale `A` nie jest zamienione na nic.\n"
"Czy rozumiesz dlaczego?\n"
"\n"
"Gdy `char == 'A'`, wtedy instrukcja `char = 'T'` rzeczywiście jest wykonywana. Ale to oznacza, że kolejny\n"
"warunek `char == 'T'` również jest spełniony, więc `char = 'A'` i wracamy do punktu wyjścia.\n"
"Musimy zmienić `char` z `T` na `A` tylko wtedy, gdy `char` nie było wcześniej `A`,\n"
"czyli gdy `char == 'A'` było `False`. Możemy to zrobić za pomocą `else`, tak jak tutaj:\n"
"\n"
"__code0__\n"
"\n"
"Teraz popraw program, aby zamieniał wszystkie znaki poprawnie."

msgid "pages.IntroducingElif.steps.final_text.text"
msgstr ""
"Często mamy do czynienia z łańcuchem klauzul `elif`, gdy chcemy, by jeden z wielu\n"
"bloków kodu się wykonał, tak jak w tym przypadku. Ogólnie kod taki jak ten:\n"
"\n"
"__code0__\n"
"\n"
"można przepisać jako:\n"
"\n"
"__code1__\n"
"\n"
"co jest krótsze i oszczędza nam skomplikowanego zagnieżdżania. Różnica jest tylko kosmetyczna:\n"
"gdy komputer wykonuje ten kod, nie potrafi odróżnić jednej wersji od drugiej.\n"
"\n"
"Zauważ, że za `elif`(ami) opcjonalnie można dodać jeden ostatni `else`. Nie umieściliśmy go\n"
"w naszym przykładzie z DNA, ale moglibyśmy dodać go, aby ostrzec nas o wszelkich nieoczekiwanych znakach\n"
"w danych wejściowych lub zmienić `elif char == 'C':` na `else:`, gdybyśmy byli pewni\n"
"że dane wejściowe są poprawne."

msgid "pages.IntroducingElif.title"
msgstr "Wprowadzenie do `elif`"

msgid "pages.IntroducingForLoops.steps.final_text.text"
msgstr ""
"Kod można czytać prawie jak zwykły angielski:\n"
"\n"
"> For each character in the string `name`, print that character.\n"
"\n"
"> Dla każdego znaku w ciągu `name`, wydrukuj ten znak.\n"
"\n"
"Każdy znak to również normalny ciąg znaków (ang. string). `character` to normalna zmienna, której przed wykonaniem kodu po `:` przypisywana jest nowa wartość. Więc kod powyżej jest równoważny:\n"
"\n"
"    __no_auto_translate__\n"
"    name = 'World'\n"
"\n"
"    character = 'W'\n"
"    print(character)\n"
"\n"
"    character = 'o'\n"
"    print(character)\n"
"\n"
"    character = 'r'\n"
"    print(character)\n"
"\n"
"    character = 'l'\n"
"    print(character)\n"
"\n"
"    character = 'd'\n"
"    print(character)\n"
"\n"
"Zauważ, że moglibyśmy użyć innej nazwy zmiennej, `character` po prostu sprawia, że jest to jaśniejsze.\n"
"\n"
"Pętla for zazwyczaj stosuje się w następującej strukturze:\n"
"\n"
"    for <zmienna> in <kolekcja>: <kod do powtórzenia>\n"
"\n"
"Elementy `for`, `in`, i `:` są niezbędne."

msgid "pages.IntroducingForLoops.steps.first_for_loop.text"
msgstr ""
"Dobre wiadomości! Udało Ci się przebrnąć przez nudne podstawy. Możemy zacząć pisać niektóre ciekawe programy i trochę się bawić. Jednym z najpotężniejszych pojęć w programowaniu jest *pętla* (ang. loop), która pozwala powtarzać ten sam kod wielokrotnie. Python ma dwa rodzaje pętli: pętle `for` i pętle `while`. Oto przykład pętli for, spróbuj uruchomić ten program:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingForLoops.title"
msgstr "Wprowadzenie do pętli for"

msgid "pages.IntroducingFstrings.steps.basic_f_string_exercise.hints.0.text"
msgstr "To jest podobne do podanego przykładu f-stringa."

msgid "pages.IntroducingFstrings.steps.basic_f_string_exercise.hints.1.text"
msgstr "Czy zapomniałeś o `f`?"

msgid "pages.IntroducingFstrings.steps.basic_f_string_exercise.hints.2.text"
msgstr "Ile par nawiasów klamrowych potrzebujesz?"

msgid "pages.IntroducingFstrings.steps.basic_f_string_exercise.text"
msgstr ""
"Nie powiedzie się, ponieważ nie możemy użyć `+` między ciągiem znaków `\"Cześć Alice. Masz \"` a liczbą `age`.\n"
"\n"
"Napraw to, zastępując wszystkie konkatenacje ciągów znaków (+) jednym f-stringiem."

msgid ""
"pages.IntroducingFstrings.steps.concatenate_string_number.output_prediction_choices.0"
msgstr "\"Hello \" + name + \". You are \" + age + \" years old.\""

msgid ""
"pages.IntroducingFstrings.steps.concatenate_string_number.output_prediction_choices.1"
msgstr "Hello name. You are age years old."

msgid ""
"pages.IntroducingFstrings.steps.concatenate_string_number.output_prediction_choices.2"
msgstr "Hello Alice. You are 20 years old."

msgid ""
"pages.IntroducingFstrings.steps.concatenate_string_number.output_prediction_choices.3"
msgstr "Hello 'Alice'. You are 20 years old."

msgid "pages.IntroducingFstrings.steps.concatenate_string_number.text"
msgstr ""
"Składnia f-stringa zaczyna się od `f` po czym następuje ciąg znaków.\n"
"F-string może zawierać nazwy zmiennych w nawiasach klamrowych `{}`.\n"
"Będą one zastępowane wartościami tych zmiennych przekształconymi na ciągi znaków.\n"
"Zmienne mogą być dowolne: ciągi znaków, liczby, listy i tak dalej.\n"
"\n"
"W związku z tym f-stringi pozwalają łatwo łączyć ciągi znaków z liczbami, które nie mogą\n"
"po prostu zostać dodane do siebie. Na przykład, uruchom poniższy program:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingFstrings.steps.eval_expr_inside_f_string.text"
msgstr ""
"Ponadto, f-string może zawierać w nawiasach klamrowych dowolne wyrażenie Pythona.\n"
"Spróbuj tego w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingFstrings.steps.final_text.text"
msgstr ""
"Świetnie!\n"
"\n"
"Od teraz zachęcamy do używania f-stringów zamiast `+` do budowania ciągów znaków tam, gdzie to możliwe."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.0.text"
msgstr "Są cztery problemy z wyrażeniem wewnątrz `print`."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.1.text"
msgstr "Jest problem z syntaksem znalezienia liczby ludzi."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.2.text"
msgstr "Potem jeden z ciągów znaków ma problem z cudzysłowami."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.3.text"
msgstr "Jest też problem z syntaksem znalezienia imienia pierwszej osoby."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.4.text"
msgstr "Nie możesz dodać ciągu znaków do liczby!"

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.5.text"
msgstr "Czy poprawnie użyłeś nawiasów klamrowych w twoim f-stringu?"

msgid "pages.IntroducingFstrings.steps.fix_broken_program.text"
msgstr ""
"Jak widać, możemy także zdefiniować f-string używając cudzysłowów, tak jak w przypadku zwykłego ciągu znaków.\n"
"I podobnie jak w przypadku cudzysłowów, f-stringi są tylko notacją. Po ich wyliczeniu komputer zapomina,\n"
"że użyto f-stringa, przechowuje tylko końcowy wynik jako zwykły ciąg znaków.\n"
"\n"
"Oto bardzo zepsuty program:\n"
"\n"
"    __copyable__\n"
"    people = [\"Alice\", \"Bob\", \"Charlie\"]\n"
"    print('There are' + people.length() + 'people waiting, the first one's name is' + people.1 + '.')\n"
"\n"
"Napraw to!\n"
"Twoje rozwiązanie powinno działać dla dowolnej listy ciągów znaków o nazwie `ludzie`.\n"
"Na przykład w powyższym przypadku powinno wypisać:\n"
"\n"
"    There are 3 people waiting, the first one's name is Alice."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.0"
msgstr "f\"{name} went to {meal} with {friend}.\""

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.1"
msgstr "\"{name} went to {meal} with {friend}.\""

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.2"
msgstr "{name} went to {meal} with {friend}."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.3"
msgstr "'name' went to 'meal' with 'friend'."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.4"
msgstr "name went to meal with friend."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.5"
msgstr "\"Alice\" went to \"lunch\" with 'Bob'."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.6"
msgstr "'Alice' went to 'lunch' with 'Bob'."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.7"
msgstr "\"Alice went to lunch with Bob.\""

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.8"
msgstr "Alice went to lunch with Bob."

msgid "pages.IntroducingFstrings.steps.introduce_f_strings.requirements"
msgstr ""
"Uruchom program powyżej, ale zastąp ten kod wewnątrz `print()`:\n"
"\n"
"__code0__\n"
"\n"
"przez:\n"
"\n"
"__code1__"

msgid "pages.IntroducingFstrings.steps.introduce_f_strings.text"
msgstr ""
"Do tej pory łączyliśmy ciągi znaków, konkatenując je za pomocą `+`, na przykład:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Jednak jest to trochę niewygodne. Możemy napisać to samo w bardziej elegancki sposób, używając *f-stringa*.\n"
"Zastąp ostatnią linię programu powyżej poniższą linią i uruchom ją.\n"
"Upewnij się, że uwzględnisz `f` przed ciągiem znaków.\n"
"\n"
"__code1__"

msgid "pages.IntroducingFstrings.title"
msgstr "f-stringi"

msgid ""
"pages.IntroducingIfStatements.steps.excited_confused_exercise.hints.0.text"
msgstr ""
"Do istniejącego programu trzeba tylko dodać kilka linii. Wszystkie "
"istniejące kody powinny pozostać takie, jakie są."

msgid ""
"pages.IntroducingIfStatements.steps.excited_confused_exercise.hints.1.text"
msgstr ""
"Kod, który dodajesz, powinien być bardzo podobny do istniejącego kodu."

msgid "pages.IntroducingIfStatements.steps.excited_confused_exercise.text"
msgstr ""
"Czas na ćwiczenie. Zmodyfikuj powyższy program, aby dodać dodatkowy\n"
"parametr logiczny `confused`, tak aby program zaczynał się tak:\n"
"\n"
"__code0__\n"
"\n"
"(`sentence` może być dowolnym łańcuchem znaków, a dwie wartości logiczne mogą być albo `True`, albo `False`)\n"
"\n"
"Gdy `confused` jest prawdziwe (`True`), wypisane zdanie powinno mieć na końcu znak zapytania.\n"
"Jeśli zarówno `confused`, jak i `excited` są prawdziwe (`True`), zdanie powinno kończyć się na `!?`."

msgid ""
"pages.IntroducingIfStatements.steps.excited_example.output_prediction_choices.0"
msgstr "Hello World"

msgid ""
"pages.IntroducingIfStatements.steps.excited_example.output_prediction_choices.1"
msgstr "Hello World!"

msgid "pages.IntroducingIfStatements.steps.excited_example.text"
msgstr ""
"Zauważ, że kod znajdujący się wewnątrz pierwszej instrukcji `if` został wykonany, ale kod drugiej nie.\n"
"\n"
"Generalnie instrukcja `if` wygląda tak:\n"
"\n"
"    if <warunek>:\n"
"        <ciało>\n"
"\n"
"gdzie `<warunek>` to dowolne wyrażenie, które daje wynik w postaci wartości logicznej, a `<ciało>` to **wcięta** lista\n"
"jednego lub więcej stwierdzeń. Struktura jest dość podobna do pętli `for`. Zwróć uwagę na dwukropek (`:`), który\n"
"jest niezbędny.\n"
"\n"
"Gdy komputer widzi `if <warunek>:`, sprawdza, czy `<warunek>` jest `True`. Jeśli tak, wykonuje ciało.\n"
"Jeśli nie, pomija je i kontynuuje resztę programu.\n"
"\n"
"Oto bardziej interesujący przykład, który możesz uruchomić:\n"
"\n"
"__program_indented__"

msgid ""
"pages.IntroducingIfStatements.steps.excited_false_example.output_prediction_choices.0"
msgstr "Hello World"

msgid ""
"pages.IntroducingIfStatements.steps.excited_false_example.output_prediction_choices.1"
msgstr "Hello World!"

msgid "pages.IntroducingIfStatements.steps.excited_false_example.requirements"
msgstr ""
"Uruchom program z poprzedniego kroku, ale zamień `True` na `False`, tak żeby"
" było `excited = False`."

msgid "pages.IntroducingIfStatements.steps.excited_false_example.text"
msgstr ""
"(Pamiętaj, że `sentence += '!'` oznacza `sentence = sentence + '!'`)\n"
"\n"
"Zmień `excited = True` na `excited = False` i uruchom program ponownie, aby zobaczyć różnicę."

msgid "pages.IntroducingIfStatements.steps.final_text.text"
msgstr ""
"Brawo! Ten program może robić 4 różne rzeczy w zależności od tego, jak łączysz `excited`\n"
"i `confused`. Wypróbuj je, jeśli chcesz."

msgid "pages.IntroducingIfStatements.steps.first_if_statements.text"
msgstr ""
"Wartości logiczne są przeznaczone do użycia wewnątrz *instrukcji warunkowych* (ang. if statements). Nazywane są też czasami *warunkami* (ang. conditionals).\n"
"\n"
"Oto prosty przykład, który możesz uruchomić:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingIfStatements.steps.introducing_booleans.text"
msgstr ""
"Teraz nauczymy się, jak powiedzieć komputerowi, aby podejmował decyzje i wykonywał kod\n"
"tylko pod pewnymi warunkami. Do tego będziemy potrzebować nowego rodzaju wartości. Widziałeś już\n"
"liczby i łańcuchy znaków, teraz spotkaj się z *wartościami logicznymi* (ang. booleans). Istnieją tylko dwie wartości logiczne:\n"
"`True` i `False`. Wypróbuj ten program:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingIfStatements.title"
msgstr "Wprowadzenie do instrukcji warunkowych"

msgid "pages.IntroducingLists.steps.can_contain_anything.text"
msgstr ""
"Lista to rodzaj *sekwencji* (uporządkowanej kolekcji), która może zawierać dowolną liczbę wartości.\n"
"Nazywamy je często *elementami*.\n"
"Mogą to być przeróżne rzeczy: liczby, ciągi znaków, wartości logiczne, a nawet inne listy! Mogą również stanowić kombinację różnych typów.\n"
"\n"
"Żeby utworzyć listę bezpośrednio, tak jak w przykładzie:\n"
"\n"
"1. Zacznij od nawiasów kwadratowych: `[]`\n"
"2. Jeśli nie chcesz mieć pustej listy, umieść wewnątrz nawiasów wyrażenia, które staną się elementami listy.\n"
"3. Oddziel elementy przecinkami (`,`) by je od siebie rozdzielić.\n"
"\n"
"Oto inny przykład tworzenia listy:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingLists.steps.final_text.text"
msgstr ""
"Gratulacje! To było bardzo trudne! Jedno z możliwych rozwiązań wygląda tak:\n"
"\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"    separator = ' - '\n"
"    total = ''\n"
"    not_first = False\n"
"\n"
"    for word in words:\n"
"        if not_first:\n"
"            total += separator\n"
"        total += word\n"
"        not_first = True\n"
"\n"
"    print(total)"

msgid "pages.IntroducingLists.steps.first_list.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"\n"
"for word in words:\n"
"    print(word)"

msgid "pages.IntroducingLists.steps.first_list.text"
msgstr ""
"Nadszedł czas, aby dowiedzieć się o potężnym nowym typie wartości, zwanym *listami*. Oto przykład:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingLists.steps.numbers_sum.text"
msgstr ""
"Jak widziałeś powyżej, listy są *iterowalne*, co oznacza, że możesz iterować po nich przy użyciu `pętli for`.\n"
"Oto program, który sumuje wszystkie liczby w liście:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingLists.steps.strings_sum.hints.0.text"
msgstr ""
"To jest bardzo podobne do ćwiczeń, które wykonałeś, tworząc ciągi znaków "
"znak po znaku."

msgid "pages.IntroducingLists.steps.strings_sum.hints.1.text"
msgstr "Rozwiązanie jest bardzo podobne do programu, który sumuje liczby."

msgid "pages.IntroducingLists.steps.strings_sum.hints.2.text"
msgstr ""
"Tak naprawdę, co się stanie, jeśli spróbujesz uruchomić ten program z listą "
"ciągów znaków?"

msgid "pages.IntroducingLists.steps.strings_sum.hints.3.text"
msgstr ""
"Problem polega na tym, że 0. Nie możesz dodać 0 do ciągu znaków, ponieważ "
"liczby i ciągi znaków są niekompatybilne."

msgid "pages.IntroducingLists.steps.strings_sum.hints.4.text"
msgstr ""
"Czy jest podobne pojęcie wśród ciągów znaków do 0? Pusta początkowa wartość?"

msgid "pages.IntroducingLists.steps.strings_sum.text"
msgstr ""
"Teraz zmodyfikuj program, tak aby mógł sumować listę ciągów znaków zamiast liczb.\n"
"Na przykład, mając:\n"
"\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"\n"
"powinien wydrukować:\n"
"\n"
"    __no_auto_translate__\n"
"    Thisisalist"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.0.text"
msgstr ""
"To jest podobne do poprzedniego ćwiczenia. Możesz zacząć od swojego "
"rozwiązania z tego."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.1.text"
msgstr ""
"To ćwiczenie nie wymaga niczego wyjątkowego, a ostateczne rozwiązanie może "
"być dość proste. Ale wymaga starannego przemyślenia podejścia."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.10.text"
msgstr ""
"Możesz napisać program, który sprawdza, czy jesteś w *pierwszej* iteracji "
"pętli."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.11.text"
msgstr ""
"Wystarczy zrobić zmienną typu bool do śledzenia tego. Nie ma potrzeby "
"używania żadnych operatorów porównania ani liczb."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.12.text"
msgstr ""
"Spojrzeliśmy na programy, które robiły coś takiego "
"[tutaj](#UnderstandingProgramsWithSnoop)."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.13.text"
msgstr ""
"Więc jeśli pominięto dodawanie separatora tylko w pierwszej iteracji, będzie"
" miał `n - 1` separatorów. Teraz wystarczy tylko przemyśleć ostrożnie, jak "
"upewnić się, że separatory są we właściwym miejscu."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.14.text"
msgstr ""
"Zapominając na chwilę o pętli, musisz dodać do ciągu znaków w tej "
"kolejności: pierwsze słowo, separator, drugie słowo, separator, trzecie "
"słowo itd."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.15.text"
msgstr ""
"To oznacza, że w pierwszej iteracji dodajesz tylko pierwsze słowo. W drugiej"
" iteracji dodajesz separator, potem drugie słowo. W trzeciej iteracji "
"dodajesz separator, potem trzecie słowo. I tak dalej."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.16.text"
msgstr "Więc w swojej pętli najpierw dodaj separator, następnie dodaj słowo."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.17.text"
msgstr ""
"Pomiń dodawanie separatora w pierwszej iteracji, sprawdzając zmienną typu "
"bool."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.18.text"
msgstr ""
"Utwórz zmienną typu bool przed pętlą, później zmień ją wewnątrz pętli."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.19.text"
msgstr ""
"Zmieniaj ją dopiero po sprawdzeniu w pętli, inaczej nie będziesz w stanie "
"pominąć pierwszej iteracji."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.2.text"
msgstr ""
"W każdej iteracji, oprócz słowa z listy, musisz również dodać separator."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.3.text"
msgstr ""
"Ale nie chcesz dodawać separatora po dodaniu ostatniego słowa na liście."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.4.text"
msgstr ""
"Niestety nie ma \"odejmowania\" w ciągach znaków; nie możesz dodać "
"ostatniego separatora, a następnie go usunąć."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.5.text"
msgstr ""
"Zróbmy krok wstecz. Ostateczny wynik powinien zawierać każde słowo i `n - 1`"
" separatorów, gdzie `n` to liczba słów."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.6.text"
msgstr "Chcesz dodać separator w każdej iteracji oprócz jednej."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.7.text"
msgstr ""
"Możesz pominąć dodawanie separatora w jednej konkretnej iteracji używając "
"instrukcji `if`."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.8.text"
msgstr ""
"Później nauczysz się sposobu iterowania po liście i sprawdzania, czy jesteś "
"w ostatniej iteracji, ale na razie nie masz możliwości tego zrobienia."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.9.text"
msgstr "Jednak iteracja, którą pomijasz, nie musi być ostatnia!"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.text"
msgstr ""
"Wspaniale!\n"
"\n"
"Jeśli chcesz, możesz kontynuować [następnej stronie](#BuildingNewLists).\n"
"\n"
"Dla dodatkowego, opcjonalnego wyzwania: rozszerz program tak, aby dodawał łańcuch separatorów *pomiędzy* każdym słowem.\n"
"Na przykład, mając\n"
"\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"    separator = ' - '\n"
"\n"
"wypisałby:\n"
"\n"
"    __no_auto_translate__\n"
"    This - is - a - list"

msgid "pages.IntroducingLists.title"
msgstr "Wprowadzenie do list"

msgid "pages.IntroducingNestedLists.steps.double_subscripting.requirements"
msgstr ""
"Uruchom `print(strings[1][0])` lub coś podobnego używając `birdseye`, aby "
"zobaczyć jak to działa."

msgid "pages.IntroducingNestedLists.steps.double_subscripting.text"
msgstr ""
"Możesz to rozwiązać tak:\n"
"\n"
"__code0__\n"
"\n"
"Istnieje krótszy sposób. `strings[1]` to wyrażenie jak każde inne i indeksowanie jak `[0]`\n"
"może być użyte na dowolnym wyrażeniu, nie tylko na zmiennych.\n"
"Więc możesz pominąć zmienną pośrednią i zrobić to jedną linią:\n"
"\n"
"__code1__\n"
"\n"
"Przyjrzyj się dobrze tej składni. Jeśli wygląda na nową i wyszukaną, to nie jest.\n"
"To tylko zwykła składnia indeksowania, zastosowana dwa razy.\n"
"Spróbuj użyć `birdseye`, aby zobaczyć jak Python rozkłada to na mniejsze części."

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.0.text"
msgstr "To jest bardzo podobne do poprzedniego ćwiczenia."

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.1.text"
msgstr ""
"Czy pamiętasz jak uzyskać dostęp do ostatniej pozycji na liście (bez użycia "
"`len`)?"

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.2.text"
msgstr "Podobnie jak uzyskujesz dostęp do przedostatniej pozycji na liście?"

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.3.text"
msgstr "Jeśli nie pamiętasz, możesz wyszukać to w Google!"

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.4.text"
msgstr "Indeksowanie działa podobnie na listach i ciągach znaków."

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.5.text"
msgstr ""
"Czy otrzymujesz błąd `index out of range`? Czy dotyczy on ciągu czy listy? "
"Dlaczego?"

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.6.text"
msgstr "Upewnij się, że nie mylisz kolejności indeksu listy i indeksu ciągu."

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.7.text"
msgstr "Użyj `birdseye` jeśli masz problemy."

msgid "pages.IntroducingNestedLists.steps.double_subscripting_exercise.text"
msgstr ""
"Używając tej składni, zmodyfikuj program tak, aby wydrukować ostatnią literę przedostatniego ciągu na liście `strings`.\n"
"Musisz użyć pojedynczego wyrażenia podobnie jak powyżej i nie wolno ci używać `len`.\n"
"Twoje rozwiązanie powinno działać dla dowolnej niepustej listy ciągów znaków.\n"
"Przy poprzednim przykładzie wejściowym powinno wydrukować `f`."

msgid "pages.IntroducingNestedLists.steps.final_text.text"
msgstr ""
"Świetnie! Teraz bardzo dobrze rozumiesz zagnieżdżone indeksowanie.\n"
"\n"
"Cały czas możemy używać wszystkich metod i funkcji list, które wcześniej poznaliśmy.\n"
"Na przykład możemy dodać nowe słowo do ostatniej podlisty `strings` używając `append`,\n"
"żeby umieścić je po `'you'`:\n"
"\n"
"__code0__\n"
"\n"
"Przecież podlista `strings[1]` to wciąż lista jak każda inna!\n"
"\n"
"Na następnej stronie dowiemy się, jak iterować po zagnieżdżonych listach."

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.0"
msgstr "hello"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.1"
msgstr "there"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.10"
msgstr "a"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.2"
msgstr "how"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.3"
msgstr "are"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.4"
msgstr "you"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.5"
msgstr "['hello', 'there']"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.6"
msgstr "['how', 'are', 'you']"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.7"
msgstr "h"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.8"
msgstr "t"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.9"
msgstr "e"

msgid "pages.IntroducingNestedLists.steps.first_nested_list_example.program"
msgstr ""
"strings = [['hello', 'there'], ['how', 'are', 'you']]\n"
"print(strings[1][0])"

msgid "pages.IntroducingNestedLists.steps.first_nested_list_example.text"
msgstr ""
"Dobra robota!\n"
"\n"
"Zastosowanie indeksowania dwa razy może być nawet bardziej potężne.\n"
"Możemy użyć go nie tylko na liście ciągów znaków, ale także na *liście list*.\n"
"Na przykład, co wydrukuje poniższy program?\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingNestedLists.steps.string_list_exercise.hints.0.text"
msgstr "Jak możesz uzyskać dostęp do drugiego ciągu na liście?"

msgid "pages.IntroducingNestedLists.steps.string_list_exercise.hints.1.text"
msgstr "A jak uzyskujesz dostęp do konkretnego znaku w ciągu?"

msgid "pages.IntroducingNestedLists.steps.string_list_exercise.hints.2.text"
msgstr "Pamiętaj, że indeksowanie list i ciągów znaków jest bardzo podobne."

msgid "pages.IntroducingNestedLists.steps.string_list_exercise.text"
msgstr ""
"Ćwiczenie: mając daną listę ciągów znaków, wydrukuj pierwszą literę drugiego ciągu na liście. Na przykład, mając:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"powinieneś wydrukować `d`."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.0.text"
msgstr "To jest bardzo podobne do poprzednich ćwiczeń."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.1.text"
msgstr "Ile razy musisz użyć indeksowania?"

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.2.text"
msgstr "Najpierw musisz uzyskać dostęp do podlisty."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.3.text"
msgstr "Potem ciągu na tej podliście."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.4.text"
msgstr "Potem litery w tym ciągu."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.5.text"
msgstr "Użyj `birdseye` jeśli masz problemy."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.text"
msgstr ""
"Jak widzisz Python pozwala nam mieć *zagnieżdżone listy*: listę, w której każdy element to inna lista (nazywamy je *podlistami*).\n"
"\n"
"Możemy używać indeksowania nawet więcej niż dwa razy.\n"
"Napisz program który bierze zagnieżdżoną listę `strings` jak powyżej,\n"
"i wydrukuje **pierwszą literę trzeciego ciągu na drugiej podliście**.\n"
"Użyj tylko pojedynczego wyrażenia, jak w poprzednim ćwiczeniu.\n"
"Dla listy podanej powyżej powinno wydrukować `y`."

msgid "pages.IntroducingNestedLists.title"
msgstr "Wprowadzenie do zagnieżdżonych list"

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.0.text"
msgstr ""
"Pomyśl, jak byś to zrobił ręcznie i systematycznie, używając ołówka"
" i papieru."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.1.text"
msgstr ""
"Fakt, że hasło musi składać się z czterech liter jest bardzo ważny. To"
" byłoby znacznie trudniejsze do rozwiązania, gdyby hasło mogło mieć dowolną długość."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.2.text"
msgstr "Ale ciąg `letters` może mieć dowolną liczbę znaków."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.3.text"
msgstr ""
"Jeśli mamy `n` różnych liter, to liczba możliwych haseł to"
" `n^4 == n*n*n*n`, ponieważ dla każdej pozycji mamy `n` możliwych liter"
" i są one niezależne."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.4.text"
msgstr ""
"Załóżmy ponownie, że `letters = \"ABCD\"`. Wyobraź sobie, że masz wszystkie możliwe"
" trzyliterowe hasła. Teraz do każdego z nich dodaj na końcu A, lub B,"
" lub C, lub D. Tak otrzymasz wszystkie możliwe czteroliterowe hasła."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.5.text"
msgstr ""
"Pamiętaj, pętla for może zawierać dowolną instrukcję, w tym inną pętlę for."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.6.text"
msgstr "Dotyczy to wszystkich pętli for."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.7.text"
msgstr "Jedna pętla for wewnątrz innej pętli for już nie wystarczy."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.8.text"
msgstr "Musisz pójść głębiej."

msgid "pages.IntroducingNestedLoops.steps.crack_password_exercise.text"
msgstr ""
"Na następne ćwiczenie musisz złamać hasło. Wiesz, że ma dokładnie cztery litery i że możliwe są tylko niektóre litery, które zapisałeś:\n"
"\n"
"__code0__\n"
"\n"
"Musisz wydrukować wszystkie możliwe hasła:\n"
"\n"
"    AAAA\n"
"    AAAB\n"
"    AAAC\n"
"    AAAD\n"
"    AABA\n"
"    AABB\n"
"    ...pomijając kilka...\n"
"    DDDA\n"
"    DDDB\n"
"    DDDC\n"
"    DDDD"

msgid "pages.IntroducingNestedLoops.steps.final_text.text"
msgstr ""
"Świetnie! Rozwiązanie wygląda tak:\n"
"\n"
"__code0__"

msgid "pages.IntroducingNestedLoops.steps.first_nested_loop.text"
msgstr ""
"Zobaczyłeś, że wcięte ciało instrukcji `if` lub pętli może zawierać dowolny rodzaj instrukcji, w tym więcej instrukcji `if` i pętli. W szczególności pętla może zawierać inną pętlę. Oto przykład:\n"
"\n"
"__program_indented__\n"
"\n"
"To nazywa się *zagnieżdżoną pętlą*. Nic w tym nie jest naprawdę nowe, warto to jednak dobrze zrozumieć, ponieważ może być bardzo przydatne do pisania interesujących programów."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.0.text"
msgstr "Będziesz potrzebować pętli for wewnątrz pętli for, tak jak wcześniej."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.1.text"
msgstr "Tym razem coś w stylu `for player1 in players:` nie będzie wystarczające."

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.10.text"
msgstr "Musisz użyć operatora porównania."

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.11.text"
msgstr ""
"Kiedy już rozgryziesz zależność, możesz wyrazić ją za pomocą instrukcji `if`."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.2.text"
msgstr "Twój program musi używać *pozycji* graczy na liście."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.3.text"
msgstr ""
"To oznacza, że musisz iterować po pozycjach i używać indeksowania "
"(subskrypcji) do dostępu do wpisów na liście."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.4.text"
msgstr "Aby iterować po pozycjach, użyj `range`..."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.5.text"
msgstr "...i `len`."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.6.text"
msgstr ""
"Spójrz na oczekiwane wyjście: `Charlie vs Alice`: `Charlie` występuje przed "
"`Alice` na liście `players`."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.7.text"
msgstr ""
"Nie chcemy wydrukować `Alice vs Charlie`, ponieważ `Alice` występuje PO "
"`Charlie` na liście `players`."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.8.text"
msgstr ""
"Chcemy wydrukować tylko te pary, gdzie lewy gracz występuje przed prawym "
"graczem na liście."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.9.text"
msgstr ""
"Jak możemy wyrazić tę zależność w terminach indeksów listy dla dwóch "
"pętli for? "

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.text"
msgstr ""
"Wow, jesteś także artystą!\n"
"\n"
"Jeśli chcesz, możesz teraz przejść do [następnej strony](#IntroducingBirdseye). Albo możesz podjąć dodatkowe wyzwanie!\n"
"\n"
"Podobnie jak w poprzednim ćwiczeniu, organizujesz turniej dla gry. Masz listę nazwisk graczy:\n"
"\n"
"__code0__\n"
"\n"
"Tym razem każda para graczy powinna pojawić się tylko raz. Konkretnie, wydrukuj tylko te pary, które są\n"
"w tej samej kolejności od lewej do prawej, jak są na liście `players`, zaczynając od par zawierających najbardziej lewą osobę\n"
"na liście `players` i przesuwając się w prawo. Na przykład, dla powyższego, Twój program powinien wydrukować\n"
"\n"
"    Charlie vs Alice\n"
"    Charlie vs Dylan\n"
"    Charlie vs Bob\n"
"    Alice vs Dylan\n"
"    Alice vs Bob\n"
"    Dylan vs Bob"

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_exercise.hints.0.text"
msgstr ""
"Pomyśl, jak byś to zrobił ręcznie i systematycznie, używając ołówka"
" i papieru."

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_exercise.hints.1.text"
msgstr "Musisz użyć pętli for wewnątrz innej pętli for."

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_exercise.hints.2.text"
msgstr ""
"Potrzebujesz instrukcji `if`, aby sprawdzić, czy dwaj gracze to nie ta sama "
"osoba."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_exercise.text"
msgstr ""
"Świetnie!\n"
"\n"
"Następne ćwiczenie: organizujesz turniej dla gry, takiej jak szachy czy tenis. Masz listę nazwisk graczy:\n"
"\n"
"__code0__\n"
"\n"
"Każdy gracz będzie grał z każdym innym graczem dwa razy: raz, gdy ma przewagę (np. ruszając się lub serwując jako pierwszy) i raz bez tej przewagi. Wydrukuj wszystkie kombinacje meczów tak jak to:\n"
"\n"
"    Alice vs Bob\n"
"    Alice vs Charlie\n"
"    Bob vs Alice\n"
"    Bob vs Charlie\n"
"    Charlie vs Alice\n"
"    Charlie vs Bob\n"
"\n"
"Zauważ, że \"Alice vs Bob\" i \"Bob vs Alice\" są obie na liście, ale nie ma \"Alice vs Alice\" - nie chcemy, aby ktoś grał sam ze sobą."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.0.text"
msgstr "Musisz użyć pętli for wewnątrz innej pętli for."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.1.text"
msgstr "Potrzebujesz liczb od 1 do 12."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.2.text"
msgstr "Kiedykolwiek potrzebujesz sekwencji kolejnych numerów, użyj `range`."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.3.text"
msgstr "Chcesz czegoś w stylu `for x in range(n):`."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.4.text"
msgstr ""
"To zacznie się od `x = 0`, ale jest na to łatwe rozwiązanie."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.5.text"
msgstr "Możesz po prostu dodać 1 do `x`."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.6.text"
msgstr "Użyj `*` do mnożenia liczb."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.7.text"
msgstr "Użyj f-stringa z kilkoma zmiennymi."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.8.text"
msgstr ""
"Pamiętaj, aby wydrukować linię z odpowiednią ilością kresek po każdej "
"sekcji."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.9.text"
msgstr ""
"Upewnij się, że każda linia jest we właściwej pętli i ma odpowiedni poziom "
"wcięcia."

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.messages.added_str_and_int.text"
msgstr "Nie możesz dodawać do siebie stringów i liczb. Użyj f-stringa."

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.messages.adding_one_in_wrong_loop.text"
msgstr ""
"Dodałeś 1 do zmiennej swojej zewnętrznej pętli w złym miejscu!\n"
"Gdzie powinieneś to zrobić, aby to naprawić?"

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.messages.too_long.text"
msgstr ""
"Twoje rozwiązanie jest za długie. Do tego problemu potrzebujesz tylko kilku linii kodu.\n"
"Użyj zagnieżdżonej pętli, aby nie musieć się powtarzać.\n"
"Komputer zrobi powtórzenie za ciebie!"

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.messages.used_times_instead_of_x.text"
msgstr ""
"To prawie poprawne! Upewnij się, że wyświetlasz prawidłowy znak `x` w swojej tabeli.\n"
"Na przykład twoje rozwiązanie powinno wyświetlać `3 x 4 = 12` a nie `3 * 4 = 12`."

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.special_messages.multiply_with_x.text"
msgstr "Aby mnożyć liczby, użyj `*`"

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.text"
msgstr ""
"Upewnij się, że w pełni rozumiesz, co się dzieje. `print(letter)` i `print('---')` są wykonywane 3 razy, ponieważ ich wcięcie umieszcza je w *zewnętrznej pętli*. `print(f'{letter} {number}')` jest wywoływane 3 × 4 = 12 razy, ponieważ znajduje się w *wewnętrznej pętli* `for number in range(4):`, która ma 4 iteracje, ale sama znajduje się w zewnętrznej pętli, więc wykonuje się 3 razy.\n"
"\n"
"Zastosujmy to! Załóżmy, że jesteś nauczycielem i musisz wydrukować wszystkie tabliczki mnożenia od 1 do 12 dla swoich uczniów. Nie chcesz ich pisać ręcznie, ale możesz napisać program, który zrobi to za ciebie! Wyjście twojego programu powinno wyglądać tak, włącznie z liniami kresek:\n"
"\n"
"    1 x 1 = 1\n"
"    1 x 2 = 2\n"
"    1 x 3 = 3\n"
"    1 x 4 = 4\n"
"    1 x 5 = 5\n"
"    1 x 6 = 6\n"
"    1 x 7 = 7\n"
"    1 x 8 = 8\n"
"    1 x 9 = 9\n"
"    1 x 10 = 10\n"
"    1 x 11 = 11\n"
"    1 x 12 = 12\n"
"    ---\n"
"    2 x 1 = 2\n"
"    2 x 2 = 4\n"
"    2 x 3 = 6\n"
"    2 x 4 = 8\n"
"    2 x 5 = 10\n"
"    2 x 6 = 12\n"
"    2 x 7 = 14\n"
"    2 x 8 = 16\n"
"    2 x 9 = 18\n"
"    2 x 10 = 20\n"
"    2 x 11 = 22\n"
"    2 x 12 = 24\n"
"    ---\n"
"    3 x 1 = 3\n"
"    3 x 2 = 6\n"
"    3 x 3 = 9\n"
"    (you get the idea...)\n"
"    11 x 10 = 110\n"
"    11 x 11 = 121\n"
"    11 x 12 = 132\n"
"    ---\n"
"    12 x 1 = 12\n"
"    12 x 2 = 24\n"
"    12 x 3 = 36\n"
"    12 x 4 = 48\n"
"    12 x 5 = 60\n"
"    12 x 6 = 72\n"
"    12 x 7 = 84\n"
"    12 x 8 = 96\n"
"    12 x 9 = 108\n"
"    12 x 10 = 120\n"
"    12 x 11 = 132\n"
"    12 x 12 = 144\n"
"    ---"

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.0.text"
msgstr ""
"Jak opisałbyś instrukcje wpisywania tego trójkąta ręcznie?"

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.1.text"
msgstr ""
"Drukuj linię `size` plusów, potem `size - 1` plusów, itd. aż do "
"1 plusa. Na przykład drukuj 5 `+`, potem 4 `+`, potem 3, 2 i 1."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.2.text"
msgstr "Podziel to na podproblemy."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.3.text"
msgstr ""
"Jak drukujesz jedną linię `+` o danej długości, i jak przechodzisz "
"przez wszystkie długości?"

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.4.text"
msgstr ""
"Budowanie linii znaków powinno być bardzo znajome z poprzednich "
"ćwiczeń, jedyna różnica polega na tym, że musisz ją zrobić o danej długości "
"zamiast tylko tej samej długości co inny ciąg."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.5.text"
msgstr "Łatwym sposobem na zrobienie czegoś `n` razy jest pętla po `range(n)`."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.6.text"
msgstr "Musisz użyć pętli for wewnątrz innej pętli for."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.7.text"
msgstr ""
"Potrzebujesz liczb, które zmniejszają się, jak 5, 4, 3, 2, 1. Jest sposób, aby "
"to zrobić za pomocą `range`, i łatwo go znaleźć, ale równie łatwo jest użyć "
"normalnego zakresu i zrobić bardzo proste obliczenia, aby przekształcić liczby "
"rosnące w liczby malejące."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.8.text"
msgstr "Jaka formuła przekształca 0 na 5, 1 na 4, 2 na 3, itd.?"

msgid "pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.text"
msgstr ""
"Wow, jesteś teraz prawie hakerem!\n"
"\n"
"Jeszcze jedno ćwiczenie. Mając daną wielkość:\n"
"\n"
"__code0__\n"
"\n"
"Wydrukuj 'odwrócony' trójkąt zrobiony ze znaku plus `+`, którego boki są tak długie jak podana wielkość, np.:\n"
"\n"
"    +++++\n"
"    ++++\n"
"    +++\n"
"    ++\n"
"    +"

msgid "pages.IntroducingNestedLoops.title"
msgstr "Wprowadzenie do zagnieżdżonych pętli"

msgid "pages.IntroducingNotPage.steps.IntroducingNot.text"
msgstr ""
"W przeciwieństwie do dwóch innych operatorów boolowskich `and` i `or`,\n"
"które są używane między dwoma wartościami boolowskimi (nazywanymi *operatorami binarnymi*),\n"
"`not` jest używany przed tylko jedną wartością boolowską (nazywanym *operatorem unarnym*).\n"
"Neguje on wyrażenie, do którego jest stosowany, trochę jak znak minus. Spróbuj w powłoce:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingNotPage.steps.NotFalse.text"
msgstr ""
"Teraz spróbuj następującego:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.0.text"
msgstr ""
"Co by było, gdybyś miał za zadanie uproszczenie tej powiązanej, ale przeciwnej funkcji?\n"
"\n"
"__code0__"

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.1.text"
msgstr ""
"W takim przypadku jest standardowy trik upraszczający, który omówiliśmy "
"kilka stron temu."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.2.text"
msgstr ""
"Ogólnie rzecz ujmując, `returns` są zbędne, bo `filename.endswith(\".png\") "
"or filename.endswith(\".jpg\")` jest już pożądaną wartością boolowską."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.3.text"
msgstr ""
"Więc możesz po prostu napisać:\n"
"\n"
"__code0__"

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.4.text"
msgstr "Dla prawdziwego ćwiczenia możesz zrobić coś podobnego."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.5.text"
msgstr ""
"Różnica w prawdziwym ćwiczeniu polega na tym, że wynik jest odwrócony."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.6.text"
msgstr ""
"To znaczy, że `invalid_image` zwraca `True` kiedy `valid_image` zwraca "
"`False` i na odwrót."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.7.text"
msgstr "Pamiętasz, co robi `not`?"

msgid "pages.IntroducingNotPage.steps.NotPriority.text"
msgstr ""
"Możesz zobaczyć w `birdseye`, że\n"
"\n"
"__code0__\n"
"\n"
"jest interpretowane przez Pythona jako\n"
"\n"
"__code1__\n"
"\n"
"zamiast:\n"
"\n"
"__code2__\n"
"\n"
"Więc, `not` ma wyższy priorytet niż `or`, jeśli nie ma nawiasów. Jest to takie samo jak w przypadku, gdy\n"
"\n"
"__code3__\n"
"\n"
"oznacza:\n"
"\n"
"__code4__\n"
"\n"
"zamiast\n"
"\n"
"__code5__\n"
"\n"
"`not` ma również wyższy priorytet niż `and`.\n"
"\n"
"Znowu, główną rzeczą do zapamiętania jest używanie nawiasów lub dodatkowych zmiennych w razie wątpliwości.\n"
"\n"
"Ćwiczenie: Załóżmy, że piszesz program przetwarzający obrazy. Tylko niektóre typy plików można przetworzyć.\n"
"Jeśli użytkownik poda ci plik, którego nie można przetworzyć, chcesz wyświetlić błąd:\n"
"\n"
"__code6__\n"
"\n"
"Załóżmy, że pliki .png i .jpg można przetwarzać, ale inne typy plików nie mogą być przetwarzane.\n"
"Oto przykładowa funkcja do tego:\n"
"\n"
"    __copyable__\n"
"__code7__\n"
"\n"
"To jest dłuższe niż potrzeba. Przepisz funkcję `invalid_image`, aby treść była jednoliniowa `return <expression>`,\n"
"tzn. bez instrukcji `if`. Powinna przejść te same testy."

msgid "pages.IntroducingNotPage.steps.NotTrueOrTrue.text"
msgstr ""
"Jaki jest priorytet `not` w porównaniu z `and` i `or`? Spróbuj następującego w `birdseye`:\n"
"\n"
"__code0__"

msgid "pages.IntroducingNotPage.steps.final_text.text"
msgstr ""
"Brawo! Oto dwie poprawne rozwiązania:\n"
"\n"
"__code0__\n"
"\n"
"(jeśli jesteś ciekawy, te rozwiązania są równoważne dzięki czemuś, co nazywa się prawem De Morgana)\n"
"\n"
"Zauważ także, że jest to kolejny ogólny wzorzec, który można uprościć: jeśli twój kod ma formę:\n"
"\n"
"__code1__\n"
"\n"
"gdzie `x` sam w sobie jest wartością boolowską, wówczas można go uprościć do:\n"
"\n"
"__code2__"

msgid "pages.IntroducingNotPage.title"
msgstr "Wprowadzenie do `not`"

msgid "pages.IntroducingOr.steps.ACommonMistake.requirements"
msgstr ""
"Uruchom program z poprzedniego kroku, ale zamień:\n"
"\n"
"__code0__\n"
"\n"
"na:\n"
"\n"
"__code1__"

msgid "pages.IntroducingOr.steps.ACommonMistake.text"
msgstr ""
"Zwróć szczególną uwagę, jak napisaliśmy warunek:\n"
"\n"
"__code0__\n"
"\n"
"Typowym błędem jest napisanie tego zamiast:\n"
"\n"
"__code1__\n"
"\n"
"To ma sens, jeśli czytasz to jak po angielsku:\n"
"\n"
"> `return` czy `name` jest równy albo `\"Alice\"` lub `\"Bob\"`\n"
"\n"
"Ale Python nie jest angielskim, i nie tak działa `or`.\n"
"\n"
"Zamień linię `return` w kodzie powyższą linią, i spróbuj uruchomić to ponownie."

msgid "pages.IntroducingOr.steps.AnExercise.disallowed.3.label"
msgstr "łańcuchowe porównanie"

msgid "pages.IntroducingOr.steps.AnExercise.hints.0.text"
msgstr ""
"Pamiętaj, możesz użyć operatorów porównujących `<, >, <=, >=, ==` do "
"wytworzenia booleanów."

msgid "pages.IntroducingOr.steps.AnExercise.hints.1.text"
msgstr "Musisz sprawdzić, jak `x` porównuje się do 0 i jak do 100."

msgid "pages.IntroducingOr.steps.AnExercise.hints.2.text"
msgstr "Musisz połączyć dwa porównania w jeden boolean używając `or`."

msgid "pages.IntroducingOr.steps.AnExercise.hints.3.text"
msgstr ""
"Powżej użyliśmy triku, aby całe ciało funkcji było po prostu `return "
"<porównanie> or <porównanie>`. Ale to nie zadziała tutaj!"

msgid "pages.IntroducingOr.steps.AnExercise.hints.4.text"
msgstr "Musisz użyć instrukcji `if`."

msgid "pages.IntroducingOr.steps.AnExercise.hints.5.text"
msgstr "Musisz mieć `return False` i `return True`."

msgid "pages.IntroducingOr.steps.AnExercise.hints.6.text"
msgstr ""
"Jeśli masz coś w rodzaju `x >= 0 or x <= 100`, jesteś na złym tropie. To "
"będzie prawdą dla *dowolnej* wartości `x`. W końcu 101 jest większe niż 0!"

msgid "pages.IntroducingOr.steps.AnExercise.text"
msgstr ""
"Gdy zbadamy to z pomocą `birdseye`, widzimy, że:\n"
"\n"
"__code0__\n"
"\n"
"nie jest tłumaczone na\n"
"\n"
"__code1__\n"
"\n"
"tak jak myślimy po angielsku, ale raczej:\n"
"\n"
"__code2__\n"
"\n"
"co ocenia się jako `\"Bob\"`, gdy `name == \"Alice\"` jest `False`.\n"
"\n"
"Może czujesz się tak:\n"
"\n"
"[![Mam teraz dodatkowe pytania](https://i.imgur.com/jN57tGt.png)](https://imgur.com/a/icKzI)\n"
"\n"
"Jedyna rzecz, którą naprawdę musisz wiedzieć to: dopóki nie wiesz, co robisz, zawsze\n"
"upewnij się, że po obu stronach `or` są booleany, ponieważ to jest operator boolean.\n"
"`name == \"Alice\" or \"Bob\"` łamie tę zasadę.\n"
"\n"
"Jeśli jesteś ciekawy, odpowiedzi są poniżej, ale możesz je pominąć, jeśli chcesz, i przejść do ćwiczenia poniżej.\n"
"\n"
"----\n"
"\n"
"> Dlaczego `(name == \"Alice\") or (\"Bob\")` równa się `\"Bob\"`? Dlaczego równa się cokolwiek? `\"Bob\"` nawet nie jest booleanem!\n"
"\n"
"Definicja \"`A or B` jest `True` jeśli `A` lub `B` jest `True`\" była uproszczeniem. Jest to najłatwiejszy\n"
"sposób myślenia o `or` większość czasu, szczególnie przy pisaniu instrukcji `if`.\n"
"Prawdziwa definicja jest taka, że jeśli `A` jest prawdziwe, to `A or B` to po prostu `A` (w rzeczywistości `B` nawet nie jest oceniane),\n"
"w przeciwnym razie to `B`.\n"
"Możesz samemu sprawdzić, że jeśli `A` i `B` są booleanami, to obie definicje są równoważne.\n"
"W tym przykładzie `A` to `name == \"Alice\"`, co jest `False`, więc `A or B` to `B`, które jest `\"Bob\"`.\n"
"\n"
"> Czy jest lepszy sposób na napisanie warunku bez powtarzania `name ==` za każdym razem?\n"
"\n"
"Tak! W [Funkcje i Metody dla List](#FunctionsAndMethodsForLists) wspomnieliśmy o operatorze `in`,\n"
"którego możesz użyć z listą w taki sposób:\n"
"\n"
"__code3__\n"
"\n"
"Ale nie zawsze możesz pozbyć się `or` w ten sposób.\n"
"\n"
"----\n"
"\n"
"Ćwiczenie: Napisz funkcję o nazwie `is_valid_percentage`, przyjmującą jeden argument numeryczny `x`.\n"
"Powinna zwracać `True`, jeśli `x` jest między 0 a 100 (włącznie), oraz zwracać `False` w przeciwnym przypadku.\n"
"Twoja funkcja powinna używać `or` i spełniać te testy:\n"
"\n"
"    __copyable__\n"
"__code4__"

msgid "pages.IntroducingOr.steps.FalseOrFalse.text"
msgstr ""
"Na koniec spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.FurtherImprovement.requirements"
msgstr ""
"Uruchom program z poprzedniego kroku, ale zamień:\n"
"\n"
"__code0__\n"
"\n"
"na:\n"
"\n"
"__code1__"

msgid "pages.IntroducingOr.steps.FurtherImprovement.text"
msgstr ""
"Możemy zrobić jeszcze lepiej. Zauważ, że\n"
"\n"
"__code0__\n"
"\n"
"jest booleanem, i oba `return` zwracają booleany `True` lub `False`.\n"
"Funkcja:\n"
"\n"
" - zwraca `True` gdy `name == \"Alice\" or name == \"Bob\"` jest `True`, oraz\n"
" - zwraca `False` gdy `name == \"Alice\" or name == \"Bob\"` jest `False`.\n"
"\n"
"Więc moglibyśmy po prostu zwrócić boolean `name == \"Alice\" or name == \"Bob\"` jako taki w obu przypadkach!\n"
"\n"
"To jest częsty sposób na uproszczenie twojego kodu. Jeśli kiedykolwiek znajdziesz się w sytuacji pisania kodu takiego jak:\n"
"\n"
"__code1__\n"
"\n"
"gdzie `x` sam w sobie jest booleanem, zawsze możesz uprościć ten blok kodu do:\n"
"\n"
"__code2__\n"
"\n"
"Zastosuj tę uproszczenie do kodu sam, i uruchom go ponownie."

msgid "pages.IntroducingOr.steps.ImprovingWithOr.requirements"
msgstr ""
"Skopiuj program z początku strony, a następnie zmień pierwsze cztery linijki"
" funkcji tak, aby użyć `or` zgodnie z sugestią."

msgid "pages.IntroducingOr.steps.ImprovingWithOr.text"
msgstr ""
"W edytorze zamień:\n"
"\n"
"__code0__\n"
"\n"
"na:\n"
"\n"
"__code1__\n"
"\n"
"Jak widzisz, `is_friend` zwróci `True` tylko wtedy, gdy `name` to Alice lub Bob.\n"
"Operator `or` używany jest między dwoma booleanami `name == \"Alice\"` i `name == \"Bob\"`."

msgid "pages.IntroducingOr.steps.InputAliceBob.text"
msgstr ""
"Dowiedzieliśmy się o *booleanach* (`True` i `False`), gdy wprowadzaliśmy instrukcje warunkowe If.\n"
"Nauczyliśmy się również o operatorach porównujących `==`, `<`, `>`, `<=`, `>=`, które zwracają booleany.\n"
"Teraz chcemy połączyć booleany, aby sprawdzać bardziej złożone warunki.\n"
"\n"
"Oto prosty przykład: wyobraź sobie, że masz dwóch przyjaciół, Alice i Boba.\n"
"Funkcja poniżej przyjmuje jeden parametr, `name`, i sprawdza, czy osoba o danym imieniu jest wśród twoich przyjaciół.\n"
"Skopiuj i uruchom kod w edytorze:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingOr.steps.InspectWithBirdseye.requirements"
msgstr "Uruchom ten sam kod co w poprzednim kroku, ale użyj `birdseye`."

msgid "pages.IntroducingOr.steps.InspectWithBirdseye.text"
msgstr ""
"Drugi i trzeci test zawiodły! Nasza funkcja wydaje się robić coś nie tak:\n"
"zwraca `\"Bob\"` (łańcuch znaków, a nie boolean!) gdy `name` to `\"Bob\"` lub `\"Charlie\"`. Co się dzieje?\n"
"Uruchom ten sam problematyczny kod ponownie z `birdseye`. Dokładnie sprawdź instrukcje `return` każdego wywołania `is_friend`.\n"
"(Użyj niebieskich przycisków ze strzałką)"

msgid "pages.IntroducingOr.steps.TrueOrFalse.text"
msgstr ""
"Dobrze, teraz spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.TrueOrTrue.text"
msgstr ""
"Zobaczmy, czy możemy to zrobić lepiej.\n"
"Możemy połączyć instrukcje `if` i `elif`, używając **`or`**. `or` jest *operatorem boolean*,\n"
"co znaczy, że jest to operator (tak jak `+` lub `-`), który łączy dwa booleany (`True` lub `False`).\n"
"\n"
"Wyrażenie `A or B` jest `True`, jeśli `A` lub `B` jest `True`, to znaczy jeśli `A` jest `True` lub `B` jest `True`, albo oba.\n"
"Jest `False` tylko wtedy, gdy ani `A` ani `B` nie jest `True`, to znaczy oba są `False`.\n"
"\n"
"Wypróbuj poniższe w konsoli.\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.final_text.text"
msgstr "Dobra robota!"

msgid "pages.IntroducingOr.title"
msgstr "Wprowadzenie do `or`"

msgid "pages.IntroducingStrings.steps.final_text.text"
msgstr ""
"Shell zwraca dokładnie to samo, ponieważ nie ma nic więcej do obliczenia. `'hello'` po prostu równa się `'hello'`.\n"
"\n"
"Znak to pojedynczy symbol taki jak litera, cyfra, znak interpunkcyjny, spacja itd. W tym przypadku łańcuch `hello` zawiera 5 znaków. Apostrofy nie są częścią łańcucha - są tam, żeby pokazać zarówno ludziom, jak i komputerom, że jest to łańcuch składający się z jakichkolwiek znaków pomiędzy apostrofami."

msgid "pages.IntroducingStrings.steps.hello_string.text"
msgstr ""
"Python pozwala na dużo więcej niż tylko obliczenia. W rzeczywistości, nie będziemy zajmować się liczbami czy matematyką przez jakiś czas. Zamiast tego przyjrzymy się *łańcuchom znaków* (ang. strings). Łańcuchy znaków to w zasadzie fragmenty tekstu. Na przykład, wprowadź następujący kod do konsoli, razem z apostrofami (`'`):\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingStrings.title"
msgstr "Wprowadzenie do łańcuchów znaków (ang. Strings)"

msgid "pages.IntroducingTheShell.steps.final_text.text"
msgstr ""
"Doskonale! Kontynuuj eksperymentowanie. Gdy będziesz gotowy, kliknij "
"'Dalej', aby kontynuować."

msgid ""
"pages.IntroducingTheShell.steps.first_expression.messages.anything_else.text"
msgstr ""
"Wspaniale, próbujesz własnych eksperymentów!\n"
"To dobry znak. Kontynuuj w tym duchu.\n"
"Tylko informuję, że ostatecznie musisz wpisać `1+2`, aby książka mogła przejść dalej."

msgid "pages.IntroducingTheShell.steps.first_expression.text"
msgstr ""
"Po prawej stronie znajduje się *shell*. To miejsce do uruchamiania niewielkich fragmentów kodu Pythona. Wystarczy wpisać jakiś kod, nacisnąć enter, i to wszystko działa! Spróbuj teraz:\n"
"\n"
"1. Kliknij gdziekolwiek na shellu (czarny obszar).\n"
"2. Wpisz `__program__`\n"
"3. Naciśnij klawisz Enter na klawiaturze."

msgid "pages.IntroducingTheShell.steps.more_calculation.requirements"
msgstr ""
"Uruchom kod w shellu podobny do `1 + 2`, ale zamiast `+` użyj `*`, `/`, lub "
"`-`."

msgid ""
"pages.IntroducingTheShell.steps.more_calculation.special_messages.multiply_with_x.text"
msgstr ""
"Widzę 'x'. Jeśli próbujesz mnożyć, użyj gwiazdki, np.:\n"
"\n"
"__code0__"

msgid "pages.IntroducingTheShell.steps.more_calculation.text"
msgstr ""
"Świetnie! Python wykonał `1+2` i otrzymał wynik `3`, więc shell to wyświetlił.\n"
"\n"
"Shell to prawdopodobnie najważniejsze narzędzie do nauki Pythona i powinieneś spędzać dużo czasu na eksperymentowaniu i odkrywaniu go. Bądź ciekawy! Nieustannie zadawaj sobie pytanie \"Co by się stało, gdybym uruchomił X?\" i natychmiast odpowiadaj na to pytanie, uruchamiając to. Nigdy nie bój się próbować czegoś nowego - jeśli zrobisz coś nie tak, nic złego się nie stanie.\n"
"\n"
"Spróbuj teraz wykonać więcej obliczeń. Możesz mnożyć liczby używając `*`, dzielić za pomocą `/`, a odejmować z `-`. Możesz także użyć nawiasów, czyli `(` i `)`."

msgid "pages.IntroducingTheShell.title"
msgstr "Wprowadzenie do shella"


msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.0.text"
msgstr ""
"Możesz zacząć od naśladowania `row_winner` powyżej, a następnie zmodyfikować"
" to, aby działało dla kolumn."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.1.text"
msgstr ""
"Nie możesz przechodzić przez kolumny `board` tak prosto jak przez rzędy."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.10.text"
msgstr ""
"Zdefiniuj zmienną logiczną dla każdej kolumny, a następnie aktualizuj ją "
"odpowiednio wewnątrz wewnętrznej pętli."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.11.text"
msgstr "Reszta logiki jest bardzo podobna do `row_winner`."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.12.text"
msgstr "Uważaj na `' '`."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.13.text"
msgstr "Nie zapomnij zwrócić `False` na końcu, jeśli jest to potrzebne."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.2.text"
msgstr ""
"Czym *jest* kolumna zagnieżdżonej listy? Pierwsza kolumna składa się z "
"pierwszego elementu pierwszego rzędu, pierwszego elementu drugiego rzędu i "
"tak dalej."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.3.text"
msgstr ""
"Przechodzenie przez wszystkie kolumny oznacza patrzenie na pierwszy element "
"każdego rzędu, potem drugi element każdego rzędu, i tak dalej."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.4.text"
msgstr ""
"Więc musisz przechodzić przez liczby reprezentujące pozycje pierwszą, drugą,"
" itd."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.5.text"
msgstr "Jak znajdziesz liczbę kolumn w `board`?"

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.6.text"
msgstr ""
"To pokrywa zewnętrzną pętlę, która przechodzi przez każdą kolumnę. Potem "
"potrzebujesz wewnętrznej pętli, aby przejść przez każdy element w kolumnie."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.7.text"
msgstr ""
"Różne wpisy kolumny NIE znajdują się w tym samym rzędzie. Więc jak możesz je"
" uzyskać?"

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.8.text"
msgstr ""
"Możesz przechodzić przez rzędy planszy i znajdować element odpowiadający tej"
" kolumnie i rzędowi."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.9.text"
msgstr ""
"Aby uzyskać dostęp do wszystkich wpisów, powiedzmy, piątej kolumny, możesz "
"przechodzić przez wszystkie rzędy i uzyskać dostęp do piątego elementu w "
"każdym rzędzie."

msgid "pages.IntroducingTicTacToe.steps.column_winner.text"
msgstr ""
"Świetna robota!\n"
"\n"
"Teraz napisz podobną funkcję `column_winner`, która sprawdza wygrywającą *kolumnę* (linię pionową) dowolnej figury:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Tu `O` wygrało w drugiej kolumnie drugiej planszy."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.0.text"
msgstr "Ile przekątnych jest na kwadratowej planszy o dowolnym rozmiarze?"

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.1.text"
msgstr ""
"Nawet jeśli rozmiar planszy się zmienia, liczba przekątnych pozostaje taka "
"sama!"

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.10.text"
msgstr ""
"Możesz użyć jednej pętli i sprawdzić obie przekątne jednocześnie. Albo "
"możesz użyć jednej pętli dla każdej przekątnej."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.2.text"
msgstr ""
"Nie możesz zrobić czegoś takiego jak `middle == board[0][0] and middle == "
"board[2][2]` tym razem, ponieważ nie wiesz, jak długa jest przekątna."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.3.text"
msgstr ""
"Co więcej, dwie przekątne mogą nie mieć ze sobą wspólnego punktu, jak `middle`."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.4.text"
msgstr ""
"Najpierw skup się na przekątnej, która biegnie od lewego górnego do prawego "
"dolnego rogu."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.5.text"
msgstr "Jak możesz uzyskać do nich dostęp z podwójnym indeksowaniem?"

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.6.text"
msgstr ""
"Czy widzisz wzór w tych podwójnych indeksach? Weź kartkę i długopis, pracuj "
"nad tym na kilku przykładach."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.7.text"
msgstr ""
"Teraz skup się na drugiej przekątnej (od prawego górnego do lewego dolnego "
"rogu). Istnieje wzór w indeksach ponownie, ale jest trochę trudniejszy."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.8.text"
msgstr "Czy pamiętasz o indeksowaniu ujemnym? Może być przydatne tutaj."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.9.text"
msgstr ""
"Gdy pojmiesz wzory, użyj tych samych pomysłów jak wcześniej, aby sprawdzić, "
"czy wszystkie wpisy są równe."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.text"
msgstr ""
"Wspaniale! To było wymagające.\n"
"\n"
"Na końcu musimy sprawdzić wygrywające przekątne. W poprzednim rozdziale napisałeś już funkcję, która to robi dla plansz 3x3.\n"
"\n"
"__code0__\n"
"\n"
"Teraz napisz `diagonal_winner`, która działa dla kwadratowych plansz dowolnego rozmiaru: 4x4, 5x5 i tak dalej...\n"
"\n"
"    __copyable__\n"
"__code1__\n"
"\n"
"W pierwszym przykładzie `X` wygrało na przekątnej od lewego dolnego do prawego górnego rogu."

msgid "pages.IntroducingTicTacToe.steps.final_text.text"
msgstr ""
"Świetna praca!\n"
"\n"
"Teraz mamy kod, który określa wygrywający stan na planszy."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.0.text"
msgstr ""
"Musisz sprawdzić każdy rząd na planszy, więc potrzebujesz pętli do tego."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.1.text"
msgstr "Jak możesz sprawdzić, czy wszystkie wpisy w rzędzie są sobie równe?"

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.10.text"
msgstr "Upewnij się, że zwracasz `False`, jeśli nie ma wygrywających rzędów."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.2.text"
msgstr ""
"To samodzielny problem sam w sobie. Możesz zacząć od zapomnienia o całej "
"planszy i po prostu sprawdzania jednego rzędu."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.3.text"
msgstr ""
"Moglibyście nawet napisać funkcję, która tylko to robi, chociaż nie musicie "
"tego robić."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.4.text"
msgstr ""
"Ponieważ rząd może mieć dowolny rozmiar, będziesz musiał przeprowadzić pętlę"
" przez cały jego obszar."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.5.text"
msgstr ""
"Dla każdego rzędu zdefiniuj zmienną logiczną (boolean). Następnie "
"przeprowadź pętlę przez ten rząd, aktualizując zmienną odpowiednio."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.6.text"
msgstr ""
"Możesz użyć pierwszego wpisu `row[0]` w rzędzie, aby porównać wszystkie "
"pozostałe wpisy do niego."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.7.text"
msgstr ""
"Zastanów się uważnie, jaką początkową wartość powinna mieć zmienna logiczna "
"i w jakich warunkach powinieneś zmienić jej wartość."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.8.text"
msgstr ""
"Po przeprowadzeniu pętli przez rząd, jeśli stwierdzisz, że wszystkie jego "
"wpisy są sobie równe, wtedy zwróć `True` (kończąc wczesniej zewnętrzną "
"pętlę)."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.9.text"
msgstr "Upewnij się, że nie zwracasz `True` dla rzędu wypełnionego spacjami."

msgid ""
"pages.IntroducingTicTacToe.steps.intro_row_winner.messages.catch_empty_row.text"
msgstr ""
"Pamiętaj, że niektóre pola mogą być `' '`. Pusty rząd nie jest wygrywającym"

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.text"
msgstr ""
"Za Tobą już wiele krótkich ćwiczeń zawierających niewielkie problemy. Teraz zajmiemy się większym, bardziej skomplikowanym\n"
"projektem, który naprawdę sprawdzi Twoją wiedzę i będzie wymagał połączenia wielu mniejszych części razem.\n"
"Będzie to niezła zabawa!\n"
"\n"
"Stworzysz tekstową, interaktywną grę w kółko i krzyżyk, przeznaczoną dla 2 graczy ludzkich.\n"
"Oto mały podgląd tego, jak będzie wyglądała gotowa gra w trakcie rozgrywki:\n"
"\n"
"      1 2 3\n"
"    1  | |\n"
"      -+-+-\n"
"    2  | |\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"    Gracz X:\n"
"    1\n"
"    1\n"
"\n"
"      1 2 3\n"
"    1 X| |\n"
"      -+-+-\n"
"    2  | |\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"    Gracz O:\n"
"    2\n"
"    2\n"
"\n"
"      1 2 3\n"
"    1 X| |\n"
"      -+-+-\n"
"    2  |O|\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"    Gracz X:\n"
"    1\n"
"    3\n"
"\n"
"      1 2 3\n"
"    1 X| |X\n"
"      -+-+-\n"
"    2  |O|\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"Dzielimy projekt na kilka małych funkcji, które będą stanowić ćwiczenia.\n"
"\n"
"Użyjesz wielu pojęć, które już umiesz: napisy (strings),\n"
"zagnieżdżone listy, zagnieżdżone pętle, `range`, wywoływanie funkcji w funkcjach, porównania i wartości logiczne (booleans).\n"
"\n"
"Po drodze dowiesz się też o kilku nowych pojęciach, w tym o znakach nowej linii, typach i `input()`.\n"
"\n"
"Oto zarys projektu:\n"
"\n"
"- trzy funkcje `row_winner`, `column_winner`,  `diagonal_winner`, które sprawdzają całą planszę pod kątem wygrywających rzędów, kolumn i przekątnych\n"
"- funkcja `winner`, która sprawdza całą planszę pod kątem zwycięzcy, łącząc powyższe funkcje\n"
"- funkcja `format_board`, która wyświetla bieżący stan gry\n"
"- funkcja `play_move`, która przyjmuje dane wejściowe od użytkownika, aby wykonać ruch,\n"
"- na końcu funkcja `play_game`, która łączy wszystko razem i uruchamia grę interaktywnie.\n"
"- Później dodamy kolejne udoskonalenia.\n"
"\n"
"Zaczynajmy!\n"
"\n"
"Tak jak w ostatnim rozdziale, będziemy reprezentować planszę do gry w kółko i krzyżyk jako zagnieżdżoną listę napisów (stringów).\n"
"Dla typowej gry będzie to lista 3x3, tj. 3 listy zawierające po 3 napisy, z graczami reprezentowanymi przez `'X'` lub `'O'`.\n"
"Puste pola będą reprezentowane przez spację, czyli `' '`. Na przykład:\n"
"\n"
"__code0__\n"
"\n"
"Jednak, aby było ciekawiej, Twój kod będzie musiał działać dla kwadratowych plansz o dowolnym rozmiarze\n"
"(4x4, 5x5 itd.), gdzie gracze mogą być reprezentowani przez dowolne napisy, np.:\n"
"\n"
"__code1__\n"
"\n"
"Napisz funkcję `row_winner`, która zwraca `True`, jeśli `board` zawiera\n"
"wygrywający rząd, czyli poziomą linię, która ma tę samą postać we wszystkich swoich miejscach (oprócz `' '`):\n"
"\n"
"    __copyable__\n"
"__code2__\n"
"\n"
"W drugim przykładzie `O` wygrywa w dolnym rzędzie."

msgid "pages.IntroducingTicTacToe.steps.winner.disallowed.0.message"
msgstr ""
"Twoje rozwiązanie powinno działać przez wywołanie tych trzech funkcji. `winner` sama nie powinna wykonywać żadnej\n"
"pętli, indeksowania itp. Powinna być bardzo krótka.\n"
"\n"
"Skopiuj funkcje `row_winner` i inne i pozostaw je takie, jakie są. Nie kopiuj kodu z nich\n"
"do funkcji `winner`, po prostu wywołaj te funkcje."

msgid "pages.IntroducingTicTacToe.steps.winner.hints.0.text"
msgstr ""
"Rozwiązanie jest dość krótkie! Po prostu użyj trzech funkcji poprawnie."

msgid "pages.IntroducingTicTacToe.steps.winner.hints.1.text"
msgstr ""
"Pomyśl o możliwych przypadkach. Kiedy `winner(board)` zwraca `False`? Kiedy "
"zwraca `True`?"

msgid "pages.IntroducingTicTacToe.steps.winner.hints.2.text"
msgstr ""
"Jak możesz użyć trzech funkcji i operatora logicznego, aby uzyskać potrzebny wynik?"

msgid "pages.IntroducingTicTacToe.steps.winner.text"
msgstr ""
"Brawo! To było dość trudne.\n"
"\n"
"Teraz możemy połączyć te trzy funkcje! Napisz funkcję `winner`, która przyjmuje jako argument `board` tak jak wcześniej,\n"
"i zwraca `True`, jeśli `board` zawiera wygrywający rząd, kolumnę lub przekątną, `False` w przeciwnym razie.\n"
"\n"
"Twoje rozwiązanie powinno działać przez wywołanie tych trzech funkcji. `winner` sama nie powinna wykonywać żadnej\n"
"pętli, indeksowania itp.\n"
"\n"
"Oto trochę kodu dla `row_winner`, `column_winner` i `diagonal_winner` wraz z kilkoma testami dla funkcji `winner`.\n"
"Kliknij przycisk Kopiuj i uzupełnij luki dla swojej funkcji `winner`.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingTicTacToe.title"
msgstr "Sprawdzanie planszy pod kątem zwycięzcy"

msgid "pages.IntroducingVariables.steps.final_text.text"
msgstr ""
"Odpowiedź brzmi, że `sunshine` wygląda na zmienną, więc Python próbuje "
"znaleźć jej wartość, ale ponieważ nigdy nie zdefiniowaliśmy zmiennej o tej "
"nazwie, otrzymujemy błąd."

msgid ""
"pages.IntroducingVariables.steps.sunshine_undefined_check.output_prediction_choices.0"
msgstr "sunshine"

msgid ""
"pages.IntroducingVariables.steps.sunshine_undefined_check.output_prediction_choices.1"
msgstr "'sunshine'"

msgid ""
"pages.IntroducingVariables.steps.sunshine_undefined_check.output_prediction_choices.2"
msgstr "Hello"

msgid ""
"pages.IntroducingVariables.steps.sunshine_undefined_check.output_prediction_choices.3"
msgstr "'Hello'"

msgid "pages.IntroducingVariables.steps.sunshine_undefined_check.text"
msgstr ""
"Jak widać, apostrofy są bardzo istotne. `'word'` jest dosłownie tylko `'word'`, stąd technicznie nazywa się to *literałem łańcucha znaków* (ang. string literal). Z drugiej strony, `word` to zmienna, której wartość może być dowolna.\n"
"\n"
"Podobnie, `'sunshine'` to `'sunshine'`, ale co to jest `__program__` bez apostrofów?"

msgid "pages.IntroducingVariables.steps.word_assign.text"
msgstr ""
"Aby tworzyć interesujące programy, nie możemy zawsze manipulować tymi samymi wartościami. Potrzebujemy sposobu na odniesienie się do wartości, które nie są znane z góry i mogą się zmieniać. To właśnie są *zmienne* (ang. variables).\n"
"\n"
"Uruchom ten kod:\n"
"\n"
"__program_indented__"

msgid ""
"pages.IntroducingVariables.steps.word_check.special_messages.bad_word.text"
msgstr ""
"Ups, musisz ustawić `word = 'Hello'` zanim będziemy mogli kontynuować."

msgid "pages.IntroducingVariables.steps.word_check.text"
msgstr ""
"To tworzy zmienną o nazwie `word`, która odnosi się do wartości ciągu znaków `'Hello'`.\n"
"\n"
"Teraz zobacz, co się stanie, gdy uruchomisz jedynie `__program__` w shellu."

msgid ""
"pages.IntroducingVariables.steps.word_string_check.output_prediction_choices.0"
msgstr "word"

msgid ""
"pages.IntroducingVariables.steps.word_string_check.output_prediction_choices.1"
msgstr "'word'"

msgid ""
"pages.IntroducingVariables.steps.word_string_check.output_prediction_choices.2"
msgstr "Hello"

msgid ""
"pages.IntroducingVariables.steps.word_string_check.output_prediction_choices.3"
msgstr "'Hello'"

msgid "pages.IntroducingVariables.steps.word_string_check.text"
msgstr ""
"Dobrze. Dla porównania, uruchom jedynie `__program__` w shellu, z "
"apostrofami."

msgid "pages.IntroducingVariables.title"
msgstr "Wprowadzenie do zmiennych"


msgid "pages.LoopingOverNestedLists.steps.final_text.text"
msgstr ""
"Opanowałeś zagnieżdżone listy i jak je połączyć z zagnieżdżonymi pętlami.\n"
"Brawo! Teraz masz w swoim arsenale bardzo potężne narzędzia programistyczne."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.0.text"
msgstr "To jest bardzo podobne do poprzedniego ćwiczenia."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.1.text"
msgstr "Kiedy powinieneś wydrukować zmienną boolean?"

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.2.text"
msgstr "Pamiętaj, że chcesz wydrukować ją tylko raz."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.3.text"
msgstr ""
"Zamiast definiować zmienną boolean dla każdej podlisty, zdefiniuj tylko "
"jedną zmienną boolean dla całej listy."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.4.text"
msgstr "Kiedy i jak powinieneś modyfikować zmienną boolean?"

msgid "pages.LoopingOverNestedLists.steps.list_contains_word_exercise.text"
msgstr ""
"Dobra robota!\n"
"\n"
"Następnie, wydrukuj tylko jeden boolean, aby wskazać, czy `word` jest obecne w jakimkolwiek ciągu całej zagnieżdżonej listy. Na przykład, jeśli\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"twój program powinien wypisać `False`."

msgid ""
"pages.LoopingOverNestedLists.steps.nested_list_loop_python_tutor.requirements"
msgstr ""
"Uruchom pojedynczy program składający się z dwóch powyższych części połączonych.\n"
"Są one oddzielone, aby nie musieć wpisywać części `numbers = [...]`,\n"
"ale wpisanie części z zagnieżdżoną pętlą jest najlepsze dla nauki.\n"
"Upewnij się, że wcięcia są poprawne."

msgid "pages.LoopingOverNestedLists.steps.nested_list_loop_python_tutor.text"
msgstr ""
"Teraz uruchom ten sam program ponownie w Python Tutor.\n"
"\n"
"Zbadaj, jak wygląda `numbers` i co oznaczają `numbers[0]` aż do `numbers[3]`.\n"
"Spójrz, jak zmieniają się zmienne `sublist` i `num`."

msgid ""
"pages.LoopingOverNestedLists.steps.nested_list_nested_loop_example.requirements"
msgstr ""
"Uruchom pojedynczy program składający się z dwóch powyższych części połączonych.\n"
"Są one oddzielone, aby nie musieć wpisywać części `numbers = [...]`,\n"
"ale wpisanie części z zagnieżdżoną pętlą jest najlepsze dla nauki.\n"
"Upewnij się, że wcięcia są poprawne."

msgid ""
"pages.LoopingOverNestedLists.steps.nested_list_nested_loop_example.text"
msgstr ""
"Możesz użyć zagnieżdżonej pętli do iteracji przez każdy element i pod-element zagnieżdżonej listy.\n"
"Na przykład, rozważ taką zagnieżdżoną listę.\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Kliknij przycisk, aby skopiować listę do edytora, a następnie wpisz następującą zagnieżdżoną pętlę.\n"
"\n"
"__code1__\n"
"\n"
"Przyjrzyj się uważnie kodowi. Zauważ, że zewnętrzna pętla tworzy zmienną `sublist`\n"
"i wewnętrzna pętla iteruje przez tę samą zmienną. To jest często używany wzorzec.\n"
"Teraz uruchom kod."

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.0.text"
msgstr "Jak sprawdzić, czy ciąg zawiera słowo?"

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.1.text"
msgstr ""
"Upewnij się, że sprawdzasz, czy **ciąg tekstowy** zawiera słowo, a nie "
"podlista."

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.2.text"
msgstr ""
"Jak można uzyskać dostęp do każdego ciągu w każdej podliście zagnieżdżonej "
"listy?"

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.3.text"
msgstr "Musisz użyć zagnieżdżonej pętli."

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.4.text"
msgstr ""
"Pętle powinny podążać za tym samym wzorcem co przykład na początku strony."

msgid "pages.LoopingOverNestedLists.steps.string_contains_word_exercise.text"
msgstr ""
"Teraz rozwiążmy kilka problemów, używając tego rodzaju pętli.\n"
"\n"
"Załóżmy, że mamy zagnieżdżoną listę ciągów tekstowych jak poniższa,\n"
"i chcemy szukać konkretnego `word` głęboko w listach.\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Możesz wyobrazić sobie, że `strings` reprezentuje książkę, gdzie każda podlista to strona i każdy ciąg znaków wewnątrz\n"
"to linia na tej stronie.\n"
"Może to również reprezentować bibliotekę, gdzie każda lista to książka, a każdy ciąg znaków to strona.\n"
"\n"
"Napisz program, który wydrukuje każdy ciąg zawierający `word`.\n"
"Powinno to działać dla dowolnego `word` i `strings`. Dla przykładu powyżej, powinien wydrukować\n"
"\n"
"    hello there\n"
"    hello world\n"
"\n"
"Pamiętaj, że istnieje konkretny sposób na sprawdzenie, czy ciąg zawiera inny ciąg. Jeśli nie pamiętasz jak, poszukaj w Google!"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.0.text"
msgstr "Dla każdej podlisty zdefiniuj zmienną boolean."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.1.text"
msgstr "Przechodząc przez podlistę, aktualizuj zmienną boolean odpowiednio."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.2.text"
msgstr "Wydrukuj zmienną boolean tylko raz dla każdej podlisty."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.3.text"
msgstr "Jaka powinna być początkowa wartość dla zmiennej boolean?"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.4.text"
msgstr ""
"Co jeśli jedna z podlist jest pusta? Co powinieneś wydrukować dla tej "
"podlisty?"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.5.text"
msgstr ""
"Jeśli znajdziesz słowo w ciągu, zmienna boolean powinna zostać ustawiona na "
"`True`."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.6.text"
msgstr "Co jeśli ciąg nie zawiera słowa?"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.7.text"
msgstr "Nie szkodzi! To nie zmienia faktu, że inny ciąg może zawierać słowo."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.8.text"
msgstr ""
"Innymi słowy, nie ustawiaj zmiennej boolean na `False` oprócz na początku."

msgid "pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.text"
msgstr ""
"Super!\n"
"\n"
"Teraz zmieńmy nieco ćwiczenie. Tym razem wyjście powinno powiedzieć nam, które *podlisty* zawierają `word`,\n"
"zamiast tego, które wewnętrzne ciągi. W szczególności chcemy wydrukować boolean dla każdej podlisty:\n"
"`True`, jeśli podlista zawiera słowo w którymkolwiek z jej ciągów, `False`, jeśli go tam wcale nie ma.\n"
"\n"
"Mając te przykładowe dane wejściowe:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"twój program powinien wypisać\n"
"\n"
"__code1__\n"
"\n"
"Zauważ, że `word in sublist` nie zadziała. Na przykład, `\"hello\" in [\"hello there\", \"how are you\"]` jest `False`\n"
"ponieważ `\"hello\"` nie jest *równa* żadnemu z dwóch elementów tej listy, mimo że znajduje się w jednym z nich."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.0.text"
msgstr "Ponieważ ciągi mogą mieć różne długości, to jest trochę trudne."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.1.text"
msgstr "Jak długo powinna trwać twoja zewnętrzna pętla tym razem?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.2.text"
msgstr ""
"Zanim zaczniesz obsługiwać ciągi, może być dobrym pomysłem najpierw znaleźć "
"najdłuższą długość ciągu."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.3.text"
msgstr "Reszta jest bardzo podobna do poprzedniego ćwiczenia."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.4.text"
msgstr ""
"Jedyna różnica polega na tym, że teraz musisz zdecydować, czy dodać literę z"
" ciągu, czy spację."

msgid "pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.text"
msgstr ""
"Świetnie! Jeśli chcesz, możesz już teraz przejść do [następnej strony](#DefiningFunctions).\n"
"Albo możesz spróbować dodatkowego wyzwania!\n"
"\n"
"Teraz uogólnijmy poprzednie ćwiczenie do ciągów o różnej długości. Znowu masz daną listę ciągów tekstowych.\n"
"Tak jak poprzednio, napisz program, który wydrukuje pierwszą literę każdego ciągu razem w jednej linii,\n"
"następnie drugie litery razem w następnej linii i tak dalej.\n"
"Ale tym razem, jeśli ciąg nie ma wystarczającej liczby liter, powinien wydrukować spację.\n"
"\n"
"Na przykład, jeśli\n"
"\n"
"    __no_auto_translate__\n"
"    strings = [\"abcqwe\", \"def\", \"ghiq\"]\n"
"\n"
"twój program powinien wypisać\n"
"\n"
"    adg\n"
"    beh\n"
"    cfi\n"
"    q q\n"
"    w\n"
"    e"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.0.text"
msgstr "To NIE jest podobne do poprzednich ćwiczeń na tej stronie."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.1.text"
msgstr ""
"Pomyśl o rozwiązaniu, gdy są tylko dwa ciągi. Jak możesz uogólnić to do "
"listy ciągów?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.2.text"
msgstr "Musisz przejść przez pierwsze litery, następnie drugie litery itd."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.3.text"
msgstr "Będziesz musiał użyć pętli, ale jak długo powinna trwać pętla?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.4.text"
msgstr "Pamiętaj, że ciągi na liście mają równe długości."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.5.text"
msgstr ""
"Dla każdej pozycji (pierwszej, drugiej itd.) zdefiniuj nowy ciąg tekstowy."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.6.text"
msgstr "Jaki powinien być początkowo ten ciąg tekstowy?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.7.text"
msgstr ""
"Dla każdej pozycji (pierwszej, drugiej itd.) będziesz musiał przejść przez "
"każdy ciąg na liście."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.8.text"
msgstr "Będziesz potrzebował kolejnej pętli wewnątrz tej, którą już masz."

msgid "pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.text"
msgstr ""
"Świetnie!\n"
"\n"
"[Wcześniej w kursie](#GettingElementsAtPositionExercises) było ćwiczenie\n"
"na wydrukowanie dwóch ciągów tekstowych pionowo, obok siebie, jak niżej:\n"
"\n"
"    H W\n"
"    e o\n"
"    l r\n"
"    l l\n"
"    o d\n"
"\n"
"Teraz będziemy to uogólniać do listy ciągów, a nie tylko dwóch.\n"
"\n"
"W tym ćwiczeniu otrzymujesz listę ciągów tekstowych o **równej długości**.\n"
"Napisz program, który wydrukuje pierwszą literę każdego ciągu w jednej linii,\n"
"następnie drugą literę każdego ciągu w następnej linii i tak dalej. Na przykład, jeśli\n"
"\n"
"__code0__\n"
"\n"
"twój program powinien wypisać\n"
"\n"
"    __no_auto_translate__\n"
"    adg\n"
"    beh\n"
"    cfi\n"
"\n"
"Twój program powinien działać dla dowolnej takiej listy. Szczególnie jeśli użyjesz następującej listy,\n"
"odkryjesz ukrytą wiadomość z Zen Pythona!\n"
"\n"
"    __copyable__\n"
"    __no_auto_translate__\n"
"    strings = [\"  b n\", \"f ete\", \"liths\", \"astat\", \"t ene\", \"  r d\"]\n"
"\n"
"Zauważ, że tym razem nie powinieneś dodawać spacji między literami w wyjściu."

msgid "pages.LoopingOverNestedLists.title"
msgstr "Iterowanie po zagnieżdżonych listach"

msgid "pages.MakingTheBoard.steps.final_text.text"
msgstr ""
"Well done!\n"
"\n"
"This could be solved by moving the first loop inside the second to make a new `row` each time:\n"
"\n"
"__code0__\n"
"\n"
"Another way is to make a copy of `row` each time, e.g. keep the original code but change one line:\n"
"\n"
"__code1__\n"
"\n"
"You can also copy `row` with `row[:]` or `list(row)`. But it's important to know that\n"
"all these methods make a *shallow copy* of the list.\n"
"That means they copy the whole list at the top level, without making copies of each element.\n"
"That's fine in this case where `row` only contains strings which can't be modified\n"
"and don't need copying. But if the elements are mutable objects like lists,\n"
"as is the case with `board`, you may run into the same problem again.\n"
"Here's an example:\n"
"\n"
"    __copyable__\n"
"__code2__\n"
"\n"
"Here each element of `cube` is a separate list, a copy of `board`.\n"
"And within each of those copies, each element is also a separate list, a copy of `row`.\n"
"But the shallow copies of `board` all have the same first element as each other (the first copy of `row`),\n"
"the same second element, and so on.\n"
"Changing `make_board` won't fix anything here, the solution is to either:\n"
"\n"
"- Call `make_board` repeatedly to make a new `board` each time, or\n"
"- Use the `deepcopy` function instead of `board.copy()`.\n"
"  `deepcopy` makes copies at every level of nested objects.\n"
"\n"
"If you're still confused, don't worry.\n"
"This is just preparing you to deal with your code behaving weirdly in the future.\n"
"You're not required to understand this right now and this lesson will still be valuable.\n"
"\n"
"Either way, we're ready to make the full game. You can do it!"

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.0.text"
msgstr "The existing code is almost correct."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.1.text"
msgstr "There are several ways to solve this."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.2.text"
msgstr "Some solutions involve adding something small."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.3.text"
msgstr ""
"You can also rearrange the code without adding or removing anything (except "
"spaces)."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.4.text"
msgstr "The problem is that a single list `row` is used several times."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.5.text"
msgstr ""
"So one solution is to make copies of `row` which will all be separate."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.6.text"
msgstr "Another solution is to make a new `row` from scratch each time."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.7.text"
msgstr ""
"There are a few ways to copy a list in Python with a tiny bit of code."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.8.text"
msgstr "Making a new row each time can be done by just rearranging the code."

msgid ""
"pages.MakingTheBoard.steps.fix_make_board.special_messages.not_separate.text"
msgstr "However, the sublists in the result are not all separate objects."

msgid "pages.MakingTheBoard.steps.fix_make_board.text"
msgstr ""
"Can you see what happened?\n"
"\n"
"Every row got an `'X'` in the first position!\n"
"It's as if the code actually did this:\n"
"\n"
"__code0__\n"
"\n"
"Try and figure out what's wrong by yourself.\n"
"But again, it's tricky, so don't drive yourself crazy over it.\n"
"\n"
"If you want, here's some hints:\n"
"\n"
" - Try running the code through some debuggers.\n"
" - Experiment. Make changes to the code and see what happens.\n"
" - No, the code didn't do 3 assignments like I suggested above. There was just one list assignment.\n"
" - There's no hidden loops or anything.\n"
" - How many lists does `board` contain? 3?\n"
" - The previous page has a subtle hint at what happened.\n"
" - There is a page from a previous chapter where this kind of problem is explained directly.\n"
" - Specifically [this page](#EqualsVsIs).\n"
" - Try running the code with Python Tutor.\n"
"\n"
"OK, if you're ready, here's the answer.\n"
"\n"
"The list `row` was only created once, and reused several times.\n"
"`board` contains the same list three times. Not copies, just one list in three places.\n"
"It's like it did this:\n"
"\n"
"__code1__\n"
"\n"
"Which means that this code:\n"
"\n"
"__code2__\n"
"\n"
"is equivalent to:\n"
"\n"
"__code3__\n"
"\n"
"which affects 'all the lists' in `board` because they're all just the one list `row`.\n"
"In other words, the above line is *also* equivalent to each of these two lines:\n"
"\n"
"__code4__\n"
"\n"
"because `row` is `board[0]`, `board[1]`, and `board[2]` all at once.\n"
"\n"
"Your job now is to fix `make_board` to not have this problem.\n"
"It should still return a list of length `size` where each\n"
"element is also list of length `size` where each element is the string `' '`.\n"
"The sublists should all be separate list objects, not the same\n"
"list repeated."

msgid "pages.MakingTheBoard.steps.naive_make_board.text"
msgstr ""
"So far the board has been provided for you as a nested list.\n"
"But for the full program, you need to create it yourself.\n"
"Should be easy, right? Here's some code to do that:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"It's close, but there's a subtle problem with it.\n"
"Make sure you understand the code,\n"
"and bonus points if you can spot the bug!\n"
"If not, don't feel bad or waste too much time on it."

msgid "pages.MakingTheBoard.title"
msgstr "Making the Board"

msgid "pages.ModifyingWhileIterating.steps.final_text.text"
msgstr ""
"Powtórzmy raz jeszcze, ***nigdy nie modyfikuj czegoś podczas iteracji nad tym***. Twoje opcje to:\n"
"\n"
"- Modyfikuj kopię\n"
"- Iteruj przez kopię\n"
"- Nie modyfikuj niczego, zamiast tego stwórz nową wersję."

msgid "pages.ModifyingWhileIterating.steps.make_copy.requirements"
msgstr ""
"Uruchom ten sam program co wyżej, ale zmień drugą linię:\n"
"\n"
"__code0__\n"
"\n"
"na:\n"
"\n"
"__code1__\n"
"\n"
"czyli dodaj `.copy()` po `numbers`, ale przed `:`."

msgid "pages.ModifyingWhileIterating.steps.make_copy.text"
msgstr ""
"Ale okazuje się, że robi to niemal to samo - nie kończy się błędem, ale nadal nie usuwa 7 ani 3.\n"
"Dzieje się tak z tego samego powodu - iteracja przez listę wciąż odbywa się pod spodem przez indeksy.\n"
"\n"
"Morał z tego taki aby ***nigdy nie modyfikować czegoś, po czym się iteruje***. Oddzielaj mutację i iterację.\n"
"\n"
"Dobra wiadomość jest taka, że istnieje wiele innych sposobów aby do tego podejść. Możesz zamiast tego po prostu iterować przez kopię, jak tutaj:\n"
"\n"
"__code0__"

msgid "pages.ModifyingWhileIterating.steps.make_copy2.text"
msgstr ""
"Teraz lista, która jest modyfikowana i lista, która jest iterowana, to oddzielne obiekty, nawet jeśli zaczynają z równą zawartością.\n"
"\n"
"Podobnie, możesz iterować przez oryginał i modyfikować kopię:\n"
"\n"
"__program_indented__"

msgid "pages.ModifyingWhileIterating.steps.make_new_list.text"
msgstr ""
"Albo możesz zbudować nową listę od zera. Zrobiliśmy już coś podobnego w ćwiczeniu:\n"
"\n"
"__program_indented__"

msgid "pages.ModifyingWhileIterating.steps.remove_instead_of_pop.text"
msgstr ""
"W trakcie działania programu widać, że nawet nie bierze pod uwagę 7 lub 3 i nie usuwa ich. Na końcu kończy się niepowodzeniem, kiedy próbuje uzyskać dostęp do indeksu, który jest za wysoki. Czy rozumiesz, dlaczego się tak dzieje?\n"
"\n"
"Zmienna indeksowa `i` przechodzi przez typowe wartości 0, 1, 2, ... jak powinna, ale w miarę zmiany listy te pozycje już nie są tymi, których chcemy. Na przykład w pierwszej iteracji `i` jest 0 i `number` to 10, który zostaje usunięty. Przesuwa to pozostałe numery o jedną pozycję w lewo, więc teraz 7 jest na pozycji 0. Ale w następnej iteracji `i` jest 1, a `numbers[i]` to 8. 7 został pominięty.\n"
"\n"
"Moglibyśmy spróbować napisać program używając `remove` zamiast `pop`, aby nie korzystać z indeksów. Nawet wygląda to ładniej w ten sposób.\n"
"\n"
"__program_indented__"

msgid "pages.ModifyingWhileIterating.steps.run_broken_with_python_tutor.text"
msgstr ""
"Spójrz na ten program. Przeszukuje on listę liczb i usuwa te mniejsze niż 10. Przynajmniej próbuje to zrobić.\n"
"Uruchom go z Python Tutor.\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"(pamiętaj, że `numbers.pop(i)` usuwa element z `numbers` o indeksie `i`)"

msgid "pages.ModifyingWhileIterating.title"
msgstr "Modyfikowanie podczas iteracji"

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno zawierać dokładnie trzy instrukcje: `x = [15, 12, "
"-6, 3]`, `y = ` stanowione przez jedną linię dokładnie skopiowaną z listy, i"
" `print(y)`."

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.1.text"
msgstr ""
"Jeśli nie jesteś pewien, sprawdź, jak oblicza się średnią/średnią "
"arytmetyczną."

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.2.text"
msgstr "Do obliczenia średniej liczb w `x` potrzebujemy dwóch rzeczy."

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.3.text"
msgstr "Które dwie funkcje/metody dają ci te dwie rzeczy?"

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.4.text"
msgstr "Jak połączyć te dwie rzeczy, aby obliczyć średnią?"

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.requirements"
msgstr ""
"Skopiuj trzy linie powyżej, a następnie zastąp "
"`(insert_one_line_from_above)` dokładnie jedną linią z długiej listy linii "
"powyżej. Środkowa linia powinna nadal zaczynać się od `y = `."

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.text"
msgstr ""
"Dobra robota! Do następnego ćwiczenia zacznij od tego niekompletnego programu:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Zastąp partię po `y = ` jedną linią z listy powyżej.\n"
"Końcowy program powinien wydrukować średnią (technicznie *średnią arytmetyczną*) liczb w `x`."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno zawierać dokładnie trzy instrukcje: `x = ['a', "
"'b', 'c']`, `y = ` stanowione przez jedną linię dokładnie skopiowaną z "
"listy, i `print(y)`."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.1.text"
msgstr "Kiedy `1 in x` jest prawdziwe?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.2.text"
msgstr "Kiedy `1` jest w `x`!"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.3.text"
msgstr "Może to być, że `1` jest na `x` raz, albo dwa razy, albo trzy razy..."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.4.text"
msgstr "...ale nie zero razy!"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.requirements"
msgstr ""
"Skopiuj trzy linie powyżej, a następnie zastąp `1 in x` dokładnie jedną "
"linią z długiej listy linii powyżej. Środkowa linia powinna nadal zaczynać "
"się od `y = `. Wybrana linia powinna mieć taki sam efekt jak `1 in x`, aby "
"program wydrukował `True`."

msgid "pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.text"
msgstr ""
"Możesz rozpoznać niektóre z nich z poprzednich ćwiczeń. Zapewniam, że te ćwiczenia nie były bezcelowe,\n"
"ponieważ nauczyłeś się teraz cennych podstawowych umiejętności. Na przykład, możesz użyć `in` do sprawdzenia, czy lista zawiera 5,\n"
"ale nie ma podobnie łatwego sposobu na sprawdzenie, czy w liście jest liczba większa niż 5.\n"
"\n"
"Teraz rozwiążesz kolejny zestaw czterech ćwiczeń dotyczących tych nowych pojęć.\n"
"Znowu, poprawne i niepoprawne linie kodu są ze sobą wymieszane,\n"
"i musisz wybrać poprawną linię z listy.\n"
"\n"
"__code0__\n"
"\n"
"Oto program:\n"
"\n"
"    __copyable__\n"
"__code1__\n"
"\n"
"Zastąp część `1 in x` (zostaw `y = `) jedną linią z listy powyżej, która robi to samo."

msgid "pages.MoreListFunctionsAndMethods.steps.count_predict_exercise.text"
msgstr ""
"**`count`**: Zwraca liczbę wystąpień argumentu na liście używając składni\n"
"\n"
"__code0__\n"
"\n"
"Na przykład uruchom tę linię w shellu:\n"
"\n"
"__program_indented__"

msgid "pages.MoreListFunctionsAndMethods.steps.final_text.text"
msgstr "Gratulacje! Jesteś teraz mistrzem metod i funkcji list!"

msgid "pages.MoreListFunctionsAndMethods.steps.in_predict_exercise.text"
msgstr ""
"**`in`**: Operator porównania, który sprawdza, czy wartość znajduje się na liście, używając składni\n"
"\n"
"__code0__\n"
"\n"
"Na przykład uruchom ten program:\n"
"\n"
"__program_indented__"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno zawierać dokładnie trzy instrukcje: `x = [12, -6, "
"2, -1, 3]`, `y = ` stanowione przez jedną linię dokładnie skopiowaną z "
"listy, i `print(y)`."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.1.text"
msgstr ""
"Liczby w `x` wydają się być wszystkie pomieszane. Czy możesz z tym coś "
"zrobić?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.2.text"
msgstr ""
"Jeśli to zrozumiałeś, spróbuj użyć tej funkcji w shellu, aby pobawić się "
"nią."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.3.text"
msgstr ""
"Jak użyjesz tej funkcji, aby uzyskać najmniejszą wartość na liście? A "
"największą?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.4.text"
msgstr "Potem jak możesz uzyskać *drugą* najmniejszą wartość?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.requirements"
msgstr ""
"Skopiuj trzy linie powyżej, a następnie zastąp "
"`(insert_one_line_from_above)` dokładnie jedną linię z długiej listy linii "
"powyżej. Środkowa linia powinna nadal zaczynać się od `y = `."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.text"
msgstr ""
"Doskonale. I ostatnie:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Zastąp partię po `y = ` jedną linią z listy powyżej.\n"
"Końcowy program powinien wydrukować *drugą najmniejszą wartość* w `x`."

msgid "pages.MoreListFunctionsAndMethods.steps.sorted_predict_exercise.text"
msgstr ""
"Oto kilka bardziej użytecznych funkcji/metod.\n"
"\n"
"**`sorted`**: Bierze iterowalny obiekt i zwraca listę elementów w kolejności od najmniejszego do największego, używając składni\n"
"\n"
"__code0__\n"
"\n"
"Na przykład uruchom tę linię w shellu:\n"
"\n"
"__program_indented__"

msgid "pages.MoreListFunctionsAndMethods.steps.sum_predict_exercise.text"
msgstr ""
"**`sum`**: Sumuje iterowalny zbiór liczb używając składni\n"
"\n"
"__code0__\n"
"\n"
"Na przykład uruchom tę linię w shellu:\n"
"\n"
"__program_indented__"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno zawierać dokładnie trzy instrukcje: `x = 100`, `y "
"= ` stanowione przez jedną linię dokładnie skopiowaną z listy, i `print(y)`."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.hints.1.text"
msgstr "Jaką funkcję/metodę można użyć do sumowania rzeczy?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.hints.2.text"
msgstr "Która funkcja/metoda daje nam liczby `1, 2, 3, ..., x`?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.hints.3.text"
msgstr ""
"Musisz wprowadzić małą zmianę, inaczej ta ostatnia liczba `x` zostanie "
"pominięta."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.requirements"
msgstr ""
"Skopiuj trzy linie powyżej, a następnie zastąp "
"`(insert_one_line_from_above)` dokładnie jedną linię z długiej listy linii "
"powyżej. Środkowa linia powinna nadal zaczynać się od `y = `."

msgid "pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.text"
msgstr ""
"Dobra robota! Do następnego ćwiczenia zacznij od tego niekompletnego programu:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Zastąp partię po `y = ` jedną linią z listy powyżej.\n"
"Końcowy program powinien wydrukować wynik sumowania wszystkich liczb od `1` do `x` włącznie, czyli `1 + 2 + 3 + ... + x`."

msgid "pages.MoreListFunctionsAndMethods.title"
msgstr "Więcej Funkcji i Metod List"

msgid "pages.MoreOnReturn.steps.break_vs_return.requirements"
msgstr ""
"Uruchom ten sam kod co w poprzednim kroku, ale zastąp całą ostatnią linię "
"funkcji (`return letter`) tylko instrukcją `break`."

msgid "pages.MoreOnReturn.steps.break_vs_return.text"
msgstr ""
"Jak już wcześniej, `return` ***zatrzymuje całą funkcję***, łącznie z wszelkimi pętlami.\n"
"\n"
"Wcześniej pokazywaliśmy [jak zatrzymać pętlę za pomocą `break`](#UsingBreak).\n"
"Zmien `return letter` na `break` i zobacz jaka jest różnica."

msgid "pages.MoreOnReturn.steps.cannot_return_multiple_values.text"
msgstr ""
"Po wykonaniu instrukcji `return`, funkcja zostaje zakończona, a dalsza część kodu jest ignorowana.\n"
"Oznacza to, że jakikolwiek kod bezpośrednio po `return` w tym samym bloku jest *nieosiągalny*:\n"
"`return 2` nigdy nie może zostać osiągnięty, bez względu na to, ile razy uruchomimy tę funkcję!\n"
"\n"
"***Tylko jeden `return` może być wykonany na wywołanie funkcji, a następnie wykonywanie zostaje zatrzymane.***\n"
"\n"
"Wielokrotne instrukcje `return` mogą być jednak użyteczne, jeśli są stosowane we właściwy sposób, np. w bloku `if-else`:\n"
"\n"
"__code0__\n"
"\n"
"Typowym błędem jest niezrozumienie działania `return` w pętlach `for`. Wypróbuj następujący kod:\n"
"\n"
"    __copyable__\n"
"__code1__"

msgid "pages.MoreOnReturn.steps.double_return_in_one_function.text"
msgstr ""
"Czasami słowo kluczowe `return` może być źródłem zamieszania i błędów wśród początkujących.\n"
"Nauczmy się więcej na ten temat.\n"
"\n"
"Uruchom ten kod:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.MoreOnReturn.steps.final_text.text"
msgstr ""
"W przeciwieństwie do `return`, `break` zatrzymuje tylko najbardziej wewnętrzną pętlę, w której jest użyty, w tym przypadku `for number in range(3):`.\n"
"Oto, co dokładnie się dzieje:\n"
"\n"
"- Dla `letter = b`, linia `print(f\"{letter} {number}\")` jest wykonana tylko dla `number = 0`,\n"
"- następnie wewnętrzna pętla jest zatrzymywana przez `break`, ale\n"
"- zewnętrzna pętla kontynuuje swoje wykonanie, przechodząc do następnej litery `c`\n"
"- która jest wykonywana w pełni, ponieważ nie powoduje aktywacji instrukcji `break`."

msgid "pages.MoreOnReturn.steps.return_ends_whole_function.text"
msgstr ""
"Na pierwszy rzut oka może się wydawać intuicyjne, by `return` zwracał jedną wartość dla każdej iteracji w pętli `for`.\n"
"Ale to nie działa w ten sposób!\n"
"Jeśli przeanalizujesz kod za pomocą `snoop` lub Python tutor, zobaczysz, że funkcja zwraca 2 w pierwszej\n"
"iteracji pętli, a następnie kończy się natychmiast.\n"
"\n"
"Nawet gdy jest tylko jedna instrukcja `return`, zostanie ona wykonana tylko raz i zwróci jedną wartość.\n"
"Jeśli chcesz zwrócić kilka wartości, zwróć listę:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Co się stanie, jeśli są zagnieżdżone pętle? Wypróbuj następującą funkcję:\n"
"\n"
"    __copyable__\n"
"__code1__"

msgid "pages.MoreOnReturn.title"
msgstr "`return` kończy wywołanie funkcji"

msgid "pages.MultiLineExpressions.steps.final_text.text"
msgstr ""
"Więc jeśli dostaniesz tajemniczy `SyntaxError`, upewnij się, że nie "
"podzieliłeś linii w niewłaściwy sposób!"

msgid "pages.MultiLineExpressions.steps.invalid_multiline.program"
msgstr ""
"is_friend = name == \"Alice\" or\n"
"            name == \"Bob\""

msgid "pages.MultiLineExpressions.steps.invalid_multiline.text"
msgstr ""
"Nasze linie kodu zaczynają być dość długie.\n"
"Na szczęście Python oferuje kilka sposobów na podzielenie jednego polecenia na wiele linii,\n"
"ale nie dzieje się to automatycznie. Musisz się upewnić, że Python rozumie, że właśnie to robisz.\n"
"Na przykład, ten kod jest nieprawidłową składnią i spowoduje błąd:\n"
"\n"
"__program_indented__"

msgid "pages.MultiLineExpressions.steps.valid_multiline.text"
msgstr ""
"Python próbuje zinterpretować to jako dwie oddzielne linie kodu i się gubi. Musisz mu powiedzieć, że\n"
"pierwsza linia kontynuuje się na drugiej linii.\n"
"\n"
"Jednym ze sposobów jest dodanie `\\` na końcu linii, aby 'uciec' (ang. _escape_) przed podziałem linii.\n"
"\n"
"Innym sposobem jest upewnienie się, że podział linii jest zawarty w jakimś rodzaju nawiasów. Wtedy kontynuacja linii\n"
"jest domyślna, ponieważ Python będzie czekał, aż wszystkie nawiasy zostaną zamknięte zanim\n"
"uzna linię za kompletną. Jeśli już masz nawiasy, na przykład dlatego, że wywołujesz funkcję\n"
"lub tworzysz listę, możesz nie musieć nic robić! W przeciwnym wypadku możesz dodać nawiasy do dowolnego wyrażenia\n"
"aby zasugerować kontynuację linii.\n"
"\n"
"Oto kilka przykładów. Zwróć szczególną uwagę na detale.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.MultiLineExpressions.title"
msgstr "Wieloliniowe instrukcje"

msgid "pages.NavigatingShellHistory.steps.final_text.text"
msgstr ""
"Oto wskazówka: często będziesz chciał ponownie uruchomić wcześniej "
"wprowadzony kawałek kodu lub jego nieco zmodyfikowaną wersję. Możesz "
"skopiować i wkleić, ale to żmudne i przeszkadza w eksperymentowaniu. Lepszą "
"metodą jest naciśnięcie strzałki w górę na klawiaturze. "
"Spowoduje to wstawienie poprzedniej linii kodu do shella. Kontynuuj "
"naciskanie, aby cofnąć się dalej w historii, a jeśli przejdziesz za daleko, "
"naciśnij strzałkę w dół, aby przejść w drugą stronę. Spróbuj teraz tego użyć."

msgid "pages.NavigatingShellHistory.title"
msgstr "Poruszanie się po historii shella"


msgid "pages.NestedListAssignment.steps.final_text.text"
msgstr "Brilliant! You're almost ready to put it all together, keep going!"

msgid "pages.NestedListAssignment.steps.modify_list_in_function.text"
msgstr ""
"We've seen how to get input from the user, now let's use that to actually put pieces\n"
"on the board and play the game. For starters, try out this code:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.0.text"
msgstr ""
"Your function needs to call `input()` twice. Input isn't passed to "
"`play_move` as an argument."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.1.text"
msgstr "`input()` always returns a string."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.10.text"
msgstr ""
"Once you've got two numbers, you need to modify the nested list `board` with"
" them."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.11.text"
msgstr "The code for this has been shown to you above."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.12.text"
msgstr ""
"You just need to use the numbers from user input instead of the hardcoded 1 "
"and 0."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.13.text"
msgstr "You can use nested subscripting in one line, or do it in two steps."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.2.text"
msgstr "A string that looks like a number is still a string, not a number."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.3.text"
msgstr "List indices have to be numbers, not strings."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.4.text"
msgstr ""
"If the board is 3x3, the user might input 1, 2, or 3 for each coordinate."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.5.text"
msgstr "What are the valid indices of a list of length 3?"

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.6.text"
msgstr "You need to take the input of 1, 2, or 3 and turn it into 0, 1, or 2."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.7.text"
msgstr "You also need to be able to handle bigger boards, like 9x9 or beyond."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.8.text"
msgstr "You can't do maths with strings, only numbers."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.9.text"
msgstr "How can you convert a string to a number?"

msgid "pages.NestedListAssignment.steps.nested_assignment_input.requirements"
msgstr ""
"Your function should modify the `board` argument. It doesn't need to "
"`return` or `print` anything."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.text"
msgstr ""
"These two lines:\n"
"\n"
"__code0__\n"
"\n"
"can be combined into one:\n"
"\n"
"__code1__\n"
"\n"
"The two pieces of code are pretty much exactly equivalent. Python first evaluates\n"
"`board[1]` to *get* the inner list, while the `[0] = ...` sets an element of `board[1]`.\n"
"You can see the value of `board[1]` in `birdseye` because it's an expression,\n"
"and you could actually replace it with any other expression.\n"
"\n"
"Now you know how to set elements in nested lists, it's time to make this interactive!\n"
"Write your own version of `play_move` that takes input from the user\n"
"to determine where to play, instead of always playing at `board[1][0]`.\n"
"It should call `input()` twice, so the user can give the row and the column\n"
"as two separate numbers. Also, our users are not programmers, so they start counting from 1,\n"
"not 0.\n"
"\n"
"For example, if the user types in these inputs:\n"
"\n"
"__code2__\n"
"\n"
"that means they want to play a move in the second row and first column, which is the same\n"
"as our original example.\n"
"\n"
"Here is some starting code:\n"
"\n"
"    __copyable__\n"
"__code3__\n"
"\n"
"This calls `play_move` twice so the user will need to enter two pairs of numbers.\n"
"Here's an example of what a 'game' should look like:\n"
"\n"
"     123\n"
"    1\n"
"    2\n"
"    3\n"
"\n"
"    X to play:\n"
"\n"
"__code2__\n"
"     123\n"
"    1\n"
"    2X\n"
"    3\n"
"\n"
"    O to play:\n"
"\n"
"    1\n"
"    3\n"
"     123\n"
"    1  O\n"
"    2X\n"
"    3\n"
"\n"
"You don't need to use the provided code exactly, it's just to give you a feeling of what's happening.\n"
"The important thing is that your `play_move` function modifies the `board` argument correctly.\n"
"It doesn't need to return or print anything, that will not be checked.\n"
"\n"
"You can assume that the user will always enter valid numbers. Later we will learn how to deal\n"
"with invalid inputs, like numbers out of range or inputs that aren't numbers at all."

msgid "pages.NestedListAssignment.steps.nested_assignment_two_lines.text"
msgstr ""
"Note how calling `play_move(game_board, 'X')` actually *modifies* `game_board` directly.\n"
"The variable `board` inside the call to `play_move` and\n"
"the variable `game_board` inside the call to `play_game` point to the same list object.\n"
"There's no copying. Python Tutor is good at showing this with arrows.\n"
"\n"
"This also means that in this case there's no need for `play_move` to return anything,\n"
"it can just modify `board` and the caller (`play_game` in this case) will see the effect.\n"
"\n"
"However, our board is two dimensional, represented by a nested list.\n"
"So we need to assign `player` to an element of an inner list, something like this:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.NestedListAssignment.title"
msgstr "Nested List Assignment: Playing Moves on the Board"

msgid ""
"pages.NewlinesAndFormatBoard.steps.discovering_newline.special_messages.bad_string.text"
msgstr ""
"Ups, łańcuch `string` nie ma właściwej wartości. Uruchom ponownie program z "
"poprzedniego kroku."

msgid "pages.NewlinesAndFormatBoard.steps.discovering_newline.text"
msgstr ""
"Huraa! *Potrójny cytowany łańcuch* może się rozciągać przez wiele linii i one będą pokazane w wyjściu.\n"
"\n"
"Podobnie jak pojedyncze i podwójne cudzysłowy, potrójne cudzysłowy to po prostu inny rodzaj notacji, nie nowy rodzaj łańcucha.\n"
"`\"\"\"abc\"\"\"` to to samo co `\"abc\"`.\n"
"\n"
"Jednakże łańcuch `string` zawiera coś nowego. Uruchom `__program__` w konsoli, aby zobaczyć."

msgid "pages.NewlinesAndFormatBoard.steps.final_text.text"
msgstr ""
"Świetna robota! To było całkiem trudne.\n"
"\n"
"Teraz opanowałeś budowanie łańcucha znaków z wieloma liniami tekstu i rozwiązałeś problem wyświetlania planszy graczom.\n"
"\n"
"Następnie dowiesz się więcej o typach w Pythonie i jak je konwertować, oraz jak uzyskać dane wejściowe od graczy.\n"
"Jesteś już w połowie drogi do zakończenia projektu. Kontynuuj!"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.0.text"
msgstr ""
"Są dwa typy linii do wyświetlenia: jeden typ łączy elementy symbolem `|` "
"pomiędzy nimi, drugi typ łączy symbole `-` z `+` pomiędzy nimi."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.1.text"
msgstr "Oba te typy linii można zbudować używając odpowiednio `join`."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.10.text"
msgstr ""
"Następnie zastosuj `join` do tej listy, używając linii `+-` jako separatora."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.11.text"
msgstr ""
"Aby poprawnie dodać znaki nowej linii do linii `+-`, spojrzyj na przypadek "
"testowy, który dostarczyliśmy."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.2.text"
msgstr ""
"Na przykład, jak możesz przekształcić rząd `['X', 'O', 'X']` w `'X|O|X'` "
"używając `join`?"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.3.text"
msgstr ""
"Podobnie, jak możesz uzyskać `'-+-+-'` używając `join`? Do jakiej listy "
"powinieneś zastosować `join`?"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.4.text"
msgstr ""
"Gdy już zrozumiesz, jak zbudować oba typy linii, jak możesz je połączyć, aby"
" uzyskać ostateczny wynik?"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.5.text"
msgstr "Zauważ, że linie z `+-` zawsze są takie same."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.6.text"
msgstr ""
"I jest jedna linia z `+-` rozdzielająca każdą parę kolejnych linii z "
"elementami."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.7.text"
msgstr "Możesz użyć `join` na samych liniach!"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.8.text"
msgstr ""
"Linie z elementami można połączyć razem z linią `+-` pomiędzy nimi (dodając "
"nowe linie w odpowiednich miejscach)."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.9.text"
msgstr ""
"Żeby zrobić to, musisz najpierw przechowywać linie z elementami w liście "
"podczas ich budowania."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.text"
msgstr ""
"Świetnie! Typowe rozwiązanie wygląda tak:\n"
"\n"
"__code0__\n"
"\n"
"Jeśli wyszukałeś, jak działa `join` i użyłeś go w swoim rozwiązaniu, to świetnie!\n"
"Możesz to rozwiązać w sposób podobny do tego:\n"
"\n"
"__code1__\n"
"\n"
"Jeśli chcesz, możesz teraz przejść do [następnej strony](#Types). Albo możesz podjąć dodatkowe wyzwanie!\n"
"\n"
"Napisz ulepszoną wersję `format_board`, która pokaże separatory rzędów i kolumn. Na przykład, jeśli\n"
"\n"
"__code2__\n"
"\n"
"wtedy `print(format_board(board))` powinno wydrukować\n"
"\n"
"    X|O|X\n"
"    -+-+-\n"
"     |O|O\n"
"    -+-+-\n"
"     |X|\n"
"\n"
"Raz jeszcze powinno to działać dla kwadratowej `board` *dowolnego rozmiaru*.\n"
"\n"
"Zachęcamy do użycia `join` w tym ćwiczeniu. Podajemy jeden test jak poprzednio, możesz napisać dodatkowe testy:\n"
"\n"
"    __copyable__\n"
"__code3__"

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.0.text"
msgstr ""
"Dokładnie przyjrzyj się dostarczonemu przez nas przypadkowi testowemu. "
"Pokazuje on wszystko, co potrzebujesz!"

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.1.text"
msgstr ""
"Musisz zbudować łańcuch dla całej planszy. Zacznij od pustego łańcucha."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.2.text"
msgstr "Dla każdego rzędu dodaj znaki z tego rzędu do łańcucha."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.3.text"
msgstr "Będziesz potrzebował pętli zagnieżdżonej."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.4.text"
msgstr ""
"Gdy dotrzesz do końca rzędu, musisz dodać znak nowej linii przed następnym "
"rzędem."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.5.text"
msgstr ""
"`'\\n'` jest tak jak inne znaki! Możesz dodać go jak zwykle przy użyciu `+`."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.6.text"
msgstr "Zauważ, że koniec ostatniego rzędu jest inny niż pozostałych."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.7.text"
msgstr ""
"Zanim dodasz nową linię, będziesz musiał sprawdzić, czy to ostatni rząd, czy"
" nie."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.8.text"
msgstr "Twoja zewnętrzna pętla powinna przejść przez długość planszy."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.9.text"
msgstr "Następnie sprawdź, czy jesteś na ostatniej pozycji, czy nie."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.text"
msgstr ""
"Teraz użyj znaku nowej linii, aby napisać funkcję `format_board` (twoje rozwiązanie powinno działać dla kwadratowej `board` dowolnego rozmiaru):\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.NewlinesAndFormatBoard.steps.introducing_newline.text"
msgstr ""
"Oto sekret!\n"
"\n"
"`\\n` reprezentuje znak ***nowej linii***. To jest po prostu inny znak, tak jak litera czy spacja (`' '`).\n"
"To jest znak między dwoma oddzielnymi liniami, które wpisujesz naciskając Enter na klawiaturze.\n"
"\n"
"Znowu, `\\n` *reprezentuje* znak nowej linii wewnątrz literału łańcucha Pythona.\n"
"Łańcuch rzeczywiście nie zawiera `\\` i `n`, zawiera tylko jeden znak. Sprawdź to w konsoli:\n"
"\n"
"__code0__"

msgid "pages.NewlinesAndFormatBoard.steps.invalid_multi_line_string.program"
msgstr ""
"assert_equal(\n"
"    format_board([\n"
"        ['X', 'O', 'X'],\n"
"        [' ', 'O', 'O'],\n"
"        [' ', 'X', ' ']\n"
"    ]),\n"
"    \"XOX\n"
"      OO\n"
"      X \"\n"
")"

msgid "pages.NewlinesAndFormatBoard.steps.invalid_multi_line_string.text"
msgstr ""
"To dobry początek, ale idealnie chcielibyśmy funkcję, która *zwraca* łańcuch znaków zamiast go wyświetlać.\n"
"W ten sposób inny kod może w łatwy sposób wykorzystać ten łańcuch w różnych sposobach. Możemy chcieć manipulować łańcuchem\n"
"(np. rysować dookoła niego ramkę lub wyodrębnić tylko pierwsze kilka linii), możemy chcieć wysłać go gdzieś innego niż na ekran\n"
"(np. do pliku) i w tym konkretnym przypadku chcemy móc go przetestować przy użyciu `assert_equal`. To nie działa:\n"
"\n"
"__code0__\n"
"\n"
"ponieważ `print_board` nie używa `return`, więc domyślnie zwraca `None`.\n"
"Zamiast tego chcemy kodu w stylu:\n"
"\n"
"__code1__\n"
"\n"
"Wtedy `print(format_board(board))` powinno wydrukować coś podobnego do tego, co widzieliśmy na początku.\n"
"Ale jak zwracamy łańcuch ze znakami nowych linii? I jak go przetestować? Chcielibyśmy zrobić coś takiego:\n"
"\n"
"    __copyable__\n"
"__code2__\n"
"\n"
"Zobacz sam, jak to nie działa."

msgid ""
"pages.NewlinesAndFormatBoard.steps.multi_line_strings_triple_quotes.program"
msgstr ""
"string = \"\"\"First line\n"
"Second line\"\"\"\n"
"print(string)"

msgid ""
"pages.NewlinesAndFormatBoard.steps.multi_line_strings_triple_quotes.text"
msgstr ""
"Zazwyczaj literał łańcucha musi być w jednej linii, więc to jest nieprawidłowe:\n"
"\n"
"    string = \"First line\n"
"    Second line\"\n"
"    print(string)\n"
"\n"
"Ale Python dostarcza rozwiązania! Rozwiązaniem jest użycie *potrójnych cudzysłowów*, czyli trzech znaków cudzysłowia z rzędu\n"
"(albo `'''` albo `\"\"\"`) do otoczenia zawartości łańcucha. Uruchom następujący program:\n"
"\n"
"__program_indented__"

msgid "pages.NewlinesAndFormatBoard.steps.one_way_to_print_board.text"
msgstr ""
"Następnie chcemy rozwiązać problem wyświetlania planszy do gry w kółko i krzyżyk. Oto jeden ze sposobów na to:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"(Co to jest `\"\".join`? Wyszukaj w Google!)"

msgid "pages.NewlinesAndFormatBoard.title"
msgstr "Znak nowej linii, `format_board`"

msgid "pages.OtherComparisonOperators.steps.brokn_kyboard.text"
msgstr ""
"Oto uroczy mały programik używający `!=`:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.0.text"
msgstr ""
"To prawie dokładnie to samo co w poprzednim kroku, tyle że użyj ciągów "
"znaków zamiast liczb."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.1.text"
msgstr "Musisz tylko uruchomić jedną bardzo małą, prostą linię w shellu."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.2.text"
msgstr ""
"Możesz to również zrobić poprzez uruchomienie wielu linii w shellu, "
"najpierw definiując zmienne a następnie porównując je, ale nie musisz tego "
"robić, możesz to zrobić bez zmiennych."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.3.text"
msgstr "Pamiętasz dodawanie dwóch ciągów znaków w shellu na początku kursu?"

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.4.text"
msgstr "Na przykład robiliśmy `'hello' + 'world'`"

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.5.text"
msgstr ""
"Do tego zadania musisz zrobić właściwie to samo, ale zamiast dodawać, "
"porównuj je."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.requirements"
msgstr ""
"Uruchom dowolny kod w shellu używający albo `<` albo `>` na dwóch ciągach "
"znaków."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.text"
msgstr ""
"Można także używać tych operatorów do porównywania ciągów znaków. Jeśli "
"ustawisz dwa ciągi znaków w kolejności alfabetycznej, pierwszy jest "
"'mniejszy niż' drugi. Sprawdź to sam."

msgid "pages.OtherComparisonOperators.steps.final_text.text"
msgstr ""
"Wspaniale!\n"
"\n"
"Istnieje wiele sposobów rozwiązania tego problemu. Oto jedno z rozwiązań:\n"
"\n"
"__code0__\n"
"\n"
"Oto inne:\n"
"\n"
"__code1__\n"
"\n"
"Te programy (i twój również) działają równie dobrze zarówno z liczbami, jak i ciągami znaków. Więc dla:\n"
"\n"
"__code2__\n"
"\n"
"wypiszą `Alice`, ponieważ to jest pierwszy ciąg znaków w kolejności alfabetycznej.\n"
"\n"
"`<` oraz `>` dają wynik False, gdy porównywane wartości są równe. Na przykład, 3 nie jest mniejsze od 3, więc `3 < 3` oraz `3 > 3` są oba False.\n"
"Aby uwzględnić równe wartości, użyj `<=` oraz `>=`.\n"
"Jeśli się przyjrzeć, przypominają one trochę ≤ oraz ≥.\n"
"Zauważ, że `=` znajduje się na końcu - nie istnieją takie operatory jak `=<` czy `=>`.\n"
"Aby to zapamiętać, przeczytaj je na głos jako \"mniejsze równe\"\n"
"i \"większe równe\".\n"
"\n"
"Podsumowując, główne operatory porównania to `==`, `!=`, `<`, `>`, `<=` oraz `>=`.\n"
"Jeśli masz kiedykolwiek wątpliwości co do tego, co one robią, pobaw się nimi w shellu!"

msgid "pages.OtherComparisonOperators.steps.grades_example.text"
msgstr ""
"Oto praktyczny przykład użycia `<`:\n"
"\n"
"__program_indented__\n"
"\n"
"Pamiętaj, że `elif percentage < 60` po `if percentage < 40` oznacza \"jeśli procent nie był mniejszy niż 40 oraz równocześnie jest mniejszy niż 60\", więc zostanie spełnione dla wszystkich liczb od 40 do 59 włącznie. Podobnie ocena 'B' jest dla procentów od 60 do 79, a ocena 'A' jest dla każdej liczby 80 i więcej."

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.hints.0.text"
msgstr "Musisz tylko uruchomić jedną bardzo małą, prostą linię w shellu."

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.hints.1.text"
msgstr "Jak byś dodał dwie liczby w shellu?"

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.hints.2.text"
msgstr "Na przykład spróbuj `123 + 456`"

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.hints.3.text"
msgstr ""
"Do tego zadania musisz zrobić właściwie to samo, ale zamiast dodawać, "
"porównuj je."

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.requirements"
msgstr ""
"Uruchom dowolny kod w shellu używający albo `<` albo `>` na dwóch liczbach."

msgid "pages.OtherComparisonOperators.steps.introducing_less_than.text"
msgstr ""
"Innymi przydatnymi operatorami są `<` (mniejsze niż) oraz `>` (większe niż)."
" Na przykład `a < b` oznacza \"`a` jest mniejsze od `b`\". Wypróbuj użycie "
"jednego z nich w shellu, aby porównać dwie liczby."

msgid "pages.OtherComparisonOperators.steps.min_three_exercise.hints.0.text"
msgstr ""
"Spróbuj napisać program, który wypisze najmniejszą z wartości `x1` i `x2`."

msgid "pages.OtherComparisonOperators.steps.min_three_exercise.hints.1.text"
msgstr "wszystko czego potrzebujesz to użyć kilka razy `<`, `if`, a może `else`."

msgid "pages.OtherComparisonOperators.steps.min_three_exercise.text"
msgstr ""
"Teraz zadanie: napisz program, który bierze trzy zmienne `x1`, `x2` i `x3`, oraz drukuje wartość najmniejszej z nich. Więc dla:\n"
"\n"
"__code0__\n"
"\n"
"powinien wypisać `10`."

msgid "pages.OtherComparisonOperators.steps.try_not_equals.text"
msgstr ""
"Przeciwieństwem operatora równości `==` jest operator *nierówności* `!=`. "
"Jeśli się przyjrzeć, to trochę przypomina ≠. Zwraca `True`, kiedy dwie "
"wartości są... nie równe. Wypróbuj `__program__` samodzielnie w shellu "

msgid "pages.OtherComparisonOperators.title"
msgstr "Inne operatory porównania"

msgid "pages.ReturningValuesFromFunctions.steps.final_text.text"
msgstr ""
"Brawo! Oto dwie możliwe rozwiązania:\n"
"\n"
"__code0__"

msgid "pages.ReturningValuesFromFunctions.steps.first_return.text"
msgstr ""
"Funkcje mogą być szczególnie użyteczne, kiedy *zwracają* wartości, zamiast je tylko wyświetlać. Wypróbuj ten przykład:\n"
"\n"
"__program_indented__"

msgid "pages.ReturningValuesFromFunctions.steps.losing_return_value.text"
msgstr ""
"Tu przekazaliśmy `number` (które ma wartość `5`) jako argument `x` do funkcji `double`, a funkcja `double` *zwróciła*\n"
"`x * 2`, to jest `5 * 2`, to jest `10`, co stało się wartością zmiennej `twice`. Specjalne słowo kluczowe `return` wewnątrz\n"
"`double` sprawia, że `double(number)` jest wyrażeniem o wartości - konkretnie wartości, która została zwrócona.\n"
"To trochę tak, jakby `twice = double(number)` było równoważne `twice = number * 2`, chociaż to nie jest\n"
"dokładnie to, co się dzieje.\n"
"\n"
"Zauważ, że `double(number)` *nie zmieniło `number`*. Na końcu `number` wciąż jest `5`. Raczej, `double(number)`\n"
"zwróciło nową wartość. Istotne jest, aby program wykorzystał tę zwróconą wartość, w tym przypadku przechowując ją\n"
"w zmiennej. Natychmiastowe wydrukowanie jej z `print(double(number))` również działa. Z drugiej strony, \n"
"spróbuj to:\n"
"\n"
"__program_indented__"

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.0.text"
msgstr "Aby pomnożyć przez 4, pomnóż przez 2 dwa razy."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.1.text"
msgstr "To oznacza, że musisz wywołać `double` dwa razy."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.10.text"
msgstr "Spojrzyj na definicję funkcji `double` jako przykład."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.11.text"
msgstr ""
"Upewnij się, że nie wywołujesz funkcji `quadruple` w ciele funkcji "
"`quadruple`. Sprawdź swoje wcięcia."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.2.text"
msgstr ""
"Upewnij się, że używasz wartości zwracanej przez `double` za każdym razem."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.3.text"
msgstr "Upewnij się, że posiadasz wszystkie elementy definicji funkcji."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.4.text"
msgstr "To obejmuje `def`, `()`, oraz `:`."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.5.text"
msgstr "Upewnij się, że twoja funkcja jest nazwana `quadruple`."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.6.text"
msgstr ""
"Upewnij się, że przyjmuje jeden parametr o nazwie `x` pomiędzy nawiasami "
"`()`."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.7.text"
msgstr "Użyj parametru w ciele funkcji."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.8.text"
msgstr "Upewnij się, że ciało jest wcięte."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.9.text"
msgstr "Upewnij się, że coś zwracasz na końcu."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.messages.used_multiply.text"
msgstr ""
"Nie możesz używać `*`, `+`, ani nawet żadnych liczb wewnątrz `quadruple`.\n"
"Musisz rozwiązać problem wywołując funkcję `double`."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.requirements"
msgstr ""
"Napisz program, który definiuje funkcję o nazwie `quadruple` zgodnie z "
"powyższym opisem."

msgid "pages.ReturningValuesFromFunctions.steps.quadruple_exercise.text"
msgstr ""
"Tu `double(number)` nadal zwróciło `10`, ale nie wykorzystaliśmy tego, więc zostało to utracone. `number` jest nadal `5`.\n"
"\n"
"Napisz funkcję `quadruple`, która bierze jeden argument `x` i zwraca ten argument pomnożony przez 4.\n"
"Możesz użyć wyłącznie funkcji `double` - bezpośrednio w ciele funkcji `quadruple` zakazane są liczby lub mnożenie."

msgid "pages.ReturningValuesFromFunctions.title"
msgstr "Zwracanie Wartości z Funkcji"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.hints.0.text"
msgstr "Jak powinieneś zdefiniować ciąg znaków?"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.hints.1.text"
msgstr "Z pojedynczymi cudzysłowami, czy z podwójnymi?"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.hints.2.text"
msgstr "Potrzebujesz tylko jednego ciągu znaków."

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.hints.3.text"
msgstr "Nie ma potrzeby dodawać ciągów znaków do siebie."

msgid "pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.text"
msgstr ""
"Jak widzisz, Python traktuje ten sam ciąg znaków zdefiniowany pojedynczymi lub podwójnymi cudzysłowami jako ten sam.\n"
"\n"
"Teraz napisz program, który wydrukuje następujący tekst z Zen of Python:\n"
"\n"
"    __copyable__\n"
"    Special cases aren't special enough to break the rules.\n"
"\n"
"Program powinien być jednolinijkowy używając `print()`, bez zmiennych."

msgid "pages.SingleAndDoubleQuotesInStrings.steps.double_quotes.text"
msgstr ""
"Więc nie możemy użyć apostrofu tak jak nam się podoba w ciągu znaków z pojedynczymi cudzysłowami.\n"
"Apostrof jest traktowany jak pojedynczy cudzysłów i dlatego działa jako *zamykający cudzysłów* definicji ciągu znaków `'Alice'`.\n"
"Potem pozostała część tekstu `s Diner'` jest niepoprawną składnią i Python tego nie rozumie.\n"
"\n"
"Na szczęście Python pozwala nam definiować ciągi znaków inaczej, używając podwójnych cudzysłowów `\"` zamiast tego:\n"
"\n"
"__program_indented__"

msgid "pages.SingleAndDoubleQuotesInStrings.steps.final_text.text"
msgstr ""
"Dobra robota!\n"
"\n"
"W większości przypadków możesz użyć pojedynczych lub podwójnych cudzysłowów do definiowania swoich ciągów znaków, tak jak ci się podoba.\n"
"Ale jeśli ciąg zawiera `'`, to użyj `\"` do jego zdefiniowania i odwrotnie."

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_double_quotes_equal.text"
msgstr ""
"Pamiętaj, że cudzysłowy to tylko część ludzkiej notacji ciągów znaków.\n"
"Nie są przechowywane jako rzeczywista część ciągu znaków.\n"
"Spróbuj tego w powłoce:\n"
"\n"
"__program_indented__"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quote_exercise.hints.0.text"
msgstr "Pomyśl prostym sposobem! Jak zwykle to robisz?"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quote_exercise.hints.1.text"
msgstr ""
"Jeśli ciąg znaków zawiera pojedynczy cudzysłów, musimy użyć podwójnych "
"cudzysłowów do jego zdefiniowania."

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quote_exercise.hints.2.text"
msgstr "Co jeśli ciąg zawiera podwójne cudzysłowy?"

msgid "pages.SingleAndDoubleQuotesInStrings.steps.single_quote_exercise.text"
msgstr ""
"Doskonale!\n"
"\n"
"Teraz wydrukuj następujący cytat dosłownie (łącznie z podwójnymi cudzysłowami):\n"
"\n"
"    __copyable__\n"
"    \"Talk is cheap. Show me the code.\" - Linus Torvalds\n"
"\n"
"Program powinien być jednolinijkowy używając `print()`, bez zmiennych."

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quotes_apostrophe.program"
msgstr "print('Alice's Diner')"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quotes_apostrophe.text"
msgstr ""
"Do tej pory definiowaliśmy ciągi znaków używając pojedynczych cudzysłowów, takich jak:\n"
"\n"
"__code0__\n"
"\n"
"Co jeśli chcemy zdefiniować ciąg znaków zawierający apostrof? Spróbuj tego:\n"
"\n"
"__program_indented__"

msgid "pages.SingleAndDoubleQuotesInStrings.title"
msgstr "Pojedyncze i podwójne cudzysłowy w ciągach znaków"

msgid "pages.StoringCalculationsInVariables.steps.final_text.text"
msgstr ""
"W przeciwieństwie do arkusza kalkulacyjnego, gdzie formuły aktualizują się "
"automatycznie, zmienna taka jak `sentence` nie pamięta, jak została "
"obliczona i nie zmieni się, jeśli zmienione zostaną wartości leżące u "
"podstawy `word` lub `name`."

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.output_prediction_choices.0"
msgstr ""
"Hello World\n"
"Hello World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.output_prediction_choices.1"
msgstr ""
"Hello World\n"
"Goodbye World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.output_prediction_choices.2"
msgstr ""
"Goodbye World\n"
"Goodbye World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.requirements"
msgstr ""
"Uruchom program składający się z czterech linii z poprzedniego kroku, a "
"następnie z dwóch linii tutaj."

msgid "pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.text"
msgstr ""
"Teraz `sentence` ma wartość `'Hello World'`, której można używać wielokrotnie. Zauważ, że będzie ona kontynuowała posiadanie tej wartości aż do jej bezpośredniego przypisania, np. za pomocą innego polecenia takiego jak `sentence = <coś>`. Na przykład, dodaj te dwie linie na końcu programu:\n"
"\n"
"__code0__"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.0"
msgstr "sentence"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.1"
msgstr "word + ' ' + name"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.2"
msgstr "Hello + ' ' + World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.3"
msgstr "'Hello' + ' ' + 'World'"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.4"
msgstr "Hello World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.5"
msgstr "'Hello World'"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.text"
msgstr ""
"Często będziesz używać zmiennych, aby przechowywać wyniki obliczeń. Pomoże to budować bardziej złożone programy. Na przykład, wypróbuj ten program:\n"
"\n"
"__code0__"

msgid "pages.StoringCalculationsInVariables.title"
msgstr "Przechowywanie obliczeń w zmiennych"

msgid "pages.StringMethodsUnderstandingMutation.steps.final_text.text"
msgstr ""
"Zauważ, że `sentence.upper()` nie zmienia oryginalnego `sentence`.\n"
"\n"
"Możesz również użyć `word.lower()` bezpośrednio w większym wyrażeniu, np.\n"
"\n"
"__code0__"

msgid ""
"pages.StringMethodsUnderstandingMutation.steps.mutation_string_append.text"
msgstr ""
"Te dwie metody także działają na łańcuchach znaków podobnie do list.\n"
"`index` zwraca *indeks początkowy* wyszukiwanego słowa `'the'` w dłuższym łańcuchu\n"
"`'feed the dog and the cat'`, który wynosi `5`.\n"
"\n"
"|  0   |  1   |  2   |  3   |  4   | **5** |  6   |  7   |  8   | ...  |\n"
"| :--: | :--: | :--: | :--: | :--: | :---: | :--: | :--: | :--: | :--: |\n"
"|  f   |  e   |  e   |  d   |      | **t** |  h   |  e   |      | ...  |\n"
"\n"
"Zauważ, że w większości przypadków metody, które *modyfikują listę in situ* (`append`, `insert`, `remove`) po prostu zwracają `None`,\n"
"podczas gdy pozostałe funkcje/metody zwracają nową użyteczną wartość bez zmiany oryginalnego argumentu.\n"
"Jedynym wyjątkiem jest metoda `pop`.\n"
"\n"
"Modyfikowanie wartości bezpośrednio nazywa się *mutacją* - typy wartości które mogą być mutowane są *mutowalne* (ang. mutable),\n"
"a te które nie mogą są *niemutowalne* (ang. immutable). Listy są mutowalne.\n"
"Łańcuchy znaków są niemutowalne - nie mają żadnych metod takich jak `append` czy nawet przypisanie do indeksu.\n"
"Zobacz sam:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.StringMethodsUnderstandingMutation.steps.string_count_index.program"
msgstr ""
"string = 'feed the dog and the cat'\n"
"print(string.count('the'))\n"
"print(string.index('the'))"

msgid "pages.StringMethodsUnderstandingMutation.steps.string_count_index.text"
msgstr ""
"`in` działa na łańcuchach znaków tak, jak na listach! Komenda zwróciła `True`, ponieważ `the` występuje w `feed the dog and the cat` jako *podłańcuch*.\n"
"Co z `count` i `index`?\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.StringMethodsUnderstandingMutation.steps.string_in_step.program"
msgstr "print('the' in 'feed the dog and the cat')"

msgid "pages.StringMethodsUnderstandingMutation.steps.string_in_step.text"
msgstr ""
"Widziałeś już, że `len` oraz indeksowanie działają na łańcuchach znaków trochę tak, jakby były one listami znaków.\n"
"Łańcuchy znaków wspierają również niektóre z nowych metod, które poznaliśmy, nie tylko dla pojedynczych znaków, ale również dla dowolnych podłańcuchów.\n"
"Na przykład, wypróbuj poniższe:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.StringMethodsUnderstandingMutation.steps.string_lower_upper.text"
msgstr ""
"Nie można po prostu zmienić łańcucha znaków - możesz jedynie tworzyć nowe łańcuchy i używać ich zamiast starych.\n"
"To oznacza, że to jest bezużyteczne stwierdzenie samo w sobie:\n"
"\n"
"__code0__\n"
"\n"
"Łańcuch pod zmienną `word` nie jest modyfikowany, zamiast tego `word.lower()` zwraca nowy łańcuch, który w tym przypadku przepada.\n"
"Jeśli chcesz zmienić wartość, do której odnosi się `word`, musisz przypisać do zmiennej nową wartość:\n"
"\n"
"    __copyable__\n"
"__code1__"

msgid "pages.StringMethodsUnderstandingMutation.title"
msgstr "Metody łańcuchów znaków i niemutowalność"

msgid "pages.TestingFunctions.steps.alert_exercise.hints.0.text"
msgstr ""
"`string` powinien być otoczony jedną spacją i `level` wykrzyknikami (`!`) z "
"obu stron."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.1.text"
msgstr ""
"Dołącz definicję `surround` z poprzedniej części do swojego programu i "
"wywołaj ją w `alert`."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.10.text"
msgstr ""
"Pomyśl, jak budujesz łańcuchy znaków z `+=`. Kolejno aktualizuj tę samą "
"zmienną, budując swój wynik."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.11.text"
msgstr "Czyli napisz `something = surround(something, '!')` w swojej pętli."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.12.text"
msgstr "Upewnij się, że zwracasz coś na końcu `alert`."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.13.text"
msgstr ""
"Upewnij się, że nie `zwracasz` wewnątrz pętli, ale po niej. Sprawdź swoje "
"wcięcia."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.14.text"
msgstr ""
"Upewnij się, że nie wywołujesz `alert` w ciele funkcji `alert`. Sprawdź "
"swoje wcięcia."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.2.text"
msgstr "Użyj `surround` dla spacji."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.3.text"
msgstr "Użyj `surround` dla wykrzykników."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.4.text"
msgstr ""
"Nie wolno łączyć kilku wykrzykników w jeden ciąg znaków, więc wywołaj "
"`surround` kilka razy."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.5.text"
msgstr "Czyli wywołaj `surround` raz dla każdej pary wykrzykników."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.6.text"
msgstr "Więc wywołaj `surround(..., '!')` kilka razy."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.7.text"
msgstr "Użyj pętli, aby wywołać to kilka razy."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.8.text"
msgstr "Użyj `range(n)`, aby twoja pętla miała `n` iteracji."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.9.text"
msgstr "Upewnij się, że używasz wartości zwracanej przez `surround`."

msgid ""
"pages.TestingFunctions.steps.alert_exercise.messages.catch_return_inside_loop.text"
msgstr ""
"W funkcji `alert` umieściłeś swoją instrukcję `return` w złym miejscu!\n"
"Zwróć uwagę na swoje wcięcia w `alert`. Możesz kończyć pętlę za wcześnie za pomocą `return`."

msgid "pages.TestingFunctions.steps.alert_exercise.messages.used_format.text"
msgstr ""
"Nie możesz używać konkatenacji, formatowania, interpolacji ani mnożenia łańcuchów znakowych ani f-stringów w `alert`.\n"
"Musisz rozwiązać problem, wywołując `surround`."

msgid "pages.TestingFunctions.steps.alert_exercise.text"
msgstr ""
"Doskonale! Teraz napisz funkcję `alert`, która przejdzie te testy:\n"
"\n"
"__code0__\n"
"\n"
"Ciało funkcji `alert` nie może zawierać `+`. Użyj zamiast tego `surround`. Twoja funkcja powinna zaczynać się tak:\n"
"\n"
"__code1__"

msgid "pages.TestingFunctions.steps.complete_quadruple_tests.requirements"
msgstr ""
"Wpisz program powyżej.\n"
"Następnie zmień ostatnie dwie linie, dodając po jednym argumencie do każdego wywołania `assert_equal`, aby testy przeszły.\n"
"Nie dotykaj definicji funkcji."

msgid "pages.TestingFunctions.steps.complete_quadruple_tests.text"
msgstr ""
"Świetnie! Nasze testy nie przeszły! Oczywiście to zazwyczaj nie jest dobra rzecz, ale mówi nam, że testy\n"
"sprawdzają swoje zadanie. Upewnią się, że nasza implementacja `double` jest poprawna.\n"
"\n"
"Praktykujmy ten nowy koncept. Poniżej znajduje się funkcja `quadruple` z wcześniej z niektórymi niekompletnymi testami.\n"
"Napraw program, dodając brakujące argumenty do wywołania `assert_equal`.\n"
"\n"
"__code0__"

msgid "pages.TestingFunctions.steps.final_text.text"
msgstr ""
"Świetna robota! Te narzędzia będą bardzo przydatne w kolejnych rozdziałach."

msgid "pages.TestingFunctions.steps.introducing_assert_equal.text"
msgstr ""
"Ważnym elementem pisania programów jest sprawdzanie, czy działają poprawnie. Możesz to zrobić ręcznie, np. sprawdzając, czy\n"
"`print(double(5))` wypisuje `10`, ale tego typu czynności mogą szybko stać się męczące.\n"
"Przydatne jest pisanie programów, które testują twoje programy. To nazywa się *automatycznym testowaniem*,\n"
"a programy to *testy*.\n"
"\n"
"Oto prosta funkcja `assert_equal` (ang. _zapewnij o równości_), która pomoże nam pisać testy:\n"
"\n"
"__code0__\n"
"\n"
"\n"
"(Co to za funkcja `repr`? Spróbuj `print(f\"{'abc'} {repr('abc')}\")`, żeby zobaczyć jedną różnicę, ale nie martw się tym zbytnio.)\n"
"\n"
"To nie jest standardowa część Pythona (choć podobne funkcje istnieją), ale dodaliśmy ją do twojego środowiska programistycznego\n"
"żebyś zawsze mógł z niej korzystać. Oto przykład użycia, który możesz wypróbować:\n"
"\n"
"__program_indented__"

msgid "pages.TestingFunctions.steps.make_tests_fail.requirements"
msgstr ""
"Uruchom program z poprzedniego kroku, zamieniając `x * 2` na `x * 3`. Resztę"
" zostaw bez zmian."

msgid "pages.TestingFunctions.steps.make_tests_fail.text"
msgstr ""
"Komunikaty OK mówią nam, że testy przeszły. Nasza funkcja `double` wydaje się działać poprawnie. Zmień ją tak, żeby zwracała\n"
"`x * 3` i zobacz co się stanie."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.0.text"
msgstr "Argument `sides` powinien być dodany przed i po `string`."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.1.text"
msgstr "Użyj konkatenacji łańcuchów znaków, aby to osiągnąć."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.2.text"
msgstr "Upewnij się, że treść jest z wcięciem."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.3.text"
msgstr "Spraw, aby na końcu zwracać coś za pomocą `return`."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.4.text"
msgstr ""
"Upewnij się, że nie wywołujesz `surround` wewnątrz ciała funkcji `surround`."
" Sprawdź swoje wcięcia."

msgid "pages.TestingFunctions.steps.surround_exercise.text"
msgstr ""
"Kolejną przydatną rzeczą dotyczącą testów jest to, że każdy może je przeczytać i zobaczyć jasne, jednoznaczne przykłady\n"
"tego, co funkcja robi. Jest to pomocne, gdy funkcja jest skomplikowana i trudna do opisania po angielsku.\n"
"\n"
"Na przykład, oto kilka testów:\n"
"\n"
"__code0__\n"
"\n"
"Nie muszę wyjaśniać, co robi `surround`, możesz zobaczyć sam.\n"
"\n"
"Napisz funkcję `surround`, która przejdzie te testy i zaczyna się tak:\n"
"\n"
"__code1__"

msgid "pages.TestingFunctions.title"
msgstr "Testowanie Funkcji"

msgid "pages.TheEqualityOperator.steps.equality_vs_assignment.program"
msgstr "print(1 + 2 = 3)"

msgid "pages.TheEqualityOperator.steps.equality_vs_assignment.requirements"
msgstr ""
"Uruchom program z poprzedniego kroku, ale zamień którykolwiek z `==` na po "
"prostu `=`."


msgid "pages.TheEqualityOperator.steps.equality_vs_assignment.text"
msgstr ""
"Jak widzisz, jeśli wartości są równe, wyrażenie równości daje wynik `True`,\n"
"w przeciwnym razie jest to `False`.\n"
"\n"
"Zwróć uwagę na różnicę między operatorem równości `==` a pojedynczym `=`, które mają różne znaczenia,\n"
"szczególnie w instrukcjach przypisania, jakie do tej pory widzieliśmy. Co się stanie, jeśli spróbujesz\n"
"usunąć pojedynczy `=` z poprzedniego programu?"

msgid "pages.TheEqualityOperator.steps.final_text.text"
msgstr "Dobra robota!"

msgid "pages.TheEqualityOperator.steps.if_equals_replacing_characters.text"
msgstr ""
"Użyjmy `==` w instrukcji `if`. W tym programie ciało `if` uruchamia się tylko wtedy, gdy `c` to znak `'s'`. Przekonaj się sam.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.TheEqualityOperator.steps.if_equals_replacing_characters_exercise.hints.0.text"
msgstr ""
"Musisz tylko dodać kilka linii kodu, które są bardzo podobne do "
"istniejących."

msgid ""
"pages.TheEqualityOperator.steps.if_equals_replacing_characters_exercise.text"
msgstr ""
"Rozszerz teraz program, aby również zamieniał `e` na `3` i `a` na `@`."

msgid "pages.TheEqualityOperator.steps.introducing_equality.text"
msgstr ""
"Istnieje kilka sposobów uzyskania wartości boolowskich bez ich bezpośredniego przypisywania,\n"
"co pozwala konstruować bardzo przydatne instrukcje `if`. W szczególności istnieje wiele\n"
"*operatorów porównania*, które porównują wartości dwóch wyrażeń.\n"
"Najczęściej stosowany jest operator równości, który sprawdza, czy dwie wartości są równe.\n"
"Jest on oznaczony dwoma znakami równości: `==`. Spróbuj uruchomić to:\n"
"\n"
"__program_indented__"

msgid "pages.TheEqualityOperator.title"
msgstr "Operator równości"

msgid "pages.TheFullTicTacToeGame.steps.final_text.text"
msgstr ""
"### ***CONGRATULATIONS!!!***\n"
"\n"
"You did it!"

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.0.text"
msgstr ""
"You should use all of the functions `winner`, `format_board` (not counting "
"its use in `play_move`), `play_move`, `make_board`, `print_winner`, and "
"`print_draw` somewhere."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.1.text"
msgstr ""
"You only need to mention each of those functions once in your code, although"
" some of them will be called several times as the program runs."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.10.text"
msgstr "Whichever function is called, it must be called exactly once."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.11.text"
msgstr ""
"One easy way to make sure you don't call a function multiple times is to "
"call it outside of any loop."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.12.text"
msgstr "We've learned about two ways to make a loop stop."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.13.text"
msgstr "One way is `break`, which specifically ends one loop and no more."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.14.text"
msgstr "The second way ends not just the loop but the whole function call."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.15.text"
msgstr "The second way is `return`."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.16.text"
msgstr ""
"Don't play moves in pairs like `play_move(board, player1)` and "
"`play_move(board, player2)` in the sample code."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.17.text"
msgstr "Instead, each loop iteration should play one move."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.18.text"
msgstr "You need a variable to keep track of which player's turn it is."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.19.text"
msgstr "The player should be switched in each loop iteration."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.2.text"
msgstr "You will need a for loop to repeatedly play moves."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.20.text"
msgstr "An `if` statement is a good way to do this."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.21.text"
msgstr "Especially combined with an `else`."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.22.text"
msgstr "Make sure `player1` plays the first move."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.23.text"
msgstr ""
"Only call `print_winner` after checking `winner` with an `if` statement."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.24.text"
msgstr ""
"You need to check for the winner inside the loop since you don't know when a"
" player might win."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.25.text"
msgstr ""
"Once you call `print_winner`, you can use `return` to end the function."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.26.text"
msgstr ""
"Just `return` by itself is fine, `play_game` isn't meant to return a value."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.27.text"
msgstr ""
"Don't use `else` after checking for a winner to call `print_draw` if there "
"isn't a winner. Just because no one has won yet doesn't mean it's a draw "
"already."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.28.text"
msgstr ""
"`print_draw` should only be called after all moves have been played and "
"there's still no winner."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.29.text"
msgstr "So it should be called after the loop, outside of it."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.3.text"
msgstr ""
"You don't need to check if the board has been filled up, because you can "
"always calculate how many moves it takes to fill up the board."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.30.text"
msgstr ""
"Check the indentation to make sure `print_draw` isn't in the body of the for"
" loop."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.4.text"
msgstr ""
"So you can just use a loop that will run a fixed number of iterations, and "
"inside the loop check if the loop needs to be ended early."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.5.text"
msgstr ""
"What's the maximum number of moves that can be played in a 3x3 board? 4x4?"

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.6.text"
msgstr ""
"A loop over a `range` is an easy way to iterate a fixed number of times."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.7.text"
msgstr "So you can use `for _ in range(N):` to play at most `N` moves."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.8.text"
msgstr "Once there's a winner, you need to end the loop and the game."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.9.text"
msgstr "Either `print_winner` or `print_draw` should be called, not both."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.text"
msgstr ""
"It's time to put it all together! Below is some code to get started.\n"
"\n"
"It includes implementations of the various functions we defined in previous pages for solving parts\n"
"of the problem, using some tricks you haven't learned yet to make them shorter. Don't change them.\n"
"\n"
"Your task is to implement `play_game` correctly. The current implementation shows what\n"
"should happen at the start of the game, but it's obviously incomplete.\n"
"The solution should work for any board size and continue the game until it's finished.\n"
"The last thing that `play_game` should do is either call `print_winner(player)`\n"
"if `winner(board)` is true, or call `print_draw()` if the board is filled up with no winner.\n"
"\n"
"You can assume that the user will only enter valid inputs,\n"
"i.e. numbers from 1 to `board_size` to choose a cell on the board that isn't already taken.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.TheFullTicTacToeGame.title"
msgstr "The Full Tic-Tac-Toe Game"

msgid "pages.Types.steps.check_type_manually.text"
msgstr ""
"Python informuje najpierw, że `type('Hello World')` to `<class 'str'>`. Nie martw się teraz o `class`.\n"
"`str` to skrót od *string* (ciąg znaków).\n"
"\n"
"Następnie `True` to `bool` (skrót od *boolean* - wartość logiczna) i `[1, 2, 3]` ma typ `list` (lista).\n"
"\n"
"Zauważ, że są dwa typy numerów:\n"
"\n"
"- `int`, skrót od 'integer', jest dla liczb całkowitych, to znaczy bez ułamków czy punktów dziesiętnych.\n"
"- `float`, skrót od 'floating point number', jest dla liczb z punktem dziesiętnym i ewentualnie częścią ułamkową\n"
"\n"
"W większości przypadków nie musisz martwić się o różne typy liczbowe, ponieważ można mieszać oba przy wykonywaniu obliczeń matematycznych.\n"
"\n"
"Typy są wartościami, które mogą być wykorzystane na różne sposoby, podobnie jak inne wartości.\n"
"Na przykład, spróbuj tego w powłoce (shell):\n"
"\n"
"__program_indented__"

msgid "pages.Types.steps.common_type_errors.text"
msgstr ""
"Co się stanie, jeśli użyjesz operatora między `str` a `int`? Wypróbuj w powłoce:\n"
"\n"
"__program_indented__"

msgid "pages.Types.steps.different_types_look_same.text"
msgstr ""
"Wartości o różnych typach są zazwyczaj dość różne od siebie, ale mogą wyglądać tak samo, gdy są wydrukowane,\n"
"co może być mylące. Spróbuj tego:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"(Możesz użyć `print(repr(123))` i `print(repr('123'))`, aby zauważyć różnicę. Co to jest `repr`? Wygoogluj to!)"

msgid "pages.Types.steps.final_text.text"
msgstr ""
"Wspaniale!\n"
"\n"
"Przy okazji, kiedy musisz skonkatenować ciągi znaków i liczby, pamiętaj, że możesz także\n"
"użyć f-stringów. Często wyglądają ładniej.\n"
"\n"
"Nauczyłeś się o typach w Pythonie oraz jak unikać powszechnych błędów poprzez konwersję typów.\n"
"Kontynuuj prace nad resztą projektu!"

msgid "pages.Types.steps.five_different_types.text"
msgstr ""
"Jak dotąd zobaczyliśmy różne rodzaje danych: ciągi znaków (strings), listy, liczby i wartości logiczne (booleans).\n"
"Nazywa się je *typami*. Każda wartość ma określony typ, który wpływa na jej zachowanie\n"
"i może być ujawniony za pomocą funkcji `type`:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.Types.steps.fixing_type_errors_with_conversion.disallowed.0.label"
msgstr "f-stringi"

msgid "pages.Types.steps.fixing_type_errors_with_conversion.hints.0.text"
msgstr "W których miejscach ten kod jest uszkodzony?"

msgid "pages.Types.steps.fixing_type_errors_with_conversion.hints.1.text"
msgstr "Są wartości, które muszą być przekonwertowane na inny typ."

msgid "pages.Types.steps.fixing_type_errors_with_conversion.hints.2.text"
msgstr "Konkretnie jest `str`, które musi być przekonwertowane na `int`."

msgid "pages.Types.steps.fixing_type_errors_with_conversion.hints.3.text"
msgstr "I jest `int`, które musi być przekonwertowane na `str`."

msgid "pages.Types.steps.fixing_type_errors_with_conversion.text"
msgstr ""
"Użycie ciągu znaków zamiast liczby całkowitej w `range` jak `range('5')`,\n"
"lub przy indeksowaniu listy jak `list['3']` także spowoduje błąd.\n"
"\n"
"Większość z tych problemów można rozwiązać poprzez konwersję ciągu znaków na liczbę całkowitą za pomocą funkcji `int`:\n"
"`int('5')` zwróci liczbę całkowitą `5`.\n"
"Podobnie, liczbę całkowitą można przekonwertować na ciąg znaków za pomocą funkcji `str`:\n"
"`str(5)` zwróci ciąg znaków `'5'`.\n"
"\n"
"Używając tej nowej wiedzy, napraw ten pokazany program:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Poprawny program powinien wydrukować:\n"
"\n"
"    Starting... 1\n"
"    Starting... 2\n"
"    Starting... 3\n"
"    Go!\n"
"\n"
"Twoje rozwiązanie powinno działać dla dowolnej wartości zmiennej `number`."

msgid "pages.Types.steps.format_board_with_numbers.hints.0.text"
msgstr ""
"Możesz zacząć od wykorzystania pomysłów z poprzedniego rozwiązania do "
"`format_board`. Bardzo polecam użycie `join`!"

msgid "pages.Types.steps.format_board_with_numbers.hints.1.text"
msgstr "Pierwsza linia musi być potraktowana oddzielnie od reszty."

msgid "pages.Types.steps.format_board_with_numbers.hints.2.text"
msgstr "Pamiętaj, że `range` daje liczby w sposób: 0, 1, 2, ..."

msgid "pages.Types.steps.format_board_with_numbers.hints.3.text"
msgstr "Chcemy numerów na pierwszej linii takich jak: 1, 2, 3..."

msgid "pages.Types.steps.format_board_with_numbers.hints.4.text"
msgstr ""
"Każdy numer musi być przekonwertowany na ciąg znaków przed dodaniem do "
"pierwszego wiersza!"

msgid "pages.Types.steps.format_board_with_numbers.hints.5.text"
msgstr "Dla wierszy samej planszy zrób coś podobnego."

msgid "pages.Types.steps.format_board_with_numbers.hints.6.text"
msgstr ""
"Zacznij z listą składającą się tylko z pierwszej linii, którą wyżej "
"zbudowałeś."

msgid "pages.Types.steps.format_board_with_numbers.hints.7.text"
msgstr ""
"Dodaj do listy ciąg znaków każdego wiersza, następnie połącz listę ze "
"znakiem nowej linii."

msgid "pages.Types.steps.format_board_with_numbers.text"
msgstr ""
"Napisz ulepszoną wersję `format_board`, która zawiera numery rzędów i kolumn, tak jak tutaj:\n"
"\n"
"     123\n"
"    1XOX\n"
"    2 OO\n"
"    3 X\n"
"\n"
"To powinno działać dla plansz dowolnej jednocyfrowej wielkości. Oto przypadek testowy:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.Types.steps.less_than_has_two_meanings.text"
msgstr ""
"Dla dwóch liczb całkowitych `+` działa jako dodawanie, natomiast dla dwóch ciągów znaków działa jako konkatenacja ciągów znaków.\n"
"Python automatycznie wywnioskuje znaczenie `+` z typów danych wejściowych.\n"
"Podobnie `<` działa inaczej na dwóch ciągach znaków i dwóch liczbach całkowitych:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.Types.steps.less_than_sorting_strings.text"
msgstr ""
"Więc `<` działa jak zwykłe 'mniej niż' między dwoma liczbami całkowitymi, ponieważ `13` jest mniejsze od `120`,\n"
"ale działa jako sortowanie słownikowe między dwoma ciągami znaków: `13` jest 'alfabetycznie' po `120`\n"
"ponieważ `3` jest po `2` w kolejności alfabetycznej.\n"
"\n"
"Zobacz jaką różnicę to robi podczas sortowania listy:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.Types.steps.plus_has_two_meanings.text"
msgstr ""
"Różne typy mają różne metody i obsługują różne operatory.\n"
"Ta sama metoda lub operator może również oznaczać różne rzeczy.\n"
"Na przykład zobacz, jak `+` ma różne znaczenia dla `str` i `int`:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.Types.title"
msgstr "Typy"

msgid "pages.UnderstandingProgramsWithPythonTutor.steps.final_text.text"
msgstr ""
"Zwróć uwagę, że kod wykonuje się dwukrotnie oddzielnie: raz tutaj, a raz na stronie pythontutor.com.\n"
"W zależności od Twojego programu, oba uruchomienia mogą dać różne wyniki."

msgid ""
"pages.UnderstandingProgramsWithPythonTutor.steps.run_with_python_tutor.text"
msgstr ""
"Nadszedł czas, aby poznać kolejne narzędzie do eksploracji programów.\n"
"Skopiuj poniższy kod do edytora, a następnie kliknij nowy przycisk \"Python Tutor\".\n"
"Przycisk otworzy nową kartę z wizualizacją na stronie [pythontutor.com](http://pythontutor.com).\n"
"Tam możesz przeglądać program krok po kroku, korzystając z przycisków \"Prev\" lub \"Next\",\n"
"lub przeciągając suwak w lewo lub w prawo. Możesz także obserwować wartości zmiennych po prawej stronie.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.UnderstandingProgramsWithPythonTutor.title"
msgstr "Zrozumienie programów z Python Tutor"

msgid "pages.UnderstandingProgramsWithSnoop.steps.final_text.text"
msgstr "Świetna robota! Pracujesz z coraz bardziej skomplikowanymi programami."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.0.text"
msgstr ""
"Kod powinien być prawie taki sam, wystarczy zrobić kilka małych zmian."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.1.text"
msgstr ""
"Upewnij się, że kod wewnątrz `jeśli zawiera:` działa na początku pętli, w "
"pierwszej iteracji."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.2.text"
msgstr "To znaczy, że `zawiera` powinno być `True` w tym momencie."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.3.text"
msgstr ""
"Upewnij się, że kod wewnątrz `jeśli zawiera:` *nie* działa po pierwszej "
"iteracji."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.4.text"
msgstr "To znaczy, że `zawiera` powinno być `False` po pierwszej iteracji."

msgid "pages.UnderstandingProgramsWithSnoop.steps.print_first_character.text"
msgstr ""
"Tada! Przewiń na początek terminala i przeanalizujmy, co pokazuje `snoop`.\n"
"Zaczyna się bardzo prosto:\n"
"\n"
"        1 | sentence = 'Hello World'\n"
"        3 | include = False\n"
"        4 | new_sentence = ''\n"
"        5 | for char in sentence:\n"
"     ...... char = 'H'\n"
"\n"
"Pierwsze linie po prostu pokazują ci linie programu, które komputer wykonał.\n"
"Po lewej stronie jest numer linii widziany w edytorze.\n"
"\n"
"Uruchomienie `for char in sentence:` przypisuje wartość do zmiennej `char`, więc `snoop` pokazuje tę wartość.\n"
"Linie zaczynające się od `......` wskazują na nową zmienną lub zmianę wartości istniejącej zmiennej.\n"
"Takie linie nie będą pokazywane, gdy są zbędne, dlatego wynik `snoop` nie zaczyna się tak:\n"
"\n"
"        1 | sentence = 'Hello World'\n"
"     ...... sentence = 'Hello World'\n"
"        3 | include = False\n"
"     ...... include = False\n"
"        4 | new_sentence = ''\n"
"     ...... new_sentence = ''\n"
"        5 | for char in sentence:\n"
"     ...... char = 'H'\n"
"\n"
"Następne dwie linie to:\n"
"\n"
"        6 |     if include:\n"
"        8 |     include = True\n"
"\n"
"Ważne jest to, czego nie widać: ponieważ `include` jest `False`, linia 7 (`new_sentence += char`) zostaje pominięta. Ale potem `include` jest ustawione na `True`, więc kolejne iteracje pętli są inne:\n"
"\n"
"        5 | for char in sentence:\n"
"     ...... char = 'e'\n"
"        6 |     if include:\n"
"        7 |         new_sentence += char\n"
"     .............. new_sentence = 'e'\n"
"\n"
"`new_sentence += char` działa po raz pierwszy i zmienna `new_sentence` otrzymuje nową wartość.\n"
"\n"
"Teraz zmodyfikuj program, aby zrobić odwrotnie: wydrukuj tylko pierwszy znak, resztę pomijając."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.0"
msgstr "Hello World"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.1"
msgstr "ello World"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.2"
msgstr "Hello Worl"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.3"
msgstr "H"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.4"
msgstr "d"

msgid "pages.UnderstandingProgramsWithSnoop.steps.print_tail.text"
msgstr ""
"Uruchom ten program:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail_snoop.requirements"
msgstr ""
"Uruchom ten sam program z poprzedniego kroku, ale użyj przycisku `snoop` "
"zamiast przycisku 'Uruchom'. Skopiuj program jeszcze raz, jeśli mogłeś go "
"zmienić."

msgid "pages.UnderstandingProgramsWithSnoop.steps.print_tail_snoop.text"
msgstr ""
"Programy zaczynają być skomplikowane!\n"
"Czas przedstawić nowe narzędzie, które pomoże ci zrozumieć programy. Kliknij przycisk `snoop`, aby uruchomić ten sam program i pokazać co się dzieje."

msgid "pages.UnderstandingProgramsWithSnoop.title"
msgstr "Zrozumienie programów z `snoop`"

msgid "pages.UsingBreak.steps.final_text.text"
msgstr ""
"Świetnie!\n"
"\n"
"Typowe rozwiązanie wygląda mniej więcej tak:\n"
"\n"
"__code0__\n"
"\n"
"Twoje rozwiązanie prawdopodobnie jest podobne. Jest w porządku, ale trochę niewydajne.\n"
"To dlatego, że pętla będzie iterować przez całą listę nawet jeśli znajdzie element na początku.\n"
"Możesz zatrzymać dowolną pętlę używając instrukcji `break`, na przykład:\n"
"\n"
"__code1__\n"
"\n"
"To jest równie poprawne, ale pomija niepotrzebne iteracje i sprawdzenia po znalezieniu elementu.\n"
"Możesz użyć `snoop`, żeby zobaczyć różnicę."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.0.text"
msgstr "Będziesz potrzebować pętli."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.1.text"
msgstr "Będziesz potrzebować instrukcji `if`."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.2.text"
msgstr "Będziesz potrzebować operatora porównania."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.3.text"
msgstr "Konkretnie `==`."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.4.text"
msgstr "Potrzebujesz zmiennej logicznej, którą wydrukujesz na końcu."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.5.text"
msgstr ""
"Jeśli znajdziesz element na liście, powinieneś ustawić tą zmienną na `True`."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.6.text"
msgstr "Gdy już znajdziesz element, nie możesz go 'odnaleźć'."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.7.text"
msgstr ""
"To oznacza, że raz ustawiona zmienna na `True`, nigdy nie powinna być "
"ustawiona na coś innego po tym."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.8.text"
msgstr "Nie używaj `else`."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.9.text"
msgstr ""
"Nie ma powodu, aby kiedykolwiek ustawiać zmienną na `False` wewnątrz pętli."

msgid "pages.UsingBreak.steps.list_contains_exercise.text"
msgstr ""
"Ćwiczenie: napisz program, który przyjmuje listę i wartość i sprawdza,\n"
"czy lista zawiera daną wartość. Na przykład, dla:\n"
"\n"
"    __no_auto_translate__\n"
"    things = ['This', 'is', 'a', 'list']\n"
"    thing_to_find = 'is'\n"
"\n"
"powinien wyświetlić `True`, ale dla:\n"
"\n"
"    __no_auto_translate__\n"
"    thing_to_find = 'other'\n"
"\n"
"powinien wyświetlić `False`."

msgid "pages.UsingBreak.title"
msgstr "Użycie `break` do wcześniejszego zakończenia pętli"

msgid "pages.UsingDictionaries.steps.dna_part1.text"
msgstr ""
"Not bad! But you may have noticed that it looks a bit awkward. Why do we have to specify `'dog'` and `'box'` in both the `cart` and the `quantities`?\n"
"On the next page we'll look at how to loop directly over the keys of a dictionary,\n"
"so we can get rid of the `cart` argument.\n"
"\n"
"But first, let's practice what we've learned a bit more.\n"
"\n"
"[Earlier in the course](#IntroducingElif) we looked at converting one strand of DNA\n"
"into a new strand with matching nucleotides.\n"
"Here's a version of that code using a function. It substitutes each letter in the input `string`\n"
"with a different one.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.UsingDictionaries.steps.dna_part2.hints.0.text"
msgstr ""
"This is still very similar to the previous exercises, but with strings "
"instead of numbers."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.1.text"
msgstr "You just have to think about the keys and values of `d`."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.2.text"
msgstr "You need to obtain the correct values to build up a string to return."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.3.text"
msgstr ""
"You can basically replace the whole `if/elif` chain with a single line."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.4.text"
msgstr "That line simply needs to use `d` to get the correct value."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.5.text"
msgstr "Remember that the keys of `d` are the characters in `string`."

msgid "pages.UsingDictionaries.steps.dna_part2.text"
msgstr ""
"Now we can use dictionaries to make this code both shorter and more general so it can be used for other purposes.\n"
"\n"
"Your job is to add another argument to the `substitute` function: a dictionary called `d`.\n"
"The keys of `d` represent characters\n"
"in the first argument `string` that should be replaced by the corresponding values of `d`. For example, `'A': 'T'`\n"
"means that `'A'` should be replaced by `'T'`:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"This version of `substitute` should work for any arguments where all the characters in `string` are keys in `d`.\n"
"No more `if` statements needed!"

msgid "pages.UsingDictionaries.steps.final_text.text"
msgstr ""
"Nice! Here's an example of how this function can also be used to encrypt and decrypt secret messages:\n"
"\n"
"    __copyable__\n"
"    __no_auto_translate__\n"
"    def substitute(string, d):\n"
"        result = \"\"\n"
"        for letter in string:\n"
"            result += d[letter]\n"
"        return result\n"
"\n"
"    plaintext = 'helloworld'\n"
"    encrypted = 'qpeefifmez'\n"
"    letters = {'h': 'q', 'e': 'p', 'l': 'e', 'o': 'f', 'w': 'i', 'r': 'm', 'd': 'z'}\n"
"    reverse = {'q': 'h', 'p': 'e', 'e': 'l', 'f': 'o', 'i': 'w', 'm': 'r', 'z': 'd'}\n"
"    assert_equal(substitute(plaintext, letters), encrypted)\n"
"    assert_equal(substitute(encrypted, reverse), plaintext)\n"
"\n"
"The same function works in both directions, we just need to pass it different dictionaries.\n"
"\n"
"The two dictionaries are almost the same, we just swap around the key and value in each pair.\n"
"So to encrypt, we replace `e` with `p`, and to decrypt we change `p` back to `e`.\n"
"\n"
"Note that `'e'` is both a key and a value in `letters`.\n"
"\n"
"Looking up `letters['e']` means that we're asking about `'e'` as a *key*, so it gives `'p'`.\n"
"Remember, we can't use `letters` to ask which key is associated with `'e'` as a *value*.\n"
"But in this case we can use the other dictionary for that: `reverse['e']` gives `'l'`,\n"
"and `letters['l']` gives `'e'` again.\n"
"\n"
"Soon you'll write a function to create a dictionary like `reverse` automatically,\n"
"i.e. `reverse = swap_keys_values(letters)`."

msgid "pages.UsingDictionaries.steps.shopping_cart1.hints.0.text"
msgstr "Remember that `prices` is a dictionary."

msgid "pages.UsingDictionaries.steps.shopping_cart1.hints.1.text"
msgstr "To access a value in a dictionary, you need a key."

msgid "pages.UsingDictionaries.steps.shopping_cart1.hints.2.text"
msgstr "The keys for `prices` are the items in the `cart`."

msgid "pages.UsingDictionaries.steps.shopping_cart1.text"
msgstr ""
"Let's see dictionaries in a real life problem. Imagine you're building an online shopping website.\n"
"You keep the prices of all your items in a dictionary:\n"
"\n"
"__code0__\n"
"\n"
"Here you can see one reason why looking up values in a dictionary could be a problem.\n"
"What would `prices[100]` be? `'dog'`? `'cat'`? `['dog', 'cat']`?\n"
"The same value can be repeated any number of times in a dictionary.\n"
"On the other hand, keys have to be unique. Imagine if your prices started like this:\n"
"\n"
"__code1__\n"
"\n"
"How much does an apple cost? We know it's `prices['apple']`, but is that `2` or `3`?\n"
"Clearly there should only be one price, so duplicate keys aren't allowed.\n"
"\n"
"Anyway, this is a normal shop where things have one price.\n"
"This normal shop has normal customers with normal shopping lists like `['apple', 'box', 'cat']`.\n"
"And even though your customers have calculators in their pockets, they still expect you to add up all the prices\n"
"yourself and tell them how much this will all cost, because that's what normal shops do.\n"
"\n"
"So let's write a function that does that. Complete the function below, particularly the line `price = ...`\n"
"\n"
"    __copyable__\n"
"__code2__"

msgid "pages.UsingDictionaries.steps.shopping_cart4.hints.0.text"
msgstr "Remember that the keys for `prices` and `quantities` are the same."

msgid "pages.UsingDictionaries.steps.shopping_cart4.hints.1.text"
msgstr "This is very similar to the previous exercise, we're just practicing."

msgid "pages.UsingDictionaries.steps.shopping_cart4.hints.2.text"
msgstr ""
"`price` should be a value from `prices`, and similarly for `quantity`."

msgid "pages.UsingDictionaries.steps.shopping_cart4.hints.3.text"
msgstr "What key should be used to obtain each value?"

msgid "pages.UsingDictionaries.steps.shopping_cart4.text"
msgstr ""
"Perfect! You publish your website and start dreaming about how rich you're going to be.\n"
"\n"
"But soon you get a complaint from a customer who wants to buy 5 million dogs...and 2 boxes to put them in.\n"
"\n"
"Your website allows buying the same items several times, e.g. `total_cost(['box', 'box'], {...})` works,\n"
"but they have to add each item one at a time, and for some reason this customer doesn't want to click\n"
"'Add to Cart' 5 million times. People are so lazy!\n"
"\n"
"Here's the new code for you to fix:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"We've added another parameter called `quantities` to `total_cost`.\n"
"Now `cart` is still a list of strings, but it doesn't have any duplicates.\n"
"`quantities` is a dictionary where the keys are the items in `cart` and the corresponding values are the quantity\n"
"of that item that the customer wants to buy."

msgid "pages.UsingDictionaries.title"
msgstr "Using Dictionaries in Practice"

msgid "pages.UsingVariables.steps.final_text.text"
msgstr ""
"Hurra! Już bez apostrofów! Wyjaśnimy, co dzieje się w tym kodzie później. "
"Na razie wystarczy wiedzieć, że `print(<coś>)` wyświetla `<coś>` w konsoli. "
"W szczególności pokazuje rzeczywistą zawartość napisów, na której nam "
"zazwyczaj zależy, zamiast przedstawienia napisów odpowiednich dla kodu, "
"które zawierają rzeczy takie jak cudzysłowy. Słowo `print` tutaj nie ma nic "
"wspólnego z drukarką czy drukowaniem."

msgid "pages.UsingVariables.steps.first_print.text"
msgstr ""
"Te cudzysłowy przy napisach zaczynają być irytujące. Spróbuj uruchomić to:\n"
"\n"
"__code0__"

msgid "pages.UsingVariables.steps.goodbye_plus_name.text"
msgstr "Obserwuj efekt tej zmiany uruchamiając `__program__` ponownie."

msgid "pages.UsingVariables.steps.hello_plus_name.text"
msgstr ""
"Możesz używać zmiennych w obliczeniach dokładnie tak samo, jak używałbyś literałów. Na przykład spróbuj:\n"
"\n"
"__program_indented__"

msgid ""
"pages.UsingVariables.steps.name_assign.messages.assigned_something_else.text"
msgstr ""
"Umieść `your_name` przed `=` aby stworzyć zmienną o nazwie `your_name`."

msgid "pages.UsingVariables.steps.name_assign.messages.empty_string.text"
msgstr "Do tego ćwiczenia wybierz niepusty napis (string)"

msgid ""
"pages.UsingVariables.steps.name_assign.messages.name_equals_something_else.text"
msgstr ""
"Masz prawidłową część `your_name = `, teraz po prawej stronie `=` umieść "
"napis (użyj apostrofów)."

msgid "pages.UsingVariables.steps.name_assign.messages.starts_with_space.text"
msgstr "Do tego ćwiczenia wybierz imię, które nie zaczyna się od spacji."

msgid "pages.UsingVariables.steps.name_assign.requirements"
msgstr ""
"Uruchom coś podobnego do `word = 'Hello'`, ale zamień `word` na `your_name`."

msgid "pages.UsingVariables.steps.name_assign.text"
msgstr ""
"Wcześniej utworzyliśmy zmienną o nazwie `word` z wartością `'Hello'` przy użyciu tego kodu:\n"
"\n"
"__code0__\n"
"\n"
"Teraz utwórz zmienną o nazwie `your_name`, której wartością jest inny napis (string).\n"
"\n"
"(Znak `_` w `your_name` to *podkreślnik*. Używaj go do rozdzielenia słów, kiedy potrzebujesz nazwy zmiennej zawierającej kilka słów. Możesz go wpisać na większości klawiatur, naciskając Shift oraz myślnik/pauza/minus (`-`).)"

msgid "pages.UsingVariables.steps.word_assign_goodbye.text"
msgstr ""
"Doskonale!\n"
"\n"
"Zmienne mogą również zmieniać swoje wartości w czasie. Aktualnie zmienna `word` ma wartość `'Hello'`. Możesz zmienić jej wartość w ten sam sposób, w jaki ją ustawiałeś po raz pierwszy. Uruchom to:\n"
"\n"
"__code0__"

msgid ""
"pages.UsingVariables.steps.word_plus_name.special_messages.bad_word.text"
msgstr ""
"Ups, musisz ustawić `word = 'Hello'` zanim będziemy mogli kontynuować."

msgid "pages.UsingVariables.steps.word_plus_name.text"
msgstr ""
"Ewentualnie możesz po prostu dodać zmienne do siebie. Spróbuj:\n"
"\n"
"__code0__"

msgid "pages.UsingVariables.steps.word_plus_name_with_space.hints.0.text"
msgstr "Musisz użyć `+` dwa razy, tak jak w 1+2+3."

msgid "pages.UsingVariables.steps.word_plus_name_with_space.hints.1.text"
msgstr ""
"Twoja odpowiedź powinna zawierać mieszankę zmiennych (bez cudzysłowu) i "
"literałów łańcuchowych (w cudzysłowie)."

msgid "pages.UsingVariables.steps.word_plus_name_with_space.hints.2.text"
msgstr "Musisz mieć znak spacji wewnątrz cudzysłowów."

msgid ""
"pages.UsingVariables.steps.word_plus_name_with_space.special_messages.bad_word.text"
msgstr ""
"Ups, musisz ustawić `word = 'Hello'` zanim będziemy mogli kontynuować."

msgid "pages.UsingVariables.steps.word_plus_name_with_space.text"
msgstr ""
"Ups... to nie wygląda ładnie. Czy możesz zmodyfikować powyższy kod tak, aby "
"między słowem a twoim imieniem była spacja?"

msgid "pages.UsingVariables.title"
msgstr "Używanie zmiennych i `print()`"


msgid "pages.WritingPrograms.steps.editor_hello_world.text"
msgstr ""
"Nadszedł czas, aby przestać robić wszystko w konsoli. W prawym górnym rogu można zobaczyć *edytor*. Jest to miejsce, w którym możesz pisać i uruchamiać dłuższe programy. Konsola jest świetna i powinieneś nadal z niej korzystać do eksploracji, ale to w edytorze żyją prawdziwe programy.\n"
"\n"
"Wpisz poniższy program do edytora, a następnie kliknij przycisk 'Uruchom':\n"
"\n"
"__code0__"

msgid "pages.WritingPrograms.steps.final_text.text"
msgstr ""
"Gratulacje, uruchomiłeś swój pierwszy rzeczywisty program!\n"
"\n"
"Poświęć trochę czasu, aby zrozumieć ten program. Python wykonuje każdą linię po kolei, od góry do dołu. Powinieneś spróbować symulować ten proces w swojej głowie - zastanów się, co robi każda linia. Zobacz, jak zmieniła się wartość zmiennej `word` i jakie to miało konsekwencje. Zauważ, że gdy używane jest wielokrotnie `print`, każda rzecz (w tym przypadku `Hello World` i `Goodbye World`) jest wypisywana na własnej linii.\n"
"\n"
"Kilka rzeczy, które warto zauważyć o programach w edytorze:\n"
"\n"
"1. Program jest uruchamiany w konsoli, co oznacza, że zmienne zdefiniowane w programie istnieją teraz w konsoli z ostatnimi wartościami, które miały w programie. Pozwala Ci to badać w konsoli po zakończeniu programu. Na przykład `name` ma teraz wartość `'World'` w konsoli.\n"
"2. Programy uruchamiają się w izolacji - nie zależą od żadnych wcześniej zdefiniowanych zmiennych. Konsola jest resetowana i wszystkie poprzednie zmienne są czyszczone. Więc pomimo że `word` obecnie istnieje w konsoli, jeśli usuniesz pierwszą linię programu i uruchomisz go ponownie, otrzymasz błąd o niezdefiniowanej zmiennej `word`.\n"
"3. Jeśli wpiszesz kod w konsoli i ma on wartość, ta wartość zostanie automatycznie wyświetlona. Nie dzieje się tak w przypadku programów w edytorze - musisz wydrukować wartości. Jeśli usuniesz `print()` z programu, zmieniając dwie linie na po prostu `word + ' ' + name`, nic nie zostanie wyświetlone.\n"
"\n"
"Najlepiej samodzielnie sprawdź te wszystkie rzeczy."

msgid "pages.WritingPrograms.title"
msgstr "Pisanie programów"
