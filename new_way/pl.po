#
msgid ""
msgstr ""
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "chapters.a_bit_more_about_strings.title"
msgstr "Trochę więcej o łańcuchach znaków"

msgid "chapters.boolean operators.title"
msgstr "Operatory logiczne"

msgid "chapters.dictionaries.title"
msgstr "Słowniki"

msgid "chapters.for_loops.title"
msgstr "Pętle for"

msgid "chapters.functions.title"
msgstr "Funkcje"

msgid "chapters.if_statements.title"
msgstr "Instrukcje warunkowe"

msgid "chapters.lists.title"
msgstr "Listy"

msgid "chapters.nested_loops.title"
msgstr "Zagnieżdżone pętle"

msgid "chapters.string_basics.title"
msgstr "Podstawy łańcuchów znaków"

msgid "chapters.the_shell.title"
msgstr "Powłoka systemowa"

msgid "chapters.tic_tac_toe_project.title"
msgstr "Projekt gry w kółko i krzyżyk"

msgid "chapters.variables.title"
msgstr "Zmienne"


msgid "frontend.are_you_sure"
msgstr "Czy na pewno?"

msgid "frontend.ask_for_help"
msgstr "Poproś o pomoc"

msgid "frontend.assessment"
msgstr "Ocena"

msgid "frontend.assessment_description"
msgstr ""
"Gdy uruchomisz kod, który nie przechodzi obecnego kroku, ta sekcja *czasami*"
" wyjaśni co jest nie tak."

msgid "frontend.assessment_lint"
msgstr "Znaleziono następujące ogólne problemy w twoim kodzie:"

msgid "frontend.assessment_passed_tests"
msgstr "Plusy są takie, że twój kod przeszedł ${num} testy/ów!"

msgid "frontend.cancel"
msgstr "Anuluj"

msgid "frontend.chat_on_slack"
msgstr "Czatuj na Slacku"

msgid "frontend.click_for_error_details"
msgstr "Kliknij, aby zobaczyć szczegóły błędu"

msgid "frontend.click_to_expand"
msgstr "Kliknij, aby rozwinąć"

msgid "frontend.contact_directly"
msgstr "Alternatywnie możesz skontaktować się z nami bezpośrednio:"

msgid "frontend.copy_warning"
msgstr ""
"**STOP!**\n"
"\n"
"Postaraj się unikać kopiowania kodu. Będziesz lepiej uczyć się, przyswajać i pamiętać, jeśli wpiszesz kod samodzielnie.\n"
"\n"
"Kiedy kopiowanie jest odpowiednie, będzie przycisk, który ułatwi to zadanie. Jeśli nie ma przycisku, postaraj się wpisywać kod.\n"
"\n"
"Cóż, nie będziemy cię zmuszać. Skopiuj, jeśli naprawdę chcesz."

msgid "frontend.copying_solution_not_allowed"
msgstr "Kopiowanie z obszaru podpowiedzi/rozwiązania nie jest dozwolone!"

msgid "frontend.current_page"
msgstr "(obecna strona)"

msgid "frontend.description"
msgstr "Opis"

msgid "frontend.developer_mode"
msgstr "Tryb deweloperski"

msgid "frontend.developer_mode_description"
msgstr "Aktywuje przyciski „Cofnij krok” i „Pomiń krok”."

msgid "frontend.did_you_mean"
msgstr "Czy miałeś na myśli..."

msgid "frontend.error_has_been_reported"
msgstr "Błąd został zgłoszony."

msgid "frontend.error_traceback"
msgstr "Traceback błędu:"

msgid "frontend.exercise_requirement"
msgstr ""
"Ten krok to ćwiczenie. Musisz wymyślić kod, który da poprawny wynik. Możliwe"
" są wiele różnych poprawnych odpowiedzi."

msgid "frontend.exercise_stdin"
msgstr ""
"Twój program musi otrzymać dane wejściowe od użytkownika poprzez funkcję "
"„input()”. Podczas testowania poprawności różne dane wejściowe użytkownika "
"zostaną zasymulowane."

msgid "frontend.feedback"
msgstr "Opinia"

msgid "frontend.feedback_email_placeholder"
msgstr "Email (opcjonalnie)"

msgid "frontend.function_exercise"
msgstr ""
"Zdefiniuj funkcję, zaczynając od:\n"
"\n"
"${header}\n"
"\n"
"Następnie wypełnij wcięte ciało własną implementacją.\n"
"\n"
"Funkcja będzie wywołana z różnymi argumentami, aby przetestować, czy generalnie działa. Możesz także sam wywołać funkcję, aby ją przetestować podczas pracy, ale nie wpłynie to na ocenę."

msgid "frontend.function_exercise_goal"
msgstr "Twoja funkcja musi `${print_or_return}` poprawny wynik."

msgid "frontend.get_another_hint"
msgstr "Uzyskaj kolejną podpowiedź"

msgid "frontend.get_hint"
msgstr "Uzyskaj podpowiedź"

msgid "frontend.give_feedback"
msgstr "Przekaż opinię"

msgid "frontend.give_feedback_from_menu"
msgstr "Przekaż opinię z menu w lewym górnym rogu."

msgid "frontend.give_feedback_instructions"
msgstr ""
"Powiedz nam, co lubisz lub czego nie lubisz! Jeśli zgłaszasz błąd, podaj szczegółowy opis problemu:\n"
"\n"
"- Co robiłeś przed i kiedy problem się pojawił?\n"
"- Jakie kroki można podjąć, aby go odtworzyć?\n"
"- Co obserwujesz i co według ciebie powinno się stać zamiast tego?"

msgid "frontend.hidden_solution_instructions"
msgstr ""
"Powyżej znajduje się przykładowe rozwiązanie, ale jest ukryte. Klikaj "
"przycisk „Odsłoń” wielokrotnie, aby odsłaniać rozwiązanie kawałek po "
"kawałku. Postaraj się zatrzymać, kiedy pomyślisz, że odsłoniłeś "
"wystarczająco i możesz sam uzupełnić pozostałe luki. Następnie wpisz "
"rozwiązanie w edytorze i uruchom je. Twoje rozwiązanie nie musi być takie "
"samo jak powyżej."

msgid "frontend.hints_and_solution"
msgstr "Podpowiedzi i Rozwiązanie"

msgid "frontend.hints_progress"
msgstr "Pokazane ${numHints} z ${totalHints} podpowiedzi"

msgid "frontend.internal_error_start"
msgstr "Ups, coś poszło nie tak! ${maybeErrorReported} Oto co możesz zrobić:"

msgid "frontend.loading_wait"
msgstr "Ładowanie..."

msgid "frontend.login_or_sign_up"
msgstr "Zaloguj się / Zarejestruj"

msgid "frontend.new"
msgstr "Nowy"

msgid "frontend.next"
msgstr "Dalej"

msgid "frontend.no"
msgstr "Nie"

msgid "frontend.no_hints_available"
msgstr ""
"Do tego kroku nie ma żadnych podpowiedzi. Spróbuj ponownie przeczytać "
"instrukcje i wymagania. Nadal możesz sprawdzić rozwiązanie, jeśli jesteś "
"naprawdę zablokowany."

msgid "frontend.no_input_variables"
msgstr "To ćwiczenie nie ma zmiennych wejściowych."

msgid "frontend.non_function_exercise"
msgstr ""
"Twój kod *musi* zacząć się od przypisania wartości do zmiennych wejściowych, np:\n"
"\n"
"${inputs}\n"
"\n"
"Wartości to tylko przykłady, możesz wybrać inne. Twój kod zostanie automatycznie przetestowany z różnymi wartościami, aby sprawdzić, czy działa w ogólności."

msgid "frontend.ok"
msgstr "OK"

msgid "frontend.open_github_issue"
msgstr "Otwórz issue na GitHubie"

msgid "frontend.output_prediction_correct"
msgstr "Poprawnie!"

msgid "frontend.output_prediction_error_choice"
msgstr "Błąd"

msgid "frontend.output_prediction_question"
msgstr "Jak myślisz, jaki będzie wynik?"

msgid "frontend.output_prediction_wrong_once"
msgstr "Ups, to nie jest prawidłowa odpowiedź. Możesz spróbować jeszcze raz!"

msgid "frontend.output_prediction_wrong_twice"
msgstr "Niestety, zła odpowiedź. Spróbuj ponownie następnym razem!"

msgid "frontend.parsons_solution_instructions"
msgstr ""
"Powyżej znajduje się przykładowe rozwiązanie z nieuporządkowanymi liniami. "
"Możesz je przeciągać, aby je posortować. Znalezienie poprawnej kolejności "
"zależy od ciebie, nie powiemy ci, czy masz rację. Eksperymentowanie i "
"uruchamianie częściowych rozwiązań w edytorze może ci pomóc to rozgryźć. "
"Nadal musisz wpisać poprawne rozwiązanie w edytorze i uruchomić je, aby "
"kontynuować."

msgid "frontend.previous"
msgstr "Wstecz"

msgid "frontend.program_in_text"
msgstr ""
"Dokładny kod, który musisz uruchomić, jest pokazany w tekście powyżej."

msgid "frontend.question_wizard"
msgstr "Kreator Pytań"

msgid "frontend.question_wizard_expected_output"
msgstr ""
"Dobrze, teraz wpisz poniżej wynik, którego oczekujesz/chcesz otrzymać od swojego programu. Co by wyświetlił, gdyby działał poprawnie? Jeśli nie ma nic wyświetlać, dodaj do swojego kodu kilka wywołań funkcji `print()`, aby wyświetlił coś użytecznego.\n"
"\n"
"When you're done, click 'Run' again to generate your question."

msgid "frontend.question_wizard_intro"
msgstr ""
"Jeśli potrzebujesz pomocy, istnieje wiele stron takich jak [Stack Overflow](https://stackoverflow.com/) i [reddit](https://www.reddit.com/r/learnpython/), gdzie możesz zadawać pytania. To narzędzie pomoże ci napisać dobrej jakości pytanie, które prawdopodobnie uzyska odpowiedzi.\n"
"\n"
"Wpisz i uruchom swój kod po prawej stronie. Jeśli nie masz żadnego kodu, bo nie wiesz od czego zacząć, obawiam się, że to narzędzie nie może ci pomóc. Nadal możesz prosić o pomoc, ale warto najpierw przeczytać [Jakich pytań należy unikać?](https://stackoverflow.com/help/dont-ask)\n"
"\n"
"Jeśli twoje pytanie dotyczy serwerów (np. Django lub Flask), żądań sieciowych, baz danych lub pakietu, który nie może być zaimportowany tutaj, to narzędzie nie będzie działać. Jednak tylko dlatego, że twój obecny kod *obejmuje* te rzeczy, nie oznacza, że o to chodzi w twoim pytaniu. Jeśli masz ogólny problem z Pythonem/programowaniem/logiką, wyizoluj go. Python z Django to wciąż Python. Jeśli nie możesz tego zrobić, przeczytaj [Jak stworzyć Minimalny, Powtarzalny Przykład](https://stackoverflow.com/help/minimal-reproducible-example) przed zadaniem pytania."

msgid "frontend.refresh_and_try_again"
msgstr "Odśwież stronę i spróbuj ponownie."

msgid "frontend.repeated_frames_description"
msgstr "${name} w linii ${lineno} (${count} razy)"

msgid "frontend.requirements"
msgstr "Wymagania"

msgid "frontend.requirements_description"
msgstr ""
"Musisz uruchomić kod zgodnie z instrukcjami powyżej. Na wypadek, gdyby te "
"nie były wystarczająco jasne, oto pewne dodatkowe wyjaśnienia:"

msgid "frontend.reveal"
msgstr "Odsłoń"

msgid "frontend.reverse_step"
msgstr "Cofnij krok"

msgid "frontend.run"
msgstr "Uruchom"

msgid "frontend.send_email_to"
msgstr "Email"

msgid "frontend.settings"
msgstr "Ustawienia"

msgid "frontend.show_shuffled_solution"
msgstr "Pokaż pomieszane rozwiązanie"

msgid "frontend.show_solution"
msgstr "Pokaż rozwiązanie"

msgid "frontend.show_unscrambled_solution"
msgstr "Pokaż niepomieszane rozwiązanie"

msgid "frontend.sign_out"
msgstr "Wyloguj"

msgid "frontend.similar_frames_skipped"
msgstr "Pominięte podobne ramki:"

msgid "frontend.skip_step"
msgstr "Pomiń krok"

msgid "frontend.stop"
msgstr "Zatrzymaj"

msgid "frontend.submit"
msgstr "Zatwierdź"

msgid "frontend.table_of_contents"
msgstr "Spis treści"

msgid "frontend.title"
msgstr "Tytuł"

msgid "frontend.toc_instructions"
msgstr ""
"Poniżej znajdują się linki do różnych stron kursu. Możesz zacząć od dowolnego miejsca i iść w dowolnej kolejności, a Twój postęp na każdej stronie będzie rejestrowany.\n"
"\n"
"Jeśli jesteś całkowicie nowy w programowaniu, lub masz wątpliwości, po prostu zacznij od początku i klikaj Następny, gdy skończysz każdą stronę."

msgid "frontend.try_running_code_again"
msgstr "Spróbuj uruchomić kod ponownie."

msgid "frontend.try_using_different_browser"
msgstr "Spróbuj użyć innej przeglądarki."

msgid "frontend.verbatim"
msgstr ""
"Ten krok ma tylko jedną poprawną odpowiedź. Musisz uruchomić dokładnie "
"poprawny kod, więc sprawdź dokładnie swoją pisownię. Tylko kilka rodzajów "
"szczegółów (takich jak spacje w niektórych miejscach) zostanie "
"zignorowanych, ponieważ nie robią one różnicy dla programu."

msgid "frontend.yes"
msgstr "Tak"

msgid "linting_messages.pyflakes.ImportShadowedByLoopVar.message_format"
msgstr ""
"**Import `{0}` jest przesłonięty przez zmienną pętli**\n"
"\n"
"Należy zmienić nazwę zmiennej pętli `{0}`, ponieważ przedefiniowuje ona wcześniej zaimportowany moduł `{0}`.\n"
"Wybierz inną nazwę zmiennej pętli, aby uniknąć tego błędu."

msgid "linting_messages.pyflakes.ImportStarNotPermitted.message_format"
msgstr ""
"**Import przy użyciu `*` **\n"
"\n"
"Użycie konstrukcji `from {0} import *` powoduje zaimportowanie wszystkiego z modułu `{0}` do bieżącej przestrzeni nazw.\n"
"Tworzy to wiele niewidocznych, nieznanych zmiennych.\n"
"Utrudnia to czytanie i rozumienie kodu oraz ustalenie skąd pochodzą poszczególne elementy.\n"
"\n"
"Unikaj tego rodzaju importu i zamiast tego dokładnie zaimportuj tylko te nazwy, których potrzebujesz."

msgid "linting_messages.pyflakes.IsLiteral.message_format"
msgstr ""
"**Porównanie `is` z literałem**\n"
"\n"
"Użyto operatora `is`/`is not` do porównania z literałem (np. ciąg znaków lub liczba).\n"
"Zamiast tego powinno się użyć operatora `==` / `!=`.\n"
"\n"
"Operator `is` sprawdza, czy dwie wyrażenia odnoszą się do dokładnie tego samego obiektu.\n"
"Rzadko chcesz go używać, zwłaszcza w przypadku podstawowych typów danych, takich jak ciągi znaków i liczby.\n"
"W takich przypadkach wydaje się, że czasami działa (np. dla małych liczb) i tajemniczo\n"
"zawodzi przy innych okazjach."

msgid "linting_messages.pyflakes.MultiValueRepeatedKeyLiteral.message_format"
msgstr ""
"**Klucz słownika `{0}` został powtórzony z różnymi wartościami**\n"
"\n"
"Słownik nie może mieć wielu wpisów dla tego samego klucza.\n"
"Sprawdź ponownie swój kod i zmień powtarzający się klucz na coś unikalnego."

msgid "linting_messages.pyflakes.RedefinedWhileUnused.message_format"
msgstr ""
"**Przedefiniowano `{0}` bez jego użycia**\n"
"\n"
"Zdefiniowałeś `{0}` w linii `{1}`, ale zanim go użyłeś, zdefiniowałeś go ponownie,\n"
"nadpisując oryginalną definicję.\n"
"\n"
"Ogólnie twoje funkcje i klasy powinny mieć różne nazwy.\n"
"Sprawdź, czy używasz wszystkiego co zdefiniowałeś, np. czy wywołałeś swoje funkcje."

msgid "linting_messages.pyflakes.UnusedImport.message_format"
msgstr ""
"**Niewykorzystany import `{0}`**\n"
"\n"
"Zaimportowałeś `{0}`, ale go nie użyłeś. Czy zapomniałeś go użyć?\n"
"Może użyłeś w jego miejsce błędnej zmiennej? Jeśli nie potrzebujesz importu, po prostu go usuń."

msgid "linting_messages.pyflakes.UnusedVariable.message_format"
msgstr ""
"**Niewykorzystana zmienna `{0}`**\n"
"\n"
"Zdefiniowałeś zmienną `{0}`, ale nigdy jej nie użyłeś. Czy zapomniałeś jej użyć?\n"
"Może użyłeś w jej miejsce błędnej zmiennej? Jeśli nie potrzebujesz jej, po prostu ją usuń."


msgid "misc_terms.blank_result"
msgstr "<pusto>"

msgid "misc_terms.case_sensitive"
msgstr ""
"Python jest wrażliwy na wielkość liter (ang. *case sensitive*)! Oznacza to, że małe i wielkie "
"litery są ważne i ich zmiana zmienia znaczenie programu. Ciągi znaków "
"`'hello'` i `'Hello'` są różne, podobnie jak nazwy zmiennych `word` i "
"`Word`."

msgid "misc_terms.code_should_start_like"
msgstr ""
"Twój kod powinien zaczynać się tak:\n"
"\n"
"{expected_start}\n"

msgid "misc_terms.copy_button"
msgstr "Kopiuj"

msgid "misc_terms.disallowed_default_label"
msgstr "więcej niż {max_count} {label}"

msgid "misc_terms.disallowed_default_message"
msgstr ""
"Brawo, znalazłeś rozwiązanie! Jednakże, dla tego ćwiczenia i twojej nauki, "
"nie wolno ci używać {label}."

msgid "misc_terms.expected_mode_birdseye"
msgstr "Mając swój kod w edytorze, kliknij przycisk `birdseye`."

msgid "misc_terms.expected_mode_pythontutor"
msgstr "Mając swój kod w edytorze, kliknij przycisk Python Tutor."

msgid "misc_terms.expected_mode_shell"
msgstr "Wpisz swój kod bezpośrednio w shell po `>>>` i wciśnij Enter."

msgid "misc_terms.expected_mode_snoop"
msgstr "Mając swój kod w edytorze, kliknij przycisk `snoop`."

msgid "misc_terms.incorrect_mode"
msgstr "Kod jest poprawny, ale nie został uruchomiony zgodnie z instrukcją."

msgid "misc_terms.invalid_inputs"
msgstr ""
"Wartości twoich zmiennych wejściowych są niepoprawne, spróbuj użyć wartości "
"podobnych do przykładu."

msgid "misc_terms.must_define_function"
msgstr "Musisz zdefiniować funkcję `{function_name}`"

msgid "misc_terms.no_more_test_inputs"
msgstr ""
"Nie ma więcej testowych danych wejściowych - rozwiązanie powinno się już "
"zakończyć"

msgid "misc_terms.not_a_function"
msgstr "`{function_name}` nie jest funkcją."

msgid "misc_terms.q_wiz_debugger"
msgstr ""
"Świetnie, że używasz debugera! Rozwiązanie problemu samodzielnie jest "
"idealne. Jeśli nie możesz, użyj przycisku 'Run', aby wygenerować pytanie."

msgid "misc_terms.q_wiz_final_message"
msgstr ""
"\n"
"Świetnie! Oto kilka końcowych wskazówek:\n"
"\n"
"- Upewnij się, że wynik pokazuje problem, który masz, a nie coś innego.\n"
"- Zredukuj swój kod do **minimalnego** przykładu. Usuń wszelki kod, który nie jest bezpośrednio związany z problemem.\n"
"- Przeprowadź swój kod przez debugery `snoop`, `birdseye` i Python Tutor, aby zrozumieć, co robi.\n"
"- Poszukaj rozwiązania swojego problemu w internecie.\n"
"- Przeczytaj [Jak zadać dobre pytanie?](https://stackoverflow.com/help/how-to-ask)\n"
"\n"
"Jeśli jesteś naprawdę gotowy, skopiuj i wklej poniższe na stronę z pytaniem,\n"
"i zastąp pierwszą linię opisem swojego problemu.\n"
"\n"
"Możesz nadal zmieniać swój kod lub oczekiwany wynik i kliknąć Run ponownie, aby wygenerować pytanie na nowo.\n"
"\n"
"    __copyable__\n"
"    *Wyjaśnij, co próbujesz zrobić i dlaczego*\n"
"\n"
"    Oto mój kod:\n"
"\n"
"{}\n"
"\n"
"    To jest wynik:\n"
"\n"
"{}\n"
"\n"
"    Oczekiwany wynik to:\n"
"\n"
"{}\n"

msgid "misc_terms.q_wiz_input_and_add"
msgstr ""
"i dodaj\n"
"\n"
"    {list_line}\n"
"\n"
"na początku twojego kodu."

msgid "misc_terms.q_wiz_input_message_start"
msgstr ""
"`input()` utrudnia zadawanie pytań i udzielanie odpowiedzi dotyczących kodu."
" Zastąp wywołania funkcji input łańcuchami znaków, tak aby każdy mógł "
"natychmiast uruchomić kod oraz otrzymać te same wyniki."

msgid "misc_terms.q_wiz_input_replace_with"
msgstr ""
"Zastąp:\n"
"\n"
"{original_lines}\n"
"\n"
"tym:\n"
"\n"
"{replaced_lines}"

msgid "misc_terms.q_wiz_no_output"
msgstr ""
"Twój kod nic nie wyświetlił. Dodaj kilka wywołań `print()`, tak aby chociaż "
"coś zostało wyświetlone. Użyj kodu, aby pokazać czytelnikom dokładnie, gdzie"
" jest problem."

msgid "misc_terms.q_wiz_same_as_expected_output"
msgstr ""
"Twój wynik jest taki sam jak oczekiwany! Jeśli problem nadal istnieje, "
"dopasuj swój kod i/lub oczekiwany wynik, tak aby te dwa wyniki się nie "
"zgadzały. Wyraźnie pokaż, co by było inaczej, gdyby kod działał tak, jak "
"chcesz."

msgid "misc_terms.signature_should_be"
msgstr ""
"Sygnatura powinna wyglądać:\n"
"\n"
"    def {function_name}{needed_signature}:\n"
"\n"
"nie:\n"
"\n"
"    def {function_name}{actual_signature}:"

msgid "misc_terms.string_spaces_differ"
msgstr ""
"Sprawdź, czy ciągi znaków w twoim kodzie mają poprawne spacje. Na przykład, "
"`'Hello'` różni się od `'Hello '` ze względu na spację na końcu."

msgid "misc_terms.syntax_error_at_line"
msgstr "w linii"

msgid "misc_terms.when_it_should_output"
msgstr "gdy powinno wyświetlić:"

msgid "misc_terms.which_is_correct"
msgstr "co jest poprawne!"

msgid "misc_terms.your_code_outputs"
msgstr "Twój kod wypisuje:"

msgid "misc_terms.your_code_outputs_given_values"
msgstr ""
"Biorąc pod uwagę te wartości:\n"
"\n"
"{given_values}\n"
"\n"
"twój kod wypisuje:"

msgid "output_predictions.Error"
msgstr "Błąd"

msgid "pages.AddingStrings.steps.final_text.text"
msgstr ""
"Brawo! Każde z poniższych rozwiązań jest poprawne:\n"
"\n"
"__code0__"

msgid "pages.AddingStrings.steps.hello_world_concat.text"
msgstr ""
"Łańcuchy znaków można łączyć za pomocą '+', jednak oznacza to coś zupełnie innego niż dodawanie liczb. Na przykład, spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.AddingStrings.steps.hello_world_space.hints.0.text"
msgstr "Spacja to znak tak samo jak każdy inny, np. 'o' lub 'w'."

msgid "pages.AddingStrings.steps.hello_world_space.hints.1.text"
msgstr "Znak spacji musi znajdować się gdzieś wewnątrz cudzysłowów."

msgid ""
"pages.AddingStrings.steps.hello_world_space.messages.literal_answer.text"
msgstr "Wciąż musisz dodać dwa lub więcej łańcuchy znaków do siebie."

msgid "pages.AddingStrings.steps.hello_world_space.requirements"
msgstr ""
"Użyj '+', aby dodać dwa lub więcej łańcuchów znaków do siebie, tak aby "
"wynikiem było łańcuch `'hello world'`."

msgid "pages.AddingStrings.steps.hello_world_space.text"
msgstr ""
"Możesz zauważyć, że `+` łączy dwa łańcuchy znaków jeden po drugim. Technicznie jest to nazywane konkatenacją.\n"
"\n"
"Oto ćwiczenie: zmień nieznacznie poprzedni kod, tak aby wynikiem była łańcuch `'hello world'`, czyli ze spacją między słowami.\n"
"\n"
"Przy okazji, jeśli utkniesz, możesz kliknąć ikonę żarówki w prawym dolnym rogu, aby uzyskać podpowiedź."

msgid "pages.AddingStrings.title"
msgstr "Łączenie łańcuchów znaków"

msgid "pages.BasicForLoopExercises.steps.final_text.text"
msgstr ""
"Robimy naprawdę duże postępy! Rozwiązujesz problemy i piszesz nowy kod!\n"
"Przed nami jeszcze ciekawsze rzeczy."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_1.hints.0.text"
msgstr ""
"Powinieneś użyć tylko jednego `print`, ponieważ każdy print wypisuje w nowej"
" linii."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_1.hints.1.text"
msgstr "Będziesz musiał użyć `+`."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_1.text"
msgstr ""
"Czas na ćwiczenia! Zmodyfikuj ten program:\n"
"\n"
"__code0__\n"
"\n"
"aby zamiast tego wyświetlił:\n"
"\n"
"    __no_auto_translate__\n"
"    ---W\n"
"    ---o\n"
"    ---r\n"
"    ---l\n"
"    ---d"

msgid "pages.BasicForLoopExercises.steps.loop_exercise_2.hints.0.text"
msgstr ""
"Na chwilę zapomnij o pętlach. Jak byś napisał program, który wypisze `name` "
" 3 razy?"

msgid "pages.BasicForLoopExercises.steps.loop_exercise_2.hints.1.text"
msgstr ""
"Rozwiązanie wygląda bardzo podobnie do innych programów, które widzieliśmy w"
" tej sekcji."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_2.hints.2.text"
msgstr ""
"Pętla for stworzy zmienną taką jak `character`, ale program nie musi jej "
"wykorzystywać."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_2.text"
msgstr ""
"Świetnie! Napisz teraz program, który wypisze `name` tyle razy, ile ma liter. Na przykład dla `name = 'Amy'`, program powinien wypisać:\n"
"\n"
"    __no_auto_translate__\n"
"    Amy\n"
"    Amy\n"
"    Amy\n"
"\n"
"Dla `name = 'World'`, powinien program powinien wypisać:\n"
"\n"
"    __no_auto_translate__\n"
"    World\n"
"    World\n"
"    World\n"
"    World\n"
"    World\n"
"\n"
"Pamiętaj, że możesz ustawić jakąkolwiek wartość zmiennej `name` w pierwszej linii. Jedynie kod znajdujący się poniżej będzie sprawdzony."

msgid "pages.BasicForLoopExercises.title"
msgstr "Podstawowe ćwiczenia z pętlą for"

msgid "pages.BasicTerminology.steps.final_text.text"
msgstr ""
"Oto słowa, które powinieneś znać:\n"
"\n"
"***Wyrażenie*** (ang. expression) to fragment kodu, który ma wartość. Na przykład, w tej linii kodu:\n"
"\n"
"    __no_auto_translate__\n"
"    sentence = 'Hello ' + name\n"
"\n"
"mamy trzy wyrażenia:\n"
"\n"
"1. `'Hello '`\n"
"2. `name`\n"
"3. `'Hello ' + name`\n"
"\n"
"Natomiast pełna linia `sentence = ...` to ***instrukcja*** (ang. statement). To polecenie, które mówi komputerowi, by wykonał akcję. Samo w sobie nie ma wartości. Oznacza to na przykład, że nie można dodawać do siebie instrukcji. Ten kod jest błędny:\n"
"\n"
"    (word = 'Hello') + (name = 'Bob')\n"
"\n"
"Konkretnie, instrukcja taka jak `sentence = ...` w której zmiennej przypisywana jest wartość, nazywana jest ***przypisaniem*** (ang. assignment) - wartość jest *przypisana do* zmiennej.\n"
"\n"
"Program to lista instrukcji, które są wykonane w kolejności. Pętla `for` to *złożona instrukcja* (ang. compound statement), co oznacza, że posiada ciało, zawierające inne instrukcje. Większość instrukcji będzie również zawierać wyrażenia, i wyrażenia mogą zawierać inne, mniejsze wyrażenia, ale wyrażenia nie mogą zawierać instrukcji.\n"
"\n"
"Proces obliczania wartości wyrażenia nazywa się ***ewaluacją*** (ang. evaluation) - zauważ, jak niemal zawiera słowo 'wartość' (ang. value). Komputer *ewaluuje* `1 + 2`, by uzyskać wartość `3`.\n"
"\n"
"Proces wykonywania pętli nazywa się ***iteracją*** (ang. iteration). Kod taki jak `for char in 'Hello':` *iteruje po* (ang. iterating over) łańcuchu znaków `'Hello'`. Fakt, że jest to możliwe, oznacza, że łańcuchy znaków są *iterowalne* (ang. iterable). W przeciwieństwie do tego, liczby nie są iterowalne, co Python powie ci dosłownie, jeśli spróbujesz wykonać `for char in 3:`. Każde wykonanie pętli to *jedna iteracja*, więc w tym przykładzie będzie ich 5."

msgid "pages.BasicTerminology.title"
msgstr "Podstawowe pojęcia"
msgid "pages.BuildingNewLists.steps.double_numbers.hints.0.text"
msgstr "Pamiętaj, że możesz mnożyć liczby używając `*`."

msgid "pages.BuildingNewLists.steps.double_numbers.hints.1.text"
msgstr ""
"Ten program jest strukturalnie bardzo podobny do programów, które pisałeś, "
"budując łańcuchy znaków znak po znaku."

msgid "pages.BuildingNewLists.steps.double_numbers.hints.2.text"
msgstr ""
"Utwórz nową listę, a następnie zbuduj ją element po elemencie w pętli for."

msgid "pages.BuildingNewLists.steps.double_numbers.hints.3.text"
msgstr "Zacznij od pustej listy."

msgid "pages.BuildingNewLists.steps.double_numbers.hints.4.text"
msgstr "Możesz utworzyć listę z jednym elementem `x`, po prostu pisząc `[x]`."

msgid "pages.BuildingNewLists.steps.double_numbers.hints.5.text"
msgstr ""
"Możesz dodać element do listy, dodając listę zawierającą jeden element."

msgid "pages.BuildingNewLists.steps.double_numbers.text"
msgstr ""
"Listy i łańcuchy znaków mają wiele wspólnego.\n"
"Na przykład, możesz dodać dwie listy, aby połączyć je w nową listę.\n"
"Możesz także utworzyć pustą listę, która nie ma żadnych elementów.\n"
"Sprawdź to sam:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Z tą wiedzą, napisz program, który bierze listę liczb\n"
"i wyświetla listę, w której każda liczba została podwojona. Na przykład, mając:\n"
"\n"
"__code1__\n"
"\n"
"wypisałby:\n"
"\n"
"__code2__"

msgid "pages.BuildingNewLists.steps.filter_numbers.disallowed.0.message"
msgstr ""
"Brawo, to jest poprawne! Jednak powinieneś użyć `.append()` zamiast `+=`."

msgid "pages.BuildingNewLists.steps.filter_numbers.hints.0.text"
msgstr "To jest bardzo podobne do poprzedniego ćwiczenia."

msgid "pages.BuildingNewLists.steps.filter_numbers.hints.1.text"
msgstr ""
"Różnica polega na tym, że czasami powinieneś pominąć dodawanie do nowej "
"listy."

msgid "pages.BuildingNewLists.steps.filter_numbers.hints.2.text"
msgstr "Użyj instrukcji `if`."

msgid "pages.BuildingNewLists.steps.filter_numbers.hints.3.text"
msgstr ""
"Użyj operatora porównania, aby przetestować, czy liczba jest wystarczająco "
"duża, aby ją dodać."

msgid "pages.BuildingNewLists.steps.filter_numbers.text"
msgstr ""
"Świetnie!\n"
"\n"
"Gdy chcesz dodać pojedynczy element na koniec listy, zamiast:\n"
"\n"
"__code0__\n"
"\n"
"częściej pisze się:\n"
"\n"
"__code1__\n"
"\n"
"Nie ma naprawdę dużej różnicy między tymi dwoma sposobami, ale `.append`\n"
"będzie bardziej znajomy i czytelny dla większości osób.\n"
"\n"
"Teraz użyj `.append`, aby napisać program, który bierze listę liczb i\n"
"wyświetla nową listę zawierającą tylko te liczby, które są większe niż 5.\n"
"\n"
"Na przykład, mając:\n"
"\n"
"__code2__\n"
"\n"
"wypisałby:\n"
"\n"
"__code3__"

msgid "pages.BuildingNewLists.steps.final_text.text"
msgstr "Fantastycznie! Robimy duże postępy."

msgid "pages.BuildingNewLists.title"
msgstr "Budowanie nowych list"

msgid "pages.BuildingUpStrings.steps.empty_string.text"
msgstr ""
"Ostatni znak w `name` jest dodawany do `line` tylko na końcu pętli, po tym jak `print(line)` już zostało wykonane po raz ostatni. Więc ten znak i pełna `name` nigdy nie zostają wydrukowane na dole trójkąta. Jeśli jesteś zdezorientowany, spróbuj umieścić `print(line)` zarówno przed, jak i po `line = line + char`.\n"
"\n"
"Zróbmy coś z tymi znakami `-` na wyjściu. Możesz już być w stanie zgadnąć jak.\n"
"\n"
"*Pusty łańcuch* (ang. empty string) to łańcuch nie zawierający w ogóle znaków.\n"
"Jest zapisany jako para apostrofów otaczających nic: `''`.\n"
"To jest jak zero, tylko że dla łańcuchów znaków.\n"
"Dodanie go do innego łańcucha daje ci po prostu niezmieniony drugi łańcuch,\n"
"tak samo jak `0 + 5` to po prostu `5`.\n"
"\n"
"Spróbuj tego w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.BuildingUpStrings.steps.final_text.text"
msgstr ""
"Czyż to nie jest piękne?\n"
"\n"
"Wzór rozpoczęcia od czegoś pustego i budowania tego w pętli `for` jest *bardzo* częsty\n"
"i będziesz miał z tym dużo praktyki. Niektóre początkowe puste wartości to\n"
"`''`, `0` i `[]` - pusta lista, o której wkrótce się dowiesz."

msgid ""
"pages.BuildingUpStrings.steps.hello_plus_equals.output_prediction_choices.0"
msgstr ""
"Hello\n"
"Hello"

msgid ""
"pages.BuildingUpStrings.steps.hello_plus_equals.output_prediction_choices.1"
msgstr ""
"Hello\n"
"Hello!"

msgid ""
"pages.BuildingUpStrings.steps.hello_plus_equals.output_prediction_choices.2"
msgstr ""
"Hello!\n"
"Hello!"

msgid "pages.BuildingUpStrings.steps.hello_plus_equals.text"
msgstr ""
"Zanim przyjrzymy się kilku pętlom, musimy szybko poznać kolejne pojęcie. Spójrz na ten program:\n"
"\n"
"__program_indented__\n"
"\n"
"Co myślisz, robi linia `hello = hello + '!'`? Uruchom program, aby się dowiedzieć."

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.0"
msgstr ""
"-\n"
"W\n"
"-\n"
"o\n"
"-\n"
"r\n"
"-\n"
"l\n"
"-\n"
"d"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.1"
msgstr ""
"-W\n"
"-o\n"
"-r\n"
"-l\n"
"-d"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.2"
msgstr "-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.3"
msgstr "-W-o-r-l-d"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.4"
msgstr ""
"-W\n"
"-Wo\n"
"-Wor\n"
"-Worl\n"
"-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.5"
msgstr ""
"-World\n"
"-Worl\n"
"-Wor\n"
"-Wo\n"
"-W"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.6"
msgstr ""
"-World\n"
"-World\n"
"-World\n"
"-World\n"
"-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.7"
msgstr ""
"-World\n"
"--World\n"
"---World\n"
"----World\n"
"-----World"

msgid "pages.BuildingUpStrings.steps.name_triangle.text"
msgstr ""
"Pythonowi nie przeszkadza, że `hello` znajduje się zarówno po lewej, jak i prawej stronie `=`, po prostu robi to, co zawsze by zrobił, gdyby zmienne były inne: oblicza `hello + '!'`, co w tym przypadku jest `'Hello' + '!'`, co daje `'Hello!'`, i to staje się nową wartością `hello`. Jeśli to pomoże, możesz myśleć o tej linii jako podzielonej na dwa kroki:\n"
"\n"
"__code0__\n"
"\n"
"lub:\n"
"\n"
"__code1__\n"
"\n"
"To jest bardzo użyteczne w pętli. Wypróbuj ten program:\n"
"\n"
"__program_indented__"

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.0.text"
msgstr ""
"Najpierw upewnij się, że nie pracujesz na uszkodzonej wersji poprzedniego "
"programu na tej stronie."

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.1.text"
msgstr "Czyli `line = line + char` powinno być przed `print(line)`."

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.2.text"
msgstr "Poza tym musisz dokonać tylko jednej ***malutkiej*** zmiany."

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.3.text"
msgstr "Chcemy pozbyć się `-`. Więc po prostu to zrób. Dosłownie."

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.4.text"
msgstr "Użyj pustego łańcucha!"

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.text"
msgstr ""
"Nie myl pustego łańcucha z `' '`, który jest niepustym łańcuchem zawierającym jeden znak: spację.\n"
"\n"
"Teraz napraw oryginalny program, aby pozbyć się tych linii w wyjściu, tak aby\n"
"dla `name = 'World'` wydrukowało:\n"
"\n"
"    __no_auto_translate__\n"
"    W\n"
"    Wo\n"
"    Wor\n"
"    Worl\n"
"    World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle_missing_last_line.output_prediction_choices.0"
msgstr ""
"-W\n"
"-Wo\n"
"-Wor\n"
"-Worl\n"
"-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle_missing_last_line.output_prediction_choices.1"
msgstr ""
"-Wo\n"
"-Wor\n"
"-Worl\n"
"-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle_missing_last_line.output_prediction_choices.2"
msgstr ""
"-\n"
"-W\n"
"-Wo\n"
"-Wor\n"
"-Worl"

msgid "pages.BuildingUpStrings.steps.name_triangle_missing_last_line.text"
msgstr ""
"Poświęć czas, aby całkowicie zrozumieć ten program. Robi coś w rodzaju:\n"
"\n"
"    line = '-'\n"
"\n"
"    char = 'W'\n"
"    line = line + char\n"
"         = '-' + 'W'\n"
"         = '-W'\n"
"    print('-W')\n"
"\n"
"    char = 'o'\n"
"    line = line + char\n"
"         = '-W' + 'o'\n"
"         = '-Wo'\n"
"    print('-Wo')\n"
"\n"
"    char = 'r'\n"
"    line = line + char\n"
"         = '-Wo' + 'r'\n"
"         = '-Wor'\n"
"    print('-Wor')\n"
"\n"
"    ...\n"
"\n"
"Szczegóły są ważne. Co się stanie, jeśli zamienisz ostatnie dwie linie i uruchomisz ten program zamiast tego?\n"
"\n"
"__program_indented__"

msgid "pages.BuildingUpStrings.title"
msgstr "Budowanie łańcuchów tekstowych"

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.0.text"
msgstr ""
"Pierwsza litera powinna mieć 0 spacji przed nią, druga litera powinna mieć 1"
" spację przed nią, trzecia powinna mieć 2, itd."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.1.text"
msgstr ""
"Powinieneś trzymać spacje w zmiennej i budować je w pętli, jak wcześniej."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.2.text"
msgstr ""
"Różnica polega na tym, że musisz wydrukować litery jednocześnie z "
"zbudowaniem spacji."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.3.text"
msgstr "Innymi słowy, potrzebujesz pojedynczej pętli, która robi to i to."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.4.text"
msgstr "Ciało pętli musi wydrukować spacje i litery, a także dodać spację."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.5.text"
msgstr ""
"Ponieważ pierwsza litera nie powinna mieć spacji przed nią, musisz dodać "
"spację po wydrukowaniu litery."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.messages.add_space_first.text"
msgstr ""
"Prawie tam! Masz jedną spację za dużo przed każdą literą.\n"
"Upewnij się, że pierwszy raz gdy twoja pętla wywoła `print`\n"
"twoja zmienna, która będzie zawierać spacje, jest pustym ciągiem.\n"
"Sprawdź kolejność swojego kodu."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.text"
msgstr ""
"Cudownie! Naprawdę Łapiesz to!\n"
"\n"
"Jeśli chcesz, możesz zrobić jeden dodatkowy opcjonalny bonusowy wyzwanie poniżej.\n"
"Jeśli nie, możesz po prostu kontynuować do [następnej strony](#BasicTerminology) teraz.\n"
"Możesz wrócić i zrobić to później, jeśli chcesz.\n"
"\n"
"Spróbuj napisać program, który wyświetli podaną `name` w przekątnej linii, na przykład:\n"
"\n"
"    W\n"
"     o\n"
"      r\n"
"       l\n"
"        d"


msgid "pages.BuildingUpStringsExercises.steps.final_text.text"
msgstr "Wow, nic Cię nie powstrzyma!"

msgid "pages.BuildingUpStringsExercises.steps.name_box.disallowed.0.message"
msgstr ""
"Dobra robota, to rozwiązanie jest poprawne! Jednak można je ulepszyć.\n"
"Wystarczy użyć jednej pętli - użycie więcej jest nieefektywne.\n"
"Możesz ponownie użyć zmiennej zawierającej linię z `-` i `+`."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.0.text"
msgstr ""
"Zrobiłeś już wszystkie trudne rzeczy w poprzednim ćwiczeniu. Teraz to tylko "
"proste dodawanie łańcuchów."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.1.text"
msgstr ""
"Potrzebujesz tylko jednej pętli for - tej używanej do tworzenia linii "
"myślników z poprzedniego ćwiczenia."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.2.text"
msgstr ""
"Nie próbuj zrobić wszystkiego naraz. Podziel problem na mniejsze, łatwiejsze"
" podproblemy."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.3.text"
msgstr ""
"Spróbuj napisać program, który wyświetla:\n"
"\n"
"    -----\n"
"    World\n"
"    -----"

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.4.text"
msgstr ""
"Ponieważ musisz wydrukować trzy oddzielne linie tekstu, będziesz musiał "
"zadzwonić `print()` trzy razy."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.5.text"
msgstr ""
"Spróbuj napisać program, który wyświetla:\n"
"\n"
"    |World|"

msgid "pages.BuildingUpStringsExercises.steps.name_box.text"
msgstr ""
"Fantastycznie!\n"
"\n"
"Przy okazji, gdy nie potrzebujesz używać zmiennej, powszechną konwencją jest nazwanie tej zmiennej `_` (podkreślenie), na przykład `for _ in name:`. Nie zmienia to działania programu, ale jest pomocne dla czytelników.\n"
"\n"
"Zróbmy to bardziej wyszukane. Rozszerz swój program, aby narysować ramkę wokół nazwy, taką jak tutaj:\n"
"\n"
"    +-----+\n"
"    |World|\n"
"    +-----+"

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.disallowed.0.message"
msgstr ""
"Dobra robota, to rozwiązanie jest poprawne!\n"
"I użyłeś pętli zagnieżdżonej (pętli wewnątrz pętli), której jeszcze nie omawialiśmy!\n"
"Jednakże w tym przypadku pętla zagnieżdżona jest nieefektywna.\n"
"Możesz utworzyć zmienną zawierającą spacje i wykorzystać to w każdej linii."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.hints.0.text"
msgstr "Będziesz potrzebować dwóch oddzielnych pętli for nad `name`."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.hints.1.text"
msgstr ""
"Każda linia z wyjątkiem pierwszej i ostatniej ma te same znaki w środku. To "
"znaczy, że możesz coś wykorzystać ponownie."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.hints.2.text"
msgstr "Stwórz zmienną zawierającą spacje w środku i używaj jej wiele razy."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.hints.3.text"
msgstr ""
"Użyj jednej pętli, aby stworzyć wiele spacji, i drugiej pętli, aby "
"wydrukować wiele linii używając wcześniej stworzonych spacji."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.text"
msgstr ""
"Coraz lepiej Ci idzie! Wygląda na to, że potrzebujesz większego wyzwania... może zamiast umieszczać nazwę w ramce, sama nazwa powinna być ramką? Napisz program, który wyświetla to:\n"
"\n"
"    +World+\n"
"    W     W\n"
"    o     o\n"
"    r     r\n"
"    l     l\n"
"    d     d\n"
"    +World+"

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.0.text"
msgstr ""
"Rozwiązanie jest bardzo podobne do oryginalnego programu trójkąta, wystarczy"
" zrobić jedną małą zmianę."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.1.text"
msgstr ""
"Chcesz nadal dodawać po jednym znaku do `line`, to tylko kwestia tego, gdzie"
" dodajesz go."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.2.text"
msgstr "Chcesz, aby linie były odwrócone, więc musisz odwrócić coś."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.3.text"
msgstr "Potrzebujesz dodać znak przed ciągiem, zamiast po."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.4.text"
msgstr ""
"3 + 7 to to samo co 7 + 3. Tak samo dla wszystkich liczb. Czy to samo "
"dotyczy ciągów znaków?"

msgid "pages.BuildingUpStringsExercises.steps.name_triangle_backwards.text"
msgstr ""
"Świetnie! Teraz zmodyfikuj program tak, aby każda linia była odwrócona, na przykład tak:\n"
"\n"
"    __no_auto_translate__\n"
"    W\n"
"    oW\n"
"    roW\n"
"    lroW\n"
"    dlroW"

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_spaced.hints.0.text"
msgstr "Będziesz potrzebować użyć jednego `+` więcej."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_spaced.hints.1.text"
msgstr ""
"Będziesz potrzebować użyć ciągu składającego się z jednej spacji: `' '`."

msgid "pages.BuildingUpStringsExercises.steps.name_triangle_spaced.text"
msgstr ""
"Zmodyfikuj ten program:\n"
"\n"
"__code0__\n"
"\n"
"aby dodać spację po każdej literze w trójkącie, tak aby wyglądało to tak:\n"
"\n"
"    W\n"
"    W o\n"
"    W o r\n"
"    W o r l\n"
"    W o r l d"

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.hints.0.text"
msgstr "Spójrz na program w kształcie trójkąta w poszukiwaniu inspiracji."

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.hints.1.text"
msgstr ""
"Spójrz na program, w którym wydrukowałeś `name` raz dla każdego znaku w "
"poszukiwaniu inspiracji."

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.hints.2.text"
msgstr ""
"Będziesz musiał zbudować łańcuch myślników (`-`) dodając po jednym znaku na "
"raz."

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.hints.3.text"
msgstr ""
"Pętla for stworzy zmienną, taką jak `char`, ale program nie musi jej używać."

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.text"
msgstr ""
"Wspaniale!\n"
"\n"
"Kod taki jak:\n"
"\n"
"__code0__\n"
"\n"
"jest tak powszechny w Pythonie, że można go skrócić. Oznacza to samo:\n"
"\n"
"__code1__\n"
"\n"
"Zwróć uwagę, że nie ma skrótu dla `line = char + line`.\n"
"\n"
"Teraz użyj `+=` i pętli for, aby napisać własny program, który wydrukuje `name` podkreślone, jak tutaj:\n"
"\n"
"    World\n"
"    -----\n"
"\n"
"Powinien być jeden `-` dla każdej litery w `name`."

msgid "pages.BuildingUpStringsExercises.title"
msgstr "Ćwiczenia: Budowanie łańcuchów znaków"

msgid "pages.CallingFunctionsTerminology.steps.final_text.text"
msgstr ""
"Słowo 'atrybut' w komunikacie o błędzie odnosi się do użycia `.` - błąd "
"pochodzi właściwie tylko z `word.append`, nawet bez wywołania."

msgid "pages.CallingFunctionsTerminology.steps.introducing_callable.text"
msgstr ""
"Wyrażenie takie jak `len(things)` lub `print(things)` to ***wywołanie*** funkcji (ang. function call), - gdy to piszesz, ***wywołujesz*** funkcję `len` lub `print`. Fakt, że jest to możliwe, oznacza, że funkcje są ***wywoływalne*** (ang. callable):\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.len_of_none.text"
msgstr ""
"`None` to specjalna wartość 'null', która nie może zrobić nic ciekawego. To powszechny symbol zastępczy reprezentujący brak realnej, użytecznej wartości. Funkcje, które nie chcą niczego zwracać, domyślnie zwracają `None`. Jeśli widzisz komunikat o błędzie dotyczący `None` lub `NoneType`, często oznacza to, że przypisałeś coś niewłaściwego do zmiennej:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.methods_of_str.text"
msgstr ""
"***Metoda*** to funkcja należąca do typu, którą można wywołać na wszystkich wartościach tego typu, używając `.`. Na przykład `upper` i `lower` to metody ciągów znaków, które są wywoływane z użyciem np. `word.upper()`:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.no_append_for_str.text"
msgstr ""
"Kolejnym przykładem jest to, że `append` to metoda list. Ale nie możesz użyć `.upper` na liście ani `.append` na ciągu znaków:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.not_callable.text"
msgstr ""
"Większość rzeczy nie jest wywoływalna, więc próba ich wywołania spowoduje błąd:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.print_functions.text"
msgstr ""
"Nadszedł czas, by poszerzyć twoje słownictwo jeszcze bardziej.\n"
"\n"
"`print` i `len` to ***funkcje***. Zobacz sam:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.print_returns_none.text"
msgstr ""
"W wywołaniu `len(things)`, `things` to ***argument***. Czasami spotkasz się też ze słowem ***parametr***, które oznacza w zasadzie to samo co argument. To trochę jakbyś przekazywał argument funkcji - konkretnie mówimy, że argument `things` jest *przekazywany* do `len`, a `len` *akceptuje* lub *odbiera* argument.\n"
"\n"
"`len(things)` wyliczy się do liczby, takiej jak 3, w takim przypadku mówimy, że `len` ***zwrócił*** 3.\n"
"\n"
"Wszystkie wywołania muszą coś zwrócić... nawet jeśli to nic. Na przykład, zadaniem funkcji `print` jest wyświetlenie czegoś na ekranie, a nie zwracanie użytecznej wartości. Dlatego zwraca coś bezużytecznego zamiast tego:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.title"
msgstr "Terminologia: Wywoływanie funkcji i metod"

msgid "pages.CallingFunctionsWithinFunctions.steps.final_text.text"
msgstr ""
"`birdseye` only shows one frame (function call) at a time. At first you see the global frame.\n"
"At the bottom is the call to `print_twice`. Click on the little blue arrow to take\n"
"you into that frame, and then click on the next one to enter `print_many`."

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.print_twice_call_print_many.text"
msgstr ""
"The body of a function can contain anything, including function calls. In fact we've already done that by calling\n"
"print. But calling one of our own functions is no different, so our functions can call each other!\n"
"\n"
"For example, we can implement `print_twice` using `print_many`:\n"
"\n"
"__program_indented__"

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.see_stack_in_birdseye.requirements"
msgstr "Run the same program as above, but with `birdseye`."

msgid "pages.CallingFunctionsWithinFunctions.steps.see_stack_in_birdseye.text"
msgstr ""
"Each time a function is called, a new *frame* is created, which contains the local variable values\n"
"in that call and other information about what's currently happening.\n"
"When the function call completes, the frame is deleted.\n"
"\n"
"You can see this in Python Tutor on the right under \"Frames\". At the top is the Global frame,\n"
"the top level frame where the whole program is running. As you click Next, new frames appear\n"
"and then disappear. In each one you can see the values of the variables.\n"
"\n"
"Finally, run the program with `birdseye`."

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.see_stack_in_pythontutor.requirements"
msgstr "Run the same program as above, but with Python Tutor."

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.see_stack_in_pythontutor.text"
msgstr ""
"`snoop` starts each function call with:\n"
"\n"
"1. A new level of indentation in the logs.\n"
"2. `>>> Call to <function name>`\n"
"3. The values of the arguments.\n"
"4. The function header line.\n"
"\n"
"It ends the call with `<<< Return value from <function name>`. We'll learn about return values soon.\n"
"\n"
"Now run the program again with Python Tutor."

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.see_stack_in_snoop.requirements"
msgstr "Run the same program as above, but with `snoop`."

msgid "pages.CallingFunctionsWithinFunctions.steps.see_stack_in_snoop.text"
msgstr ""
"It's important to get a good sense of what's going on here and to know how\n"
"to explore function calls, so we're going to try this out in each debugger.\n"
"\n"
"First, run the program again with `snoop`."

msgid "pages.CallingFunctionsWithinFunctions.title"
msgstr "Calling Functions Within Functions"

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.0.text"
msgstr "How many diagonals are there on the board?"

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.1.text"
msgstr ""
"Which entries of the three sublists make up each diagonal? How can you "
"access these entries?"

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.2.text"
msgstr "Every list always has 3 entries, so no need for a loop."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.3.text"
msgstr ""
"There are two problems to solve here: checking for a win in a specific "
"diagonal, and combining the checks for each diagonal."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.4.text"
msgstr "One problem can be solved using `and`, the other using `or`."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.5.text"
msgstr ""
"There's a lot of similarity with the `all_equal` function. You can even call"
" that function to help! But then you have to include its definition."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.6.text"
msgstr ""
"Similar to `all_equal`, check that the 3 entries on a diagonal are equal to "
"each other, e.g. by using `and`."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.7.text"
msgstr "Check the two diagonals together, using `or`."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.text"
msgstr ""
"If you read it casually from left to right, you may think that:\n"
"\n"
"__code0__\n"
"\n"
"is equivalent to\n"
"\n"
"__code1__\n"
"\n"
"but it's actually equivalent to\n"
"\n"
"__code2__\n"
"\n"
"This is because `and` has a higher priority than `or`.\n"
"This is important because the first interpretation reduces to `True and False` which is `False`, while the second\n"
"interpretation reduces to `True or False` which is `True`!\n"
"You can try both options with parentheses in the shell to confirm.\n"
"\n"
"**The lesson here is to be extra careful when combining operators.** Either add parentheses to be safe or\n"
"break up your expression into smaller parts and assign each part to a variable.\n"
"This will make your code clear, readable, and unambiguous, and will save you from painful mistakes.\n"
"\n"
"Time for an exercise. Suppose you're writing a program to play tic-tac-toe,\n"
"also known as noughts and crosses or Xs and Os. If you've never heard of tic-tac-toe, you can read the rules\n"
"and play a few games [here](https://gametable.org/games/tic-tac-toe/).\n"
"\n"
"We need to check if someone has won a game. Our function `all_equal` is already helpful for checking rows.\n"
"\n"
"Write a function to check if someone has won a game by placing 3 of the same pieces on one of the diagonal lines.\n"
"The board is given as a nested list `board` of 3 sublists, each sublist containing 3 strings, representing a row. For example:\n"
"\n"
"__code3__\n"
"\n"
"The function should return a boolean: `True` if one of the diagonals have 3 of the same pieces, `False` otherwise.\n"
"Click the Copy button to get started with the code below.\n"
"We provided some tests for you, your job is to replace the `...` with your code.\n"
"\n"
"    __copyable__\n"
"__code4__"

msgid "pages.CombiningAndAndOr.steps.CombiningAndOr.text"
msgstr ""
"If you use both `and` and `or` in a single expression, it's a lot like combining `*` and `+`.\n"
"The operators are evaluated in a specific order.\n"
"\n"
"For example, try the following code in the shell.\n"
"What do you expect?\n"
"\n"
"__program_indented__"

msgid "pages.CombiningAndAndOr.steps.final_text.text"
msgstr ""
"Well done! This was a hard one. Here are some possible solutions:\n"
"\n"
"__code0__\n"
"\n"
"or:\n"
"\n"
"__code1__"

msgid "pages.CombiningAndAndOr.title"
msgstr "Combining `and` and `or`"

msgid "pages.CombiningCompoundStatements.steps.final_text.text"
msgstr ""
"Zauważ, że ciało instrukcji `if` (4 linie) jest wcięte jak zwykle, podczas gdy ciało\n"
"pętli `for` (1 linia) jest wcięte o dodatkowe 4 spacje w każdej linii, aby pokazać, że\n"
"te linie są wewnątrz pętli `for`. Strukturę całego programu można zobaczyć\n"
"po prostu patrząc na wcięcia.\n"
"\n"
"Alternatywnie, możesz umieścić `if` w środku `for`:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Te dwa programy dają dokładnie ten sam wynik. Jednak pierwszy z nich jest bardziej wydajny, ponieważ\n"
"iteruje po łańcuchu tylko wtedy, gdy jest to potrzebne, ponieważ gdy `excited = False` nic się nie zmienia."

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.0"
msgstr "Hello World"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.2"
msgstr "Hello World!!!!!!!!!!!"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.3"
msgstr "!!!!!!!!!!!Hello World"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.4"
msgstr "Hello World!"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.5"
msgstr "!Hello World"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.6"
msgstr "!Hello World!"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.7"
msgstr "H!e!l!l!o! !W!o!r!l!d!"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.8"
msgstr "!H!e!l!l!o! !W!o!r!l!d"

msgid "pages.CombiningCompoundStatements.steps.for_inside_if.text"
msgstr ""
"Instrukcje złożone takie jak pętle `for` i instrukcje warunkowe `if` mają ciała, które są listą\n"
"wnętrznych instrukcji. Te wewnętrzne instrukcje mogą być czymkolwiek, włącznie z innymi złożonymi instrukcjami.\n"
"Spróbuj tego przykładu pętli `for` wewnątrz instrukcji `if`, gdy chcesz pokazać,\n"
"że jesteś *naprawdę* podekscytowany:\n"
"\n"
"__program_indented__"

msgid "pages.CombiningCompoundStatements.title"
msgstr "Łączenie instrukcji złożonych"

msgid "pages.DefiningFunctions.steps.change_function_name.hints.0.text"
msgstr ""
"You have to change the name in the function definition header, but that's "
"not all."

msgid "pages.DefiningFunctions.steps.change_function_name.hints.1.text"
msgstr ""
"If you just change the name in the function definition header, what happens?"

msgid "pages.DefiningFunctions.steps.change_function_name.hints.2.text"
msgstr ""
"You get an error. Look at the message. What is it telling you? Where does "
"the error come from?"

msgid "pages.DefiningFunctions.steps.change_function_name.hints.3.text"
msgstr ""
"If your function is called `say_hello`, what does `greet(\"Alice\")` mean?"

msgid "pages.DefiningFunctions.steps.change_function_name.hints.4.text"
msgstr "You need to change exactly 3 lines of the program."

msgid "pages.DefiningFunctions.steps.change_function_name.hints.5.text"
msgstr "In each line you change, change exactly one word."

msgid "pages.DefiningFunctions.steps.change_function_name.hints.6.text"
msgstr ""
"Don't touch the body of the function. It should still have `print(\"How are "
"you?\")`."

msgid "pages.DefiningFunctions.steps.change_function_name.hints.7.text"
msgstr ""
"You should still call the function twice after defining it, with arguments "
"`\"Alice\"` and `\"Bob\"`."

msgid "pages.DefiningFunctions.steps.change_function_name.text"
msgstr ""
"Note how the output of the program changed. `How are you?` is printed twice. You can think of the whole program as being\n"
"equivalent to this:\n"
"\n"
"__code0__\n"
"\n"
"This shows one of the most useful things about functions. They let you reuse the same code multiple times without\n"
"having to repeat yourself. It's like writing a program within a program.\n"
"\n"
"The header line of a function definition always has these parts:\n"
"\n"
"1. The special keyword `def`, followed by a space.\n"
"2. The name of the function. This is like a variable name - you can choose the name you want, but there are some constraints,\n"
"e.g. it can't contain a space.\n"
"3. A pair of parentheses `(` and `)`\n"
"4. Zero or more parameter names between the parentheses, separated by commas if there's more than one. Here we have\n"
"one parameter called `name`.\n"
"5. A colon `:`\n"
"\n"
"Let's do some simple exercises. Change the name of the function from `greet` to `say_hello`.\n"
"Make sure the whole program stays working as before, but don't change anything else."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.0.text"
msgstr ""
"You have to change the parameter name in the function definition header, but"
" that's not all."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.1.text"
msgstr ""
"If you just change the parameter name in the function definition header, "
"what happens?"

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.2.text"
msgstr ""
"You get an error. Look at the message. What is it telling you? Where does "
"the error come from?"

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.3.text"
msgstr ""
"If the parameter is called `person_name`, what does `print(f\"Hello "
"{name}!\")` mean?"

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.4.text"
msgstr "You need to change exactly 2 lines of the program."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.5.text"
msgstr "In each line you change, change exactly one word."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.6.text"
msgstr ""
"Don't touch the part after the function definition, i.e. "
"`say_hello(\"Alice\")` and `say_hello(\"Bob\")`."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.7.text"
msgstr ""
"You should still have two statements in the function body, including "
"`print(\"How are you?\")`."

msgid "pages.DefiningFunctions.steps.change_parameter_name.text"
msgstr ""
"Good! Now do a similar exercise: change the name of the parameter from "
"`name` to `person_name`."

msgid "pages.DefiningFunctions.steps.define_greet.text"
msgstr ""
"You've seen how to call functions such as `print()` and `len()`. Now you're going to learn how to write your own\n"
"functions that you or other people can use. This is very important as programs get bigger and more complicated.\n"
"\n"
"Here's a simple example:\n"
"\n"
"__program_indented__\n"
"\n"
"This defines a function called `greet` which accepts one parameter. Below the definition, we call the function twice.\n"
"Run the code to see what happens."

msgid "pages.DefiningFunctions.steps.final_text.text"
msgstr ""
"Perfect! Now you have a solid foundation of the basics of defining "
"functions."

msgid "pages.DefiningFunctions.steps.how_are_you.output_prediction_choices.0"
msgstr ""
"Hello Alice!\n"
"How are you?\n"
"Hello Bob!\n"
"How are you?"

msgid "pages.DefiningFunctions.steps.how_are_you.output_prediction_choices.1"
msgstr ""
"Hello Alice!\n"
"Hello Bob!\n"
"How are you?"

msgid "pages.DefiningFunctions.steps.how_are_you.output_prediction_choices.2"
msgstr ""
"Hello Alice!\n"
"How are you?\n"
"Hello Bob!"

msgid "pages.DefiningFunctions.steps.how_are_you.requirements"
msgstr ""
"Add `print(\"How are you?\")` after `print(f\"Hello {name}!\")` with the same indentation.\n"
"Keep the two calls to `greet` after the definition as is."

msgid "pages.DefiningFunctions.steps.how_are_you.text"
msgstr ""
"A function definition is a compound statement. Like `if` and `for`, it has a header line followed by an indented body\n"
"which can contain one or more statements.\n"
"\n"
"Add another statement to the function so that it looks like this:\n"
"\n"
"__code0__\n"
"\n"
"Then run the program again."

msgid "pages.DefiningFunctions.steps.print_many.output_prediction_choices.2"
msgstr ""
"Hello\n"
"Hello\n"
"Hello"

msgid "pages.DefiningFunctions.steps.print_many.output_prediction_choices.3"
msgstr "Hello"

msgid "pages.DefiningFunctions.steps.print_many.output_prediction_choices.4"
msgstr ""
"H\n"
"e\n"
"l\n"
"l\n"
"o"

msgid "pages.DefiningFunctions.steps.print_many.text"
msgstr ""
"Functions can have many parameters. Here's an example:\n"
"\n"
"__program_indented__"

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.0.text"
msgstr ""
"There's no clever problem solving here, this is just about following the "
"recipe for defining a function."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.1.text"
msgstr "Make sure you have all the parts of a function listed above."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.2.text"
msgstr "That includes `def`, `()`, and `:`."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.3.text"
msgstr "Make sure your function is named `print_twice`."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.4.text"
msgstr ""
"Make sure it accepts one parameter called `x` in between the parentheses "
"`()`."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.5.text"
msgstr "Look at the other functions defined above for help."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.6.text"
msgstr "Use the parameter inside the function body."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.7.text"
msgstr "Make sure the body is indented."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.8.text"
msgstr "The body needs two statements or a very simple loop."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.9.text"
msgstr ""
"Make sure that you don't call `print_twice` inside the function body of "
"`print_twice`. Check your indentation."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.requirements"
msgstr ""
"Write a program which defines a function called `print_twice` as described "
"above."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.text"
msgstr ""
"Well done!\n"
"\n"
"Now write your own function called `print_twice` which accepts one argument `x` and prints that argument twice\n"
"on two lines.\n"
"\n"
"For example, `print_twice(\"Hello\")` should output:\n"
"\n"
"__code0__\n"
"\n"
"You can test your function by calling it after the function definition, but it's not required."

msgid "pages.DefiningFunctions.steps.swap_parameters.hints.0.text"
msgstr ""
"The only change to the function definition should be the swapping of "
"parameters as instructed, nothing else."

msgid "pages.DefiningFunctions.steps.swap_parameters.hints.1.text"
msgstr "You need to fix the call to `print_many`."

msgid "pages.DefiningFunctions.steps.swap_parameters.hints.2.text"
msgstr ""
"If the function is defined as `def print_many(n, thing)`, what does "
"`print_many(\"Hello\", 3)` mean?"

msgid "pages.DefiningFunctions.steps.swap_parameters.hints.3.text"
msgstr "We still want `thing = \"Hello\"` and `n = 3`."

msgid "pages.DefiningFunctions.steps.swap_parameters.text"
msgstr ""
"Note the commas used to separate parameters in the function definition and arguments in the function call,\n"
"and the correspondence between the definition and the call:\n"
"\n"
"    def print_many(thing, n):\n"
"                     ^    ^\n"
"                     |    |\n"
"      print_many(\"Hello\", 3)\n"
"\n"
"So calling `print_many(\"Hello\", 3)` is like running:\n"
"\n"
"__code0__\n"
"\n"
"Now for another simple exercise. Swap around the parameters in the function definition header so that it says:\n"
"\n"
"__code1__\n"
"\n"
"If you do this and nothing else, you will get an error. Fix the rest of the program so that it behaves like before.\n"
"*Don't change the body of the function*."

msgid "pages.DefiningFunctions.title"
msgstr "Defining Functions"

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.hints.0.text"
msgstr ""
"Remember that we previously had `for item in cart` in the function, but "
"`cart` is no longer an argument."

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.hints.1.text"
msgstr ""
"Now `quantities` is the only argument that defines what the customer is "
"buying."

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.hints.2.text"
msgstr ""
"You need to iterate over the keys of `quantities` instead. Remember that "
"'iterate' here means 'loop over' with a `for` loop."

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.hints.3.text"
msgstr "You can use `.keys()`, but you don't have to."

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.text"
msgstr ""
"Now you can use this to modify our function on the previous page to remove the `cart` argument:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.DictionaryKeysAndValues.steps.english_to_french.hints.0.text"
msgstr "You will need to iterate (loop) over the dictionary."

msgid "pages.DictionaryKeysAndValues.steps.english_to_french.hints.1.text"
msgstr ""
"You need to print both the key (English word) and the value (French word) of"
" each dictionary entry."

msgid "pages.DictionaryKeysAndValues.steps.english_to_french.hints.2.text"
msgstr "You can get the value using the key in the same way as always."

msgid "pages.DictionaryKeysAndValues.steps.english_to_french.text"
msgstr ""
"That looks nice! We've fully solved the problem of adding up the total cost.\n"
"\n"
"Coming back to our first example: write a function\n"
"which prints out each word in an English-to-French dictionary and its translation, labeling them with their languages.\n"
"Here's your starting code:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"For example, the last line of code above should print:\n"
"\n"
"    English: apple\n"
"    French: pomme\n"
"    ---\n"
"    English: box\n"
"    French: boite\n"
"    ---"

msgid "pages.DictionaryKeysAndValues.steps.english_to_german.hints.0.text"
msgstr ""
"This is still very similar to the previous exercise, nothing special yet."

msgid "pages.DictionaryKeysAndValues.steps.english_to_german.hints.1.text"
msgstr ""
"You can reuse your previous solution, just add another argument and a tiny "
"bit of code inside."

msgid "pages.DictionaryKeysAndValues.steps.english_to_german.hints.2.text"
msgstr "You now have to print one dictionary key and two dictionary values."

msgid "pages.DictionaryKeysAndValues.steps.english_to_german.text"
msgstr ""
"Great! Now let's add a German dictionary as well:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"That should print:\n"
"\n"
"    English: apple\n"
"    French: pomme\n"
"    German: apfel\n"
"    ---\n"
"    English: box\n"
"    French: boite\n"
"    German: kasten\n"
"    ---\n"
"\n"
"The two dictionaries will always have the same keys, just different values."

msgid "pages.DictionaryKeysAndValues.steps.final_text.text"
msgstr ""
"Congratulations! You've reached the end of the course so far. More is on the"
" way!"

msgid "pages.DictionaryKeysAndValues.steps.introducing_keys.requirements"
msgstr "Run `print(quantities.keys())` where `quantities` is a dictionary."

msgid "pages.DictionaryKeysAndValues.steps.introducing_keys.text"
msgstr ""
"Copy this code into the editor:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Then change `print(quantities)` to `print(quantities.keys())`, and run the whole program."

msgid "pages.DictionaryKeysAndValues.steps.keys_are_iterable.text"
msgstr ""
"The `.keys()` method of `dict` does basically what you'd expect. You can iterate over the value it returns\n"
"just like you'd iterate over a list:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.DictionaryKeysAndValues.steps.keys_are_iterable2.requirements"
msgstr ""
"Run the same code as the previous step, but without `.keys()`. after "
"`quantities`, so the middle line is `for key in quantities:`"

msgid "pages.DictionaryKeysAndValues.steps.keys_are_iterable2.text"
msgstr ""
"Actually, you don't even need `.keys()`. Iterating directly over a dictionary automatically iterates over its keys.\n"
"Sometimes it's nice to write `.keys()` to make your code more readable, but you don't have to.\n"
"Remove the `.keys()` and run the code again."

msgid "pages.DictionaryKeysAndValues.steps.nested_dictionaries.text"
msgstr ""
"Beautiful! There's a pattern emerging here. The two languages could be merged into one big nested dictionary:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.DictionaryKeysAndValues.title"
msgstr "Iterating over Dictionary Keys"

msgid "pages.EqualsVsIs.steps.final_text.text"
msgstr ""
"Teraz `list1 is list2` to `True`, ponieważ *jest tylko jedna lista*, i obie zmienne\n"
"`list1` i `list2` odnoszą się do tej samej listy. `list1.append(4)` dodaje do jednej listy\n"
"i wynik można zobaczyć zarówno w `print(list1)`, jak i w `print(list2)`, ponieważ obie linie\n"
"są teraz po prostu różnymi sposobami wypisywania tej samej listy.\n"
"\n"
"Polecam uruchomić obie wersje z Python Tutor, aby zobaczyć, jak wizualizuje on różnicę.\n"
"W drugim przypadku obie zmienne mają strzałki wskazujące na jeden obiekt listy.\n"
"\n"
"`list2 = list1` nie tworzy wiecznego połączenia między zmiennymi. Jeśli przypiszesz nową wartość\n"
"*którejkolwiek* z zmiennych, np. `list1 = [7, 8, 9]`, druga zmienna nie będzie miała wpływu\n"
"i nadal będzie wskazywać na pierwotną listę.\n"
"\n"
"Najprościej - przypisanie takie jak:\n"
"\n"
"    list2 = <wyrażenie>\n"
"\n"
"oznacza 'spraw, by zmienna `list2` odnosiła się do tego, do czego zewaluuje się `<wyrażenie>`'.\n"
"Wartość nie jest kopiowana, co pozwala na to, że obie zmienne mogą wskazywać na tę samą listę.\n"
"Ale jak już wcześniej nauczyliśmy się, `list2` nie pamięta `<wyrażenie>`, tylko wartość.\n"
"Zmienna nie wie o innych zmiennych.\n"
"\n"
"Możesz skopiować listę za pomocą metody `copy`:\n"
"\n"
"__code0__\n"
"\n"
"To spowoduje, że program znów będzie się zachowywał jak pierwsza wersja.\n"
"\n"
"Jeśli napotkasz taki rodzaj problemu i nadal będziesz mieć trudności z zrozumieniem tych spraw, przeczytaj esej [Fakty i mity na temat nazw i wartości w Pythonie](https://nedbatchelder.com/text/names.html)."

msgid "pages.EqualsVsIs.steps.same_list.requirements"
msgstr ""
"Uruchom ten sam program co powyżej, ale zastąp *drugie* `[1, 2, 3]` przez "
"`list1`."

msgid "pages.EqualsVsIs.steps.same_list.text"
msgstr ""
"Ten program jest dość prosty i w większości składa się z rzeczy, które już znasz.\n"
"Tworzymy dwie zmienne, które odnoszą się do list.\n"
"Listy mają te same elementy, więc są one równe: `list1 == list2` to `True`.\n"
"\n"
"Ale jest tu nowy operator porównania: `is`. Tutaj `list1 is list2` to `False`.\n"
"Oznacza to, że mimo że dwie listy są równe,\n"
"są to nadal dwie oddzielne, odrębne, indywidualne listy.\n"
"W rezultacie, gdy dodajesz 4 do `list1`, zmienia się tylko `list1`.\n"
"\n"
"Teraz zmień `list2 = [1, 2, 3]` na `list2 = list1` i zobacz, jakie to robi różnice."

msgid "pages.EqualsVsIs.steps.two_separate_lists.text"
msgstr ""
"Nadszedł czas, aby nauczyć się niektórych szczegółów technicznych, które są często źle rozumiane i prowadzą do błędów.\n"
"Uruchom ten program:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.EqualsVsIs.title"
msgstr "`==` vs `is` i posiadanie wielu nazw dla jednej wartości"

msgid "pages.FunctionsAndMethodsForLists.steps.append_vs_concatenate.text"
msgstr ""
"Przyjrzyjmy się, jak pracować z listami. Załóżmy, że mamy listę `nums = [1, 2, 3]`. Możemy użyć:\n"
"\n"
"- **`append`**: Dodaje element na końcu listy. `nums.append(4)` zmienia listę na `[1, 2, 3, 4]`.\n"
"- **`len`**: Zwraca liczbę elementów. `len(nums)` wynosi `3`.\n"
"- **`range`**: `range(n)` to obiekt podobny do listy liczb od `0` do `n - 1`. Oznacza to, że zawiera `n` liczb. W szczególności, `range(len(nums))` jest jak `[0, 1, 2]`, które są indeksami każdego elementu w `nums`.\n"
"- **`[]` (indeksowanie)**: Pobiera wartość o danym indeksie. `nums[0]` to `1`, `nums[1]` to `2`, `nums[2]` to `3`.\n"
"- **`+`**: Konkatenacja list. `nums + [4, 5]` to `[1, 2, 3, 4, 5]`.\n"
"\n"
"Zauważ, że `nums.append(4)` modyfikuje istniejącą listę `nums`, podczas gdy `nums + [4, 5]` tego nie robi.\n"
"Aby zachować wartość `nums + [4, 5]`, można ją przypisać do *nowej zmiennej*.\n"
"Uruchom następujący kod:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.FunctionsAndMethodsForLists.steps.final_text.text"
msgstr "Świetna robota!"

msgid "pages.FunctionsAndMethodsForLists.steps.index_predict_exercise.text"
msgstr ""
"**`index`**: Znajduje pierwszy element o podanej wartości w liście i zwraca jego indeks\n"
"\n"
"__code0__\n"
"\n"
"Jeżeli podanej wartości nie ma w liście, interpreter zwróci błąd. Uruchom poniższy kod w shellu:\n"
"\n"
"__program_indented__"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno mieć dokładnie trzy instrukcje: `x = ['a', 'b', "
"'c']`, `y = ` po której następuje jedna linia dokładnie skopiowana z listy, "
"oraz `print(y)`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.1.text"
msgstr "Które linie kodu tworzą nową listę zamiast modyfikować?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.2.text"
msgstr "`x` to lista. Każdy element `x` to łańcuch znaków."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.3.text"
msgstr ""
"Możesz dodawać listy do siebie, możesz dodawać łańcuchy znaków do siebie, "
"ale nie możesz dodawać łańcucha znaków do listy."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.4.text"
msgstr "Jak zrobić listę zawierającą jeden element?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.requirements"
msgstr ""
"Skopiuj trzy powyższe linie, a następnie zastąp "
"`(wstaw_jedną_linię_z_powyżej)` dokładnie jedną linią z długiej listy linii "
"wcześniejszych. Musisz wybrać poprawną linię, jest tylko jedna właściwa "
"odpowiedź. Wpisz linię dokładnie. Nie zastępuj części `y = `, powinna być "
"tam przed linią, którą wpiszesz, w tej samej linii."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.text"
msgstr ""
"Świetnie!\n"
"\n"
"Możesz zdać sobie sprawę, że praca z ostatnim elementem za pomocą `x[len(x) - 1]` jest nieco kłopotliwa.\n"
"To samo można osiągnąć przez `x[-1]`.\n"
"Podobnie, przedostatni element `x[len(x) - 2]` można zapisać jako `x[-2]`, i tak dalej.\n"
"Python pozwala nam także liczyć indeks do tyłu, zaczynając od ostatniego elementu z `-1`:\n"
"\n"
"| Indeks     | Pierwszy el. | Drugi el.   | Trzeci el.  | ... | Przedostatni el. | Ostatni el.  |\n"
"|-----------|---------------|--------------|--------------|-----|-------------------|---------------|\n"
"| Do przodu  | `0`           | `1`          | `2`          | ... | `len(x) - 2`      |`len(x) - 1`   |\n"
"| Do tyłu    | `-len(x)`     |`-len(x) + 1` |`-len(x) + 2` | ... | `-2`              |  `-1`         |\n"
"\n"
"Następne ćwiczenie:\n"
"\n"
"Tym razem, zamiast modyfikować listę `x`, utworzysz nową listę `y`:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"`y` powinno być takie samo jak `x`, ale powinno mieć też pierwszy element powtórzony na końcu.\n"
"Dlatego program wydrukuje `['a', 'b', 'c', 'a']`."

msgid "pages.FunctionsAndMethodsForLists.steps.pop_predict_exercise.text"
msgstr ""
"**`pop`**: Usuwa i zwraca element o danym *indeksie* używając składni\n"
"\n"
"__code0__\n"
"\n"
"Bez argumentu, tzn. po prostu `some_list.pop()`, usunie i zwróci ostatni element.\n"
"Powoduje błąd, jeśli `index` nie jest prawidłowym indeksem `some_list`. Na przykład uruchom ten program:\n"
"\n"
"__program_indented__"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno mieć dokładnie trzy instrukcje: `x = ['a', 'b', "
"'c']`, jedna linia dokładnie skopiowana z listy (bez dodatków), oraz "
"`print(x)`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.1.text"
msgstr "Przesunięcie pierwszego elementu na koniec wymaga dwóch rzeczy."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.2.text"
msgstr "Usunięcie pierwszego elementu..."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.3.text"
msgstr "i dodanie go na koniec."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.4.text"
msgstr "Które funkcje/metody możesz użyć do tego?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.5.text"
msgstr "Pamiętaj, że pierwszy indeks to 0."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.requirements"
msgstr ""
"Skopiuj trzy powyższe linie, a następnie zastąp "
"`(wstaw_jedną_linię_z_powyżej)` dokładnie jedną linią z długiej listy tuż "
"przed tym. Musisz wybrać poprawną linię, jest tylko jedna właściwa "
"odpowiedź. Wpisz linię dokładnie."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.text"
msgstr ""
"Teraz rozwiążesz cztery krótkie ćwiczenia związane z tymi pojęciami.\n"
"Poniżej znajduje się lista poprawnych i niepoprawnych linii kodu wymieszanych ze sobą.\n"
"Każde nadchodzące ćwiczenie ma rozwiązanie, które zawiera dokładnie jedną z poniższych linii,\n"
"a ty musisz znaleźć poprawną linię z listy.\n"
"\n"
"__code0__\n"
"\n"
"Oto niekompletny program:\n"
"\n"
"    __copyable__\n"
"__code1__\n"
"\n"
"Zastąp środkową linię jedną linią z powyższej listy. Ostateczny program powinien zmodyfikować `x` tak, aby przenieść pierwszy element na koniec, tak aby drukował `['b', 'c', 'a']`."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno mieć dokładnie trzy instrukcje: `x = [1, 2, 0, "
"3]`, jedna linia dokładnie skopiowana z listy (bez dodatków), oraz "
"`print(x)`."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.1.text"
msgstr "Co robi `x.remove(0)`?"

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.2.text"
msgstr "Usuwa element!"

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.3.text"
msgstr "Która funkcja/metoda może także usunąć element?"

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.4.text"
msgstr ""
"Inna funkcja/metoda nie może po prostu dostać informacji 'usuń 0', "
"potrzebuje innego rodzaju informacji."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.5.text"
msgstr "Dokładniej, musi wiedzieć, gdzie jest 0."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.6.text"
msgstr "Która funkcja/metoda dostarcza tego rodzaju informacji?"

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.requirements"
msgstr ""
"Skopiuj trzy powyższe linie, a następnie zastąp `x.remove(0)` dokładnie "
"jedną linią z długiej listy linii wcześniejszych. Linia, którą wybierzesz, "
"powinna mieć ten sam efekt co `x.remove(0)`, tak żeby program wydrukował "
"`[1, 2, 3]`."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.text"
msgstr ""
"Świetna robota. Teraz ostatnie ćwiczenie:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Zastąp środkową linię `x.remove(0)` jedną linią z listy, która robi to samo."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_predict_exercise.text"
msgstr ""
"**`remove`**: Usuwa pierwsze wystąpienie podanej *wartości* za pomocą składni\n"
"\n"
"__code0__\n"
"\n"
"Powoduje błąd, jeśli wartość nie znajduje się na liście. Na przykład uruchom ten program:\n"
"\n"
"__program_indented__"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno mieć dokładnie trzy instrukcje: `x = ['a', 'b', "
"'c']`, jedna linia dokładnie skopiowana z listy (bez dodatków), oraz "
"`print(x)`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.1.text"
msgstr "Musisz pobrać wartość pierwszego elementu w `x`..."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.2.text"
msgstr "i przypisać tę wartość do ostatniej pozycji w `x`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.3.text"
msgstr "Jak przypisujesz wartość na konkretnym indeksie na liście?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.4.text"
msgstr "Jakie są indeksy pierwszego i ostatniego elementu w `x`?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.requirements"
msgstr ""
"Skopiuj trzy powyższe linie, a następnie zastąp "
"`(wstaw_jedną_linię_z_powyżej)` dokładnie jedną linią z poprzedniej długiej "
"listy. Musisz wybrać poprawną linię, jest tylko jedna właściwa odpowiedź. "
"Wpisz linię dokładnie."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.text"
msgstr ""
"Dobra robota. W kolejnym ćwiczeniu, zacznij od tego samego niekompletnego programu:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Wybierz linię kodu z listy, która nadpisuje ostatni element `x` pierwszym elementem,\n"
"tak aby drukowało `['a', 'b', 'a']`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_predict.text"
msgstr ""
"Jak widać, `+` nie modyfikuje `nums`, ale `append` tak.\n"
"\n"
"Oto kilka nowych rzeczy.\n"
"\n"
"**`przypisanie wartości do elementu`**: Ustawia wartość o danym indeksie (zastępując wartość, która była tam wcześniej) za pomocą składni\n"
"\n"
"__code0__\n"
"\n"
"Jeśli `index` nie jest prawidłowym indeksem `some_list`, interpreter zwróci błąd. Na przykład uruchom ten program:\n"
"\n"
"__program_indented__"

msgid "pages.FunctionsAndMethodsForLists.title"
msgstr "Funkcje i metody dla list"

msgid "pages.GettingElementsAtPosition.steps.final_text.text"
msgstr ""
"Jeśli nadal nie czujesz się komfortowo z funkcją `range` i/lub `len`, poćwicz i eksperymentuj z nimi przez chwilę.\n"
"Oto kilka prostych ćwiczeń, które możesz spróbować wykonać samodzielnie, jeśli chcesz.\n"
"\n"
"- Wypisz liczby od `1` do `100` włącznie.\n"
"- Wypisz swoje imię 100 razy.\n"
"- Wypisz każde słowo z listy `words` oprócz ostatniego.\n"
"- Wypisz każde słowo z `words` w odwrotnej kolejności, czyli wypisz ostatnie słowo, potem przedostatnie słowo itp.\n"
"- Powróć do bonusowego problemu na końcu strony [Wprowadzenie do List](#IntroducingLists),\n"
"niezależnie od tego, czy go rozwiązałeś. Jest teraz znacznie łatwiejsze z `range` i `len`!\n"
"\n"
"Gdy będziesz gotowy, kontynuuj na następną stronę, gdzie czeka na ciebie coś trochę bardziej wymagającego."

msgid "pages.GettingElementsAtPosition.steps.index_error.program"
msgstr "words[4]"

msgid "pages.GettingElementsAtPosition.steps.index_error.requirements"
msgstr "Uruchom coś takiego jak `words[3]`, ale zastąp `3` większą liczbą."

msgid "pages.GettingElementsAtPosition.steps.index_error.text"
msgstr ""
"Ogólnie rzecz biorąc, możesz pobrać element na miejscu `i` używając `words[i]`. Operacja ta nazywa się *indeksowanie*, a miejsce to *indeks*.\n"
"\n"
"Prawdopodobnie zauważyłeś, że pierwszy indeks to 0, a nie 1. W programowaniu liczenie zaczyna się od 0. To wydaje się dziwne, ale tak właśnie działa większość języków programowania i ogólnie uznaje się to za lepsze.\n"
"\n"
"To również oznacza, że ostatni indeks w tej liście 4 elementów to 3. Co się stanie, jeśli spróbujesz uzyskać indeks większy niż ten?"

msgid "pages.GettingElementsAtPosition.steps.indices_out_of_bounds.text"
msgstr "Teraz spróbuj `__program__` w konsoli."

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.0"
msgstr ""
"This\n"
"is\n"
"a\n"
"list"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.2"
msgstr ""
"0\n"
"This\n"
"1\n"
"is\n"
"2\n"
"a\n"
"3\n"
"list"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.3"
msgstr ""
"This\n"
"0\n"
"is\n"
"1\n"
"a\n"
"2\n"
"list\n"
"3"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.4"
msgstr ""
"0\n"
"1\n"
"2\n"
"3\n"
"This\n"
"is\n"
"a\n"
"list"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.5"
msgstr ""
"This\n"
"is\n"
"a\n"
"list\n"
"0\n"
"1\n"
"2\n"
"3"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"indices = [0, 1, 2, 3]\n"
"\n"
"for index in indices:\n"
"    print(index)\n"
"    print(words[index])"

msgid "pages.GettingElementsAtPosition.steps.introducing_len_and_range.text"
msgstr ""
"I oto jest. `words[4]` oraz reszta nie istnieje, więc próba ich uzyskania skończy się błędem.\n"
"Ten pierwszy program jest trochę powtarzalny. Ulepszmy go za pomocą listy i pętli!\n"
"\n"
"__program_indented__"

msgid "pages.GettingElementsAtPosition.steps.introducing_subscripting.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"\n"
"print(words[0])\n"
"print(words[1])\n"
"print(words[2])\n"
"print(words[3])"

msgid "pages.GettingElementsAtPosition.steps.introducing_subscripting.text"
msgstr ""
"Pętla jest świetna, ale często chcesz po prostu pobrać pojedynczy element z listy na znanym miejscu.\n"
"Oto jak:\n"
"\n"
"__program_indented__"

msgid ""
"pages.GettingElementsAtPosition.steps.print_indices_and_words.hints.0.text"
msgstr "Pamiętaj, że wcześniej użyliśmy `range(4)`."

msgid ""
"pages.GettingElementsAtPosition.steps.print_indices_and_words.hints.1.text"
msgstr ""
"Tym razem powinno to działać dla dowolnej listy. Co jeśli lista ma 5 "
"elementów albo 10?"

msgid ""
"pages.GettingElementsAtPosition.steps.print_indices_and_words.hints.2.text"
msgstr "Połącz dwie funkcje, których się nauczyłeś!"

msgid "pages.GettingElementsAtPosition.steps.print_indices_and_words.text"
msgstr ""
"Zatem ogólnie rzecz biorąc, prawidłowe indeksy to:\n"
"\n"
"__code0__\n"
"\n"
"Teraz możemy naprawić program z wcześniej tak, aby działał z dowolną listą. Uzupełnij `...`:\n"
"\n"
"    __copyable__\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"\n"
"    for index in ...:\n"
"        print(index)\n"
"        print(words[index])\n"
"\n"
"Dla podanej wartości przykładowej `words` program powinien wypisać:\n"
"\n"
"    0\n"
"    This\n"
"    1\n"
"    is\n"
"    2\n"
"    a\n"
"    3\n"
"    list"

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.0.text"
msgstr ""
"Aby uzyskać dostęp do ostatniego elementu listy, potrzebujesz indeksu "
"ostatniej pozycji."

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.1.text"
msgstr ""
"Jeśli lista ma 2 elementy, pierwszy element znajduje się na indeksie 0, więc"
" ostatni element jest na indeksie 1."

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.2.text"
msgstr ""
"Podobnie, gdyby lista miała 3 elementy, ostatni element byłby na indeksie 2."

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.3.text"
msgstr "Czy widzisz wzór pomiędzy tymi numerami? Jak możesz to wyrazić?"

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.4.text"
msgstr ""
"Czy potrafisz wymyślić ogólne rozwiązanie, które działa na każdym rozmiarze?"

msgid "pages.GettingElementsAtPosition.steps.print_last_element.text"
msgstr ""
"Ćwiczenie: dla dowolnej niepustej listy `words`, wydrukuj ostatni element. Na przykład, jeśli\n"
"\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"\n"
"twój program powinien wydrukować `list`."

msgid ""
"pages.GettingElementsAtPosition.steps.printing_the_range.output_prediction_choices.4"
msgstr ""
"This\n"
"is\n"
"a\n"
"list"

msgid "pages.GettingElementsAtPosition.steps.printing_the_range.text"
msgstr ""
"Jak widzisz, wynik jest taki sam. Spróbuj tego:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.GettingElementsAtPosition.steps.range_almost_the_same_as_list.text"
msgstr ""
"`range(4)` to to samo, co `[0, 1, 2, 3]` ... prawie. Spróbuj `__program__` w"
" konsoli."

msgid "pages.GettingElementsAtPosition.steps.range_len.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"indices = range(4)\n"
"\n"
"for index in indices:\n"
"    print(index)\n"
"    print(words[index])"

msgid "pages.GettingElementsAtPosition.steps.range_len.requirements"
msgstr ""
"Uruchom ten sam program z poprzedniego kroku, ale zamień drugą linię "
"`indices = [0, 1, 2, 3]` na `indices = range(4)`."

msgid "pages.GettingElementsAtPosition.steps.range_len.text"
msgstr ""
"To wygląda nieco lepiej, ale wypisywanie `[0, 1, 2, ...]` to nie jest najlepsze rozwiązanie, szczególnie, gdy lista jest długa.\n"
"Istnieje przydatna funkcja `range`, która zrobi to za ciebie. Zamień `[0, 1, 2, 3]` na `range(4)`,\n"
"czyli `indices = range(4)`."

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.0"
msgstr "range(4)"

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.1"
msgstr "range(0, 4)"

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.2"
msgstr "list(range(4))"

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.3"
msgstr "list(range(0, 4))"

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.4"
msgstr "range(0, 1, 2, 3)"

msgid "pages.GettingElementsAtPosition.steps.range_versus_list.text"
msgstr ""
"To jest może być zaskakujące. Jeśli jesteś ciekawy, `0` reprezentuje początek zakresu.\n"
"`0` to domyślny początek, więc `range(4)` jest równy `range(0, 4)`.\n"
"`4` to koniec zakresu, ale koniec jest zawsze wykluczony, więc ostatnia wartość to `3`.\n"
"Jeśli teraz jesteś zdezorientowany, nie martw się.\n"
"\n"
"Istnieje dobry powód, dla którego `range(4)` nie jest właściwie listą - sprawia, że programy działają szybciej i są bardziej wydajne.\n"
"W tej chwili nie warto tego bardziej wyjaśniać.\n"
"\n"
"Ale łatwo możesz to przekonwertować na listę: spróbuj `__program__` w konsoli."

msgid "pages.GettingElementsAtPosition.steps.using_len_first_time.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"print(len(words))"

msgid "pages.GettingElementsAtPosition.steps.using_len_first_time.text"
msgstr ""
"To tylko demonstracja, żebyś mógł zobaczyć zakres w bardziej znajomej formie.\n"
"Nigdy właściwie nie powinieneś tego robić.\n"
"\n"
"Jeśli czujesz się przytłoczony, nie martw się! Wszystko, co musisz wiedzieć, to że `range(n)`\n"
"jest bardzo podobne do listy:\n"
"\n"
"__code0__\n"
"\n"
"Tak przy okazji, możesz uzyskać liczbę elementów listy (często nazywaną *długością*) używając funkcji `len`.\n"
"Spróbuj to, uruchamiając ten kod:\n"
"\n"
"    __copyable__\n"
"__code1__"

msgid "pages.GettingElementsAtPosition.title"
msgstr "Pobieranie elementów, `range()`, i `len()`"

msgid "pages.GettingElementsAtPositionExercises.steps.final_text.text"
msgstr "Fantastycznie! Zrób sobie przerwę, zasłużyłeś na to!"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.0.text"
msgstr ""
"Będziesz musiał spojrzeć na wszystkie możliwe indeksy `things` i sprawdzić, "
"który z nich jest odpowiedzią."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.1.text"
msgstr ""
"Aby przejrzeć wszystkie możliwe indeksy, będziesz potrzebował pętli po "
"`range(len(things))`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.2.text"
msgstr "Aby sprawdzić, czy indeks jest odpowiedzią, będziesz musiał użyć:"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.3.text"
msgstr "- `if`"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.4.text"
msgstr "- indeksu w subskrypcie"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.5.text"
msgstr "- `==`"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.6.text"
msgstr ""
"Ponieważ szukasz pierwszego indeksu, musisz zatrzymać pętlę, gdy go "
"znajdziesz."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.7.text"
msgstr "Niedawno nauczyłeś się, jak zatrzymać pętlę w połowie."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.8.text"
msgstr "Potrzebujesz użyć `break`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.messages.all_indices.text"
msgstr ""
"Jesteś prawie na miejscu! Jednak to drukuje wszystkie indeksy,\n"
" nie tylko pierwszy."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.messages.last_index.text"
msgstr ""
"Jesteś prawie na miejscu! Jednak to drukuje *ostatni* indeks,\n"
" nie pierwszy."

msgid "pages.GettingElementsAtPositionExercises.steps.index_exercise.text"
msgstr ""
"Zakładając, że masz listę `things` oraz wartość `to_find`,\n"
"wydrukuj pierwszy indeks `to_find` na liście, tzn. najmniejszą liczbę `i` taką, że\n"
"`things[i]` jest `to_find`. Na przykład, dla\n"
"\n"
"    __no_auto_translate__\n"
"    things = ['on', 'the', 'way', 'to', 'the', 'store']\n"
"    to_find = 'the'\n"
"\n"
"twój program powinien wydrukować `1`.\n"
"\n"
"Możesz założyć, że `to_find` pojawia się przynajmniej raz."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.0.text"
msgstr ""
"Czy eksperymentowałeś z indeksowaniem i `len()` ze stringami w shellu?"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.1.text"
msgstr ""
"Na moment zapomnij o pętlach. Jak byś wydrukował tylko pierwszą linię, która"
" zawiera pierwszy znak każdego z dwóch stringów?"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.2.text"
msgstr ""
"W drugiej linii chcesz wydrukować drugi znak każdego stringa, i tak dalej."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.3.text"
msgstr "Będziesz potrzebować pętli `for`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.4.text"
msgstr "Będziesz potrzebować indeksowania (subskrypcji)."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.5.text"
msgstr "Będziesz potrzebować `range`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.6.text"
msgstr "Będziesz potrzebować `len`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.7.text"
msgstr "Będziesz potrzebować `+`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.8.text"
msgstr "Będziesz musiał zindeksować oba stringi."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.9.text"
msgstr ""
"Będziesz musiał przekazać ten sam indeks do obu stringów za każdym razem, "
"aby pobierać odpowiadające sobie znaki."

msgid "pages.GettingElementsAtPositionExercises.steps.zip_exercise.text"
msgstr ""
"Świetnie!\n"
"\n"
"Tak na marginesie, indeksowanie i `len()` również działają na stringach. Wypróbuj je w shellu.\n"
"\n"
"Oto kolejne ćwiczenie. Mając dwa stringi o równych długościach, np:\n"
"\n"
"    __no_auto_translate__\n"
"    string1 = 'Hello'\n"
"    string2 = 'World'\n"
"\n"
"wydrukuj je pionowo, obok siebie, z odstępem między każdą parą znaków:\n"
"\n"
"    H W\n"
"    e o\n"
"    l r\n"
"    l l\n"
"    o d"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.0.text"
msgstr ""
"Rozwiązanie ma tę samą ogólną strukturę i kluczowe elementy co poprzednie "
"rozwiązanie, jednak jest znacznie dłuższe i będzie wymagać kilku dodatkowych"
" pomysłów i części."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.1.text"
msgstr ""
"W szczególności powinno nadal zawierać coś w stylu:\n"
"\n"
"__code0__"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.2.text"
msgstr ""
"Co powinno się znaleźć w `range()`? Ani `len(string1)`, ani `len(string2)` "
"nie są wystarczająco dobre."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.3.text"
msgstr "Chcesz iteracji pętli dla każdego znaku w dłuższym stringu."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.4.text"
msgstr "To oznacza, że potrzebujesz `range(<długość najdłuższego stringu>)`"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.5.text"
msgstr ""
"Innymi słowy, potrzebujesz znaleźć większą z dwóch wartości `len(string1)` i"
" `len(string2)`. Już wykonałeś podobne ćwiczenie."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.6.text"
msgstr ""
"Kiedy już rozwiążesz kwestię pętli `for i in range(...)`, `i` czasami będzie"
" za duże, żeby było ważnym indeksem dla obu stringów. Będziesz musiał "
"sprawdzić, czy nie jest za duże przed indeksowaniem."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.7.text"
msgstr ""
"Pamiętaj, że największy ważny indeks dla `string1` to `len(string1) - 1`. "
"`len(string1)` jest za duże."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.8.text"
msgstr ""
"Będziesz potrzebować dwóch instrukcji `if`, jednej dla każdego stringu."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.9.text"
msgstr ""
"Będziesz musiał ustawić np. `char1 = ' '` gdy `string1[i]` nie jest ważny."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.text"
msgstr ""
"Niesamowite!\n"
"\n"
"Twoje rozwiązanie prawdopodobnie wyglądało mniej więcej tak:\n"
"\n"
"__code0__\n"
"\n"
"To nie działa zbyt dobrze, jeśli stringi mają różne długości.\n"
"W rzeczywistości, błędy pojawiają się na różne sposoby w zależności od tego, czy `string1` czy `string2` jest dłuższy.\n"
"Twoje kolejne wyzwanie polega na rozwiązaniu tego problemu poprzez wypełnienie 'brakujących' znaków spacjami.\n"
"\n"
"Na przykład, dla:\n"
"\n"
"    __no_auto_translate__\n"
"    string1 = 'Goodbye'\n"
"    string2 = 'World'\n"
"\n"
"wypisz:\n"
"\n"
"    G W\n"
"    o o\n"
"    o r\n"
"    d l\n"
"    b d\n"
"    y\n"
"    e\n"
"\n"
"i dla:\n"
"\n"
"    __no_auto_translate__\n"
"    string1 = 'Hello'\n"
"    string2 = 'Elizabeth'\n"
"\n"
"wypisz:\n"
"\n"
"    H E\n"
"    e l\n"
"    l i\n"
"    l z\n"
"    o a\n"
"      b\n"
"      e\n"
"      t\n"
"      h"

msgid "pages.GettingElementsAtPositionExercises.title"
msgstr "Ćwiczenia z `range()` i `len()`"

msgid "pages.HowToFindInformationWithGoogleAndMore.steps.dir_list.text"
msgstr ""
"Świetnie!\n"
"\n"
"Może być również przydatne wyszukiwanie takich rzeczy jak \"python list tutorial\", na przykład gdy:\n"
"\n"
"- Wyszukiwanie konkretnej metody się nie powiodło i chcesz ją znaleźć ręcznie.\n"
"- Nadal masz wątpliwości dotyczące list po tym kursie.\n"
"- Minęło trochę czasu odkąd uczyłeś się o listach i potrzebujesz przypomnienia.\n"
"- Zmagasz się z rozwiązaniem problemu z listami i musisz wrócić do podstaw i wzmocnić swoje podstawy.\n"
"\n"
"Są również sposoby na znalezienie informacji bez googlowania. Spróbuj `__program__` w konsoli."

msgid "pages.HowToFindInformationWithGoogleAndMore.steps.final_text.text"
msgstr ""
"`dir()` zwraca listę atrybutów argumentu, które są przeważnie metodami. "
"Wiele z nich zaczyna się od `__` , które na razie możesz zignorować - "
"przewiń do końca listy, a zobaczysz kilka znajomych metod."

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.hints.0.text"
msgstr "Użyj słów 'python' i 'lista' w zapytaniu wyszukiwania."

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.hints.1.text"
msgstr ""
"Zamiast umieszczać wartość na początku lub na końcu, chcemy ją umieścić "
"____________?"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.hints.2.text"
msgstr "'w środku' lub 'na indeksie' lub 'w określonej pozycji'"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.hints.3.text"
msgstr "'python dodaj wartość na indeksie'"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.requirements"
msgstr ""
"Uruchom kod podobny do trzech powyższych linii, ale zmień `nums.append(9)` na odpowiednie wywołanie funkcji/metody,\n"
"aby umieścić 9 zaraz po drugim elemencie (2 w przykładzie `nums = [1, 2, 3, 4, 5]`) zamiast na końcu.\n"
"Istnieje tylko jedna poprawna odpowiedź na to, co powinna być środkowa linia.\n"
"Musisz przeszukać internet, aby dowiedzieć się, jakiej funkcji/metody użyć i jak jej używać."

msgid "pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.text"
msgstr ""
"Dobrze ci poszło! Zróbmy jeszcze jedno zadanie. Rozważ ten program:\n"
"\n"
"__code0__\n"
"\n"
"To zmieni `nums`, tak że wypisze:\n"
"\n"
"__code1__\n"
"\n"
"Ale załóżmy, że nie chcesz, aby 9 było na końcu, chcesz by znalazła się między drugim a trzecim elementem, aby wynik był:\n"
"\n"
"__code2__\n"
"\n"
"Zastąp środkową linię `nums.append(9)` odpowiednim wywołaniem funkcji/metody, aby to osiągnąć."

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.hints.0.text"
msgstr "Użyj słów 'python' i 'lista' w zapytaniu wyszukiwania."

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.hints.1.text"
msgstr ""
"Jednym słowem, co jest szczególnego w `91` na liście `[21, 55, 4, 91, 62, "
"49]`?"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.hints.2.text"
msgstr "'największy' lub 'największa'"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.hints.3.text"
msgstr "'python największa wartość na liście'"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.requirements"
msgstr ""
"Uruchom kod podobny do `sum([21, 55, 4, 91, 62, 49])`, ale zastąp `sum` nazwą innej konkretnej funkcji.\n"
"Istnieje tylko jedna poprawna odpowiedź na to, jaka funkcja powinna zostać użyta. Musisz przeszukać internet,\n"
"aby dowiedzieć się, której użyć. Jest to powszechnie używana wbudowana funkcja w Pythonie."

msgid "pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.text"
msgstr ""
"Przydatne jest znać funkcje, które właśnie omówiliśmy, ale nie jest łatwo je wszystkie zapamiętać, a jest ich jeszcze więcej. Ważniejszą umiejętnością jest potrafić wyszukać informacje. Na przykład, oto kilka typowych sposobów jak byś mógł wyszukać wyżej wymienione funkcje w Google, jeśli zapomniałeś ich nazw:\n"
"\n"
"- `append`\n"
"    - python dodaj element do listy\n"
"    - python dodaj element na końcu listy\n"
"- `len`\n"
"    - python rozmiar listy\n"
"    - python liczba elementów na liście\n"
"    - python ile znaków w ciągu\n"
"- `sum`\n"
"    - python dodaj listę liczb\n"
"    - python suma liczb\n"
"- `in`\n"
"    - python sprawdź czy lista zawiera wartość\n"
"    - python sprawdź czy lista ma element\n"
"- `index`\n"
"    - python znajdź pozycję elementu\n"
"    - python uzyskaj indeks wartości\n"
"\n"
"Ćwiczymy teraz tę umiejętność. Znajdź funkcję/metodę, która zwraca wartość na liście, która jest większa niż jakakolwiek inna wartość. Na przykład, podana lista `[21, 55, 4, 91, 62, 49]`, powinna zwrócić `91`. Powinieneś napisać odpowiedź w konsoli jako pojedyncze, małe wyrażenie. Na przykład, jeśli szukałbyś funkcji `sum`, moglibyśmy napisać `sum([21, 55, 4, 91, 62, 49])`. Nie rozwiązuj tego ręcznie za pomocą pętli. Zauważ, że funkcja, której szukasz, nie była wcześniej tutaj wspomniana."

msgid "pages.HowToFindInformationWithGoogleAndMore.title"
msgstr "Jak szukać informacji z pomocą Google, i nie tylko"

msgid "pages.IfAndElse.steps.capitalise.hints.0.text"
msgstr ""
"Nauczyłeś się wszystkich narzędzi, których potrzebujesz. Wierzę w Ciebie! "
"Szukaj inspiracji w poprzednich programach."

msgid "pages.IfAndElse.steps.capitalise.hints.1.text"
msgstr "Będziesz potrzebować pętli, aby zbudować nowe zdanie znak po znaku."

msgid "pages.IfAndElse.steps.capitalise.hints.2.text"
msgstr ""
"Będziesz potrzebował `if/else`, aby zdecydować, czy dodać wielką literę, czy"
" małą."

msgid "pages.IfAndElse.steps.capitalise.hints.3.text"
msgstr ""
"Twoje `if/else` musi wykonać różne bloki kodu w zależności od iteracji "
"pętli, w której się znajduje."

msgid "pages.IfAndElse.steps.capitalise.hints.4.text"
msgstr ""
"To oznacza, że warunek Twojego `if` musi być zmienną, która zmienia się "
"wewnątrz pętli."

msgid "pages.IfAndElse.steps.capitalise.hints.5.text"
msgstr ""
"W pierwszej iteracji potrzebujesz wielkiej litery. W kolejnych iteracjach "
"potrzebujesz małej litery."

msgid "pages.IfAndElse.steps.capitalise.text"
msgstr ""
"Czas na wyzwanie!\n"
"\n"
"Napisz program, który, mając dany ciąg `sentence`, wydrukuje zmodyfikowaną wersję z\n"
"tymi samymi literami, gdzie pierwsza litera jest wielka, a reszta małe.\n"
"Na przykład, wynik powinien być `Hello world`, niezależnie czy wejście `sentence = 'hello world'`\n"
"czy `'HELLO WORLD'`."

msgid "pages.IfAndElse.steps.else_full_stop.hints.0.text"
msgstr ""
"Nie zmieniaj niczego, co jest już tam, dodaj tylko trochę więcej kodu."

msgid "pages.IfAndElse.steps.else_full_stop.hints.1.text"
msgstr ""
"`else` musi znajdować się bezpośrednio po ciele `if`, z niczym pomiędzy."

msgid "pages.IfAndElse.steps.else_full_stop.hints.2.text"
msgstr ""
"`sentence += char` musi zostać wykonane zarówno, gdy `excited` jest `True`, "
"jak i `False`."

msgid "pages.IfAndElse.steps.else_full_stop.hints.3.text"
msgstr ""
"Mógłbyś mieć kopię `sentence += char` zarówno w bloku `if`, jak i `else`, "
"ale jest lepszy sposób."

msgid "pages.IfAndElse.steps.else_full_stop.hints.4.text"
msgstr "Użyj `else`, aby przypisać inną wartość dla `char`."

msgid "pages.IfAndElse.steps.else_full_stop.hints.5.text"
msgstr ""
"Jeśli `excited` jest `False`, wtedy `char` powinien być `'.'` zamiast `'!'`."

msgid "pages.IfAndElse.steps.else_full_stop.text"
msgstr ""
"Jeśli `excited` ma wartość prawda, to `char` zostało zdefiniowane i wszystko działa poprawnie. W przeciwnym razie\n"
"`char` nigdy nie zostaje przypisane wartość, więc próba użycia go w `sentence += char` kończy się niepowodzeniem.\n"
"\n"
"Napraw to, dodając klauzulę `else` do `if`, tak aby jeśłi `excited` jest nieprawdziwe, kropka (`.`)\n"
"została dodana na końcu zdania zamiast wykrzyknika (`!`)."

msgid "pages.IfAndElse.steps.final_text.text"
msgstr ""
"Doskonale! Zatrzymaj się na chwilę i ciesz się z tego, co osiągnąłeś. Czy "
"czujesz, że Twój mózg rośnie?"

msgid "pages.IfAndElse.steps.first_if_else.text"
msgstr ""
"Instrukcja `if` może opcjonalnie mieć część `else`. Uruchom ten przykład:\n"
"\n"
"__program_indented__"

msgid "pages.IfAndElse.steps.first_if_else_false.requirements"
msgstr ""
"Uruchom ten sam program z poprzedniego kroku, ale zastąp `True` na `False`, "
"więc `condition = False`."

msgid "pages.IfAndElse.steps.first_if_else_false.text"
msgstr ""
"Teraz zmień pierwszą linię na `condition = False` i uruchom to ponownie."

msgid "pages.IfAndElse.steps.if_upper_else_lower.text"
msgstr ""
"Pomyśl o `else` jako o sformułowaniu 'w przeciwnym razie'. Oznacza to, że jeśli warunek w `if` jest fałszywy, to zostanie wykonany kod w `else`. Bez względu na to, czy warunek jest prawdziwy czy fałszywy, dokładnie jeden z dwóch bloków zostanie wykonany.\n"
"\n"
"Oto bardziej interesujący przykład do uruchomienia:\n"
"\n"
"__program_indented__"

msgid "pages.IfAndElse.steps.if_upper_else_lower_false.requirements"
msgstr ""
"Uruchom ten sam program z poprzedniego kroku, ale zastąp `True` na `False`, "
"więc `excited = False`."

msgid "pages.IfAndElse.steps.if_upper_else_lower_false.text"
msgstr ""
"`sentence.upper()` to nowy rodzaj wyrażenia, z którym się jeszcze nie spotkaliśmy. Chodzi o to, że `sentence` to ciąg znaków i ciągi znaków mają różne *metody*, które pozwalają wygodnie obliczać nowe wartości, w tym `upper` i `lower`. Nazwy odnoszą się do wielkich liter (uppercase) i małych liter (lowercase). `'Hello World'.upper()` zwraca `'HELLO WORLD'`. Nie zmienia to jednak zawartości `sentence`, więc musisz przypisać nową wartość ponownie za pomocą `sentence = sentence.upper()`.\n"
"\n"
"Teraz zmień `excited` na `False` i uruchom to ponownie."

msgid "pages.IfAndElse.steps.spongebob.hints.0.text"
msgstr ""
"To podobne do poprzedniego ćwiczenia. Różnica polega na tym, kiedy i gdzie "
"ustawiasz zmienną warunkową."

msgid "pages.IfAndElse.steps.spongebob.hints.1.text"
msgstr ""
"Będziesz potrzebować zmiennej typu boolean, która zmienia się z każdą "
"iteracją."

msgid "pages.IfAndElse.steps.spongebob.hints.2.text"
msgstr ""
"Najpierw napisz mały program, który bierze zmienną typu boolean i odwraca "
"ją, np. jeśli zmienna jest `True`, staje się `False` i odwrotnie, jeśli "
"zaczyna sie od `False`, zmienia się na `True`. Bez pętli, tylko z `if/else`."

msgid "pages.IfAndElse.steps.spongebob.hints.3.text"
msgstr ""
"Będziesz musiał użyć tej zmiennej w warunku `if` oraz przypisać do tej samej"
" zmiennej w ciele."

msgid "pages.IfAndElse.steps.spongebob.hints.4.text"
msgstr ""
"Połącz to odwracające `if/else` z tym, które wybiera wielką lub małą literę."

msgid "pages.IfAndElse.steps.spongebob.text"
msgstr ""
"Wspaniale!!!\n"
"\n"
"Jeszcze jedno ćwiczenie, a potem możesz się zrelaksować.\n"
"\n"
"Napisz program, który wypisuje `sentence` w sposób kpiący, np.:\n"
"\n"
"    OnE MoRe eXeRcIsE, aNd tHeN YoU CaN ReLaX.\n"
"\n"
"Co drugi znak powinien być małą literą, reszta wielkimi literami."

msgid "pages.IfAndElse.steps.undefined_char.output_prediction_choices.0"
msgstr "Hello World"

msgid "pages.IfAndElse.steps.undefined_char.output_prediction_choices.1"
msgstr "Hello World!"

msgid "pages.IfAndElse.steps.undefined_char.requirements"
msgstr ""
"Skopiuj program powyżej. Uruchom go tak, jak jest jeśli chcesz. Następnie "
"zmień `excited = True` na `excited = False` i uruchom to ponownie."

msgid "pages.IfAndElse.steps.undefined_char.text"
msgstr ""
"Oto zepsuty program:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Czy widzisz problem? Jeśli uruchomisz ten kod, wszystko wydaje się być w porządku. Co może pójść nie tak?\n"
"\n"
"Odpowiedzi poniżej! Czy już to rozgryzłeś?\n"
"\n"
"Co się dzieje, jeśli zmienisz `excited` na `False`?"

msgid "pages.IfAndElse.title"
msgstr "`if` i `else`"

msgid "pages.Indentation.steps.final_text.text"
msgstr ""
"Kiedy używasz wcięć, powinieneś zawsze wciąć o 4 spacje. Wprawdzie każde "
"spójne wcięcie jest akceptowalne, ale 4 spacje to konwencja, której "
"przestrzega prawie każdy. Zauważ, że edytor na ogół ci to ułatwia. "
"Na przykład, jeśli naciśniesz klawisz 'Tab' na klawiaturze w edytorze, "
"zostaną wstawione 4 spacje."

msgid "pages.Indentation.steps.mismatched_indentations.program"
msgstr ""
"for character in name:\n"
"    print(character)\n"
"  print('---')"

msgid "pages.Indentation.steps.mismatched_indentations.text"
msgstr ""
"Ponieważ `print('---')` nie jest wcięte, nie jest częścią ciała pętli. Oznacza to, że jest wykonywane tylko raz, po zakończeniu całej pętli. Obydwa programy są poprawne, po prostu robią różne rzeczy.\n"
"\n"
"Poniższy program jest niepoprawny. Obie linie w ciele pętli są wcięte, ale o różnych ilościach. Pierwsza linia zaczyna się od 4 spacji, druga linia zaczyna się od 2. Spróbuj go uruchomić.\n"
"\n"
"__program_indented__"

msgid "pages.Indentation.steps.missing_indentation.program"
msgstr ""
"for character in name:\n"
"print(character)"

msgid "pages.Indentation.steps.missing_indentation.text"
msgstr ""
"Ta pętla przykładowa:\n"
"\n"
"__code0__\n"
"\n"
"działa, ale zazwyczaj jest (i powinna) być napisana tak:\n"
"\n"
"__code1__\n"
"\n"
"Konkretnie, kod do powtórzenia (znany jako *ciało*) zaczyna się w nowej linii po dwukropku (`:`), i musi być *wcięty*, tzn. mieć kilka spacji przed nim. Kod poniżej bez wcięcia jest nieprawidłowy, uruchom go, aby przekonać się sam:\n"
"\n"
"__program_indented__"

msgid "pages.Indentation.steps.one_indented_line.text"
msgstr ""
"Są dwie linie z wcięciem, więc obie są częścią ciała, więc `---` zostanie wydrukowane po każdym znaku. Teraz spróbuj uruchomić ten sam kod bez wcięcia w ostatniej linii:\n"
"\n"
"__code0__"

msgid "pages.Indentation.steps.two_indented_lines.text"
msgstr ""
"Spacje są wymagane, aby powiedzieć Pythonowi, które linie kodu należą do ciała pętli for. Jest to kluczowe, kiedy pętla zawiera kilka linii, co często ma miejsce. Na przykład, uruchom ten kod:\n"
"\n"
"__code0__"

msgid "pages.Indentation.title"
msgstr "Wcięcia"

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.0.text"
msgstr "`input()` always returns a string."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.1.text"
msgstr "A string that looks like a number is still a string, not a number."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.2.text"
msgstr "In `super_secret_number = 7`, `7` is a number, not a string."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.3.text"
msgstr "That makes `super_secret_number` also a number."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.4.text"
msgstr "A string cannot equal a number."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.5.text"
msgstr ""
"To check that two values are equal, make sure they're the same type first."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.6.text"
msgstr ""
"So to compare a number and a string, first convert the number to a string or"
" convert the string to a number."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.7.text"
msgstr ""
"You learned how to convert between strings and numbers in the previous page."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.8.text"
msgstr ""
"Use `int()` to convert to an integer (whole number) or `str()` to convert to"
" a string."

msgid "pages.InteractiveProgramsWithInput.steps.convert_input_to_int.text"
msgstr ""
"Whatever you typed in (not including pressing Enter at the end) is returned from the `input()` function as a string.\n"
"\n"
"It's essential to understand that `input()` ***always returns a string***, no matter what the user typed in.\n"
"It's up to you to convert that string to the type you need.\n"
"Forgetting this detail is a common source of confusing bugs.\n"
"\n"
"For example, this program looks fine at a glance, but if you try it out you'll see that it doesn't actually work:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Fix the program so that when the user inputs the value of `super_secret_number` (`7` in this example)\n"
"the program prints `Amazing! Are you psychic?` as expected.\n"
"It should work when `super_secret_number` is any whole number (`int`)."

msgid "pages.InteractiveProgramsWithInput.steps.final_text.text"
msgstr ""
"Perfect!\n"
"\n"
"There's two main fixes that would work here. You can convert the input to a number:\n"
"\n"
"__code0__\n"
"\n"
"or convert the correct answer to a string:\n"
"\n"
"__code1__\n"
"\n"
"An important difference between these two approaches is that the first approach will raise an error\n"
"if the user types something that isn't a number, which may or may not be what you want."

msgid "pages.InteractiveProgramsWithInput.steps.first_input.text"
msgstr ""
"The programs we have written so far are not interactive.\n"
"To make our interactive Tic-tac-toe game, we will need a method of receiving input from the players.\n"
"Python allows us to do that with the built-in `input` function. Run this program:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"When `name = input()` runs, the program actually stops and waits for you to type in the shell and press Enter,\n"
"so you will need to do that for it to complete."

msgid "pages.InteractiveProgramsWithInput.title"
msgstr "Interactive Programs with `input()`"

msgid "pages.IntroducingAnd.steps.AndExercise.hints.0.text"
msgstr ""
"If you have something like `x < 0 and x > 100`, you're on the wrong track. "
"That's going to be `False` for *any* value of `x`!"

msgid "pages.IntroducingAnd.steps.AndExercise.hints.1.text"
msgstr ""
"The solution with `and` is different in several ways from the solution with "
"`or`."

msgid "pages.IntroducingAnd.steps.AndExercise.hints.2.text"
msgstr ""
"Our solution with `or` first determines if `x` is an invalid percentage, "
"else concludes validity. Using `and` will do this in reverse."

msgid "pages.IntroducingAnd.steps.AndExercise.hints.3.text"
msgstr "You will have to reverse the `return` statements accordingly."

msgid "pages.IntroducingAnd.steps.AndExercise.hints.4.text"
msgstr "You will have to change the comparison operators too."

msgid "pages.IntroducingAnd.steps.AndExercise.text"
msgstr ""
"Let's practice now. Previously we wrote a function `is_valid_percentage` using `or`. Here's an example\n"
"solution:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Rewrite this function using `and` instead."

msgid "pages.IntroducingAnd.steps.FalseAndFalse.text"
msgstr ""
"Finally, try:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.0.text"
msgstr "The list will always have 3 elements."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.1.text"
msgstr "That means you don't need to use a loop."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.2.text"
msgstr "Remember that you can get the first element using `row[0]`."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.3.text"
msgstr ""
"The first element, second element, and third element all need to be equal."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.4.text"
msgstr ""
"That means the first element should be equal to the second element and also "
"the third element."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.text"
msgstr ""
"Awesome! Here's one possible solution:\n"
"\n"
"__code0__\n"
"\n"
"As before, we can simplify this solution to:\n"
"\n"
"__code1__\n"
"\n"
"There's another trick to improve this further called comparison chaining. Any condition like this:\n"
"\n"
"__code2__\n"
"\n"
"can be shortened by removing the extra `and b` into:\n"
"\n"
"__code3__\n"
"\n"
"This works for any comparison operators, including `==`, and the two operators can even be different.\n"
"So the solution can be simplified to:\n"
"\n"
"__code4__\n"
"\n"
"Next exercise: given a list of three elements, check if all three elements are equal.\n"
"\n"
"    __copyable__\n"
"__code5__"

msgid "pages.IntroducingAnd.steps.TrueAndFalse.text"
msgstr ""
"Good, now try:\n"
"\n"
"__program_indented__\n"
"\n"
"What do you expect?"

msgid "pages.IntroducingAnd.steps.TrueAndTrue.text"
msgstr ""
"Another boolean operator in Python is `and`.\n"
"The expression `A and B` is `True` only if BOTH `A` and `B` are `True`. Otherwise it's `False`.\n"
"Try it in the shell:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingAnd.steps.final_text.text"
msgstr ""
"Good job. There are many possible correct solutions here:\n"
"\n"
"__code0__\n"
"\n"
"or using comparison chaining again:\n"
"\n"
"__code1__\n"
"\n"
"or check that it's equal to a list containing the first element three times:\n"
"\n"
"__code2__"

msgid "pages.IntroducingAnd.title"
msgstr "Introducing `and`"

msgid "pages.IntroducingBirdseye.steps.birdseye_loop_example.text"
msgstr ""
"While the other tools show how code runs line by line and the values of variables, `birdseye` shows you the value of every expression in a program. This lets you see how a complex expression is broken down into smaller sub-expressions\n"
"and what the value of each one is.\n"
"\n"
"Hover your mouse over the various boxed expressions in the last line of the program.\n"
"As each box is highlighted, its value is shown at the bottom of the screen. Clicking on the box will stick it on a panel so you can see several expression values at once and move your mouse around freely.\n"
"\n"
"In this case `birdseye` shows that the expression:\n"
"\n"
"__code0__\n"
"\n"
"is broken into\n"
"\n"
"__code1__\n"
"\n"
"rather than\n"
"\n"
"__code2__\n"
"\n"
"In other words, Python follows the usual order of operations in maths, rather than just evaluating from left to right.\n"
"\n"
"Note that there are some expressions that `birdseye` doesn't put in a box. In this case `2`, `3`, `4`, `5`, and `print` are all expressions as well, but their values are obvious and boxing them would just be clutter.\n"
"\n"
"Here's a more complicated example to try out:\n"
"\n"
"    __copyable__\n"
"__code3__"

msgid "pages.IntroducingBirdseye.steps.final_text.text"
msgstr ""
"Note that:\n"
"\n"
"1. There's a pair of arrows next to the for loop. Click on them to navigate through the loop in time and see what happened in different iterations.\n"
"2. Code that doesn't run in an iteration because of the `if` is greyed out. The expressions within have no values because they weren't evaluated.\n"
"3. The values recorded for the expressions `vowels` and `consonants` depend on which box you look at. In the lines after the loop, they contain all the letters, but inside the loop they only contain some, and exactly how many depends on which iteration you're on.\n"
"4. In `vowels.append(letter)`, you see what the values of those variables were *at that moment*. That means that `letter` is about to be appended to `vowels` but this hasn't happened yet, so `vowels` doesn't contain `letter`."

msgid "pages.IntroducingBirdseye.steps.first_birdseye_example.text"
msgstr ""
"You've seen `snoop` and Python Tutor. futurecoder comes with one last tool to analyse programs as they run, called `birdseye`.\n"
"\n"
"Here's an example program to run. Copy it into the editor and click the `birdseye` button. This will open a new browser tab with the visualisation.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingBirdseye.title"
msgstr "Understanding Programs with `birdseye`"

msgid ""
"pages.IntroducingDictionaries.steps.dict_access.special_messages.bad_french_value.text"
msgstr ""
"Oops, you need to set `french = {'apple': 'pomme', 'box': 'boite'}` before "
"we can continue."

msgid "pages.IntroducingDictionaries.steps.dict_access.text"
msgstr ""
"`french` is a dictionary with two key-value pairs:\n"
"\n"
"- `'apple': 'pomme'` where `'apple'` is the key and `'pomme'` is the value.\n"
"- `'box': 'boite'` where `'box'` is the key and `'boite'` is the value.\n"
"\n"
"Like lists, a comma (`,`) is used to separate items (key-value pairs) from each other. A colon (`:`) separates the keys from the values.\n"
"Note that curly brackets (`{}`) are used to create the dictionary instead of the square brackets (`[]`) used when writing lists.\n"
"\n"
"Remember that with lists, you get values based on their *index*, i.e. their position in the list.\n"
"So if `words = ['apple', 'box']`, then `words[0]` is `'apple'` and `words[1]` is `'box'`.\n"
"Try this in the shell:\n"
"\n"
"__program_indented__"

msgid ""
"pages.IntroducingDictionaries.steps.dict_access2.special_messages.bad_french_value.text"
msgstr ""
"Oops, you need to set `french = {'apple': 'pomme', 'box': 'boite'}` before "
"we can continue."

msgid "pages.IntroducingDictionaries.steps.dict_access2.text"
msgstr ""
"That doesn't work because the position of items in a dictionary usually doesn't matter.\n"
"You don't usually care what's the 2nd or 5th or 100th word of the dictionary,\n"
"you just want to find a specific word like 'apple'. So try that instead:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingDictionaries.steps.dict_access3.requirements"
msgstr ""
"Run the same code as the previous step (`french['apple']`) in the shell, but"
" replace `'apple'` with `'box'`."

msgid ""
"pages.IntroducingDictionaries.steps.dict_access3.special_messages.bad_french_value.text"
msgstr ""
"Oops, you need to set `french = {'apple': 'pomme', 'box': 'boite'}` before "
"we can continue."

msgid "pages.IntroducingDictionaries.steps.dict_access3.text"
msgstr ""
"That's better!\n"
"\n"
"Now run a similar line in the shell to look up the translation for `'box'`."

msgid ""
"pages.IntroducingDictionaries.steps.dict_access4.special_messages.bad_french_value.text"
msgstr ""
"Oops, you need to set `french = {'apple': 'pomme', 'box': 'boite'}` before "
"we can continue."

msgid "pages.IntroducingDictionaries.steps.dict_access4.text"
msgstr ""
"And now you know both Python and French!\n"
"\n"
"Now let's translate from French to English:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingDictionaries.steps.final_text.text"
msgstr ""
"Sorry, you can't do that either. You can only look up a key to get its value, not the other way around.\n"
"The dictionary `french` only has 2 keys: `'apple'` and `'box'`. `'pomme'` is a value, not a key.\n"
"We'll soon learn why you can't just look up values directly, and what you can do about it.\n"
"\n"
"Note that both `french[0]` and `french['pomme']` raised the same type of error: a `KeyError`.\n"
"This error means that the provided key (`0` or `'pomme'` in this case) wasn't found in the dictionary.\n"
"It's not that `french[0]` isn't *allowed*, it's just that it means the same thing as always:\n"
"find the value associated with the key `0`. In this case it finds that no such key exists.\n"
"But `0` *could* be a key, because many types of keys are allowed, including strings and numbers."

msgid "pages.IntroducingDictionaries.steps.first_dict.text"
msgstr ""
"We've seen several types: `str`, `int`, `float`, `bool`, and `list`.\n"
"Only one of these types can contain multiple values: `list`.\n"
"Now we're going to learn about another container type: `dict`, short for ***dictionary***.\n"
"\n"
"Think of the familiar kind of dictionary where you look up a word to find its definition or a translation in another language.\n"
"Dictionaries in Python are similar, but more general. You look up a *key* (e.g. a word) to get the associated *value* (e.g. a definition or translation).\n"
"\n"
"For example, here's a little dictionary translating English words to French:\n"
"\n"
"__code0__\n"
"\n"
"Run the line above in the shell."

msgid "pages.IntroducingDictionaries.title"
msgstr "Introducing Dictionaries"

msgid "pages.IntroducingElif.steps.dna_example.text"
msgstr ""
"Szybka lekcja biologii! Większość komórek w twoim ciele zawiera pełny kod genetyczny w DNA.\n"
"Składa się on z nici zbudowanych z molekularnych jednostek zwanych nukleobazami, które występują w czterech rodzajach:\n"
"Adenina, Cytozyna, Guanina i Tymina, czyli w skrócie ACGT.\n"
"Część pojedynczej nici może wyglądać na przykład tak:\n"
"\n"
"    AGTAGCGTCCTTAGTTACAGGATGGCTTAT...\n"
"\n"
"Będzie ona sparowana z inną nicią, gdzie A jest zastępowane przez T i odwrotnie,\n"
"a C jest zastępowane przez G i odwrotnie, np.:\n"
"\n"
"    TCATCGCAGGAATCAATGTCCTACCGAATA...\n"
"\n"
"Dwie nici są 'zamykane' razem w słynną strukturę podwójnej helisy,\n"
"łącząc się poprzez pasujące pary A-T i C-G. Te połączenia są istotne w kopiowaniu DNA, gdy\n"
"komórki się dzielą i rozmnażają. Podwójna helisa jest rozpinana, a kod jest przepisywany\n"
"na jego przeciwną wersję, aby utworzyć kopię.\n"
"\n"
"Zamierzamy powtórzyć ten proces. Spróbujmy napisać podobny program, jak ten, który właśnie napisaliśmy:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingElif.steps.dna_example_with_elif.requirements"
msgstr ""
"Skopiuj program z pierwszego kroku na tej stronie, ale zamień 4 bloki `if` na kombinację bloków `if` i `elif` stąd.\n"
"Innymi słowy, zamień każde z ostatnich trzech `if` na `elif`, ale pozostaw pierwszy `if` bez zmian."

msgid "pages.IntroducingElif.steps.dna_example_with_elif.text"
msgstr ""
"Świetnie! Naśladowałeś właśnie to, co robią twoje komórki na co dzień.\n"
"\n"
"`if` wewnątrz `else` można zastąpić pojedynczym słowem kluczowym `elif`. Na przykład,\n"
"poprzedni kod można zmienić na:\n"
"\n"
"__code0__"

msgid "pages.IntroducingElif.steps.dna_example_with_else.hints.0.text"
msgstr ""
"Zmień:\n"
"\n"
"__code0__\n"
"\n"
"aby wyglądało jak poprawiony fragment. To tylko mała zmiana, wykonaj ją bez kopiowania i wklejania."

msgid "pages.IntroducingElif.steps.dna_example_with_else.hints.1.text"
msgstr "Teraz dokonaj tej samej zmiany w kodzie zamieniającym G i C."

msgid "pages.IntroducingElif.steps.dna_example_with_else.text"
msgstr ""
"Ojej, to nie do końca działa. `T` zostaje zamienione na `A`, ale `A` nie jest zamienione na nic.\n"
"Czy rozumiesz dlaczego?\n"
"\n"
"Gdy `char == 'A'`, wtedy instrukcja `char = 'T'` rzeczywiście jest wykonywana. Ale to oznacza, że kolejny\n"
"warunek `char == 'T'` również jest spełniony, więc `char = 'A'` i wracamy do punktu wyjścia.\n"
"Musimy zmienić `char` z `T` na `A` tylko wtedy, gdy `char` nie było wcześniej `A`,\n"
"czyli gdy `char == 'A'` było `False`. Możemy to zrobić za pomocą `else`, tak jak tutaj:\n"
"\n"
"__code0__\n"
"\n"
"Teraz popraw program, aby zamieniał wszystkie znaki poprawnie."

msgid "pages.IntroducingElif.steps.final_text.text"
msgstr ""
"Często mamy do czynienia z łańcuchem klauzul `elif`, gdy chcemy, by jeden z wielu\n"
"bloków kodu się wykonał, tak jak w tym przypadku. Ogólnie kod taki jak ten:\n"
"\n"
"__code0__\n"
"\n"
"można przepisać jako:\n"
"\n"
"__code1__\n"
"\n"
"co jest krótsze i oszczędza nam skomplikowanego zagnieżdżania. Różnica jest tylko kosmetyczna:\n"
"gdy komputer wykonuje ten kod, nie potrafi odróżnić jednej wersji od drugiej.\n"
"\n"
"Zauważ, że za `elif`(ami) opcjonalnie można dodać jeden ostatni `else`. Nie umieściliśmy go\n"
"w naszym przykładzie z DNA, ale moglibyśmy dodać go, aby ostrzec nas o wszelkich nieoczekiwanych znakach\n"
"w danych wejściowych lub zmienić `elif char == 'C':` na `else:`, gdybyśmy byli pewni\n"
"że dane wejściowe są poprawne."

msgid "pages.IntroducingElif.title"
msgstr "Wprowadzenie do `elif`"

msgid "pages.IntroducingForLoops.steps.final_text.text"
msgstr ""
"Kod można czytać prawie jak zwykły angielski:\n"
"\n"
"> For each character in the string `name`, print that character.\n"
"\n"
"> Dla każdego znaku w ciągu `name`, wydrukuj ten znak.\n"
"\n"
"Każdy znak to również normalny ciąg znaków (ang. string). `character` to normalna zmienna, której przed wykonaniem kodu po `:` przypisywana jest nowa wartość. Więc kod powyżej jest równoważny:\n"
"\n"
"    __no_auto_translate__\n"
"    name = 'World'\n"
"\n"
"    character = 'W'\n"
"    print(character)\n"
"\n"
"    character = 'o'\n"
"    print(character)\n"
"\n"
"    character = 'r'\n"
"    print(character)\n"
"\n"
"    character = 'l'\n"
"    print(character)\n"
"\n"
"    character = 'd'\n"
"    print(character)\n"
"\n"
"Zauważ, że moglibyśmy użyć innej nazwy zmiennej, `character` po prostu sprawia, że jest to jaśniejsze.\n"
"\n"
"Pętla for zazwyczaj stosuje się w następującej strukturze:\n"
"\n"
"    for <zmienna> in <kolekcja>: <kod do powtórzenia>\n"
"\n"
"Elementy `for`, `in`, i `:` są niezbędne."

msgid "pages.IntroducingForLoops.steps.first_for_loop.text"
msgstr ""
"Dobre wiadomości! Udało Ci się przebrnąć przez nudne podstawy. Możemy zacząć pisać niektóre ciekawe programy i trochę się bawić. Jednym z najpotężniejszych pojęć w programowaniu jest *pętla* (ang. loop), która pozwala powtarzać ten sam kod wielokrotnie. Python ma dwa rodzaje pętli: pętle `for` i pętle `while`. Oto przykład pętli for, spróbuj uruchomić ten program:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingForLoops.title"
msgstr "Wprowadzenie do pętli for"

msgid "pages.IntroducingFstrings.steps.basic_f_string_exercise.hints.0.text"
msgstr "To jest podobne do podanego przykładu f-stringa."

msgid "pages.IntroducingFstrings.steps.basic_f_string_exercise.hints.1.text"
msgstr "Czy zapomniałeś o `f`?"

msgid "pages.IntroducingFstrings.steps.basic_f_string_exercise.hints.2.text"
msgstr "Ile par nawiasów klamrowych potrzebujesz?"

msgid "pages.IntroducingFstrings.steps.basic_f_string_exercise.text"
msgstr ""
"Nie powiedzie się, ponieważ nie możemy użyć `+` między ciągiem znaków `\"Cześć Alice. Masz \"` a liczbą `age`.\n"
"\n"
"Napraw to, zastępując wszystkie konkatenacje ciągów znaków (+) jednym f-stringiem."

msgid ""
"pages.IntroducingFstrings.steps.concatenate_string_number.output_prediction_choices.0"
msgstr "\"Hello \" + name + \". You are \" + age + \" years old.\""

msgid ""
"pages.IntroducingFstrings.steps.concatenate_string_number.output_prediction_choices.1"
msgstr "Hello name. You are age years old."

msgid ""
"pages.IntroducingFstrings.steps.concatenate_string_number.output_prediction_choices.2"
msgstr "Hello Alice. You are 20 years old."

msgid ""
"pages.IntroducingFstrings.steps.concatenate_string_number.output_prediction_choices.3"
msgstr "Hello 'Alice'. You are 20 years old."

msgid "pages.IntroducingFstrings.steps.concatenate_string_number.text"
msgstr ""
"Składnia f-stringa zaczyna się od `f` po czym następuje ciąg znaków.\n"
"F-string może zawierać nazwy zmiennych w nawiasach klamrowych `{}`.\n"
"Będą one zastępowane wartościami tych zmiennych przekształconymi na ciągi znaków.\n"
"Zmienne mogą być dowolne: ciągi znaków, liczby, listy i tak dalej.\n"
"\n"
"W związku z tym f-stringi pozwalają łatwo łączyć ciągi znaków z liczbami, które nie mogą\n"
"po prostu zostać dodane do siebie. Na przykład, uruchom poniższy program:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingFstrings.steps.eval_expr_inside_f_string.text"
msgstr ""
"Ponadto, f-string może zawierać w nawiasach klamrowych dowolne wyrażenie Pythona.\n"
"Spróbuj tego w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingFstrings.steps.final_text.text"
msgstr ""
"Świetnie!\n"
"\n"
"Od teraz zachęcamy do używania f-stringów zamiast `+` do budowania ciągów znaków tam, gdzie to możliwe."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.0.text"
msgstr "Są cztery problemy z wyrażeniem wewnątrz `print`."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.1.text"
msgstr "Jest problem z syntaksem znalezienia liczby ludzi."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.2.text"
msgstr "Potem jeden z ciągów znaków ma problem z cudzysłowami."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.3.text"
msgstr "Jest też problem z syntaksem znalezienia imienia pierwszej osoby."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.4.text"
msgstr "Nie możesz dodać ciągu znaków do liczby!"

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.5.text"
msgstr "Czy poprawnie użyłeś nawiasów klamrowych w twoim f-stringu?"

msgid "pages.IntroducingFstrings.steps.fix_broken_program.text"
msgstr ""
"Jak widać, możemy także zdefiniować f-string używając cudzysłowów, tak jak w przypadku zwykłego ciągu znaków.\n"
"I podobnie jak w przypadku cudzysłowów, f-stringi są tylko notacją. Po ich wyliczeniu komputer zapomina,\n"
"że użyto f-stringa, przechowuje tylko końcowy wynik jako zwykły ciąg znaków.\n"
"\n"
"Oto bardzo zepsuty program:\n"
"\n"
"    __copyable__\n"
"    people = [\"Alice\", \"Bob\", \"Charlie\"]\n"
"    print('There are' + people.length() + 'people waiting, the first one's name is' + people.1 + '.')\n"
"\n"
"Napraw to!\n"
"Twoje rozwiązanie powinno działać dla dowolnej listy ciągów znaków o nazwie `ludzie`.\n"
"Na przykład w powyższym przypadku powinno wypisać:\n"
"\n"
"    There are 3 people waiting, the first one's name is Alice."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.0"
msgstr "f\"{name} went to {meal} with {friend}.\""

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.1"
msgstr "\"{name} went to {meal} with {friend}.\""

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.2"
msgstr "{name} went to {meal} with {friend}."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.3"
msgstr "'name' went to 'meal' with 'friend'."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.4"
msgstr "name went to meal with friend."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.5"
msgstr "\"Alice\" went to \"lunch\" with 'Bob'."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.6"
msgstr "'Alice' went to 'lunch' with 'Bob'."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.7"
msgstr "\"Alice went to lunch with Bob.\""

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.8"
msgstr "Alice went to lunch with Bob."

msgid "pages.IntroducingFstrings.steps.introduce_f_strings.requirements"
msgstr ""
"Uruchom program powyżej, ale zastąp ten kod wewnątrz `print()`:\n"
"\n"
"__code0__\n"
"\n"
"przez:\n"
"\n"
"__code1__"

msgid "pages.IntroducingFstrings.steps.introduce_f_strings.text"
msgstr ""
"Do tej pory łączyliśmy ciągi znaków, konkatenując je za pomocą `+`, na przykład:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Jednak jest to trochę niewygodne. Możemy napisać to samo w bardziej elegancki sposób, używając *f-stringa*.\n"
"Zastąp ostatnią linię programu powyżej poniższą linią i uruchom ją.\n"
"Upewnij się, że uwzględnisz `f` przed ciągiem znaków.\n"
"\n"
"__code1__"

msgid "pages.IntroducingFstrings.title"
msgstr "f-stringi"

msgid ""
"pages.IntroducingIfStatements.steps.excited_confused_exercise.hints.0.text"
msgstr ""
"Do istniejącego programu trzeba tylko dodać kilka linii. Wszystkie "
"istniejące kody powinny pozostać takie, jakie są."

msgid ""
"pages.IntroducingIfStatements.steps.excited_confused_exercise.hints.1.text"
msgstr ""
"Kod, który dodajesz, powinien być bardzo podobny do istniejącego kodu."

msgid "pages.IntroducingIfStatements.steps.excited_confused_exercise.text"
msgstr ""
"Czas na ćwiczenie. Zmodyfikuj powyższy program, aby dodać dodatkowy\n"
"parametr logiczny `confused`, tak aby program zaczynał się tak:\n"
"\n"
"__code0__\n"
"\n"
"(`sentence` może być dowolnym łańcuchem znaków, a dwie wartości logiczne mogą być albo `True`, albo `False`)\n"
"\n"
"Gdy `confused` jest prawdziwe (`True`), wypisane zdanie powinno mieć na końcu znak zapytania.\n"
"Jeśli zarówno `confused`, jak i `excited` są prawdziwe (`True`), zdanie powinno kończyć się na `!?`."

msgid ""
"pages.IntroducingIfStatements.steps.excited_example.output_prediction_choices.0"
msgstr "Hello World"

msgid ""
"pages.IntroducingIfStatements.steps.excited_example.output_prediction_choices.1"
msgstr "Hello World!"

msgid "pages.IntroducingIfStatements.steps.excited_example.text"
msgstr ""
"Zauważ, że kod znajdujący się wewnątrz pierwszej instrukcji `if` został wykonany, ale kod drugiej nie.\n"
"\n"
"Generalnie instrukcja `if` wygląda tak:\n"
"\n"
"    if <warunek>:\n"
"        <ciało>\n"
"\n"
"gdzie `<warunek>` to dowolne wyrażenie, które daje wynik w postaci wartości logicznej, a `<ciało>` to **wcięta** lista\n"
"jednego lub więcej stwierdzeń. Struktura jest dość podobna do pętli `for`. Zwróć uwagę na dwukropek (`:`), który\n"
"jest niezbędny.\n"
"\n"
"Gdy komputer widzi `if <warunek>:`, sprawdza, czy `<warunek>` jest `True`. Jeśli tak, wykonuje ciało.\n"
"Jeśli nie, pomija je i kontynuuje resztę programu.\n"
"\n"
"Oto bardziej interesujący przykład, który możesz uruchomić:\n"
"\n"
"__program_indented__"

msgid ""
"pages.IntroducingIfStatements.steps.excited_false_example.output_prediction_choices.0"
msgstr "Hello World"

msgid ""
"pages.IntroducingIfStatements.steps.excited_false_example.output_prediction_choices.1"
msgstr "Hello World!"

msgid "pages.IntroducingIfStatements.steps.excited_false_example.requirements"
msgstr ""
"Uruchom program z poprzedniego kroku, ale zamień `True` na `False`, tak żeby"
" było `excited = False`."

msgid "pages.IntroducingIfStatements.steps.excited_false_example.text"
msgstr ""
"(Pamiętaj, że `sentence += '!'` oznacza `sentence = sentence + '!'`)\n"
"\n"
"Zmień `excited = True` na `excited = False` i uruchom program ponownie, aby zobaczyć różnicę."

msgid "pages.IntroducingIfStatements.steps.final_text.text"
msgstr ""
"Brawo! Ten program może robić 4 różne rzeczy w zależności od tego, jak łączysz `excited`\n"
"i `confused`. Wypróbuj je, jeśli chcesz."

msgid "pages.IntroducingIfStatements.steps.first_if_statements.text"
msgstr ""
"Wartości logiczne są przeznaczone do użycia wewnątrz *instrukcji warunkowych* (ang. if statements). Nazywane są też czasami *warunkami* (ang. conditionals).\n"
"\n"
"Oto prosty przykład, który możesz uruchomić:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingIfStatements.steps.introducing_booleans.text"
msgstr ""
"Teraz nauczymy się, jak powiedzieć komputerowi, aby podejmował decyzje i wykonywał kod\n"
"tylko pod pewnymi warunkami. Do tego będziemy potrzebować nowego rodzaju wartości. Widziałeś już\n"
"liczby i łańcuchy znaków, teraz spotkaj się z *wartościami logicznymi* (ang. booleans). Istnieją tylko dwie wartości logiczne:\n"
"`True` i `False`. Wypróbuj ten program:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingIfStatements.title"
msgstr "Wprowadzenie do instrukcji warunkowych"

msgid "pages.IntroducingLists.steps.can_contain_anything.text"
msgstr ""
"Lista to rodzaj *sekwencji* (uporządkowanej kolekcji), która może zawierać dowolną liczbę wartości.\n"
"Nazywamy je często *elementami*.\n"
"Mogą to być przeróżne rzeczy: liczby, ciągi znaków, wartości logiczne, a nawet inne listy! Mogą również stanowić kombinację różnych typów.\n"
"\n"
"Żeby utworzyć listę bezpośrednio, tak jak w przykładzie:\n"
"\n"
"1. Zacznij od nawiasów kwadratowych: `[]`\n"
"2. Jeśli nie chcesz mieć pustej listy, umieść wewnątrz nawiasów wyrażenia, które staną się elementami listy.\n"
"3. Oddziel elementy przecinkami (`,`) by je od siebie rozdzielić.\n"
"\n"
"Oto inny przykład tworzenia listy:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingLists.steps.final_text.text"
msgstr ""
"Gratulacje! To było bardzo trudne! Jedno z możliwych rozwiązań wygląda tak:\n"
"\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"    separator = ' - '\n"
"    total = ''\n"
"    not_first = False\n"
"\n"
"    for word in words:\n"
"        if not_first:\n"
"            total += separator\n"
"        total += word\n"
"        not_first = True\n"
"\n"
"    print(total)"

msgid "pages.IntroducingLists.steps.first_list.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"\n"
"for word in words:\n"
"    print(word)"

msgid "pages.IntroducingLists.steps.first_list.text"
msgstr ""
"Nadszedł czas, aby dowiedzieć się o potężnym nowym typie wartości, zwanym *listami*. Oto przykład:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingLists.steps.numbers_sum.text"
msgstr ""
"Jak widziałeś powyżej, listy są *iterowalne*, co oznacza, że możesz iterować po nich przy użyciu `pętli for`.\n"
"Oto program, który sumuje wszystkie liczby w liście:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingLists.steps.strings_sum.hints.0.text"
msgstr ""
"To jest bardzo podobne do ćwiczeń, które wykonałeś, tworząc ciągi znaków "
"znak po znaku."

msgid "pages.IntroducingLists.steps.strings_sum.hints.1.text"
msgstr "Rozwiązanie jest bardzo podobne do programu, który sumuje liczby."

msgid "pages.IntroducingLists.steps.strings_sum.hints.2.text"
msgstr ""
"Tak naprawdę, co się stanie, jeśli spróbujesz uruchomić ten program z listą "
"ciągów znaków?"

msgid "pages.IntroducingLists.steps.strings_sum.hints.3.text"
msgstr ""
"Problem polega na tym, że 0. Nie możesz dodać 0 do ciągu znaków, ponieważ "
"liczby i ciągi znaków są niekompatybilne."

msgid "pages.IntroducingLists.steps.strings_sum.hints.4.text"
msgstr ""
"Czy jest podobne pojęcie wśród ciągów znaków do 0? Pusta początkowa wartość?"

msgid "pages.IntroducingLists.steps.strings_sum.text"
msgstr ""
"Teraz zmodyfikuj program, tak aby mógł sumować listę ciągów znaków zamiast liczb.\n"
"Na przykład, mając:\n"
"\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"\n"
"powinien wydrukować:\n"
"\n"
"    __no_auto_translate__\n"
"    Thisisalist"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.0.text"
msgstr ""
"To jest podobne do poprzedniego ćwiczenia. Możesz zacząć od swojego "
"rozwiązania z tego."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.1.text"
msgstr ""
"To ćwiczenie nie wymaga niczego wyjątkowego, a ostateczne rozwiązanie może "
"być dość proste. Ale wymaga starannego przemyślenia podejścia."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.10.text"
msgstr ""
"Możesz napisać program, który sprawdza, czy jesteś w *pierwszej* iteracji "
"pętli."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.11.text"
msgstr ""
"Wystarczy zrobić zmienną typu bool do śledzenia tego. Nie ma potrzeby "
"używania żadnych operatorów porównania ani liczb."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.12.text"
msgstr ""
"Spojrzeliśmy na programy, które robiły coś takiego "
"[tutaj](#UnderstandingProgramsWithSnoop)."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.13.text"
msgstr ""
"Więc jeśli pominięto dodawanie separatora tylko w pierwszej iteracji, będzie"
" miał `n - 1` separatorów. Teraz wystarczy tylko przemyśleć ostrożnie, jak "
"upewnić się, że separatory są we właściwym miejscu."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.14.text"
msgstr ""
"Zapominając na chwilę o pętli, musisz dodać do ciągu znaków w tej "
"kolejności: pierwsze słowo, separator, drugie słowo, separator, trzecie "
"słowo itd."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.15.text"
msgstr ""
"To oznacza, że w pierwszej iteracji dodajesz tylko pierwsze słowo. W drugiej"
" iteracji dodajesz separator, potem drugie słowo. W trzeciej iteracji "
"dodajesz separator, potem trzecie słowo. I tak dalej."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.16.text"
msgstr "Więc w swojej pętli najpierw dodaj separator, następnie dodaj słowo."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.17.text"
msgstr ""
"Pomiń dodawanie separatora w pierwszej iteracji, sprawdzając zmienną typu "
"bool."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.18.text"
msgstr ""
"Utwórz zmienną typu bool przed pętlą, później zmień ją wewnątrz pętli."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.19.text"
msgstr ""
"Zmieniaj ją dopiero po sprawdzeniu w pętli, inaczej nie będziesz w stanie "
"pominąć pierwszej iteracji."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.2.text"
msgstr ""
"W każdej iteracji, oprócz słowa z listy, musisz również dodać separator."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.3.text"
msgstr ""
"Ale nie chcesz dodawać separatora po dodaniu ostatniego słowa na liście."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.4.text"
msgstr ""
"Niestety nie ma \"odejmowania\" w ciągach znaków; nie możesz dodać "
"ostatniego separatora, a następnie go usunąć."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.5.text"
msgstr ""
"Zróbmy krok wstecz. Ostateczny wynik powinien zawierać każde słowo i `n - 1`"
" separatorów, gdzie `n` to liczba słów."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.6.text"
msgstr "Chcesz dodać separator w każdej iteracji oprócz jednej."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.7.text"
msgstr ""
"Możesz pominąć dodawanie separatora w jednej konkretnej iteracji używając "
"instrukcji `if`."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.8.text"
msgstr ""
"Później nauczysz się sposobu iterowania po liście i sprawdzania, czy jesteś "
"w ostatniej iteracji, ale na razie nie masz możliwości tego zrobienia."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.9.text"
msgstr "Jednak iteracja, którą pomijasz, nie musi być ostatnia!"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.text"
msgstr ""
"Wspaniale!\n"
"\n"
"Jeśli chcesz, możesz kontynuować [następnej stronie](#BuildingNewLists).\n"
"\n"
"Dla dodatkowego, opcjonalnego wyzwania: rozszerz program tak, aby dodawał łańcuch separatorów *pomiędzy* każdym słowem.\n"
"Na przykład, mając\n"
"\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"    separator = ' - '\n"
"\n"
"wypisałby:\n"
"\n"
"    __no_auto_translate__\n"
"    This - is - a - list"

msgid "pages.IntroducingLists.title"
msgstr "Wprowadzenie do list"

msgid "pages.IntroducingNestedLists.steps.double_subscripting.requirements"
msgstr ""
"Run `print(strings[1][0])` or something similar using `birdseye` to see how "
"it works."

msgid "pages.IntroducingNestedLists.steps.double_subscripting.text"
msgstr ""
"You may have solved it like this:\n"
"\n"
"__code0__\n"
"\n"
"There's a shorter way. `strings[1]` is an expression like any other, and subscripting like `[0]`\n"
"can be used on any expression, not just variables.\n"
"So you can skip the intermediate variable and just do it in one line:\n"
"\n"
"__code1__\n"
"\n"
"Take a good look at this syntax. If it looks new and fancy, it's not.\n"
"It's just the usual syntax for subscripting, applied twice.\n"
"Try it in `birdseye` to see how Python breaks it down into smaller pieces."

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.0.text"
msgstr "This is very similar to the previous exercise."

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.1.text"
msgstr ""
"Do you remember how to access the last position of a list (without using "
"`len`)?"

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.2.text"
msgstr "Similarly how do you access the second-to-last position in a list?"

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.3.text"
msgstr "If you can't remember, you can Google it!"

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.4.text"
msgstr "Indexing works similarly on lists and strings."

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.5.text"
msgstr ""
"Do you get an `index out of range` error? Is it for a string, or a list? "
"Why?"

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.6.text"
msgstr ""
"Make sure you are not confusing the order of the list index and the string "
"index."

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.7.text"
msgstr "Use `birdseye` if you're having trouble."

msgid "pages.IntroducingNestedLists.steps.double_subscripting_exercise.text"
msgstr ""
"Using this syntax, modify the program to print the last letter of the second-to-last string in the list `strings`.\n"
"You must use a single expression like above, and you are not allowed to use `len`.\n"
"Your solution should work for any non-empty list of strings.\n"
"For the previous example input it should print `f`."

msgid "pages.IntroducingNestedLists.steps.final_text.text"
msgstr ""
"Excellent! You now understand nested subscripting very well.\n"
"\n"
"We can still use all the list methods and functions we learned before.\n"
"For example we can add a new word to the last sublist of `strings` with `append`,\n"
"to come after `'you'`:\n"
"\n"
"__code0__\n"
"\n"
"After all, the sublist `strings[1]` is still a list like any other!\n"
"\n"
"On the next page we will learn about looping over nested lists."

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.0"
msgstr "hello"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.1"
msgstr "there"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.10"
msgstr "a"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.2"
msgstr "how"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.3"
msgstr "are"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.4"
msgstr "you"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.5"
msgstr "['hello', 'there']"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.6"
msgstr "['how', 'are', 'you']"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.7"
msgstr "h"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.8"
msgstr "t"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.9"
msgstr "e"

msgid "pages.IntroducingNestedLists.steps.first_nested_list_example.program"
msgstr ""
"strings = [['hello', 'there'], ['how', 'are', 'you']]\n"
"print(strings[1][0])"

msgid "pages.IntroducingNestedLists.steps.first_nested_list_example.text"
msgstr ""
"Well done!\n"
"\n"
"Applying subscripting twice can be even more powerful.\n"
"We can use it on not only a list of strings, but on *a list of lists* too.\n"
"For example, what does the following program print?\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingNestedLists.steps.string_list_exercise.hints.0.text"
msgstr "How can you access the second string in the list?"

msgid "pages.IntroducingNestedLists.steps.string_list_exercise.hints.1.text"
msgstr "Then how do you access a particular letter in a string?"

msgid "pages.IntroducingNestedLists.steps.string_list_exercise.hints.2.text"
msgstr "Remember that the indexing of lists and strings are very similar."

msgid "pages.IntroducingNestedLists.steps.string_list_exercise.text"
msgstr ""
"Exercise: given a list of strings, print the first letter of the second string in the list. For example, given:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"you should print `d`."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.0.text"
msgstr "This is very similar to the previous exercises."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.1.text"
msgstr "How many times do you need to use subscripting?"

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.2.text"
msgstr "First you need to access a sublist."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.3.text"
msgstr "Then a string in that sublist."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.4.text"
msgstr "Then a letter in that string."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.5.text"
msgstr "Use `birdseye` if you're having trouble."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.text"
msgstr ""
"As you can see Python allows us to have *nested lists*: a list where each element is another list (we refer to them as *sublists*).\n"
"\n"
"We can use subscripting even more than twice.\n"
"Write a program that takes a nested list `strings` like above,\n"
"and prints the **first letter of the third string in the second sublist**.\n"
"Use only a single expression like in the previous exercise.\n"
"For example, for the list above, it should print `y`."

msgid "pages.IntroducingNestedLists.title"
msgstr "Introducing Nested Lists"

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.0.text"
msgstr ""
"Think about how you would do this manually and systematically, with a pencil"
" and paper."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.1.text"
msgstr ""
"The fact that the password must be four letters long is very important. This"
" would be a lot harder to solve if the password could be any given length."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.2.text"
msgstr "But the string `letters` might have any number of characters."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.3.text"
msgstr ""
"If there are `n` different letters, then the number of possible passwords is"
" `n^4 == n*n*n*n` because there are `n` possible letters for each position "
"and they're all independent."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.4.text"
msgstr ""
"Suppose again that `letters = \"ABCD\"`. Imagine you have all possible "
"three-letter passwords. Now for each one, add an A at the end, or add a B, "
"or a C, or a D. That's how you would get all possible four-letter passwords."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.5.text"
msgstr ""
"Remember, a for loop can contain any statement, including another for loop."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.6.text"
msgstr "That applies to all for loops."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.7.text"
msgstr "One for loop inside another for loop is no longer enough."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.8.text"
msgstr "You have to go deeper."

msgid "pages.IntroducingNestedLoops.steps.crack_password_exercise.text"
msgstr ""
"For your next exercise, you need to crack a password. You know that it's exactly four letters long and that only a few letters are possible, which you've written down:\n"
"\n"
"__code0__\n"
"\n"
"You need to print out all possible passwords:\n"
"\n"
"    AAAA\n"
"    AAAB\n"
"    AAAC\n"
"    AAAD\n"
"    AABA\n"
"    AABB\n"
"    ...skipping a few...\n"
"    DDDA\n"
"    DDDB\n"
"    DDDC\n"
"    DDDD"

msgid "pages.IntroducingNestedLoops.steps.final_text.text"
msgstr ""
"Excellent! The solution goes like this:\n"
"\n"
"__code0__"

msgid "pages.IntroducingNestedLoops.steps.first_nested_loop.text"
msgstr ""
"You've seen that the indented body of an `if` or a loop can contain any kind of statement, including more `if` statements and loops. In particular a loop can contain another loop. Here's an example:\n"
"\n"
"__program_indented__\n"
"\n"
"This is called a *nested loop*. Nothing about it is really new, it's just worth understanding properly because it can be very useful for writing interesting programs."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.0.text"
msgstr "You'll need a for loop inside a for loop like before."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.1.text"
msgstr "This time something like `for player1 in players:` won't be enough."

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.10.text"
msgstr "You need to use a comparison operator."

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.11.text"
msgstr ""
"Once you figure out the relation, you can express it with an `if` statement."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.2.text"
msgstr "Your program needs to use the *positions* of the players in the list."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.3.text"
msgstr ""
"That means you need to loop over the positions and use indexing "
"(subscripting) to access the list entries."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.4.text"
msgstr "To loop over the positions, use `range`..."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.5.text"
msgstr "...and `len`."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.6.text"
msgstr ""
"Look at the desired output: `Charlie vs Alice`: `Charlie` comes before "
"`Alice` in the `players` list."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.7.text"
msgstr ""
"We don't want to print `Alice vs Charlie` because `Alice` comes AFTER "
"`Charlie` in `players`."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.8.text"
msgstr ""
"The only pairs we want to print are those where the left player comes before"
" the right player in the list."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.9.text"
msgstr ""
"How can we express this relation in terms of the list indices of the two "
"for-loops?"

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.text"
msgstr ""
"Wow, you're an artist too!\n"
"\n"
"If you'd like, you can just continue to the [next page](#IntroducingBirdseye) now. Or you can do a bonus challenge!\n"
"\n"
"Like the earlier exercise, you're organising a tournament for a game. You have a list of player names:\n"
"\n"
"__code0__\n"
"\n"
"This time, each pair of players should only appear once. Specifically, print only those pairs that are in\n"
"the same left-to-right order as they are in `players`, starting with pairs containing the leftmost person\n"
"in `players` and moving right. For example, for the above, your program should print\n"
"\n"
"    Charlie vs Alice\n"
"    Charlie vs Dylan\n"
"    Charlie vs Bob\n"
"    Alice vs Dylan\n"
"    Alice vs Bob\n"
"    Dylan vs Bob"

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_exercise.hints.0.text"
msgstr ""
"Think about how you would do this manually and systematically, with a pencil"
" and paper."

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_exercise.hints.1.text"
msgstr "You need to use a for loop inside a for loop."

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_exercise.hints.2.text"
msgstr ""
"You need an `if` statement to check that the two players aren't the same "
"person."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_exercise.text"
msgstr ""
"Perfect!\n"
"\n"
"Next exercise: you're organising a tournament for a game, such as chess or tennis. You have a list of player names:\n"
"\n"
"__code0__\n"
"\n"
"Every player is going to play against every other player twice: once where they get the advantage (e.g. by moving or serving first) and once not. Print out all the match combinations like this:\n"
"\n"
"    Alice vs Bob\n"
"    Alice vs Charlie\n"
"    Bob vs Alice\n"
"    Bob vs Charlie\n"
"    Charlie vs Alice\n"
"    Charlie vs Bob\n"
"\n"
"Note that \"Alice vs Bob\" and \"Bob vs Alice\" are both in the list, but there's no \"Alice vs Alice\" - we don't want anyone playing with themselves."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.0.text"
msgstr "You need to use a for loop inside a for loop."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.1.text"
msgstr "You need the numbers from 1 to 12."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.2.text"
msgstr "Whenever you need a sequence of consecutive numbers, use `range`."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.3.text"
msgstr "You want something like `for x in range(n):`."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.4.text"
msgstr ""
"This will start with `x = 0`, but there's an easy workaround for that."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.5.text"
msgstr "You can just add 1 to `x`."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.6.text"
msgstr "Use `*` to multiply numbers."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.7.text"
msgstr "Use an f-string with several variables."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.8.text"
msgstr ""
"Remember to print a line with the correct number of dashes after each "
"section."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.9.text"
msgstr ""
"Make sure each line is in the correct loop and has the right amount of "
"indentation."

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.messages.added_str_and_int.text"
msgstr "You can't add together strings and numbers. Use an f-string."

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.messages.adding_one_in_wrong_loop.text"
msgstr ""
"You added 1 to your outer loop variable at the wrong place!\n"
"Where should you do that instead to fix it?"

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.messages.too_long.text"
msgstr ""
"Your solution is too long. You only need a few lines of code for this problem.\n"
"Use a nested loop so that you don't need to repeat yourself.\n"
"The computer will do the repetition for you!"

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.messages.used_times_instead_of_x.text"
msgstr ""
"That's almost correct! Make sure to display the right character `x` in your table.\n"
"For example, your solution should display `3 x 4 = 12` and not `3 * 4 = 12`."

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.special_messages.multiply_with_x.text"
msgstr "To multiply numbers, use `*`"

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.text"
msgstr ""
"Make sure you fully grasp what's going on. `print(letter)` and `print('---')` each run 3 times, because their indentation puts them in the *outer loop*. `print(f'{letter} {number}')` is called 3 × 4 = 12 times, because it's in the *inner loop* `for number in range(4):` which has 4 iterations but is itself in the outer loop so it runs 3 times.\n"
"\n"
"Let's put this to use! Suppose you're a teacher and you need to print out all the multiplication tables from 1 to 12 for your students. You don't want to write them manually, but you can write a program to do it for you! Your program output should look like this including the lines of dashes:\n"
"\n"
"    1 x 1 = 1\n"
"    1 x 2 = 2\n"
"    1 x 3 = 3\n"
"    1 x 4 = 4\n"
"    1 x 5 = 5\n"
"    1 x 6 = 6\n"
"    1 x 7 = 7\n"
"    1 x 8 = 8\n"
"    1 x 9 = 9\n"
"    1 x 10 = 10\n"
"    1 x 11 = 11\n"
"    1 x 12 = 12\n"
"    ---\n"
"    2 x 1 = 2\n"
"    2 x 2 = 4\n"
"    2 x 3 = 6\n"
"    2 x 4 = 8\n"
"    2 x 5 = 10\n"
"    2 x 6 = 12\n"
"    2 x 7 = 14\n"
"    2 x 8 = 16\n"
"    2 x 9 = 18\n"
"    2 x 10 = 20\n"
"    2 x 11 = 22\n"
"    2 x 12 = 24\n"
"    ---\n"
"    3 x 1 = 3\n"
"    3 x 2 = 6\n"
"    3 x 3 = 9\n"
"    (you get the idea...)\n"
"    11 x 10 = 110\n"
"    11 x 11 = 121\n"
"    11 x 12 = 132\n"
"    ---\n"
"    12 x 1 = 12\n"
"    12 x 2 = 24\n"
"    12 x 3 = 36\n"
"    12 x 4 = 48\n"
"    12 x 5 = 60\n"
"    12 x 6 = 72\n"
"    12 x 7 = 84\n"
"    12 x 8 = 96\n"
"    12 x 9 = 108\n"
"    12 x 10 = 120\n"
"    12 x 11 = 132\n"
"    12 x 12 = 144\n"
"    ---"

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.0.text"
msgstr ""
"How would you describe instructions to type in this triangle manually?"

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.1.text"
msgstr ""
"Print a line of `size` plus signs, then `size - 1` plus signs, etc. down to "
"1 plus sign. For example print 5 `+`s, then 4 `+`s, then 3, 2, and 1."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.2.text"
msgstr "Break this down into subproblems."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.3.text"
msgstr ""
"How do you print one line of `+`s of a given length, and how do you go "
"through all the lengths?"

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.4.text"
msgstr ""
"Building up a line of characters should be very familiar from previous "
"exercises, the only difference is that you have to make it a given length "
"instead of just the same length as another string."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.5.text"
msgstr "An easy way to do something `n` times is to loop over `range(n)`."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.6.text"
msgstr "You need to use a for loop inside a for loop."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.7.text"
msgstr ""
"You need numbers that count down, like 5, 4, 3, 2, 1. There is a way to do "
"this with `range`, and you can easily look it up, but it's also easy to use "
"a normal range and do some very simple maths to convert numbers counting up "
"into numbers counting down."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.8.text"
msgstr "What formula converts 0 into 5, 1 into 4, 2 into 3, etc?"

msgid "pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.text"
msgstr ""
"Wow, you're basically a hacker now!\n"
"\n"
"One more exercise. Given a size:\n"
"\n"
"__code0__\n"
"\n"
"Print out an 'upside down' triangle made of the plus sign `+` whose sides are as long as the given size, e.g:\n"
"\n"
"    +++++\n"
"    ++++\n"
"    +++\n"
"    ++\n"
"    +"

msgid "pages.IntroducingNestedLoops.title"
msgstr "Introducing Nested Loops"

msgid "pages.IntroducingNotPage.steps.IntroducingNot.text"
msgstr ""
"Unlike the other two boolean operators `and` and `or`,\n"
"which are used in between two booleans (called *binary* operators),\n"
"`not` is used before only one boolean (called a *unary* operator).\n"
"It negates the expression to which it is applied, a bit like a minus sign. Try in the shell:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingNotPage.steps.NotFalse.text"
msgstr ""
"Now try the following:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.0.text"
msgstr ""
"What if you were instead asked to simplify this related but opposite function?\n"
"\n"
"__code0__"

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.1.text"
msgstr ""
"In that case there is a standard simplification trick you can apply that we "
"discussed a few pages ago."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.2.text"
msgstr ""
"In particular the `returns` are redundant because "
"`filename.endswith(\".png\") or filename.endswith(\".jpg\")` is already the "
"desired boolean."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.3.text"
msgstr ""
"So you can just write:\n"
"\n"
"__code0__"

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.4.text"
msgstr "For the real exercise, you can do something similar."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.5.text"
msgstr "The difference in the real exercise is that the result is reversed."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.6.text"
msgstr ""
"That is, `invalid_image` returns `True` when `valid_image` returns `False` "
"and vice versa."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.7.text"
msgstr "Remember what `not` does?"

msgid "pages.IntroducingNotPage.steps.NotPriority.text"
msgstr ""
"You can see in `birdseye` that\n"
"\n"
"__code0__\n"
"\n"
"is interpreted by Python as\n"
"\n"
"__code1__\n"
"\n"
"rather than:\n"
"\n"
"__code2__\n"
"\n"
"So, `not` has higher priority than `or` if there are no parentheses. It's the same as how\n"
"\n"
"__code3__\n"
"\n"
"means:\n"
"\n"
"__code4__\n"
"\n"
"rather than\n"
"\n"
"__code5__\n"
"\n"
"`not` also has higher priority than `and`.\n"
"\n"
"Again, the main thing to remember is to use parentheses or extra variables when in doubt.\n"
"\n"
"Exercise: Suppose you're writing a program which processes images. Only certain types of file can be processed.\n"
"If the user gives you a file that can't be processed, you want to show an error:\n"
"\n"
"__code6__\n"
"\n"
"Suppose that .png and .jpg files can be processed, but other file types cannot.\n"
"Here's an example function to do that:\n"
"\n"
"    __copyable__\n"
"__code7__\n"
"\n"
"This is longer than it needs to be. Rewrite `invalid_image` so that the body is a single line `return <expression>`,\n"
"i.e. no `if` statement. It should pass the same tests."

msgid "pages.IntroducingNotPage.steps.NotTrueOrTrue.text"
msgstr ""
"What is the priority of `not` compared to `and` and `or`? Try the following in `birdseye`:\n"
"\n"
"__code0__"

msgid "pages.IntroducingNotPage.steps.final_text.text"
msgstr ""
"Well done! Here are two valid solutions:\n"
"\n"
"__code0__\n"
"\n"
"(if you're curious, these are equivalent because of something called De Morgan's law)\n"
"\n"
"Also notice that this is another general pattern that can be simplified: if your code has the form:\n"
"\n"
"__code1__\n"
"\n"
"where `x` itself is a boolean, then it can be simplified to:\n"
"\n"
"__code2__"

msgid "pages.IntroducingNotPage.title"
msgstr "Introducing `not`"

msgid "pages.IntroducingOr.steps.ACommonMistake.requirements"
msgstr ""
"Run the program from the previous step, but replace:\n"
"\n"
"__code0__\n"
"\n"
"with:\n"
"\n"
"__code1__"

msgid "pages.IntroducingOr.steps.ACommonMistake.text"
msgstr ""
"Take careful note of how we wrote the condition:\n"
"\n"
"__code0__\n"
"\n"
"A common mistake is to write this instead:\n"
"\n"
"__code1__\n"
"\n"
"It makes sense if you read it like English:\n"
"\n"
"> `return` whether `name` is equal to either `\"Alice\"` or `\"Bob\"`\n"
"\n"
"But Python is not English, and that's not how `or` works.\n"
"\n"
"Replace the `return` line in the code with the above line, and try running it again."

msgid "pages.IntroducingOr.steps.AnExercise.disallowed.3.label"
msgstr "comparison chaining"

msgid "pages.IntroducingOr.steps.AnExercise.hints.0.text"
msgstr ""
"Remember, you can use comparison operators `<, >, <=, >=, ==` to produce "
"booleans."

msgid "pages.IntroducingOr.steps.AnExercise.hints.1.text"
msgstr "You need to check how `x` compares to 0 and how it compares to 100."

msgid "pages.IntroducingOr.steps.AnExercise.hints.2.text"
msgstr "You need to combine the two comparisons into one boolean using `or`."

msgid "pages.IntroducingOr.steps.AnExercise.hints.3.text"
msgstr ""
"Above we used a trick so that the whole function body was just `return "
"<comparison> or <comparison>`. But that won't work here!"

msgid "pages.IntroducingOr.steps.AnExercise.hints.4.text"
msgstr "You need to use an `if` statement."

msgid "pages.IntroducingOr.steps.AnExercise.hints.5.text"
msgstr "You need to have a `return False` and a `return True`."

msgid "pages.IntroducingOr.steps.AnExercise.hints.6.text"
msgstr ""
"If you have something like `x >= 0 or x <= 100`, you're on the wrong track. "
"That's going to be true for *any* value of `x`. After all, 101 is greater "
"than 0!"

msgid "pages.IntroducingOr.steps.AnExercise.text"
msgstr ""
"When we inspect it with `birdseye`, we can see that:\n"
"\n"
"__code0__\n"
"\n"
"is not translated into\n"
"\n"
"__code1__\n"
"\n"
"the way we think in English, but rather:\n"
"\n"
"__code2__\n"
"\n"
"which evaluates to `\"Bob\"` when `name == \"Alice\"` is `False`.\n"
"\n"
"Perhaps you feel like this:\n"
"\n"
"[![I now have additional questions](https://i.imgur.com/jN57tGt.png)](https://imgur.com/a/icKzI)\n"
"\n"
"The only thing you really need to know is this: Until you know what you're doing, always\n"
"make sure you put booleans on both sides of `or`, because it's a boolean operator.\n"
"`name == \"Alice\" or \"Bob\"` breaks that rule.\n"
"\n"
"If you're curious, the answers are below, but you can skip them if you want and move onto the exercise below.\n"
"\n"
"----\n"
"\n"
"> Why does `(name == \"Alice\") or (\"Bob\")` equal `\"Bob\"`? Why does it equal anything? `\"Bob\"` isn't even a boolean!\n"
"\n"
"The definition \"`A or B` is `True` if either `A` or `B` is `True`\" was a simplification. It's the easiest\n"
"way to think about `or` most of the time, especially for writing `if` statements.\n"
"The real definition is that if `A` is true then `A or B` is just `A` (in fact `B` is not even evaluated),\n"
"otherwise it's `B`.\n"
"You can see for yourself that if `A` and `B` are booleans then the two definitions are equivalent.\n"
"In this example `A` is `name == \"Alice\"` which is `False`, so `A or B` is `B` which is `\"Bob\"`.\n"
"\n"
"> Is there a better way to write the condition without repeating `name ==` each time?\n"
"\n"
"Yes! In [Functions and Methods for Lists](#FunctionsAndMethodsForLists) we mentioned the `in`\n"
"operator, which you can use with a list like this:\n"
"\n"
"__code3__\n"
"\n"
"But you can't always get rid of `or` like that.\n"
"\n"
"----\n"
"\n"
"Exercise: Write a function named `is_valid_percentage`, accepting one numerical argument `x`.\n"
"It should return `True` if `x` is between 0 and 100 (inclusive), and return `False` otherwise.\n"
"Your function should use `or`, and pass these tests:\n"
"\n"
"    __copyable__\n"
"__code4__"

msgid "pages.IntroducingOr.steps.FalseOrFalse.text"
msgstr ""
"Finally, try:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.FurtherImprovement.requirements"
msgstr ""
"Run the program from the previous step, but replace:\n"
"\n"
"__code0__\n"
"\n"
"with:\n"
"\n"
"__code1__"

msgid "pages.IntroducingOr.steps.FurtherImprovement.text"
msgstr ""
"We can do even better. Notice that\n"
"\n"
"__code0__\n"
"\n"
"is a boolean, and both `return` statements are returning booleans `True` or `False`.\n"
"The function:\n"
"\n"
" - returns `True` when `name == \"Alice\" or name == \"Bob\"` is `True`, and\n"
" - returns `False` when `name == \"Alice\" or name == \"Bob\"` is `False`.\n"
"\n"
"So we could simply return the boolean `name == \"Alice\" or name == \"Bob\"` itself in both cases!\n"
"\n"
"This is a common pattern for simplifying your code. If you ever find yourself writing code like:\n"
"\n"
"__code1__\n"
"\n"
"where `x` itself is a boolean, you can always simplify this block of code to:\n"
"\n"
"__code2__\n"
"\n"
"Apply this simplification to the code yourself, and run it again."

msgid "pages.IntroducingOr.steps.ImprovingWithOr.requirements"
msgstr ""
"Copy the program from the top of the page, then change the first four lines "
"of the function to use `or` as suggested."

msgid "pages.IntroducingOr.steps.ImprovingWithOr.text"
msgstr ""
"In the editor, replace:\n"
"\n"
"__code0__\n"
"\n"
"with:\n"
"\n"
"__code1__\n"
"\n"
"As you can see, `is_friend` will return `True` only when `name` is Alice or Bob.\n"
"The `or` is used in between the two booleans `name == \"Alice\"` and `name == \"Bob\"`."

msgid "pages.IntroducingOr.steps.InputAliceBob.text"
msgstr ""
"We learned about *booleans* (`True` and `False`) when we introduced If statements.\n"
"We also learned about comparison operators `==`, `<`, `>`, `<=`, `>=` which return booleans.\n"
"Now we want to combine booleans to check for more complex conditions.\n"
"\n"
"Here's a simple example: imagine you have two friends, Alice and Bob.\n"
"The function below accepts one parameter, `name`, and checks if the person with the given name is among your friends.\n"
"Copy and run the code in the editor:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingOr.steps.InspectWithBirdseye.requirements"
msgstr "Run the same code as in the previous step, but with `birdseye`."

msgid "pages.IntroducingOr.steps.InspectWithBirdseye.text"
msgstr ""
"The second and third tests fail! Our function seems to be doing the wrong thing:\n"
"it returns `\"Bob\"` (a string, not a boolean!) when `name` is `\"Bob\"` or `\"Charlie\"`. What is going on?\n"
"Run the same problematic code again with `birdseye`. Inspect the `return` statements of each `is_friend` call carefully.\n"
"(Use the blue arrow buttons)"

msgid "pages.IntroducingOr.steps.TrueOrFalse.text"
msgstr ""
"Good, now try:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.TrueOrTrue.text"
msgstr ""
"Let's see if we can do better.\n"
"We can combine the `if` and `elif` statements using **`or`**. `or` is a *boolean operator*,\n"
"meaning it's an operator (like `+` or `-`) which combines two booleans (`True` or `False`).\n"
"\n"
"The expression `A or B` is `True` if either `A` or `B` is `True`, i.e. if `A` is `True` or `B` is `True`, or both.\n"
"It's only `False` if neither `A` nor `B` is `True`, i.e. both are `False`.\n"
"\n"
"Try the following in the shell.\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.final_text.text"
msgstr "Good job!"

msgid "pages.IntroducingOr.title"
msgstr "Introducing `or`"

msgid "pages.IntroducingStrings.steps.final_text.text"
msgstr ""
"Shell zwraca dokładnie to samo, ponieważ nie ma nic więcej do obliczenia. `'hello'` po prostu równa się `'hello'`.\n"
"\n"
"Znak to pojedynczy symbol taki jak litera, cyfra, znak interpunkcyjny, spacja itd. W tym przypadku łańcuch `hello` zawiera 5 znaków. Apostrofy nie są częścią łańcucha - są tam, żeby pokazać zarówno ludziom, jak i komputerom, że jest to łańcuch składający się z jakichkolwiek znaków pomiędzy apostrofami."

msgid "pages.IntroducingStrings.steps.hello_string.text"
msgstr ""
"Python pozwala na dużo więcej niż tylko obliczenia. W rzeczywistości, nie będziemy zajmować się liczbami czy matematyką przez jakiś czas. Zamiast tego przyjrzymy się *łańcuchom znaków* (ang. strings). Łańcuchy znaków to w zasadzie fragmenty tekstu. Na przykład, wprowadź następujący kod do konsoli, razem z apostrofami (`'`):\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingStrings.title"
msgstr "Wprowadzenie do łańcuchów znaków (ang. Strings)"

msgid "pages.IntroducingTheShell.steps.final_text.text"
msgstr ""
"Doskonale! Kontynuuj eksperymentowanie. Gdy będziesz gotowy, kliknij "
"'Dalej', aby kontynuować."

msgid ""
"pages.IntroducingTheShell.steps.first_expression.messages.anything_else.text"
msgstr ""
"Wspaniale, próbujesz własnych eksperymentów!\n"
"To dobry znak. Kontynuuj w tym duchu.\n"
"Tylko informuję, że ostatecznie musisz wpisać `1+2`, aby książka mogła przejść dalej."

msgid "pages.IntroducingTheShell.steps.first_expression.text"
msgstr ""
"Po prawej stronie znajduje się *shell*. To miejsce do uruchamiania niewielkich fragmentów kodu Pythona. Wystarczy wpisać jakiś kod, nacisnąć enter, i to wszystko działa! Spróbuj teraz:\n"
"\n"
"1. Kliknij gdziekolwiek na shellu (czarny obszar).\n"
"2. Wpisz `__program__`\n"
"3. Naciśnij klawisz Enter na klawiaturze."

msgid "pages.IntroducingTheShell.steps.more_calculation.requirements"
msgstr ""
"Uruchom kod w shellu podobny do `1 + 2`, ale zamiast `+` użyj `*`, `/`, lub "
"`-`."

msgid ""
"pages.IntroducingTheShell.steps.more_calculation.special_messages.multiply_with_x.text"
msgstr ""
"Widzę 'x'. Jeśli próbujesz mnożyć, użyj gwiazdki, np.:\n"
"\n"
"__code0__"

msgid "pages.IntroducingTheShell.steps.more_calculation.text"
msgstr ""
"Świetnie! Python wykonał `1+2` i otrzymał wynik `3`, więc shell to wyświetlił.\n"
"\n"
"Shell to prawdopodobnie najważniejsze narzędzie do nauki Pythona i powinieneś spędzać dużo czasu na eksperymentowaniu i odkrywaniu go. Bądź ciekawy! Nieustannie zadawaj sobie pytanie \"Co by się stało, gdybym uruchomił X?\" i natychmiast odpowiadaj na to pytanie, uruchamiając to. Nigdy nie bój się próbować czegoś nowego - jeśli zrobisz coś nie tak, nic złego się nie stanie.\n"
"\n"
"Spróbuj teraz wykonać więcej obliczeń. Możesz mnożyć liczby używając `*`, dzielić za pomocą `/`, a odejmować z `-`. Możesz także użyć nawiasów, czyli `(` i `)`."

msgid "pages.IntroducingTheShell.title"
msgstr "Wprowadzenie do shella"


msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.0.text"
msgstr ""
"You can start by imitating `row_winner` above, then change it to make it "
"work with columns."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.1.text"
msgstr "You can't loop through the columns of `board` as simply as its rows."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.10.text"
msgstr ""
"Define a boolean for each column, then update it accordingly inside the "
"inner loop."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.11.text"
msgstr "The rest of the logic is very similar to `row_winner`."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.12.text"
msgstr "Watch out for `' '`."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.13.text"
msgstr "Remember to return `False` at the end if needed."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.2.text"
msgstr ""
"What *is* a column of a nested list? The first column consists of the first "
"element of the first row, the first element of the second row, etc."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.3.text"
msgstr ""
"Looping through all columns means looking at the first element of every row,"
" then the second element of every row, etc."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.4.text"
msgstr ""
"So you need to loop through numbers representing the positions first, "
"second, etc."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.5.text"
msgstr "How do you find the number of columns in `board`?"

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.6.text"
msgstr ""
"That covers the outer loop, which goes through each column. Then you need an"
" inner loop to go through each element in the column."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.7.text"
msgstr ""
"The different entries of a column are NOT on the same row. So how can you "
"access them?"

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.8.text"
msgstr ""
"You can loop through rows of the board and find the element corresponding to"
" that row and the current column."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.9.text"
msgstr ""
"To access all the entries of, say, the 5th column, you can loop through all "
"the rows, and access the 5th element in each row."

msgid "pages.IntroducingTicTacToe.steps.column_winner.text"
msgstr ""
"Great job!\n"
"\n"
"Now write a similar function `column_winner` which checks for a winning *column* (a vertical line) of either piece:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Here `O` won in the second column of the second board."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.0.text"
msgstr "How many diagonals are there on a square board of arbitrary size?"

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.1.text"
msgstr ""
"Even if the size of the board changes, the number of diagonals remains the "
"same!"

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.10.text"
msgstr ""
"You can use one loop and check both diagonals at the same time. Or you can "
"use one loop for each diagonal."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.2.text"
msgstr ""
"You can't do something like `middle == board[0][0] and middle == "
"board[2][2]` this time, because you don't know how long a diagonal is."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.3.text"
msgstr ""
"Moreover the two diagonals might not have anything in common like `middle`."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.4.text"
msgstr "First, focus on the diagonal that goes from top left to bottom right."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.5.text"
msgstr "How can you access those entries with double subscripting?"

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.6.text"
msgstr ""
"Do you see a pattern in those double subscripts? Get some paper and pen, "
"work it out on some examples."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.7.text"
msgstr ""
"Now focus on the other diagonal (from top right to bottom left). There is a "
"pattern in the subscripts again, but it's a little bit more difficult."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.8.text"
msgstr "Do you remember negative indexing? It might be helpful here."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.9.text"
msgstr ""
"Once you get the hang of the patterns, use the same ideas from before to "
"check if all entries are equal."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.text"
msgstr ""
"Excellent! That was challenging.\n"
"\n"
"Finally we need to check for winning diagonals. You already wrote a function to do just that in the previous chapter, for 3-by-3 boards:\n"
"\n"
"__code0__\n"
"\n"
"Now write a `diagonal_winner` that works for square boards of any size: 4-by-4, 5-by-5, and so on...\n"
"\n"
"    __copyable__\n"
"__code1__\n"
"\n"
"In the first example, `X` won in the diagonal going from the bottom left to the top right."

msgid "pages.IntroducingTicTacToe.steps.final_text.text"
msgstr ""
"Great work!\n"
"\n"
"Now we have the code to determine a winning state on the board."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.0.text"
msgstr ""
"You need to check every row in the board, so you'll need a loop for that."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.1.text"
msgstr "How can you check if all entries in a row are equal to each other?"

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.10.text"
msgstr "Make sure you return `False` if there are no winning rows"

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.2.text"
msgstr ""
"That's a self contained problem on its own. You can start by forgetting "
"about the whole board and just checking a single row."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.3.text"
msgstr ""
"You could even write a function which just does this, although you don't "
"have to."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.4.text"
msgstr ""
"Since the row could have any size, you'll have to loop all the way through "
"it."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.5.text"
msgstr ""
"For each row, define a boolean. Then loop through that row, updating the "
"boolean accordingly."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.6.text"
msgstr ""
"You can use the first entry `row[0]` in a row to compare all the row entries"
" to it."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.7.text"
msgstr ""
"Think carefully about what the initial value of the boolean should be, and "
"under what conditions you should change its value."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.8.text"
msgstr ""
"After looping through a row, if you determined that all its entries are "
"equal, then return `True` (ending the outer loop early)."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.9.text"
msgstr "Make sure you don't return `True` for a row filled with spaces."

msgid ""
"pages.IntroducingTicTacToe.steps.intro_row_winner.messages.catch_empty_row.text"
msgstr ""
"Keep in mind that some entries might be `' '`. An empty row is not a winning"
" row."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.text"
msgstr ""
"You've done many short exercises solving one little problem. Now we're going to tackle a larger, more complex\n"
"project which will really test your knowledge and require combining many smaller parts together.\n"
"It's going to be so fun!\n"
"\n"
"You will develop a text-based interactive tic-tac-toe game to be played by 2 human players.\n"
"Here is a small preview of what the finished game will look like in play:\n"
"\n"
"      1 2 3\n"
"    1  | |\n"
"      -+-+-\n"
"    2  | |\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"    X to play:\n"
"    1\n"
"    1\n"
"\n"
"      1 2 3\n"
"    1 X| |\n"
"      -+-+-\n"
"    2  | |\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"    O to play:\n"
"    2\n"
"    2\n"
"\n"
"      1 2 3\n"
"    1 X| |\n"
"      -+-+-\n"
"    2  |O|\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"    X to play:\n"
"    1\n"
"    3\n"
"\n"
"      1 2 3\n"
"    1 X| |X\n"
"      -+-+-\n"
"    2  |O|\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"We will break up the project into several small functions, which will be exercises.\n"
"\n"
"You will use many of the concepts you have learned so far: strings,\n"
"nested lists, nested loops, `range`, calling functions within functions, comparisons, and booleans.\n"
"\n"
"Along the way you will also learn some new concepts, including newline characters, types, and `input()`.\n"
"\n"
"Here is a rough outline of the project:\n"
"\n"
"- three functions `row_winner`, `column_winner`,  `diagonal_winner`  that check the whole board for winning rows, columns, and diagonals\n"
"- a function `winner` that checks the whole board for a winner, combining the above functions\n"
"- a function `format_board` that displays the current state of the game\n"
"- a function `play_move` that takes user input to play a move,\n"
"- finally a `play_game` function that puts it all together and runs the game interactively.\n"
"- Later on we will add further improvements.\n"
"\n"
"Let's get started!\n"
"\n"
"As in the last chapter, we will represent the tic-tac-toe board as a nested list of strings.\n"
"For a typical game this will be a 3x3 list, i.e. 3 lists each containing 3 strings, with players represented by `'X'` or `'O'`.\n"
"Empty squares will be represented by a space, i.e. `' '`. For example:\n"
"\n"
"__code0__\n"
"\n"
"However to make things more interesting your code will need to work for square boards of any size\n"
"(4x4, 5x5, etc) where players can be represented by any strings, e.g.\n"
"\n"
"__code1__\n"
"\n"
"Write a function `row_winner` which returns `True` if `board` contains\n"
"a winning row, i.e. a horizontal line which has the same character in all its entries (except `' '`):\n"
"\n"
"    __copyable__\n"
"__code2__\n"
"\n"
"In the second example, `O` wins in the bottom row."

msgid "pages.IntroducingTicTacToe.steps.winner.disallowed.0.message"
msgstr ""
"Your solution should work by calling the three functions. `winner` itself should not do any\n"
"looping, subscripting, etc. It should be very short.\n"
"\n"
"Copy the `row_winner` and other functions and leave them as they are. Don't copy code from them\n"
"into the `winner` function, just call those functions."

msgid "pages.IntroducingTicTacToe.steps.winner.hints.0.text"
msgstr ""
"The solution is quite short! Simply use the three functions correctly."

msgid "pages.IntroducingTicTacToe.steps.winner.hints.1.text"
msgstr ""
"Think about possible cases. When does `winner(board)` return `False`? When "
"does it return `True`?"

msgid "pages.IntroducingTicTacToe.steps.winner.hints.2.text"
msgstr ""
"How can you use the three functions and a boolean operator together to get "
"the result you need?"

msgid "pages.IntroducingTicTacToe.steps.winner.text"
msgstr ""
"Bravo! That was quite tough.\n"
"\n"
"Now we can put the three functions together! Write a function `winner` that takes an argument `board` as before,\n"
"and returns `True` if `board` contains either a winning row, column or diagonal, `False` otherwise.\n"
"\n"
"Your solution should work by calling the three functions. `winner` itself should not do any\n"
"looping, subscripting, etc.\n"
"\n"
"Here is some code for `row_winner`, `column_winner` and `diagonal_winner`, along with some tests for `winner`.\n"
"Click the Copy button, and fill in the blanks for your `winner` function.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingTicTacToe.title"
msgstr "Checking the board for winners"

msgid "pages.IntroducingVariables.steps.final_text.text"
msgstr ""
"Odpowiedź brzmi, że `sunshine` wygląda na zmienną, więc Python próbuje "
"znaleźć jej wartość, ale ponieważ nigdy nie zdefiniowaliśmy zmiennej o tej "
"nazwie, otrzymujemy błąd."

msgid ""
"pages.IntroducingVariables.steps.sunshine_undefined_check.output_prediction_choices.0"
msgstr "sunshine"

msgid ""
"pages.IntroducingVariables.steps.sunshine_undefined_check.output_prediction_choices.1"
msgstr "'sunshine'"

msgid ""
"pages.IntroducingVariables.steps.sunshine_undefined_check.output_prediction_choices.2"
msgstr "Hello"

msgid ""
"pages.IntroducingVariables.steps.sunshine_undefined_check.output_prediction_choices.3"
msgstr "'Hello'"

msgid "pages.IntroducingVariables.steps.sunshine_undefined_check.text"
msgstr ""
"Jak widać, apostrofy są bardzo istotne. `'word'` jest dosłownie tylko `'word'`, stąd technicznie nazywa się to *literałem łańcucha znaków* (ang. string literal). Z drugiej strony, `word` to zmienna, której wartość może być dowolna.\n"
"\n"
"Podobnie, `'sunshine'` to `'sunshine'`, ale co to jest `__program__` bez apostrofów?"

msgid "pages.IntroducingVariables.steps.word_assign.text"
msgstr ""
"Aby tworzyć interesujące programy, nie możemy zawsze manipulować tymi samymi wartościami. Potrzebujemy sposobu na odniesienie się do wartości, które nie są znane z góry i mogą się zmieniać. To właśnie są *zmienne* (ang. variables).\n"
"\n"
"Uruchom ten kod:\n"
"\n"
"__program_indented__"

msgid ""
"pages.IntroducingVariables.steps.word_check.special_messages.bad_word.text"
msgstr ""
"Ups, musisz ustawić `word = 'Hello'` zanim będziemy mogli kontynuować."

msgid "pages.IntroducingVariables.steps.word_check.text"
msgstr ""
"To tworzy zmienną o nazwie `word`, która odnosi się do wartości ciągu znaków `'Hello'`.\n"
"\n"
"Teraz zobacz, co się stanie, gdy uruchomisz jedynie `__program__` w shellu."

msgid ""
"pages.IntroducingVariables.steps.word_string_check.output_prediction_choices.0"
msgstr "word"

msgid ""
"pages.IntroducingVariables.steps.word_string_check.output_prediction_choices.1"
msgstr "'word'"

msgid ""
"pages.IntroducingVariables.steps.word_string_check.output_prediction_choices.2"
msgstr "Hello"

msgid ""
"pages.IntroducingVariables.steps.word_string_check.output_prediction_choices.3"
msgstr "'Hello'"

msgid "pages.IntroducingVariables.steps.word_string_check.text"
msgstr ""
"Dobrze. Dla porównania, uruchom jedynie `__program__` w shellu, z "
"apostrofami."

msgid "pages.IntroducingVariables.title"
msgstr "Wprowadzenie do zmiennych"


msgid "pages.LoopingOverNestedLists.steps.final_text.text"
msgstr ""
"You have mastered nested lists and how to combine them with nested loops.\n"
"Brilliant! You now have extremely powerful programming tools in your tool belt."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.0.text"
msgstr "This is very similar to the previous exercise."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.1.text"
msgstr "When should you print the boolean?"

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.2.text"
msgstr "Remember you want to print it only once."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.3.text"
msgstr ""
"Instead of defining a boolean for each sublist, define only one boolean for "
"the entire list."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.4.text"
msgstr "When and how should you modify the boolean?"

msgid "pages.LoopingOverNestedLists.steps.list_contains_word_exercise.text"
msgstr ""
"Well done!\n"
"\n"
"Next, print only one boolean to indicate if `word` is present in any string in the entire nested list at all. For example, if\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"your program should print `False`."

msgid ""
"pages.LoopingOverNestedLists.steps.nested_list_loop_python_tutor.requirements"
msgstr ""
"Run a single program consisting of the two parts above combined.\n"
"They're separated so that you don't need to type in the `numbers = [...]` part,\n"
"but typing in the nested loop part is best for learning.\n"
"Make sure the indentation is correct."

msgid "pages.LoopingOverNestedLists.steps.nested_list_loop_python_tutor.text"
msgstr ""
"Now run the same program again in Python Tutor.\n"
"\n"
"Examine what `numbers` looks like, and what `numbers[0]` up to `numbers[3]` are.\n"
"Look at how `sublist` and `num` variables advance."

msgid ""
"pages.LoopingOverNestedLists.steps.nested_list_nested_loop_example.requirements"
msgstr ""
"Run a single program consisting of the two parts above combined.\n"
"They're separated so that you don't need to type in the `numbers = [...]` part,\n"
"but typing in the nested loop part is best for learning.\n"
"Make sure the indentation is correct."

msgid ""
"pages.LoopingOverNestedLists.steps.nested_list_nested_loop_example.text"
msgstr ""
"You can use a nested loop to iterate over each element and sub-element of a nested list.\n"
"For example, consider this nested list.\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Click the button to copy the list into the editor, then type in the following nested loop.\n"
"\n"
"__code1__\n"
"\n"
"Look carefully at the code. Note that the outer loop creates a variable `sublist`\n"
"and the inner loop iterates over the same variable. This is a common pattern.\n"
"Now run the code."

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.0.text"
msgstr "How do you check if a string contains a word?"

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.1.text"
msgstr ""
"Make sure to check whether **the string** contains the word, not the "
"sublist."

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.2.text"
msgstr "How can you access each string in each sublist of a nested list?"

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.3.text"
msgstr "You need to use a nested loop."

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.4.text"
msgstr ""
"The loops should follow the same pattern as the example at the beginning of "
"the page."

msgid "pages.LoopingOverNestedLists.steps.string_contains_word_exercise.text"
msgstr ""
"Now let's solve some problems using this kind of loop.\n"
"\n"
"Suppose we have a nested list of strings like the one below,\n"
"and we want to search for a particular `word` deep within the list.\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"You can imagine that `strings` represents a book, where each sublist is a page and each string within\n"
"is a line in that page.\n"
"It could also represent a library, where each list is a book, and each string is a page.\n"
"\n"
"Write a program to print every string that contains `word`.\n"
"It should work for any `word` and `strings`. For the example above, it should print\n"
"\n"
"    hello there\n"
"    hello world\n"
"\n"
"Remember that there is a specific way to check if a string contains another string. If you can't remember how, Google it!"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.0.text"
msgstr "For each sublist, define a boolean."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.1.text"
msgstr "Go through a sublist, update the boolean accordingly."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.2.text"
msgstr "Only print the boolean once for each sublist."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.3.text"
msgstr "What should be the initial value for the boolean?"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.4.text"
msgstr ""
"What if one of the sublists is empty? What should you print for that "
"sublist?"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.5.text"
msgstr ""
"If you find the word in a string, the boolean should be set to `True`."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.6.text"
msgstr "What if a string doesn't contain the word?"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.7.text"
msgstr ""
"Doesn't matter! It doesn't change whether any other string might contain the"
" word."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.8.text"
msgstr ""
"In other words, don't set the boolean to `False` except at the beginning."

msgid "pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.text"
msgstr ""
"Nice!\n"
"\n"
"Now let's change the exercise slightly. This time the output should tell us which *sublists* contain `word`,\n"
"rather than which inner strings. In particular, we want to print a boolean for each sublist:\n"
"`True` if the sublist contains the word in any of its strings, `False` if it's not there at all.\n"
"\n"
"Given these example inputs:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"then your program should print\n"
"\n"
"__code1__\n"
"\n"
"Note that `word in sublist` won't work. For example, `\"hello\" in [\"hello there\", \"how are you\"]` is `False`\n"
"because `\"hello\"` is not *equal* to either of the two elements of that list, even though it is in one of them."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.0.text"
msgstr "Since the strings can have different lengths, this is a bit tricky."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.1.text"
msgstr "For how long should your outer loop go this time?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.2.text"
msgstr ""
"Before you start handling the strings, it might be a good idea to find the "
"longest string length first."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.3.text"
msgstr "The rest is very similar to the previous exercise."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.4.text"
msgstr ""
"The only difference is that now you have to determine whether to add a "
"letter from a string, or a space."

msgid "pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.text"
msgstr ""
"Excellent! If you'd like, you can just continue to the [next page](#DefiningFunctions) now.\n"
"Or you can do a bonus challenge!\n"
"\n"
"Now let's generalize the previous exercise to strings of unequal length. Once again you are given a list of strings.\n"
"Like before, write a program that prints the first letter of each string together on one line,\n"
"then the second letters together on the next line, and so on.\n"
"But this time, if a string does not have enough letters, it should print a space.\n"
"\n"
"For example, if\n"
"\n"
"    __no_auto_translate__\n"
"    strings = [\"abcqwe\", \"def\", \"ghiq\"]\n"
"\n"
"your program should print\n"
"\n"
"    adg\n"
"    beh\n"
"    cfi\n"
"    q q\n"
"    w\n"
"    e"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.0.text"
msgstr "This is NOT similar to the previous exercises on this page."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.1.text"
msgstr ""
"Think about the solution when there's just two strings. How can you "
"generalize it to a list of strings?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.2.text"
msgstr ""
"You'll need to go through the first letters, then the second letters, and so"
" on."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.3.text"
msgstr "You'll have to use a loop, but how long should the loop take?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.4.text"
msgstr "Remember that strings in the list have equal lengths."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.5.text"
msgstr "For each position (first, second etc.) define a new string."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.6.text"
msgstr "What should that string be initially?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.7.text"
msgstr ""
"For each position (first, second etc.) you'll have to go through each string"
" in the list."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.8.text"
msgstr "You'll need another loop inside the one you have."

msgid "pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.text"
msgstr ""
"Excellent!\n"
"\n"
"[Earlier in the course](#GettingElementsAtPositionExercises) there was an exercise\n"
"to print two strings vertically side by side, like this:\n"
"\n"
"    H W\n"
"    e o\n"
"    l r\n"
"    l l\n"
"    o d\n"
"\n"
"Now we're going to generalize this to a list of strings, rather than just two.\n"
"\n"
"For this exercise you are given a list of strings of **equal length**.\n"
"Write a program that prints the first letter of each string on one line,\n"
"then the second letter of each string on the next line, and so on. For example, if\n"
"\n"
"__code0__\n"
"\n"
"then your program should print\n"
"\n"
"    __no_auto_translate__\n"
"    adg\n"
"    beh\n"
"    cfi\n"
"\n"
"Your program should work for any such list. In particular, if you use the following list,\n"
"you'll discover a hidden message from the Zen of Python!\n"
"\n"
"    __copyable__\n"
"    __no_auto_translate__\n"
"    strings = [\"  b n\", \"f ete\", \"liths\", \"astat\", \"t ene\", \"  r d\"]\n"
"\n"
"Note that this time you shouldn't add spaces between letters in the output."

msgid "pages.LoopingOverNestedLists.title"
msgstr "Looping Over Nested Lists"

msgid "pages.MakingTheBoard.steps.final_text.text"
msgstr ""
"Well done!\n"
"\n"
"This could be solved by moving the first loop inside the second to make a new `row` each time:\n"
"\n"
"__code0__\n"
"\n"
"Another way is to make a copy of `row` each time, e.g. keep the original code but change one line:\n"
"\n"
"__code1__\n"
"\n"
"You can also copy `row` with `row[:]` or `list(row)`. But it's important to know that\n"
"all these methods make a *shallow copy* of the list.\n"
"That means they copy the whole list at the top level, without making copies of each element.\n"
"That's fine in this case where `row` only contains strings which can't be modified\n"
"and don't need copying. But if the elements are mutable objects like lists,\n"
"as is the case with `board`, you may run into the same problem again.\n"
"Here's an example:\n"
"\n"
"    __copyable__\n"
"__code2__\n"
"\n"
"Here each element of `cube` is a separate list, a copy of `board`.\n"
"And within each of those copies, each element is also a separate list, a copy of `row`.\n"
"But the shallow copies of `board` all have the same first element as each other (the first copy of `row`),\n"
"the same second element, and so on.\n"
"Changing `make_board` won't fix anything here, the solution is to either:\n"
"\n"
"- Call `make_board` repeatedly to make a new `board` each time, or\n"
"- Use the `deepcopy` function instead of `board.copy()`.\n"
"  `deepcopy` makes copies at every level of nested objects.\n"
"\n"
"If you're still confused, don't worry.\n"
"This is just preparing you to deal with your code behaving weirdly in the future.\n"
"You're not required to understand this right now and this lesson will still be valuable.\n"
"\n"
"Either way, we're ready to make the full game. You can do it!"

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.0.text"
msgstr "The existing code is almost correct."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.1.text"
msgstr "There are several ways to solve this."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.2.text"
msgstr "Some solutions involve adding something small."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.3.text"
msgstr ""
"You can also rearrange the code without adding or removing anything (except "
"spaces)."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.4.text"
msgstr "The problem is that a single list `row` is used several times."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.5.text"
msgstr ""
"So one solution is to make copies of `row` which will all be separate."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.6.text"
msgstr "Another solution is to make a new `row` from scratch each time."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.7.text"
msgstr ""
"There are a few ways to copy a list in Python with a tiny bit of code."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.8.text"
msgstr "Making a new row each time can be done by just rearranging the code."

msgid ""
"pages.MakingTheBoard.steps.fix_make_board.special_messages.not_separate.text"
msgstr "However, the sublists in the result are not all separate objects."

msgid "pages.MakingTheBoard.steps.fix_make_board.text"
msgstr ""
"Can you see what happened?\n"
"\n"
"Every row got an `'X'` in the first position!\n"
"It's as if the code actually did this:\n"
"\n"
"__code0__\n"
"\n"
"Try and figure out what's wrong by yourself.\n"
"But again, it's tricky, so don't drive yourself crazy over it.\n"
"\n"
"If you want, here's some hints:\n"
"\n"
" - Try running the code through some debuggers.\n"
" - Experiment. Make changes to the code and see what happens.\n"
" - No, the code didn't do 3 assignments like I suggested above. There was just one list assignment.\n"
" - There's no hidden loops or anything.\n"
" - How many lists does `board` contain? 3?\n"
" - The previous page has a subtle hint at what happened.\n"
" - There is a page from a previous chapter where this kind of problem is explained directly.\n"
" - Specifically [this page](#EqualsVsIs).\n"
" - Try running the code with Python Tutor.\n"
"\n"
"OK, if you're ready, here's the answer.\n"
"\n"
"The list `row` was only created once, and reused several times.\n"
"`board` contains the same list three times. Not copies, just one list in three places.\n"
"It's like it did this:\n"
"\n"
"__code1__\n"
"\n"
"Which means that this code:\n"
"\n"
"__code2__\n"
"\n"
"is equivalent to:\n"
"\n"
"__code3__\n"
"\n"
"which affects 'all the lists' in `board` because they're all just the one list `row`.\n"
"In other words, the above line is *also* equivalent to each of these two lines:\n"
"\n"
"__code4__\n"
"\n"
"because `row` is `board[0]`, `board[1]`, and `board[2]` all at once.\n"
"\n"
"Your job now is to fix `make_board` to not have this problem.\n"
"It should still return a list of length `size` where each\n"
"element is also list of length `size` where each element is the string `' '`.\n"
"The sublists should all be separate list objects, not the same\n"
"list repeated."

msgid "pages.MakingTheBoard.steps.naive_make_board.text"
msgstr ""
"So far the board has been provided for you as a nested list.\n"
"But for the full program, you need to create it yourself.\n"
"Should be easy, right? Here's some code to do that:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"It's close, but there's a subtle problem with it.\n"
"Make sure you understand the code,\n"
"and bonus points if you can spot the bug!\n"
"If not, don't feel bad or waste too much time on it."

msgid "pages.MakingTheBoard.title"
msgstr "Making the Board"

msgid "pages.ModifyingWhileIterating.steps.final_text.text"
msgstr ""
"Powtórzmy raz jeszcze, ***nigdy nie modyfikuj czegoś podczas iteracji nad tym***. Twoje opcje to:\n"
"\n"
"- Modyfikuj kopię\n"
"- Iteruj przez kopię\n"
"- Nie modyfikuj niczego, zamiast tego stwórz nową wersję."

msgid "pages.ModifyingWhileIterating.steps.make_copy.requirements"
msgstr ""
"Uruchom ten sam program co wyżej, ale zmień drugą linię:\n"
"\n"
"__code0__\n"
"\n"
"na:\n"
"\n"
"__code1__\n"
"\n"
"czyli dodaj `.copy()` po `numbers`, ale przed `:`."

msgid "pages.ModifyingWhileIterating.steps.make_copy.text"
msgstr ""
"Ale okazuje się, że robi to niemal to samo - nie kończy się błędem, ale nadal nie usuwa 7 ani 3.\n"
"Dzieje się tak z tego samego powodu - iteracja przez listę wciąż odbywa się pod spodem przez indeksy.\n"
"\n"
"Morał z tego taki aby ***nigdy nie modyfikować czegoś, po czym się iteruje***. Oddzielaj mutację i iterację.\n"
"\n"
"Dobra wiadomość jest taka, że istnieje wiele innych sposobów aby do tego podejść. Możesz zamiast tego po prostu iterować przez kopię, jak tutaj:\n"
"\n"
"__code0__"

msgid "pages.ModifyingWhileIterating.steps.make_copy2.text"
msgstr ""
"Teraz lista, która jest modyfikowana i lista, która jest iterowana, to oddzielne obiekty, nawet jeśli zaczynają z równą zawartością.\n"
"\n"
"Podobnie, możesz iterować przez oryginał i modyfikować kopię:\n"
"\n"
"__program_indented__"

msgid "pages.ModifyingWhileIterating.steps.make_new_list.text"
msgstr ""
"Albo możesz zbudować nową listę od zera. Zrobiliśmy już coś podobnego w ćwiczeniu:\n"
"\n"
"__program_indented__"

msgid "pages.ModifyingWhileIterating.steps.remove_instead_of_pop.text"
msgstr ""
"W trakcie działania programu widać, że nawet nie bierze pod uwagę 7 lub 3 i nie usuwa ich. Na końcu kończy się niepowodzeniem, kiedy próbuje uzyskać dostęp do indeksu, który jest za wysoki. Czy rozumiesz, dlaczego się tak dzieje?\n"
"\n"
"Zmienna indeksowa `i` przechodzi przez typowe wartości 0, 1, 2, ... jak powinna, ale w miarę zmiany listy te pozycje już nie są tymi, których chcemy. Na przykład w pierwszej iteracji `i` jest 0 i `number` to 10, który zostaje usunięty. Przesuwa to pozostałe numery o jedną pozycję w lewo, więc teraz 7 jest na pozycji 0. Ale w następnej iteracji `i` jest 1, a `numbers[i]` to 8. 7 został pominięty.\n"
"\n"
"Moglibyśmy spróbować napisać program używając `remove` zamiast `pop`, aby nie korzystać z indeksów. Nawet wygląda to ładniej w ten sposób.\n"
"\n"
"__program_indented__"

msgid "pages.ModifyingWhileIterating.steps.run_broken_with_python_tutor.text"
msgstr ""
"Spójrz na ten program. Przeszukuje on listę liczb i usuwa te mniejsze niż 10. Przynajmniej próbuje to zrobić.\n"
"Uruchom go z Python Tutor.\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"(pamiętaj, że `numbers.pop(i)` usuwa element z `numbers` o indeksie `i`)"

msgid "pages.ModifyingWhileIterating.title"
msgstr "Modyfikowanie podczas iteracji"

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno zawierać dokładnie trzy instrukcje: `x = [15, 12, "
"-6, 3]`, `y = ` stanowione przez jedną linię dokładnie skopiowaną z listy, i"
" `print(y)`."

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.1.text"
msgstr ""
"Jeśli nie jesteś pewien, sprawdź, jak oblicza się średnią/średnią "
"arytmetyczną."

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.2.text"
msgstr "Do obliczenia średniej liczb w `x` potrzebujemy dwóch rzeczy."

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.3.text"
msgstr "Które dwie funkcje/metody dają ci te dwie rzeczy?"

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.4.text"
msgstr "Jak połączyć te dwie rzeczy, aby obliczyć średnią?"

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.requirements"
msgstr ""
"Skopiuj trzy linie powyżej, a następnie zastąp "
"`(insert_one_line_from_above)` dokładnie jedną linią z długiej listy linii "
"powyżej. Środkowa linia powinna nadal zaczynać się od `y = `."

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.text"
msgstr ""
"Dobra robota! Do następnego ćwiczenia zacznij od tego niekompletnego programu:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Zastąp partię po `y = ` jedną linią z listy powyżej.\n"
"Końcowy program powinien wydrukować średnią (technicznie *średnią arytmetyczną*) liczb w `x`."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno zawierać dokładnie trzy instrukcje: `x = ['a', "
"'b', 'c']`, `y = ` stanowione przez jedną linię dokładnie skopiowaną z "
"listy, i `print(y)`."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.1.text"
msgstr "Kiedy `1 in x` jest prawdziwe?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.2.text"
msgstr "Kiedy `1` jest w `x`!"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.3.text"
msgstr "Może to być, że `1` jest na `x` raz, albo dwa razy, albo trzy razy..."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.4.text"
msgstr "...ale nie zero razy!"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.requirements"
msgstr ""
"Skopiuj trzy linie powyżej, a następnie zastąp `1 in x` dokładnie jedną "
"linią z długiej listy linii powyżej. Środkowa linia powinna nadal zaczynać "
"się od `y = `. Wybrana linia powinna mieć taki sam efekt jak `1 in x`, aby "
"program wydrukował `True`."

msgid "pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.text"
msgstr ""
"Możesz rozpoznać niektóre z nich z poprzednich ćwiczeń. Zapewniam, że te ćwiczenia nie były bezcelowe,\n"
"ponieważ nauczyłeś się teraz cennych podstawowych umiejętności. Na przykład, możesz użyć `in` do sprawdzenia, czy lista zawiera 5,\n"
"ale nie ma podobnie łatwego sposobu na sprawdzenie, czy w liście jest liczba większa niż 5.\n"
"\n"
"Teraz rozwiążesz kolejny zestaw czterech ćwiczeń dotyczących tych nowych pojęć.\n"
"Znowu, poprawne i niepoprawne linie kodu są ze sobą wymieszane,\n"
"i musisz wybrać poprawną linię z listy.\n"
"\n"
"__code0__\n"
"\n"
"Oto program:\n"
"\n"
"    __copyable__\n"
"__code1__\n"
"\n"
"Zastąp część `1 in x` (zostaw `y = `) jedną linią z listy powyżej, która robi to samo."

msgid "pages.MoreListFunctionsAndMethods.steps.count_predict_exercise.text"
msgstr ""
"**`count`**: Zwraca liczbę wystąpień argumentu na liście używając składni\n"
"\n"
"__code0__\n"
"\n"
"Na przykład uruchom tę linię w shellu:\n"
"\n"
"__program_indented__"

msgid "pages.MoreListFunctionsAndMethods.steps.final_text.text"
msgstr "Gratulacje! Jesteś teraz mistrzem metod i funkcji list!"

msgid "pages.MoreListFunctionsAndMethods.steps.in_predict_exercise.text"
msgstr ""
"**`in`**: Operator porównania, który sprawdza, czy wartość znajduje się na liście, używając składni\n"
"\n"
"__code0__\n"
"\n"
"Na przykład uruchom ten program:\n"
"\n"
"__program_indented__"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno zawierać dokładnie trzy instrukcje: `x = [12, -6, "
"2, -1, 3]`, `y = ` stanowione przez jedną linię dokładnie skopiowaną z "
"listy, i `print(y)`."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.1.text"
msgstr ""
"Liczby w `x` wydają się być wszystkie pomieszane. Czy możesz z tym coś "
"zrobić?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.2.text"
msgstr ""
"Jeśli to zrozumiałeś, spróbuj użyć tej funkcji w shellu, aby pobawić się "
"nią."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.3.text"
msgstr ""
"Jak użyjesz tej funkcji, aby uzyskać najmniejszą wartość na liście? A "
"największą?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.4.text"
msgstr "Potem jak możesz uzyskać *drugą* najmniejszą wartość?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.requirements"
msgstr ""
"Skopiuj trzy linie powyżej, a następnie zastąp "
"`(insert_one_line_from_above)` dokładnie jedną linię z długiej listy linii "
"powyżej. Środkowa linia powinna nadal zaczynać się od `y = `."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.text"
msgstr ""
"Doskonale. I ostatnie:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Zastąp partię po `y = ` jedną linią z listy powyżej.\n"
"Końcowy program powinien wydrukować *drugą najmniejszą wartość* w `x`."

msgid "pages.MoreListFunctionsAndMethods.steps.sorted_predict_exercise.text"
msgstr ""
"Oto kilka bardziej użytecznych funkcji/metod.\n"
"\n"
"**`sorted`**: Bierze iterowalny obiekt i zwraca listę elementów w kolejności od najmniejszego do największego, używając składni\n"
"\n"
"__code0__\n"
"\n"
"Na przykład uruchom tę linię w shellu:\n"
"\n"
"__program_indented__"

msgid "pages.MoreListFunctionsAndMethods.steps.sum_predict_exercise.text"
msgstr ""
"**`sum`**: Sumuje iterowalny zbiór liczb używając składni\n"
"\n"
"__code0__\n"
"\n"
"Na przykład uruchom tę linię w shellu:\n"
"\n"
"__program_indented__"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno zawierać dokładnie trzy instrukcje: `x = 100`, `y "
"= ` stanowione przez jedną linię dokładnie skopiowaną z listy, i `print(y)`."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.hints.1.text"
msgstr "Jaką funkcję/metodę można użyć do sumowania rzeczy?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.hints.2.text"
msgstr "Która funkcja/metoda daje nam liczby `1, 2, 3, ..., x`?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.hints.3.text"
msgstr ""
"Musisz wprowadzić małą zmianę, inaczej ta ostatnia liczba `x` zostanie "
"pominięta."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.requirements"
msgstr ""
"Skopiuj trzy linie powyżej, a następnie zastąp "
"`(insert_one_line_from_above)` dokładnie jedną linię z długiej listy linii "
"powyżej. Środkowa linia powinna nadal zaczynać się od `y = `."

msgid "pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.text"
msgstr ""
"Dobra robota! Do następnego ćwiczenia zacznij od tego niekompletnego programu:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Zastąp partię po `y = ` jedną linią z listy powyżej.\n"
"Końcowy program powinien wydrukować wynik sumowania wszystkich liczb od `1` do `x` włącznie, czyli `1 + 2 + 3 + ... + x`."

msgid "pages.MoreListFunctionsAndMethods.title"
msgstr "Więcej Funkcji i Metod List"

msgid "pages.MoreOnReturn.steps.break_vs_return.requirements"
msgstr ""
"Run the same code as in the previous step, but replace the whole last line "
"of the function (`return letter`) with just `break`."

msgid "pages.MoreOnReturn.steps.break_vs_return.text"
msgstr ""
"As before, `return` ***stops the whole function***, including all loops.\n"
"\n"
"Previously we showed [how to stop a loop with `break`](#UsingBreak).\n"
"Change `return letter` to `break` and see what the difference is."

msgid "pages.MoreOnReturn.steps.cannot_return_multiple_values.text"
msgstr ""
"Once a `return` statement is executed, the function will stop, and the rest of the code is ignored.\n"
"This means that any code immediately after a `return` in the same block is *unreachable*:\n"
"`return 2` can *never* be reached no matter how many times we run this function!\n"
"\n"
"***One, and only one `return` can be executed per function call, then execution stops.***\n"
"\n"
"Multiple `return` statements can still be useful when used properly, e.g. in an `if-else` block:\n"
"\n"
"__code0__\n"
"\n"
"A common mistake is to misunderstand what `return` does in `for` loops. Try the following:\n"
"\n"
"    __copyable__\n"
"__code1__"

msgid "pages.MoreOnReturn.steps.double_return_in_one_function.text"
msgstr ""
"Sometimes `return` can be a source of confusion and mistakes for new learners.\n"
"Let's learn more about how it works.\n"
"\n"
"Run this code:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.MoreOnReturn.steps.final_text.text"
msgstr ""
"Unlike `return`, `break` only stops the innermost loop in which it is used, in this case `for number in range(3):`.\n"
"Here's exactly what happens:\n"
"\n"
"- For `letter = b`, the line `print(f\"{letter} {number}\")` is executed only for `number = 0`,\n"
"- then the inner loop is stopped by `break`, but\n"
"- the outer loop continues its execution, moving on to the next letter `c`\n"
"- which is executed in full since it does not trigger the `break` statement."

msgid "pages.MoreOnReturn.steps.return_ends_whole_function.text"
msgstr ""
"At first it may look intuitive to `return` one value for each iteration in a `for` loop.\n"
"But it doesn't work like that!\n"
"If you inspect the code with `snoop` or Python tutor you can see that the function returns 2 in the first\n"
"loop iteration and then ends immediately.\n"
"\n"
"Even when there's only one `return` statement, it will get executed only once and return one value.\n"
"If you want to return several values, return a list:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"What happens if there are nested loops? Try the following function:\n"
"\n"
"    __copyable__\n"
"__code1__"

msgid "pages.MoreOnReturn.title"
msgstr "`return` ends the function call"

msgid "pages.MultiLineExpressions.steps.final_text.text"
msgstr ""
"So if you get a mysterious `SyntaxError`, make sure that you haven't "
"improperly broken up any lines!"

msgid "pages.MultiLineExpressions.steps.invalid_multiline.program"
msgstr ""
"is_friend = name == \"Alice\" or\n"
"            name == \"Bob\""

msgid "pages.MultiLineExpressions.steps.invalid_multiline.text"
msgstr ""
"Our code lines are starting to get quite long.\n"
"Thankfully Python offers a few ways to spread out one statement across many lines,\n"
"but it's not automatic. You have to make sure Python understands that's what you're doing.\n"
"For example, this code is invalid syntax and will give you an error:\n"
"\n"
"__program_indented__"

msgid "pages.MultiLineExpressions.steps.valid_multiline.text"
msgstr ""
"Python tries to intepret this as two separate lines of code and gets confused. You need to tell it that\n"
"the first line is continuing onto the second line.\n"
"\n"
"One way to do this is by adding `\\` at the end of the line to 'escape' the line break.\n"
"\n"
"Another way is to ensure that the line break is contained within some kind of brackets. Then the line\n"
"continuation is implied because Python will wait till all brackets have been closed before\n"
"considering a line to be complete. If you already have brackets because for example you're calling a function\n"
"or making a list, you may not need to do anything! Otherwise you can add brackets to any expression\n"
"to imply the line continuation.\n"
"\n"
"Here are some examples. Pay close attention to the details.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.MultiLineExpressions.title"
msgstr "Multi-line statements"

msgid "pages.NavigatingShellHistory.steps.final_text.text"
msgstr ""
"Oto wskazówka: często będziesz chciał ponownie uruchomić wcześniej "
"wprowadzony kawałek kodu lub jego nieco zmodyfikowaną wersję. Możesz "
"skopiować i wkleić, ale to żmudne i przeszkadza w eksperymentowaniu. Lepszą "
"metodą jest naciśnięcie strzałki w górę na klawiaturze. "
"Spowoduje to wstawienie poprzedniej linii kodu do shella. Kontynuuj "
"naciskanie, aby cofnąć się dalej w historii, a jeśli przejdziesz za daleko, "
"naciśnij strzałkę w dół, aby przejść w drugą stronę. Spróbuj teraz tego użyć."

msgid "pages.NavigatingShellHistory.title"
msgstr "Poruszanie się po historii shella"


msgid "pages.NestedListAssignment.steps.final_text.text"
msgstr "Brilliant! You're almost ready to put it all together, keep going!"

msgid "pages.NestedListAssignment.steps.modify_list_in_function.text"
msgstr ""
"We've seen how to get input from the user, now let's use that to actually put pieces\n"
"on the board and play the game. For starters, try out this code:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.0.text"
msgstr ""
"Your function needs to call `input()` twice. Input isn't passed to "
"`play_move` as an argument."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.1.text"
msgstr "`input()` always returns a string."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.10.text"
msgstr ""
"Once you've got two numbers, you need to modify the nested list `board` with"
" them."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.11.text"
msgstr "The code for this has been shown to you above."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.12.text"
msgstr ""
"You just need to use the numbers from user input instead of the hardcoded 1 "
"and 0."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.13.text"
msgstr "You can use nested subscripting in one line, or do it in two steps."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.2.text"
msgstr "A string that looks like a number is still a string, not a number."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.3.text"
msgstr "List indices have to be numbers, not strings."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.4.text"
msgstr ""
"If the board is 3x3, the user might input 1, 2, or 3 for each coordinate."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.5.text"
msgstr "What are the valid indices of a list of length 3?"

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.6.text"
msgstr "You need to take the input of 1, 2, or 3 and turn it into 0, 1, or 2."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.7.text"
msgstr "You also need to be able to handle bigger boards, like 9x9 or beyond."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.8.text"
msgstr "You can't do maths with strings, only numbers."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.9.text"
msgstr "How can you convert a string to a number?"

msgid "pages.NestedListAssignment.steps.nested_assignment_input.requirements"
msgstr ""
"Your function should modify the `board` argument. It doesn't need to "
"`return` or `print` anything."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.text"
msgstr ""
"These two lines:\n"
"\n"
"__code0__\n"
"\n"
"can be combined into one:\n"
"\n"
"__code1__\n"
"\n"
"The two pieces of code are pretty much exactly equivalent. Python first evaluates\n"
"`board[1]` to *get* the inner list, while the `[0] = ...` sets an element of `board[1]`.\n"
"You can see the value of `board[1]` in `birdseye` because it's an expression,\n"
"and you could actually replace it with any other expression.\n"
"\n"
"Now you know how to set elements in nested lists, it's time to make this interactive!\n"
"Write your own version of `play_move` that takes input from the user\n"
"to determine where to play, instead of always playing at `board[1][0]`.\n"
"It should call `input()` twice, so the user can give the row and the column\n"
"as two separate numbers. Also, our users are not programmers, so they start counting from 1,\n"
"not 0.\n"
"\n"
"For example, if the user types in these inputs:\n"
"\n"
"__code2__\n"
"\n"
"that means they want to play a move in the second row and first column, which is the same\n"
"as our original example.\n"
"\n"
"Here is some starting code:\n"
"\n"
"    __copyable__\n"
"__code3__\n"
"\n"
"This calls `play_move` twice so the user will need to enter two pairs of numbers.\n"
"Here's an example of what a 'game' should look like:\n"
"\n"
"     123\n"
"    1\n"
"    2\n"
"    3\n"
"\n"
"    X to play:\n"
"\n"
"__code2__\n"
"     123\n"
"    1\n"
"    2X\n"
"    3\n"
"\n"
"    O to play:\n"
"\n"
"    1\n"
"    3\n"
"     123\n"
"    1  O\n"
"    2X\n"
"    3\n"
"\n"
"You don't need to use the provided code exactly, it's just to give you a feeling of what's happening.\n"
"The important thing is that your `play_move` function modifies the `board` argument correctly.\n"
"It doesn't need to return or print anything, that will not be checked.\n"
"\n"
"You can assume that the user will always enter valid numbers. Later we will learn how to deal\n"
"with invalid inputs, like numbers out of range or inputs that aren't numbers at all."

msgid "pages.NestedListAssignment.steps.nested_assignment_two_lines.text"
msgstr ""
"Note how calling `play_move(game_board, 'X')` actually *modifies* `game_board` directly.\n"
"The variable `board` inside the call to `play_move` and\n"
"the variable `game_board` inside the call to `play_game` point to the same list object.\n"
"There's no copying. Python Tutor is good at showing this with arrows.\n"
"\n"
"This also means that in this case there's no need for `play_move` to return anything,\n"
"it can just modify `board` and the caller (`play_game` in this case) will see the effect.\n"
"\n"
"However, our board is two dimensional, represented by a nested list.\n"
"So we need to assign `player` to an element of an inner list, something like this:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.NestedListAssignment.title"
msgstr "Nested List Assignment: Playing Moves on the Board"

msgid ""
"pages.NewlinesAndFormatBoard.steps.discovering_newline.special_messages.bad_string.text"
msgstr ""
"Oops, `string` doesn't have the right value. Run the program from the "
"previous step again."

msgid "pages.NewlinesAndFormatBoard.steps.discovering_newline.text"
msgstr ""
"Hooray! A *triple quoted string* is allowed to span many lines and they will be shown in the output.\n"
"\n"
"Like single and double quotes, triple quotes are just another kind of notation, not a new kind of string.\n"
"`\"\"\"abc\"\"\"` is the same thing as `\"abc\"`.\n"
"\n"
"However `string` does contain something new. Run `__program__` in the shell to see."

msgid "pages.NewlinesAndFormatBoard.steps.final_text.text"
msgstr ""
"Great work! That was quite challenging.\n"
"\n"
"Now you have mastered how to build up a string of multiple lines of text, and solved the problem of displaying the board to the players.\n"
"\n"
"Next you will learn more about types in Python and how to convert them, and how to get input from the players.\n"
"You are already about halfway done with the project. Keep going!"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.0.text"
msgstr ""
"There are two types of lines to be displayed: one type has the pieces joined"
" by `|`s in between them, the other type has `-`s joined by `+`s in between "
"them."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.1.text"
msgstr ""
"Both of these types of lines can be built up by using `join` appropriately."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.10.text"
msgstr "Then apply `join` to that list, with the `+-` line as separator."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.11.text"
msgstr ""
"To add the newlines to the `+-` line correctly, take a look at the test case"
" we provided."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.2.text"
msgstr ""
"For example, how can you convert a row `['X', 'O', 'X']` into `'X|O|X'` "
"using `join`?"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.3.text"
msgstr ""
"Similarly, how can you obtain `'-+-+-'` using `join`? To what list should "
"you apply `join`?"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.4.text"
msgstr ""
"Once you figured out how to build up both types of lines, how can you "
"combine them to obtain the final result?"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.5.text"
msgstr "Notice that the lines with the `+-`  signs are always the same."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.6.text"
msgstr ""
"And there is one line with `+-` separating every consecutive pair of lines "
"with pieces."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.7.text"
msgstr "You can use `join` on the lines themselves!"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.8.text"
msgstr ""
"The lines with the pieces can be joined together with the `+-` line in "
"between them (with newlines added in appropriate places)."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.9.text"
msgstr ""
"To do that, first you need to keep the lines with the pieces stored in a "
"list as you are building them."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.text"
msgstr ""
"Excellent! A typical solution looks like:\n"
"\n"
"__code0__\n"
"\n"
"If you looked up how `join` works and used it in your solution, that's great!\n"
"You might have solved it with something like this:\n"
"\n"
"__code1__\n"
"\n"
"If you'd like, you can just continue to the [next page](#Types) now. Or you can do a bonus challenge!\n"
"\n"
"Write an improved version of `format_board` that displays row and column separators. For example, if\n"
"\n"
"__code2__\n"
"\n"
"then `print(format_board(board))` should print\n"
"\n"
"    X|O|X\n"
"    -+-+-\n"
"     |O|O\n"
"    -+-+-\n"
"     |X|\n"
"\n"
"Once again it should work for a square `board` of *any size*.\n"
"\n"
"You are strongly encouraged to use `join` on this exercise. We provide one test as before, you can write additional tests:\n"
"\n"
"    __copyable__\n"
"__code3__"

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.0.text"
msgstr ""
"Look carefully at the test case we provided. It shows you all you need!"

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.1.text"
msgstr ""
"You need to build up a string for the whole board. Start with an empty "
"string."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.2.text"
msgstr "For each row, add the characters from that row to the string."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.3.text"
msgstr "You'll need a nested loop."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.4.text"
msgstr ""
"When you reach the end of a row, you need to add a newline before the next "
"row."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.5.text"
msgstr ""
"`'\\n'` is just like any other character! You can add it as usual with `+`."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.6.text"
msgstr "Notice that the end of the last row is different than the others."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.7.text"
msgstr ""
"Before you add a newline, you'll need to check if it's the last row or not."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.8.text"
msgstr "Your outer loop should loop over the length of the board."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.9.text"
msgstr "Then check if you are at the last index or not."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.text"
msgstr ""
"Now use the newline character to write the function `format_board` (your solution should work for a square `board` of any size):\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.NewlinesAndFormatBoard.steps.introducing_newline.text"
msgstr ""
"There's the secret!\n"
"\n"
"`\\n` represents a ***newline*** character. This is just another character, like a letter or a space (`' '`).\n"
"It's the character between two separate lines that you type in by pressing Enter on your keyboard.\n"
"\n"
"Again, `\\n` *represents* the newline character within a Python string literal.\n"
"The string doesn't actually contain `\\` and `n`, it just contains one character. Check this in the shell:\n"
"\n"
"__code0__"

msgid "pages.NewlinesAndFormatBoard.steps.invalid_multi_line_string.program"
msgstr ""
"assert_equal(\n"
"    format_board([\n"
"        ['X', 'O', 'X'],\n"
"        [' ', 'O', 'O'],\n"
"        [' ', 'X', ' ']\n"
"    ]),\n"
"    \"XOX\n"
"      OO\n"
"      X \"\n"
")"

msgid "pages.NewlinesAndFormatBoard.steps.invalid_multi_line_string.text"
msgstr ""
"This is a good start but ideally we'd like a function which *returns* a string rather than printing it.\n"
"This way other code can make easy use of the string in different ways. We might want to manipulate the string\n"
"(e.g. draw a box around it or extract only the first few lines), we might want to send it somewhere other than the screen\n"
"(e.g. a file) and in this particular case we want to be able to test it with `assert_equal`. This doesn't work:\n"
"\n"
"__code0__\n"
"\n"
"because `print_board` doesn't use `return` so it just returns `None` by default.\n"
"So instead we want code like this:\n"
"\n"
"__code1__\n"
"\n"
"Then `print(format_board(board))` should print something like what we saw at the beginning.\n"
"But how do we return a string with multiple lines? And how do we test it? We'd like to do something like this:\n"
"\n"
"    __copyable__\n"
"__code2__\n"
"\n"
"See for yourself how this doesn't work."

msgid ""
"pages.NewlinesAndFormatBoard.steps.multi_line_strings_triple_quotes.program"
msgstr ""
"string = \"\"\"First line\n"
"Second line\"\"\"\n"
"print(string)"

msgid ""
"pages.NewlinesAndFormatBoard.steps.multi_line_strings_triple_quotes.text"
msgstr ""
"Normally a string literal has to be on one line, so this is invalid:\n"
"\n"
"    string = \"First line\n"
"    Second line\"\n"
"    print(string)\n"
"\n"
"But Python provides a way! The solution is to use *triple quotes*, i.e. three quote characters in a row\n"
"(either `'''` or `\"\"\"`) around the contents of the string. Run the following:\n"
"\n"
"__program_indented__"

msgid "pages.NewlinesAndFormatBoard.steps.one_way_to_print_board.text"
msgstr ""
"Next we want to tackle the problem of displaying the tic-tac-toe board. Here's one way to do this:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"(What's `\"\".join`? Google it!)"

msgid "pages.NewlinesAndFormatBoard.title"
msgstr "The newline character, `format_board`"

msgid "pages.OtherComparisonOperators.steps.brokn_kyboard.text"
msgstr ""
"Oto uroczy mały programik używający `!=`:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.0.text"
msgstr ""
"To prawie dokładnie to samo co w poprzednim kroku, tyle że użyj ciągów "
"znaków zamiast liczb."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.1.text"
msgstr "Musisz tylko uruchomić jedną bardzo małą, prostą linię w shellu."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.2.text"
msgstr ""
"Możesz to również zrobić poprzez uruchomienie wielu linii w shellu, "
"najpierw definiując zmienne a następnie porównując je, ale nie musisz tego "
"robić, możesz to zrobić bez zmiennych."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.3.text"
msgstr "Pamiętasz dodawanie dwóch ciągów znaków w shellu na początku kursu?"

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.4.text"
msgstr "Na przykład robiliśmy `'hello' + 'world'`"

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.5.text"
msgstr ""
"Do tego zadania musisz zrobić właściwie to samo, ale zamiast dodawać, "
"porównuj je."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.requirements"
msgstr ""
"Uruchom dowolny kod w shellu używający albo `<` albo `>` na dwóch ciągach "
"znaków."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.text"
msgstr ""
"Można także używać tych operatorów do porównywania ciągów znaków. Jeśli "
"ustawisz dwa ciągi znaków w kolejności alfabetycznej, pierwszy jest "
"'mniejszy niż' drugi. Sprawdź to sam."

msgid "pages.OtherComparisonOperators.steps.final_text.text"
msgstr ""
"Wspaniale!\n"
"\n"
"Istnieje wiele sposobów rozwiązania tego problemu. Oto jedno z rozwiązań:\n"
"\n"
"__code0__\n"
"\n"
"Oto inne:\n"
"\n"
"__code1__\n"
"\n"
"Te programy (i twój również) działają równie dobrze zarówno z liczbami, jak i ciągami znaków. Więc dla:\n"
"\n"
"__code2__\n"
"\n"
"wypiszą `Alice`, ponieważ to jest pierwszy ciąg znaków w kolejności alfabetycznej.\n"
"\n"
"`<` oraz `>` dają wynik False, gdy porównywane wartości są równe. Na przykład, 3 nie jest mniejsze od 3, więc `3 < 3` oraz `3 > 3` są oba False.\n"
"Aby uwzględnić równe wartości, użyj `<=` oraz `>=`.\n"
"Jeśli się przyjrzeć, przypominają one trochę ≤ oraz ≥.\n"
"Zauważ, że `=` znajduje się na końcu - nie istnieją takie operatory jak `=<` czy `=>`.\n"
"Aby to zapamiętać, przeczytaj je na głos jako \"mniejsze równe\"\n"
"i \"większe równe\".\n"
"\n"
"Podsumowując, główne operatory porównania to `==`, `!=`, `<`, `>`, `<=` oraz `>=`.\n"
"Jeśli masz kiedykolwiek wątpliwości co do tego, co one robią, pobaw się nimi w shellu!"

msgid "pages.OtherComparisonOperators.steps.grades_example.text"
msgstr ""
"Oto praktyczny przykład użycia `<`:\n"
"\n"
"__program_indented__\n"
"\n"
"Pamiętaj, że `elif percentage < 60` po `if percentage < 40` oznacza \"jeśli procent nie był mniejszy niż 40 oraz równocześnie jest mniejszy niż 60\", więc zostanie spełnione dla wszystkich liczb od 40 do 59 włącznie. Podobnie ocena 'B' jest dla procentów od 60 do 79, a ocena 'A' jest dla każdej liczby 80 i więcej."

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.hints.0.text"
msgstr "Musisz tylko uruchomić jedną bardzo małą, prostą linię w shellu."

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.hints.1.text"
msgstr "Jak byś dodał dwie liczby w shellu?"

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.hints.2.text"
msgstr "Na przykład spróbuj `123 + 456`"

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.hints.3.text"
msgstr ""
"Do tego zadania musisz zrobić właściwie to samo, ale zamiast dodawać, "
"porównuj je."

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.requirements"
msgstr ""
"Uruchom dowolny kod w shellu używający albo `<` albo `>` na dwóch liczbach."

msgid "pages.OtherComparisonOperators.steps.introducing_less_than.text"
msgstr ""
"Innymi przydatnymi operatorami są `<` (mniejsze niż) oraz `>` (większe niż)."
" Na przykład `a < b` oznacza \"`a` jest mniejsze od `b`\". Wypróbuj użycie "
"jednego z nich w shellu, aby porównać dwie liczby."

msgid "pages.OtherComparisonOperators.steps.min_three_exercise.hints.0.text"
msgstr ""
"Spróbuj napisać program, który wypisze najmniejszą z wartości `x1` i `x2`."

msgid "pages.OtherComparisonOperators.steps.min_three_exercise.hints.1.text"
msgstr "wszystko czego potrzebujesz to użyć kilka razy `<`, `if`, a może `else`."

msgid "pages.OtherComparisonOperators.steps.min_three_exercise.text"
msgstr ""
"Teraz zadanie: napisz program, który bierze trzy zmienne `x1`, `x2` i `x3`, oraz drukuje wartość najmniejszej z nich. Więc dla:\n"
"\n"
"__code0__\n"
"\n"
"powinien wypisać `10`."

msgid "pages.OtherComparisonOperators.steps.try_not_equals.text"
msgstr ""
"Przeciwieństwem operatora równości `==` jest operator *nierówności* `!=`. "
"Jeśli się przyjrzeć, to trochę przypomina ≠. Zwraca `True`, kiedy dwie "
"wartości są... nie równe. Wypróbuj `__program__` samodzielnie w shellu "

msgid "pages.OtherComparisonOperators.title"
msgstr "Inne operatory porównania"

msgid "pages.ReturningValuesFromFunctions.steps.final_text.text"
msgstr ""
"Well done! Here are two possible solutions:\n"
"\n"
"__code0__"

msgid "pages.ReturningValuesFromFunctions.steps.first_return.text"
msgstr ""
"Functions can be especially useful when they *return* values, rather than just printing them. Try this example:\n"
"\n"
"__program_indented__"

msgid "pages.ReturningValuesFromFunctions.steps.losing_return_value.text"
msgstr ""
"Here we passed `number` (which has value `5`) as the argument `x` to the function `double`, and `double` *returned*\n"
"`x * 2`, i.e. `5 * 2`, i.e. `10`, which became the value of the variable `twice`. The special keyword `return` inside\n"
"`double` makes `double(number)` an expression with a value - specifically the value which was returned.\n"
"It's a bit like `twice = double(number)` is equivalent to `twice = number * 2`, although that's not\n"
"exactly what happens.\n"
"\n"
"Note that `double(number)` *didn't change `number`*. At the end, `number` is still `5`. Rather, `double(number)`\n"
"returned a new value. It's crucial that the program made use of that returned value, in this case by storing\n"
"it in a variable. Immediately printing it with `print(double(number))` also works. On the other hand,\n"
"try this:\n"
"\n"
"__program_indented__"

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.0.text"
msgstr "To multiply by 4, multiply by 2 twice."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.1.text"
msgstr "That means you need to call `double` twice."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.10.text"
msgstr "Look at the definition of `double` for an example."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.11.text"
msgstr ""
"Make sure that you don't call `quadruple` inside the function body of "
"`quadruple`. Check your indentation."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.2.text"
msgstr "Make sure you use the returned value from `double` each time."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.3.text"
msgstr "Make sure you have all the parts of a function definition."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.4.text"
msgstr "That includes `def`, `()`, and `:`."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.5.text"
msgstr "Make sure your function is named `quadruple`."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.6.text"
msgstr ""
"Make sure it accepts one parameter called `x` in between the parentheses "
"`()`."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.7.text"
msgstr "Use the parameter inside the function body."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.8.text"
msgstr "Make sure the body is indented."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.9.text"
msgstr "Make sure you `return` something at the end."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.messages.used_multiply.text"
msgstr ""
"You cannot use `*`, `+`, or even any numbers inside `quadruple`.\n"
"You must call `double` to solve the problem."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.requirements"
msgstr ""
"Write a program which defines a function called `quadruple` as described "
"above."

msgid "pages.ReturningValuesFromFunctions.steps.quadruple_exercise.text"
msgstr ""
"Here `double(number)` still returned `10`, but we didn't make use of that so it was lost. `number` is still `5`.\n"
"\n"
"Write a function `quadruple` which takes one argument `x` and returns that argument multiplied by 4.\n"
"You must only use the `double` function - no numbers or multiplication are allowed directly in the body\n"
"of `quadruple`."

msgid "pages.ReturningValuesFromFunctions.title"
msgstr "Returning Values From Functions"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.hints.0.text"
msgstr "Jak powinieneś zdefiniować ciąg znaków?"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.hints.1.text"
msgstr "Z pojedynczymi cudzysłowami, czy z podwójnymi?"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.hints.2.text"
msgstr "Potrzebujesz tylko jednego ciągu znaków."

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.hints.3.text"
msgstr "Nie ma potrzeby dodawać ciągów znaków do siebie."

msgid "pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.text"
msgstr ""
"Jak widzisz, Python traktuje ten sam ciąg znaków zdefiniowany pojedynczymi lub podwójnymi cudzysłowami jako ten sam.\n"
"\n"
"Teraz napisz program, który wydrukuje następujący tekst z Zen of Python:\n"
"\n"
"    __copyable__\n"
"    Special cases aren't special enough to break the rules.\n"
"\n"
"Program powinien być jednolinijkowy używając `print()`, bez zmiennych."

msgid "pages.SingleAndDoubleQuotesInStrings.steps.double_quotes.text"
msgstr ""
"Więc nie możemy użyć apostrofu tak jak nam się podoba w ciągu znaków z pojedynczymi cudzysłowami.\n"
"Apostrof jest traktowany jak pojedynczy cudzysłów i dlatego działa jako *zamykający cudzysłów* definicji ciągu znaków `'Alice'`.\n"
"Potem pozostała część tekstu `s Diner'` jest niepoprawną składnią i Python tego nie rozumie.\n"
"\n"
"Na szczęście Python pozwala nam definiować ciągi znaków inaczej, używając podwójnych cudzysłowów `\"` zamiast tego:\n"
"\n"
"__program_indented__"

msgid "pages.SingleAndDoubleQuotesInStrings.steps.final_text.text"
msgstr ""
"Dobra robota!\n"
"\n"
"W większości przypadków możesz użyć pojedynczych lub podwójnych cudzysłowów do definiowania swoich ciągów znaków, tak jak ci się podoba.\n"
"Ale jeśli ciąg zawiera `'`, to użyj `\"` do jego zdefiniowania i odwrotnie."

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_double_quotes_equal.text"
msgstr ""
"Pamiętaj, że cudzysłowy to tylko część ludzkiej notacji ciągów znaków.\n"
"Nie są przechowywane jako rzeczywista część ciągu znaków.\n"
"Spróbuj tego w powłoce:\n"
"\n"
"__program_indented__"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quote_exercise.hints.0.text"
msgstr "Pomyśl prostym sposobem! Jak zwykle to robisz?"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quote_exercise.hints.1.text"
msgstr ""
"Jeśli ciąg znaków zawiera pojedynczy cudzysłów, musimy użyć podwójnych "
"cudzysłowów do jego zdefiniowania."

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quote_exercise.hints.2.text"
msgstr "Co jeśli ciąg zawiera podwójne cudzysłowy?"

msgid "pages.SingleAndDoubleQuotesInStrings.steps.single_quote_exercise.text"
msgstr ""
"Doskonale!\n"
"\n"
"Teraz wydrukuj następujący cytat dosłownie (łącznie z podwójnymi cudzysłowami):\n"
"\n"
"    __copyable__\n"
"    \"Talk is cheap. Show me the code.\" - Linus Torvalds\n"
"\n"
"Program powinien być jednolinijkowy używając `print()`, bez zmiennych."

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quotes_apostrophe.program"
msgstr "print('Alice's Diner')"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quotes_apostrophe.text"
msgstr ""
"Do tej pory definiowaliśmy ciągi znaków używając pojedynczych cudzysłowów, takich jak:\n"
"\n"
"__code0__\n"
"\n"
"Co jeśli chcemy zdefiniować ciąg znaków zawierający apostrof? Spróbuj tego:\n"
"\n"
"__program_indented__"

msgid "pages.SingleAndDoubleQuotesInStrings.title"
msgstr "Pojedyncze i podwójne cudzysłowy w ciągach znaków"

msgid "pages.StoringCalculationsInVariables.steps.final_text.text"
msgstr ""
"W przeciwieństwie do arkusza kalkulacyjnego, gdzie formuły aktualizują się "
"automatycznie, zmienna taka jak `sentence` nie pamięta, jak została "
"obliczona i nie zmieni się, jeśli zmienione zostaną wartości leżące u "
"podstawy `word` lub `name`."

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.output_prediction_choices.0"
msgstr ""
"Hello World\n"
"Hello World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.output_prediction_choices.1"
msgstr ""
"Hello World\n"
"Goodbye World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.output_prediction_choices.2"
msgstr ""
"Goodbye World\n"
"Goodbye World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.requirements"
msgstr ""
"Uruchom program składający się z czterech linii z poprzedniego kroku, a "
"następnie z dwóch linii tutaj."

msgid "pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.text"
msgstr ""
"Teraz `sentence` ma wartość `'Hello World'`, której można używać wielokrotnie. Zauważ, że będzie ona kontynuowała posiadanie tej wartości aż do jej bezpośredniego przypisania, np. za pomocą innego polecenia takiego jak `sentence = <coś>`. Na przykład, dodaj te dwie linie na końcu programu:\n"
"\n"
"__code0__"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.0"
msgstr "sentence"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.1"
msgstr "word + ' ' + name"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.2"
msgstr "Hello + ' ' + World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.3"
msgstr "'Hello' + ' ' + 'World'"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.4"
msgstr "Hello World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.5"
msgstr "'Hello World'"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.text"
msgstr ""
"Często będziesz używać zmiennych, aby przechowywać wyniki obliczeń. Pomoże to budować bardziej złożone programy. Na przykład, wypróbuj ten program:\n"
"\n"
"__code0__"

msgid "pages.StoringCalculationsInVariables.title"
msgstr "Przechowywanie obliczeń w zmiennych"

msgid "pages.StringMethodsUnderstandingMutation.steps.final_text.text"
msgstr ""
"Zauważ, że `sentence.upper()` nie zmienia oryginalnego `sentence`.\n"
"\n"
"Możesz również użyć `word.lower()` bezpośrednio w większym wyrażeniu, np.\n"
"\n"
"__code0__"

msgid ""
"pages.StringMethodsUnderstandingMutation.steps.mutation_string_append.text"
msgstr ""
"Te dwie metody także działają na łańcuchach znaków podobnie do list.\n"
"`index` zwraca *indeks początkowy* wyszukiwanego słowa `'the'` w dłuższym łańcuchu\n"
"`'feed the dog and the cat'`, który wynosi `5`.\n"
"\n"
"|  0   |  1   |  2   |  3   |  4   | **5** |  6   |  7   |  8   | ...  |\n"
"| :--: | :--: | :--: | :--: | :--: | :---: | :--: | :--: | :--: | :--: |\n"
"|  f   |  e   |  e   |  d   |      | **t** |  h   |  e   |      | ...  |\n"
"\n"
"Zauważ, że w większości przypadków metody, które *modyfikują listę in situ* (`append`, `insert`, `remove`) po prostu zwracają `None`,\n"
"podczas gdy pozostałe funkcje/metody zwracają nową użyteczną wartość bez zmiany oryginalnego argumentu.\n"
"Jedynym wyjątkiem jest metoda `pop`.\n"
"\n"
"Modyfikowanie wartości bezpośrednio nazywa się *mutacją* - typy wartości które mogą być mutowane są *mutowalne* (ang. mutable),\n"
"a te które nie mogą są *niemutowalne* (ang. immutable). Listy są mutowalne.\n"
"Łańcuchy znaków są niemutowalne - nie mają żadnych metod takich jak `append` czy nawet przypisanie do indeksu.\n"
"Zobacz sam:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.StringMethodsUnderstandingMutation.steps.string_count_index.program"
msgstr ""
"string = 'feed the dog and the cat'\n"
"print(string.count('the'))\n"
"print(string.index('the'))"

msgid "pages.StringMethodsUnderstandingMutation.steps.string_count_index.text"
msgstr ""
"`in` działa na łańcuchach znaków tak, jak na listach! Komenda zwróciła `True`, ponieważ `the` występuje w `feed the dog and the cat` jako *podłańcuch*.\n"
"Co z `count` i `index`?\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.StringMethodsUnderstandingMutation.steps.string_in_step.program"
msgstr "print('the' in 'feed the dog and the cat')"

msgid "pages.StringMethodsUnderstandingMutation.steps.string_in_step.text"
msgstr ""
"Widziałeś już, że `len` oraz indeksowanie działają na łańcuchach znaków trochę tak, jakby były one listami znaków.\n"
"Łańcuchy znaków wspierają również niektóre z nowych metod, które poznaliśmy, nie tylko dla pojedynczych znaków, ale również dla dowolnych podłańcuchów.\n"
"Na przykład, wypróbuj poniższe:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.StringMethodsUnderstandingMutation.steps.string_lower_upper.text"
msgstr ""
"Nie można po prostu zmienić łańcucha znaków - możesz jedynie tworzyć nowe łańcuchy i używać ich zamiast starych.\n"
"To oznacza, że to jest bezużyteczne stwierdzenie samo w sobie:\n"
"\n"
"__code0__\n"
"\n"
"Łańcuch pod zmienną `word` nie jest modyfikowany, zamiast tego `word.lower()` zwraca nowy łańcuch, który w tym przypadku przepada.\n"
"Jeśli chcesz zmienić wartość, do której odnosi się `word`, musisz przypisać do zmiennej nową wartość:\n"
"\n"
"    __copyable__\n"
"__code1__"

msgid "pages.StringMethodsUnderstandingMutation.title"
msgstr "Metody łańcuchów znaków i niemutowalność"

msgid "pages.TestingFunctions.steps.alert_exercise.hints.0.text"
msgstr ""
"`string` should be surrounded by one space and `level` exclamation marks "
"(`!`) on each side."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.1.text"
msgstr ""
"Include the definition of `surround` from before in your program and call it"
" in `alert`."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.10.text"
msgstr ""
"Think of how you would build up strings with `+=`. Repeatedly update the "
"same variable, building up your result."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.11.text"
msgstr "That is, write `something = surround(something, '!')` in your loop."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.12.text"
msgstr "Make sure you `return` something at the end of `alert`."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.13.text"
msgstr ""
"Make sure you don't `return` inside the loop, but after it. Check your "
"indentation."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.14.text"
msgstr ""
"Make sure that you don't call `alert` inside the function body of `alert`. "
"Check your indentation."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.2.text"
msgstr "Use `surround` for the spaces."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.3.text"
msgstr "Use `surround` for the exclamation marks."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.4.text"
msgstr ""
"You're not allowed to combine several exclamation marks into one string, so "
"call `surround` several times."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.5.text"
msgstr "That is, call `surround` once for each pair of exclamation marks."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.6.text"
msgstr "So call `surround(..., '!')` several times."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.7.text"
msgstr "Use a loop to call it several times."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.8.text"
msgstr "Use `range(n)` to make your loop have `n` iterations."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.9.text"
msgstr "Make sure you use the return value from `surround`."

msgid ""
"pages.TestingFunctions.steps.alert_exercise.messages.catch_return_inside_loop.text"
msgstr ""
"In the `alert` function, you placed your `return` statement at the wrong place!\n"
"Pay attention to your indentations in `alert`. You might be ending a loop too early with `return`."

msgid "pages.TestingFunctions.steps.alert_exercise.messages.used_format.text"
msgstr ""
"You cannot use string concatenation/formatting/interpolation/multiplication or f-strings in `alert`.\n"
"You must call `surround` to solve the problem."

msgid "pages.TestingFunctions.steps.alert_exercise.text"
msgstr ""
"Perfect! Now write a function `alert` that passes these tests:\n"
"\n"
"__code0__\n"
"\n"
"The body of `alert` is not allowed to contain `+`. Use `surround` instead. Your function should start like this:\n"
"\n"
"__code1__"

msgid "pages.TestingFunctions.steps.complete_quadruple_tests.requirements"
msgstr ""
"Type in the program above.\n"
"Then change the last two lines by adding one argument to each `assert_equal` call to make the tests pass.\n"
"Don't touch the function definitions."

msgid "pages.TestingFunctions.steps.complete_quadruple_tests.text"
msgstr ""
"Excellent! Our tests failed! Of course that's not usually a good thing, but it tells us that the tests are\n"
"doing their job. They will make sure that our implementation of `double` is correct.\n"
"\n"
"Let's practice this new concept. Below is the function `quadruple` from before with some incomplete tests.\n"
"Fix the program by adding the missing arguments to `assert_equal`.\n"
"\n"
"__code0__"

msgid "pages.TestingFunctions.steps.final_text.text"
msgstr "Great work! These tools will be very helpful in coming chapters."

msgid "pages.TestingFunctions.steps.introducing_assert_equal.text"
msgstr ""
"An important part of writing programs is testing that they work correctly. You can do this manually, e.g. by checking that\n"
"`print(double(5))` prints `10`, but this kind of thing can get tedious quickly.\n"
"It's helpful to actually write programs that test your programs. This is called *automated testing*,\n"
"and the programs are called *tests*.\n"
"\n"
"Here's a simple function `assert_equal` to help us write tests:\n"
"\n"
"__code0__\n"
"\n"
"\n"
"(What's that function `repr`? Try `print(f\"{'abc'} {repr('abc')}\")` to see one difference, but don't worry about it too much.)\n"
"\n"
"This isn't a standard part of python (although similar functions are), but we've added it to your coding environment\n"
"so you can always use it. Here's an example of using it for you to try out:\n"
"\n"
"__program_indented__"

msgid "pages.TestingFunctions.steps.make_tests_fail.requirements"
msgstr ""
"Run the program from the previous step, but replace `x * 2` with `x * 3`. "
"Keep the rest the same."

msgid "pages.TestingFunctions.steps.make_tests_fail.text"
msgstr ""
"The OKs tell us that the tests passed. Our `double` function seems to be working correctly. Change it to return\n"
"`x * 3` instead and see what happens."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.0.text"
msgstr "The argument `sides` should be added before and after `string`."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.1.text"
msgstr "Use string concatenation to do this."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.2.text"
msgstr "Make sure the body is indented."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.3.text"
msgstr "Make sure you `return` something at the end."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.4.text"
msgstr ""
"Make sure that you don't call `surround` inside the function body of "
"`surround`. Check your indentation."

msgid "pages.TestingFunctions.steps.surround_exercise.text"
msgstr ""
"Another useful thing about the tests is that anyone can read them and see clear, unambiguous examples\n"
"of what the function does. This is helpful when a function is complicated and difficult to describe in English.\n"
"\n"
"For example, here are some tests:\n"
"\n"
"__code0__\n"
"\n"
"I don't need to explain what `surround` does, you can see for yourself.\n"
"\n"
"Write a function `surround` that passes these tests and starts like this:\n"
"\n"
"__code1__"

msgid "pages.TestingFunctions.title"
msgstr "Testing Functions"

msgid "pages.TheEqualityOperator.steps.equality_vs_assignment.program"
msgstr "print(1 + 2 = 3)"

msgid "pages.TheEqualityOperator.steps.equality_vs_assignment.requirements"
msgstr ""
"Uruchom program z poprzedniego kroku, ale zamień którykolwiek z `==` na po "
"prostu `=`."


msgid "pages.TheEqualityOperator.steps.equality_vs_assignment.text"
msgstr ""
"Jak widzisz, jeśli wartości są równe, wyrażenie równości daje wynik `True`,\n"
"w przeciwnym razie jest to `False`.\n"
"\n"
"Zwróć uwagę na różnicę między operatorem równości `==` a pojedynczym `=`, które mają różne znaczenia,\n"
"szczególnie w instrukcjach przypisania, jakie do tej pory widzieliśmy. Co się stanie, jeśli spróbujesz\n"
"usunąć pojedynczy `=` z poprzedniego programu?"

msgid "pages.TheEqualityOperator.steps.final_text.text"
msgstr "Dobra robota!"

msgid "pages.TheEqualityOperator.steps.if_equals_replacing_characters.text"
msgstr ""
"Użyjmy `==` w instrukcji `if`. W tym programie ciało `if` uruchamia się tylko wtedy, gdy `c` to znak `'s'`. Przekonaj się sam.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.TheEqualityOperator.steps.if_equals_replacing_characters_exercise.hints.0.text"
msgstr ""
"Musisz tylko dodać kilka linii kodu, które są bardzo podobne do "
"istniejących."

msgid ""
"pages.TheEqualityOperator.steps.if_equals_replacing_characters_exercise.text"
msgstr ""
"Rozszerz teraz program, aby również zamieniał `e` na `3` i `a` na `@`."

msgid "pages.TheEqualityOperator.steps.introducing_equality.text"
msgstr ""
"Istnieje kilka sposobów uzyskania wartości boolowskich bez ich bezpośredniego przypisywania,\n"
"co pozwala konstruować bardzo przydatne instrukcje `if`. W szczególności istnieje wiele\n"
"*operatorów porównania*, które porównują wartości dwóch wyrażeń.\n"
"Najczęściej stosowany jest operator równości, który sprawdza, czy dwie wartości są równe.\n"
"Jest on oznaczony dwoma znakami równości: `==`. Spróbuj uruchomić to:\n"
"\n"
"__program_indented__"

msgid "pages.TheEqualityOperator.title"
msgstr "Operator równości"

msgid "pages.TheFullTicTacToeGame.steps.final_text.text"
msgstr ""
"### ***CONGRATULATIONS!!!***\n"
"\n"
"You did it!"

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.0.text"
msgstr ""
"You should use all of the functions `winner`, `format_board` (not counting "
"its use in `play_move`), `play_move`, `make_board`, `print_winner`, and "
"`print_draw` somewhere."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.1.text"
msgstr ""
"You only need to mention each of those functions once in your code, although"
" some of them will be called several times as the program runs."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.10.text"
msgstr "Whichever function is called, it must be called exactly once."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.11.text"
msgstr ""
"One easy way to make sure you don't call a function multiple times is to "
"call it outside of any loop."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.12.text"
msgstr "We've learned about two ways to make a loop stop."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.13.text"
msgstr "One way is `break`, which specifically ends one loop and no more."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.14.text"
msgstr "The second way ends not just the loop but the whole function call."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.15.text"
msgstr "The second way is `return`."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.16.text"
msgstr ""
"Don't play moves in pairs like `play_move(board, player1)` and "
"`play_move(board, player2)` in the sample code."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.17.text"
msgstr "Instead, each loop iteration should play one move."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.18.text"
msgstr "You need a variable to keep track of which player's turn it is."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.19.text"
msgstr "The player should be switched in each loop iteration."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.2.text"
msgstr "You will need a for loop to repeatedly play moves."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.20.text"
msgstr "An `if` statement is a good way to do this."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.21.text"
msgstr "Especially combined with an `else`."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.22.text"
msgstr "Make sure `player1` plays the first move."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.23.text"
msgstr ""
"Only call `print_winner` after checking `winner` with an `if` statement."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.24.text"
msgstr ""
"You need to check for the winner inside the loop since you don't know when a"
" player might win."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.25.text"
msgstr ""
"Once you call `print_winner`, you can use `return` to end the function."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.26.text"
msgstr ""
"Just `return` by itself is fine, `play_game` isn't meant to return a value."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.27.text"
msgstr ""
"Don't use `else` after checking for a winner to call `print_draw` if there "
"isn't a winner. Just because no one has won yet doesn't mean it's a draw "
"already."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.28.text"
msgstr ""
"`print_draw` should only be called after all moves have been played and "
"there's still no winner."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.29.text"
msgstr "So it should be called after the loop, outside of it."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.3.text"
msgstr ""
"You don't need to check if the board has been filled up, because you can "
"always calculate how many moves it takes to fill up the board."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.30.text"
msgstr ""
"Check the indentation to make sure `print_draw` isn't in the body of the for"
" loop."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.4.text"
msgstr ""
"So you can just use a loop that will run a fixed number of iterations, and "
"inside the loop check if the loop needs to be ended early."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.5.text"
msgstr ""
"What's the maximum number of moves that can be played in a 3x3 board? 4x4?"

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.6.text"
msgstr ""
"A loop over a `range` is an easy way to iterate a fixed number of times."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.7.text"
msgstr "So you can use `for _ in range(N):` to play at most `N` moves."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.8.text"
msgstr "Once there's a winner, you need to end the loop and the game."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.9.text"
msgstr "Either `print_winner` or `print_draw` should be called, not both."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.text"
msgstr ""
"It's time to put it all together! Below is some code to get started.\n"
"\n"
"It includes implementations of the various functions we defined in previous pages for solving parts\n"
"of the problem, using some tricks you haven't learned yet to make them shorter. Don't change them.\n"
"\n"
"Your task is to implement `play_game` correctly. The current implementation shows what\n"
"should happen at the start of the game, but it's obviously incomplete.\n"
"The solution should work for any board size and continue the game until it's finished.\n"
"The last thing that `play_game` should do is either call `print_winner(player)`\n"
"if `winner(board)` is true, or call `print_draw()` if the board is filled up with no winner.\n"
"\n"
"You can assume that the user will only enter valid inputs,\n"
"i.e. numbers from 1 to `board_size` to choose a cell on the board that isn't already taken.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.TheFullTicTacToeGame.title"
msgstr "The Full Tic-Tac-Toe Game"

msgid "pages.Types.steps.check_type_manually.text"
msgstr ""
"Python reports first that `type('Hello World')` is `<class 'str'>`. Don't worry about `class` for now.\n"
"`str` is short for *string*.\n"
"\n"
"Then `True` is a `bool` (short for *boolean*) and `[1, 2, 3]` has type `list`.\n"
"\n"
"Note that there are two types for numbers:\n"
"\n"
"- `int`, short for 'integer', is for whole numbers, meaning no fractions or decimal points.\n"
"- `float`, short for 'floating point number', is for numbers with a decimal point and maybe a fractional part\n"
"\n"
"In most cases you don't have to worry about the different types of number, as you can mix the two when doing maths.\n"
"\n"
"Types are values which can be used in various ways, just like other values.\n"
"For example, try this in the shell:\n"
"\n"
"__program_indented__"

msgid "pages.Types.steps.common_type_errors.text"
msgstr ""
"What happens if you use an operator between a `str` and an `int`? Try in the shell:\n"
"\n"
"__program_indented__"

msgid "pages.Types.steps.different_types_look_same.text"
msgstr ""
"Values with different types are usually quite different from each other, but they can look the same when printed,\n"
"which can be confusing. Try this:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"(You can use `print(repr(123))` and `print(repr('123'))` to tell the difference. What's `repr`? Google it!)"

msgid "pages.Types.steps.final_text.text"
msgstr ""
"Excellent!\n"
"\n"
"By the way, when you need to concatenate strings and numbers, remember that you can also\n"
"use f-strings. They often look nicer.\n"
"\n"
"You've learned about types in Python and how to avoid common errors by converting types.\n"
"Keep going with the rest of the project!"

msgid "pages.Types.steps.five_different_types.text"
msgstr ""
"So far we've seen various kinds of data: strings, lists, numbers and booleans.\n"
"These are called *types*. Every value has a type which affects how it behaves\n"
"and can be revealed with the `type` function:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.Types.steps.fixing_type_errors_with_conversion.disallowed.0.label"
msgstr "f-strings"

msgid "pages.Types.steps.fixing_type_errors_with_conversion.hints.0.text"
msgstr "At what points is this code broken?"

msgid "pages.Types.steps.fixing_type_errors_with_conversion.hints.1.text"
msgstr "There are values that need to be converted to a different type."

msgid "pages.Types.steps.fixing_type_errors_with_conversion.hints.2.text"
msgstr "Specifically there's a `str` that needs to be converted to an `int`."

msgid "pages.Types.steps.fixing_type_errors_with_conversion.hints.3.text"
msgstr "And an `int` that needs to be converted to a `str`."

msgid "pages.Types.steps.fixing_type_errors_with_conversion.text"
msgstr ""
"Using a string instead of an integer in `range` like `range('5')`,\n"
"or in list subscripting like `list['3']` will also lead to an error.\n"
"\n"
"Most of these problems can be solved by converting the string to an integer by using `int` as a function:\n"
"`int('5')` will return the integer `5`.\n"
"Similarly an integer can be converted to a string by using `str` as a function:\n"
"`str(5)` will return the string `'5'`.\n"
"\n"
"Using this new knowledge, fix this broken program:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"The correct program should print:\n"
"\n"
"    Starting... 1\n"
"    Starting... 2\n"
"    Starting... 3\n"
"    Go!\n"
"\n"
"Your solution should work for any value of the variable `number`."

msgid "pages.Types.steps.format_board_with_numbers.hints.0.text"
msgstr ""
"You can start by using the ideas from your previous solution to "
"`format_board`. Using `join` is highly recommended!"

msgid "pages.Types.steps.format_board_with_numbers.hints.1.text"
msgstr "The first line has to be treated separately from the rest."

msgid "pages.Types.steps.format_board_with_numbers.hints.2.text"
msgstr "Remember that `range` yields numbers in the way: 0, 1, 2, ..."

msgid "pages.Types.steps.format_board_with_numbers.hints.3.text"
msgstr "We want numbers on the first line like this: 1, 2, 3..."

msgid "pages.Types.steps.format_board_with_numbers.hints.4.text"
msgstr ""
"Each number has to be converted to a string before being added to the first "
"row!"

msgid "pages.Types.steps.format_board_with_numbers.hints.5.text"
msgstr "For the rows of the board itself, do something similar."

msgid "pages.Types.steps.format_board_with_numbers.hints.6.text"
msgstr ""
"Start with a list consisting only of the first line that you built above."

msgid "pages.Types.steps.format_board_with_numbers.hints.7.text"
msgstr ""
"Add each row's string to the list, then join the list with a newline "
"character."

msgid "pages.Types.steps.format_board_with_numbers.text"
msgstr ""
"Write an improved version of `format_board` that has row and column numbers like this:\n"
"\n"
"     123\n"
"    1XOX\n"
"    2 OO\n"
"    3 X\n"
"\n"
"It should work for boards of any single-digit size. Here's a test case:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.Types.steps.less_than_has_two_meanings.text"
msgstr ""
"For two integers `+` acts as addition, whereas for two strings it acts as string concatenation.\n"
"Python automatically figures out the meaning of `+` from the types of the inputs.\n"
"Similarly `<` acts differently on two strings and two integers:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.Types.steps.less_than_sorting_strings.text"
msgstr ""
"So `<` acts as the usual 'less than' between two integers, because `13` is less than `120`,\n"
"but it acts as the dictionary ordering between two strings: `13` is 'alphabetically' after `120`\n"
"because `3` comes after `2`.\n"
"\n"
"See what difference this makes when sorting a list:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.Types.steps.plus_has_two_meanings.text"
msgstr ""
"Different types have different methods and support different operators.\n"
"The same method or operator can also mean different things.\n"
"For example, see how `+` has different meanings for `str` and `int`:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.Types.title"
msgstr "Types"

msgid "pages.UnderstandingProgramsWithPythonTutor.steps.final_text.text"
msgstr ""
"Zwróć uwagę, że kod wykonuje się dwukrotnie oddzielnie: raz tutaj, a raz na stronie pythontutor.com.\n"
"W zależności od Twojego programu, oba uruchomienia mogą dać różne wyniki."

msgid ""
"pages.UnderstandingProgramsWithPythonTutor.steps.run_with_python_tutor.text"
msgstr ""
"Nadszedł czas, aby poznać kolejne narzędzie do eksploracji programów.\n"
"Skopiuj poniższy kod do edytora, a następnie kliknij nowy przycisk \"Python Tutor\".\n"
"Przycisk otworzy nową kartę z wizualizacją na stronie [pythontutor.com](http://pythontutor.com).\n"
"Tam możesz przeglądać program krok po kroku, korzystając z przycisków \"Prev\" lub \"Next\",\n"
"lub przeciągając suwak w lewo lub w prawo. Możesz także obserwować wartości zmiennych po prawej stronie.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.UnderstandingProgramsWithPythonTutor.title"
msgstr "Zrozumienie programów z Python Tutor"

msgid "pages.UnderstandingProgramsWithSnoop.steps.final_text.text"
msgstr "Świetna robota! Pracujesz z coraz bardziej skomplikowanymi programami."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.0.text"
msgstr ""
"Kod powinien być prawie taki sam, wystarczy zrobić kilka małych zmian."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.1.text"
msgstr ""
"Upewnij się, że kod wewnątrz `jeśli zawiera:` działa na początku pętli, w "
"pierwszej iteracji."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.2.text"
msgstr "To znaczy, że `zawiera` powinno być `True` w tym momencie."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.3.text"
msgstr ""
"Upewnij się, że kod wewnątrz `jeśli zawiera:` *nie* działa po pierwszej "
"iteracji."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.4.text"
msgstr "To znaczy, że `zawiera` powinno być `False` po pierwszej iteracji."

msgid "pages.UnderstandingProgramsWithSnoop.steps.print_first_character.text"
msgstr ""
"Tada! Przewiń na początek terminala i przeanalizujmy, co pokazuje `snoop`.\n"
"Zaczyna się bardzo prosto:\n"
"\n"
"        1 | sentence = 'Hello World'\n"
"        3 | include = False\n"
"        4 | new_sentence = ''\n"
"        5 | for char in sentence:\n"
"     ...... char = 'H'\n"
"\n"
"Pierwsze linie po prostu pokazują ci linie programu, które komputer wykonał.\n"
"Po lewej stronie jest numer linii widziany w edytorze.\n"
"\n"
"Uruchomienie `for char in sentence:` przypisuje wartość do zmiennej `char`, więc `snoop` pokazuje tę wartość.\n"
"Linie zaczynające się od `......` wskazują na nową zmienną lub zmianę wartości istniejącej zmiennej.\n"
"Takie linie nie będą pokazywane, gdy są zbędne, dlatego wynik `snoop` nie zaczyna się tak:\n"
"\n"
"        1 | sentence = 'Hello World'\n"
"     ...... sentence = 'Hello World'\n"
"        3 | include = False\n"
"     ...... include = False\n"
"        4 | new_sentence = ''\n"
"     ...... new_sentence = ''\n"
"        5 | for char in sentence:\n"
"     ...... char = 'H'\n"
"\n"
"Następne dwie linie to:\n"
"\n"
"        6 |     if include:\n"
"        8 |     include = True\n"
"\n"
"Ważne jest to, czego nie widać: ponieważ `include` jest `False`, linia 7 (`new_sentence += char`) zostaje pominięta. Ale potem `include` jest ustawione na `True`, więc kolejne iteracje pętli są inne:\n"
"\n"
"        5 | for char in sentence:\n"
"     ...... char = 'e'\n"
"        6 |     if include:\n"
"        7 |         new_sentence += char\n"
"     .............. new_sentence = 'e'\n"
"\n"
"`new_sentence += char` działa po raz pierwszy i zmienna `new_sentence` otrzymuje nową wartość.\n"
"\n"
"Teraz zmodyfikuj program, aby zrobić odwrotnie: wydrukuj tylko pierwszy znak, resztę pomijając."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.0"
msgstr "Hello World"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.1"
msgstr "ello World"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.2"
msgstr "Hello Worl"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.3"
msgstr "H"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.4"
msgstr "d"

msgid "pages.UnderstandingProgramsWithSnoop.steps.print_tail.text"
msgstr ""
"Uruchom ten program:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail_snoop.requirements"
msgstr ""
"Uruchom ten sam program z poprzedniego kroku, ale użyj przycisku `snoop` "
"zamiast przycisku 'Uruchom'. Skopiuj program jeszcze raz, jeśli mogłeś go "
"zmienić."

msgid "pages.UnderstandingProgramsWithSnoop.steps.print_tail_snoop.text"
msgstr ""
"Programy zaczynają być skomplikowane!\n"
"Czas przedstawić nowe narzędzie, które pomoże ci zrozumieć programy. Kliknij przycisk `snoop`, aby uruchomić ten sam program i pokazać co się dzieje."

msgid "pages.UnderstandingProgramsWithSnoop.title"
msgstr "Zrozumienie programów z `snoop`"

msgid "pages.UsingBreak.steps.final_text.text"
msgstr ""
"Świetnie!\n"
"\n"
"Typowe rozwiązanie wygląda mniej więcej tak:\n"
"\n"
"__code0__\n"
"\n"
"Twoje rozwiązanie prawdopodobnie jest podobne. Jest w porządku, ale trochę niewydajne.\n"
"To dlatego, że pętla będzie iterować przez całą listę nawet jeśli znajdzie element na początku.\n"
"Możesz zatrzymać dowolną pętlę używając instrukcji `break`, na przykład:\n"
"\n"
"__code1__\n"
"\n"
"To jest równie poprawne, ale pomija niepotrzebne iteracje i sprawdzenia po znalezieniu elementu.\n"
"Możesz użyć `snoop`, żeby zobaczyć różnicę."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.0.text"
msgstr "Będziesz potrzebować pętli."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.1.text"
msgstr "Będziesz potrzebować instrukcji `if`."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.2.text"
msgstr "Będziesz potrzebować operatora porównania."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.3.text"
msgstr "Konkretnie `==`."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.4.text"
msgstr "Potrzebujesz zmiennej logicznej, którą wydrukujesz na końcu."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.5.text"
msgstr ""
"Jeśli znajdziesz element na liście, powinieneś ustawić tą zmienną na `True`."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.6.text"
msgstr "Gdy już znajdziesz element, nie możesz go 'odnaleźć'."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.7.text"
msgstr ""
"To oznacza, że raz ustawiona zmienna na `True`, nigdy nie powinna być "
"ustawiona na coś innego po tym."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.8.text"
msgstr "Nie używaj `else`."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.9.text"
msgstr ""
"Nie ma powodu, aby kiedykolwiek ustawiać zmienną na `False` wewnątrz pętli."

msgid "pages.UsingBreak.steps.list_contains_exercise.text"
msgstr ""
"Ćwiczenie: napisz program, który przyjmuje listę i wartość i sprawdza,\n"
"czy lista zawiera daną wartość. Na przykład, dla:\n"
"\n"
"    __no_auto_translate__\n"
"    things = ['This', 'is', 'a', 'list']\n"
"    thing_to_find = 'is'\n"
"\n"
"powinien wyświetlić `True`, ale dla:\n"
"\n"
"    __no_auto_translate__\n"
"    thing_to_find = 'other'\n"
"\n"
"powinien wyświetlić `False`."

msgid "pages.UsingBreak.title"
msgstr "Użycie `break` do wcześniejszego zakończenia pętli"

msgid "pages.UsingDictionaries.steps.dna_part1.text"
msgstr ""
"Not bad! But you may have noticed that it looks a bit awkward. Why do we have to specify `'dog'` and `'box'` in both the `cart` and the `quantities`?\n"
"On the next page we'll look at how to loop directly over the keys of a dictionary,\n"
"so we can get rid of the `cart` argument.\n"
"\n"
"But first, let's practice what we've learned a bit more.\n"
"\n"
"[Earlier in the course](#IntroducingElif) we looked at converting one strand of DNA\n"
"into a new strand with matching nucleotides.\n"
"Here's a version of that code using a function. It substitutes each letter in the input `string`\n"
"with a different one.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.UsingDictionaries.steps.dna_part2.hints.0.text"
msgstr ""
"This is still very similar to the previous exercises, but with strings "
"instead of numbers."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.1.text"
msgstr "You just have to think about the keys and values of `d`."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.2.text"
msgstr "You need to obtain the correct values to build up a string to return."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.3.text"
msgstr ""
"You can basically replace the whole `if/elif` chain with a single line."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.4.text"
msgstr "That line simply needs to use `d` to get the correct value."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.5.text"
msgstr "Remember that the keys of `d` are the characters in `string`."

msgid "pages.UsingDictionaries.steps.dna_part2.text"
msgstr ""
"Now we can use dictionaries to make this code both shorter and more general so it can be used for other purposes.\n"
"\n"
"Your job is to add another argument to the `substitute` function: a dictionary called `d`.\n"
"The keys of `d` represent characters\n"
"in the first argument `string` that should be replaced by the corresponding values of `d`. For example, `'A': 'T'`\n"
"means that `'A'` should be replaced by `'T'`:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"This version of `substitute` should work for any arguments where all the characters in `string` are keys in `d`.\n"
"No more `if` statements needed!"

msgid "pages.UsingDictionaries.steps.final_text.text"
msgstr ""
"Nice! Here's an example of how this function can also be used to encrypt and decrypt secret messages:\n"
"\n"
"    __copyable__\n"
"    __no_auto_translate__\n"
"    def substitute(string, d):\n"
"        result = \"\"\n"
"        for letter in string:\n"
"            result += d[letter]\n"
"        return result\n"
"\n"
"    plaintext = 'helloworld'\n"
"    encrypted = 'qpeefifmez'\n"
"    letters = {'h': 'q', 'e': 'p', 'l': 'e', 'o': 'f', 'w': 'i', 'r': 'm', 'd': 'z'}\n"
"    reverse = {'q': 'h', 'p': 'e', 'e': 'l', 'f': 'o', 'i': 'w', 'm': 'r', 'z': 'd'}\n"
"    assert_equal(substitute(plaintext, letters), encrypted)\n"
"    assert_equal(substitute(encrypted, reverse), plaintext)\n"
"\n"
"The same function works in both directions, we just need to pass it different dictionaries.\n"
"\n"
"The two dictionaries are almost the same, we just swap around the key and value in each pair.\n"
"So to encrypt, we replace `e` with `p`, and to decrypt we change `p` back to `e`.\n"
"\n"
"Note that `'e'` is both a key and a value in `letters`.\n"
"\n"
"Looking up `letters['e']` means that we're asking about `'e'` as a *key*, so it gives `'p'`.\n"
"Remember, we can't use `letters` to ask which key is associated with `'e'` as a *value*.\n"
"But in this case we can use the other dictionary for that: `reverse['e']` gives `'l'`,\n"
"and `letters['l']` gives `'e'` again.\n"
"\n"
"Soon you'll write a function to create a dictionary like `reverse` automatically,\n"
"i.e. `reverse = swap_keys_values(letters)`."

msgid "pages.UsingDictionaries.steps.shopping_cart1.hints.0.text"
msgstr "Remember that `prices` is a dictionary."

msgid "pages.UsingDictionaries.steps.shopping_cart1.hints.1.text"
msgstr "To access a value in a dictionary, you need a key."

msgid "pages.UsingDictionaries.steps.shopping_cart1.hints.2.text"
msgstr "The keys for `prices` are the items in the `cart`."

msgid "pages.UsingDictionaries.steps.shopping_cart1.text"
msgstr ""
"Let's see dictionaries in a real life problem. Imagine you're building an online shopping website.\n"
"You keep the prices of all your items in a dictionary:\n"
"\n"
"__code0__\n"
"\n"
"Here you can see one reason why looking up values in a dictionary could be a problem.\n"
"What would `prices[100]` be? `'dog'`? `'cat'`? `['dog', 'cat']`?\n"
"The same value can be repeated any number of times in a dictionary.\n"
"On the other hand, keys have to be unique. Imagine if your prices started like this:\n"
"\n"
"__code1__\n"
"\n"
"How much does an apple cost? We know it's `prices['apple']`, but is that `2` or `3`?\n"
"Clearly there should only be one price, so duplicate keys aren't allowed.\n"
"\n"
"Anyway, this is a normal shop where things have one price.\n"
"This normal shop has normal customers with normal shopping lists like `['apple', 'box', 'cat']`.\n"
"And even though your customers have calculators in their pockets, they still expect you to add up all the prices\n"
"yourself and tell them how much this will all cost, because that's what normal shops do.\n"
"\n"
"So let's write a function that does that. Complete the function below, particularly the line `price = ...`\n"
"\n"
"    __copyable__\n"
"__code2__"

msgid "pages.UsingDictionaries.steps.shopping_cart4.hints.0.text"
msgstr "Remember that the keys for `prices` and `quantities` are the same."

msgid "pages.UsingDictionaries.steps.shopping_cart4.hints.1.text"
msgstr "This is very similar to the previous exercise, we're just practicing."

msgid "pages.UsingDictionaries.steps.shopping_cart4.hints.2.text"
msgstr ""
"`price` should be a value from `prices`, and similarly for `quantity`."

msgid "pages.UsingDictionaries.steps.shopping_cart4.hints.3.text"
msgstr "What key should be used to obtain each value?"

msgid "pages.UsingDictionaries.steps.shopping_cart4.text"
msgstr ""
"Perfect! You publish your website and start dreaming about how rich you're going to be.\n"
"\n"
"But soon you get a complaint from a customer who wants to buy 5 million dogs...and 2 boxes to put them in.\n"
"\n"
"Your website allows buying the same items several times, e.g. `total_cost(['box', 'box'], {...})` works,\n"
"but they have to add each item one at a time, and for some reason this customer doesn't want to click\n"
"'Add to Cart' 5 million times. People are so lazy!\n"
"\n"
"Here's the new code for you to fix:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"We've added another parameter called `quantities` to `total_cost`.\n"
"Now `cart` is still a list of strings, but it doesn't have any duplicates.\n"
"`quantities` is a dictionary where the keys are the items in `cart` and the corresponding values are the quantity\n"
"of that item that the customer wants to buy."

msgid "pages.UsingDictionaries.title"
msgstr "Using Dictionaries in Practice"

msgid "pages.UsingVariables.steps.final_text.text"
msgstr ""
"Hurra! Już bez apostrofów! Wyjaśnimy, co dzieje się w tym kodzie później. "
"Na razie wystarczy wiedzieć, że `print(<coś>)` wyświetla `<coś>` w konsoli. "
"W szczególności pokazuje rzeczywistą zawartość napisów, na której nam "
"zazwyczaj zależy, zamiast przedstawienia napisów odpowiednich dla kodu, "
"które zawierają rzeczy takie jak cudzysłowy. Słowo `print` tutaj nie ma nic "
"wspólnego z drukarką czy drukowaniem."

msgid "pages.UsingVariables.steps.first_print.text"
msgstr ""
"Te cudzysłowy przy napisach zaczynają być irytujące. Spróbuj uruchomić to:\n"
"\n"
"__code0__"

msgid "pages.UsingVariables.steps.goodbye_plus_name.text"
msgstr "Obserwuj efekt tej zmiany uruchamiając `__program__` ponownie."

msgid "pages.UsingVariables.steps.hello_plus_name.text"
msgstr ""
"Możesz używać zmiennych w obliczeniach dokładnie tak samo, jak używałbyś literałów. Na przykład spróbuj:\n"
"\n"
"__program_indented__"

msgid ""
"pages.UsingVariables.steps.name_assign.messages.assigned_something_else.text"
msgstr ""
"Umieść `your_name` przed `=` aby stworzyć zmienną o nazwie `your_name`."

msgid "pages.UsingVariables.steps.name_assign.messages.empty_string.text"
msgstr "Do tego ćwiczenia wybierz niepusty napis (string)"

msgid ""
"pages.UsingVariables.steps.name_assign.messages.name_equals_something_else.text"
msgstr ""
"Masz prawidłową część `your_name = `, teraz po prawej stronie `=` umieść "
"napis (użyj apostrofów)."

msgid "pages.UsingVariables.steps.name_assign.messages.starts_with_space.text"
msgstr "Do tego ćwiczenia wybierz imię, które nie zaczyna się od spacji."

msgid "pages.UsingVariables.steps.name_assign.requirements"
msgstr ""
"Uruchom coś podobnego do `word = 'Hello'`, ale zamień `word` na `your_name`."

msgid "pages.UsingVariables.steps.name_assign.text"
msgstr ""
"Wcześniej utworzyliśmy zmienną o nazwie `word` z wartością `'Hello'` przy użyciu tego kodu:\n"
"\n"
"__code0__\n"
"\n"
"Teraz utwórz zmienną o nazwie `your_name`, której wartością jest inny napis (string).\n"
"\n"
"(Znak `_` w `your_name` to *podkreślnik*. Używaj go do rozdzielenia słów, kiedy potrzebujesz nazwy zmiennej zawierającej kilka słów. Możesz go wpisać na większości klawiatur, naciskając Shift oraz myślnik/pauza/minus (`-`).)"

msgid "pages.UsingVariables.steps.word_assign_goodbye.text"
msgstr ""
"Doskonale!\n"
"\n"
"Zmienne mogą również zmieniać swoje wartości w czasie. Aktualnie zmienna `word` ma wartość `'Hello'`. Możesz zmienić jej wartość w ten sam sposób, w jaki ją ustawiałeś po raz pierwszy. Uruchom to:\n"
"\n"
"__code0__"

msgid ""
"pages.UsingVariables.steps.word_plus_name.special_messages.bad_word.text"
msgstr ""
"Ups, musisz ustawić `word = 'Hello'` zanim będziemy mogli kontynuować."

msgid "pages.UsingVariables.steps.word_plus_name.text"
msgstr ""
"Ewentualnie możesz po prostu dodać zmienne do siebie. Spróbuj:\n"
"\n"
"__code0__"

msgid "pages.UsingVariables.steps.word_plus_name_with_space.hints.0.text"
msgstr "Musisz użyć `+` dwa razy, tak jak w 1+2+3."

msgid "pages.UsingVariables.steps.word_plus_name_with_space.hints.1.text"
msgstr ""
"Twoja odpowiedź powinna zawierać mieszankę zmiennych (bez cudzysłowu) i "
"literałów łańcuchowych (w cudzysłowie)."

msgid "pages.UsingVariables.steps.word_plus_name_with_space.hints.2.text"
msgstr "Musisz mieć znak spacji wewnątrz cudzysłowów."

msgid ""
"pages.UsingVariables.steps.word_plus_name_with_space.special_messages.bad_word.text"
msgstr ""
"Ups, musisz ustawić `word = 'Hello'` zanim będziemy mogli kontynuować."

msgid "pages.UsingVariables.steps.word_plus_name_with_space.text"
msgstr ""
"Ups... to nie wygląda ładnie. Czy możesz zmodyfikować powyższy kod tak, aby "
"między słowem a twoim imieniem była spacja?"

msgid "pages.UsingVariables.title"
msgstr "Używanie zmiennych i `print()`"


msgid "pages.WritingPrograms.steps.editor_hello_world.text"
msgstr ""
"Nadszedł czas, aby przestać robić wszystko w konsoli. W prawym górnym rogu można zobaczyć *edytor*. Jest to miejsce, w którym możesz pisać i uruchamiać dłuższe programy. Konsola jest świetna i powinieneś nadal z niej korzystać do eksploracji, ale to w edytorze żyją prawdziwe programy.\n"
"\n"
"Wpisz poniższy program do edytora, a następnie kliknij przycisk 'Uruchom':\n"
"\n"
"__code0__"

msgid "pages.WritingPrograms.steps.final_text.text"
msgstr ""
"Gratulacje, uruchomiłeś swój pierwszy rzeczywisty program!\n"
"\n"
"Poświęć trochę czasu, aby zrozumieć ten program. Python wykonuje każdą linię po kolei, od góry do dołu. Powinieneś spróbować symulować ten proces w swojej głowie - zastanów się, co robi każda linia. Zobacz, jak zmieniła się wartość zmiennej `word` i jakie to miało konsekwencje. Zauważ, że gdy używane jest wielokrotnie `print`, każda rzecz (w tym przypadku `Hello World` i `Goodbye World`) jest wypisywana na własnej linii.\n"
"\n"
"Kilka rzeczy, które warto zauważyć o programach w edytorze:\n"
"\n"
"1. Program jest uruchamiany w konsoli, co oznacza, że zmienne zdefiniowane w programie istnieją teraz w konsoli z ostatnimi wartościami, które miały w programie. Pozwala Ci to badać w konsoli po zakończeniu programu. Na przykład `name` ma teraz wartość `'World'` w konsoli.\n"
"2. Programy uruchamiają się w izolacji - nie zależą od żadnych wcześniej zdefiniowanych zmiennych. Konsola jest resetowana i wszystkie poprzednie zmienne są czyszczone. Więc pomimo że `word` obecnie istnieje w konsoli, jeśli usuniesz pierwszą linię programu i uruchomisz go ponownie, otrzymasz błąd o niezdefiniowanej zmiennej `word`.\n"
"3. Jeśli wpiszesz kod w konsoli i ma on wartość, ta wartość zostanie automatycznie wyświetlona. Nie dzieje się tak w przypadku programów w edytorze - musisz wydrukować wartości. Jeśli usuniesz `print()` z programu, zmieniając dwie linie na po prostu `word + ' ' + name`, nic nie zostanie wyświetlone.\n"
"\n"
"Najlepiej samodzielnie sprawdź te wszystkie rzeczy."

msgid "pages.WritingPrograms.title"
msgstr "Pisanie programów"
