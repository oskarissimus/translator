#
msgid ""
msgstr ""
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "chapters.a_bit_more_about_strings.title"
msgstr "Trochę więcej o łańcuchach znaków"

msgid "chapters.boolean operators.title"
msgstr "Operatory logiczne"

msgid "chapters.dictionaries.title"
msgstr "Słowniki"

msgid "chapters.for_loops.title"
msgstr "Pętle for"

msgid "chapters.functions.title"
msgstr "Funkcje"

msgid "chapters.if_statements.title"
msgstr "Instrukcje warunkowe"

msgid "chapters.lists.title"
msgstr "Listy"

msgid "chapters.nested_loops.title"
msgstr "Zagnieżdżone pętle"

msgid "chapters.string_basics.title"
msgstr "Podstawy łańcuchów znaków"

msgid "chapters.the_shell.title"
msgstr "Powłoka systemowa"

msgid "chapters.tic_tac_toe_project.title"
msgstr "Projekt gry w kółko i krzyżyk"

msgid "chapters.variables.title"
msgstr "Zmienne"


msgid "frontend.are_you_sure"
msgstr "Czy na pewno?"

msgid "frontend.ask_for_help"
msgstr "Poproś o pomoc"

msgid "frontend.assessment"
msgstr "Ocena"

msgid "frontend.assessment_description"
msgstr ""
"Gdy uruchomisz kod, który nie przechodzi obecnego kroku, ta sekcja *czasami*"
" wyjaśni co jest nie tak."

msgid "frontend.assessment_lint"
msgstr "Znaleziono następujące ogólne problemy w twoim kodzie:"

msgid "frontend.assessment_passed_tests"
msgstr "Plusy są takie, że twój kod przeszedł ${num} testy/ów!"

msgid "frontend.cancel"
msgstr "Anuluj"

msgid "frontend.chat_on_slack"
msgstr "Czatuj na Slacku"

msgid "frontend.click_for_error_details"
msgstr "Kliknij, aby zobaczyć szczegóły błędu"

msgid "frontend.click_to_expand"
msgstr "Kliknij, aby rozwinąć"

msgid "frontend.contact_directly"
msgstr "Alternatywnie możesz skontaktować się z nami bezpośrednio:"

msgid "frontend.copy_warning"
msgstr ""
"**STOP!**\n"
"\n"
"Postaraj się unikać kopiowania kodu. Będziesz lepiej uczyć się, przyswajać i pamiętać, jeśli wpiszesz kod samodzielnie.\n"
"\n"
"Kiedy kopiowanie jest odpowiednie, będzie przycisk, który ułatwi to zadanie. Jeśli nie ma przycisku, postaraj się wpisywać kod.\n"
"\n"
"Cóż, nie będziemy cię zmuszać. Skopiuj, jeśli naprawdę chcesz."

msgid "frontend.copying_solution_not_allowed"
msgstr "Kopiowanie z obszaru podpowiedzi/rozwiązania nie jest dozwolone!"

msgid "frontend.current_page"
msgstr "(obecna strona)"

msgid "frontend.description"
msgstr "Opis"

msgid "frontend.developer_mode"
msgstr "Tryb deweloperski"

msgid "frontend.developer_mode_description"
msgstr "Aktywuje przyciski „Cofnij krok” i „Pomiń krok”."

msgid "frontend.did_you_mean"
msgstr "Czy miałeś na myśli..."

msgid "frontend.error_has_been_reported"
msgstr "Błąd został zgłoszony."

msgid "frontend.error_traceback"
msgstr "Traceback błędu:"

msgid "frontend.exercise_requirement"
msgstr ""
"Ten krok to ćwiczenie. Musisz wymyślić kod, który da poprawny wynik. Możliwe"
" są wiele różnych poprawnych odpowiedzi."

msgid "frontend.exercise_stdin"
msgstr ""
"Twój program musi otrzymać dane wejściowe od użytkownika poprzez funkcję "
"„input()”. Podczas testowania poprawności różne dane wejściowe użytkownika "
"zostaną zasymulowane."

msgid "frontend.feedback"
msgstr "Opinia"

msgid "frontend.feedback_email_placeholder"
msgstr "Email (opcjonalnie)"

msgid "frontend.function_exercise"
msgstr ""
"Zdefiniuj funkcję, zaczynając od:\n"
"\n"
"${header}\n"
"\n"
"Następnie wypełnij wcięte ciało własną implementacją.\n"
"\n"
"Funkcja będzie wywołana z różnymi argumentami, aby przetestować, czy generalnie działa. Możesz także sam wywołać funkcję, aby ją przetestować podczas pracy, ale nie wpłynie to na ocenę."

msgid "frontend.function_exercise_goal"
msgstr "Twoja funkcja musi `${print_or_return}` poprawny wynik."

msgid "frontend.get_another_hint"
msgstr "Uzyskaj kolejną podpowiedź"

msgid "frontend.get_hint"
msgstr "Uzyskaj podpowiedź"

msgid "frontend.give_feedback"
msgstr "Przekaż opinię"

msgid "frontend.give_feedback_from_menu"
msgstr "Przekaż opinię z menu w lewym górnym rogu."

msgid "frontend.give_feedback_instructions"
msgstr ""
"Powiedz nam, co lubisz lub czego nie lubisz! Jeśli zgłaszasz błąd, podaj szczegółowy opis problemu:\n"
"\n"
"- Co robiłeś przed i kiedy problem się pojawił?\n"
"- Jakie kroki można podjąć, aby go odtworzyć?\n"
"- Co obserwujesz i co według ciebie powinno się stać zamiast tego?"

msgid "frontend.hidden_solution_instructions"
msgstr ""
"Powyżej znajduje się przykładowe rozwiązanie, ale jest ukryte. Klikaj "
"przycisk „Odsłoń” wielokrotnie, aby odsłaniać rozwiązanie kawałek po "
"kawałku. Postaraj się zatrzymać, kiedy pomyślisz, że odsłoniłeś "
"wystarczająco i możesz sam uzupełnić pozostałe luki. Następnie wpisz "
"rozwiązanie w edytorze i uruchom je. Twoje rozwiązanie nie musi być takie "
"samo jak powyżej."

msgid "frontend.hints_and_solution"
msgstr "Podpowiedzi i Rozwiązanie"

msgid "frontend.hints_progress"
msgstr "Pokazane ${numHints} z ${totalHints} podpowiedzi"

msgid "frontend.internal_error_start"
msgstr "Ups, coś poszło nie tak! ${maybeErrorReported} Oto co możesz zrobić:"

msgid "frontend.loading_wait"
msgstr "Ładowanie..."

msgid "frontend.login_or_sign_up"
msgstr "Zaloguj się / Zarejestruj"

msgid "frontend.new"
msgstr "Nowy"

msgid "frontend.next"
msgstr "Dalej"

msgid "frontend.no"
msgstr "Nie"

msgid "frontend.no_hints_available"
msgstr ""
"Do tego kroku nie ma żadnych podpowiedzi. Spróbuj ponownie przeczytać "
"instrukcje i wymagania. Nadal możesz sprawdzić rozwiązanie, jeśli jesteś "
"naprawdę zablokowany."

msgid "frontend.no_input_variables"
msgstr "To ćwiczenie nie ma zmiennych wejściowych."

msgid "frontend.non_function_exercise"
msgstr ""
"Twój kod *musi* zacząć się od przypisania wartości do zmiennych wejściowych, np:\n"
"\n"
"${inputs}\n"
"\n"
"Wartości to tylko przykłady, możesz wybrać inne. Twój kod zostanie automatycznie przetestowany z różnymi wartościami, aby sprawdzić, czy działa w ogólności."

msgid "frontend.ok"
msgstr "OK"

msgid "frontend.open_github_issue"
msgstr "Otwórz issue na GitHubie"

msgid "frontend.output_prediction_correct"
msgstr "Poprawnie!"

msgid "frontend.output_prediction_error_choice"
msgstr "Błąd"

msgid "frontend.output_prediction_question"
msgstr "Jak myślisz, jaki będzie wynik?"

msgid "frontend.output_prediction_wrong_once"
msgstr "Ups, to nie jest prawidłowa odpowiedź. Możesz spróbować jeszcze raz!"

msgid "frontend.output_prediction_wrong_twice"
msgstr "Niestety, zła odpowiedź. Spróbuj ponownie następnym razem!"

msgid "frontend.parsons_solution_instructions"
msgstr ""
"Powyżej znajduje się przykładowe rozwiązanie z nieuporządkowanymi liniami. "
"Możesz je przeciągać, aby je posortować. Znalezienie poprawnej kolejności "
"zależy od ciebie, nie powiemy ci, czy masz rację. Eksperymentowanie i "
"uruchamianie częściowych rozwiązań w edytorze może ci pomóc to rozgryźć. "
"Nadal musisz wpisać poprawne rozwiązanie w edytorze i uruchomić je, aby "
"kontynuować."

msgid "frontend.previous"
msgstr "Wstecz"

msgid "frontend.program_in_text"
msgstr ""
"Dokładny kod, który musisz uruchomić, jest pokazany w tekście powyżej."

msgid "frontend.question_wizard"
msgstr "Kreator Pytań"

msgid "frontend.question_wizard_expected_output"
msgstr ""
"Dobrze, teraz wpisz poniżej wynik, którego oczekujesz/chcesz otrzymać od swojego programu. Co by wyświetlił, gdyby działał poprawnie? Jeśli nie ma nic wyświetlać, dodaj do swojego kodu kilka wywołań funkcji `print()`, aby wyświetlił coś użytecznego.\n"
"\n"
"When you're done, click 'Run' again to generate your question."

msgid "frontend.question_wizard_intro"
msgstr ""
"Jeśli potrzebujesz pomocy, istnieje wiele stron takich jak [Stack Overflow](https://stackoverflow.com/) i [reddit](https://www.reddit.com/r/learnpython/), gdzie możesz zadawać pytania. To narzędzie pomoże ci napisać dobrej jakości pytanie, które prawdopodobnie uzyska odpowiedzi.\n"
"\n"
"Wpisz i uruchom swój kod po prawej stronie. Jeśli nie masz żadnego kodu, bo nie wiesz od czego zacząć, obawiam się, że to narzędzie nie może ci pomóc. Nadal możesz prosić o pomoc, ale warto najpierw przeczytać [Jakich pytań należy unikać?](https://stackoverflow.com/help/dont-ask)\n"
"\n"
"Jeśli twoje pytanie dotyczy serwerów (np. Django lub Flask), żądań sieciowych, baz danych lub pakietu, który nie może być zaimportowany tutaj, to narzędzie nie będzie działać. Jednak tylko dlatego, że twój obecny kod *obejmuje* te rzeczy, nie oznacza, że o to chodzi w twoim pytaniu. Jeśli masz ogólny problem z Pythonem/programowaniem/logiką, wyizoluj go. Python z Django to wciąż Python. Jeśli nie możesz tego zrobić, przeczytaj [Jak stworzyć Minimalny, Powtarzalny Przykład](https://stackoverflow.com/help/minimal-reproducible-example) przed zadaniem pytania."

msgid "frontend.refresh_and_try_again"
msgstr "Odśwież stronę i spróbuj ponownie."

msgid "frontend.repeated_frames_description"
msgstr "${name} w linii ${lineno} (${count} razy)"

msgid "frontend.requirements"
msgstr "Wymagania"

msgid "frontend.requirements_description"
msgstr ""
"Musisz uruchomić kod zgodnie z instrukcjami powyżej. Na wypadek, gdyby te "
"nie były wystarczająco jasne, oto pewne dodatkowe wyjaśnienia:"

msgid "frontend.reveal"
msgstr "Odsłoń"

msgid "frontend.reverse_step"
msgstr "Cofnij krok"

msgid "frontend.run"
msgstr "Uruchom"

msgid "frontend.send_email_to"
msgstr "Email"

msgid "frontend.settings"
msgstr "Ustawienia"

msgid "frontend.show_shuffled_solution"
msgstr "Pokaż pomieszane rozwiązanie"

msgid "frontend.show_solution"
msgstr "Pokaż rozwiązanie"

msgid "frontend.show_unscrambled_solution"
msgstr "Pokaż niepomieszane rozwiązanie"

msgid "frontend.sign_out"
msgstr "Wyloguj"

msgid "frontend.similar_frames_skipped"
msgstr "Pominięte podobne ramki:"

msgid "frontend.skip_step"
msgstr "Pomiń krok"

msgid "frontend.stop"
msgstr "Zatrzymaj"

msgid "frontend.submit"
msgstr "Zatwierdź"

msgid "frontend.table_of_contents"
msgstr "Spis treści"

msgid "frontend.title"
msgstr "Tytuł"

msgid "frontend.toc_instructions"
msgstr ""
"Poniżej znajdują się linki do różnych stron kursu. Możesz zacząć od dowolnego miejsca i iść w dowolnej kolejności, a Twój postęp na każdej stronie będzie rejestrowany.\n"
"\n"
"Jeśli jesteś całkowicie nowy w programowaniu, lub masz wątpliwości, po prostu zacznij od początku i klikaj Następny, gdy skończysz każdą stronę."

msgid "frontend.try_running_code_again"
msgstr "Spróbuj uruchomić kod ponownie."

msgid "frontend.try_using_different_browser"
msgstr "Spróbuj użyć innej przeglądarki."

msgid "frontend.verbatim"
msgstr ""
"Ten krok ma tylko jedną poprawną odpowiedź. Musisz uruchomić dokładnie "
"poprawny kod, więc sprawdź dokładnie swoją pisownię. Tylko kilka rodzajów "
"szczegółów (takich jak spacje w niektórych miejscach) zostanie "
"zignorowanych, ponieważ nie robią one różnicy dla programu."

msgid "frontend.yes"
msgstr "Tak"

msgid "linting_messages.pyflakes.ImportShadowedByLoopVar.message_format"
msgstr ""
"**Import `{0}` jest przesłonięty przez zmienną pętli**\n"
"\n"
"Należy zmienić nazwę zmiennej pętli `{0}`, ponieważ przedefiniowuje ona wcześniej zaimportowany moduł `{0}`.\n"
"Wybierz inną nazwę zmiennej pętli, aby uniknąć tego błędu."

msgid "linting_messages.pyflakes.ImportStarNotPermitted.message_format"
msgstr ""
"**Import przy użyciu `*` **\n"
"\n"
"Użycie konstrukcji `from {0} import *` powoduje zaimportowanie wszystkiego z modułu `{0}` do bieżącej przestrzeni nazw.\n"
"Tworzy to wiele niewidocznych, nieznanych zmiennych.\n"
"Utrudnia to czytanie i rozumienie kodu oraz ustalenie skąd pochodzą poszczególne elementy.\n"
"\n"
"Unikaj tego rodzaju importu i zamiast tego dokładnie zaimportuj tylko te nazwy, których potrzebujesz."

msgid "linting_messages.pyflakes.IsLiteral.message_format"
msgstr ""
"**Porównanie `is` z literałem**\n"
"\n"
"Użyto operatora `is`/`is not` do porównania z literałem (np. ciąg znaków lub liczba).\n"
"Zamiast tego powinno się użyć operatora `==` / `!=`.\n"
"\n"
"Operator `is` sprawdza, czy dwie wyrażenia odnoszą się do dokładnie tego samego obiektu.\n"
"Rzadko chcesz go używać, zwłaszcza w przypadku podstawowych typów danych, takich jak ciągi znaków i liczby.\n"
"W takich przypadkach wydaje się, że czasami działa (np. dla małych liczb) i tajemniczo\n"
"zawodzi przy innych okazjach."

msgid "linting_messages.pyflakes.MultiValueRepeatedKeyLiteral.message_format"
msgstr ""
"**Klucz słownika `{0}` został powtórzony z różnymi wartościami**\n"
"\n"
"Słownik nie może mieć wielu wpisów dla tego samego klucza.\n"
"Sprawdź ponownie swój kod i zmień powtarzający się klucz na coś unikalnego."

msgid "linting_messages.pyflakes.RedefinedWhileUnused.message_format"
msgstr ""
"**Przedefiniowano `{0}` bez jego użycia**\n"
"\n"
"Zdefiniowałeś `{0}` w linii `{1}`, ale zanim go użyłeś, zdefiniowałeś go ponownie,\n"
"nadpisując oryginalną definicję.\n"
"\n"
"Ogólnie twoje funkcje i klasy powinny mieć różne nazwy.\n"
"Sprawdź, czy używasz wszystkiego co zdefiniowałeś, np. czy wywołałeś swoje funkcje."

msgid "linting_messages.pyflakes.UnusedImport.message_format"
msgstr ""
"**Niewykorzystany import `{0}`**\n"
"\n"
"Zaimportowałeś `{0}`, ale go nie użyłeś. Czy zapomniałeś go użyć?\n"
"Może użyłeś w jego miejsce błędnej zmiennej? Jeśli nie potrzebujesz importu, po prostu go usuń."

msgid "linting_messages.pyflakes.UnusedVariable.message_format"
msgstr ""
"**Niewykorzystana zmienna `{0}`**\n"
"\n"
"Zdefiniowałeś zmienną `{0}`, ale nigdy jej nie użyłeś. Czy zapomniałeś jej użyć?\n"
"Może użyłeś w jej miejsce błędnej zmiennej? Jeśli nie potrzebujesz jej, po prostu ją usuń."


msgid "misc_terms.blank_result"
msgstr "<pusto>"

msgid "misc_terms.case_sensitive"
msgstr ""
"Python jest wrażliwy na wielkość liter (ang. *case sensitive*)! Oznacza to, że małe i wielkie "
"litery są ważne i ich zmiana zmienia znaczenie programu. Ciągi znaków "
"`'hello'` i `'Hello'` są różne, podobnie jak nazwy zmiennych `word` i "
"`Word`."

msgid "misc_terms.code_should_start_like"
msgstr ""
"Twój kod powinien zaczynać się tak:\n"
"\n"
"{expected_start}\n"

msgid "misc_terms.copy_button"
msgstr "Kopiuj"

msgid "misc_terms.disallowed_default_label"
msgstr "więcej niż {max_count} {label}"

msgid "misc_terms.disallowed_default_message"
msgstr ""
"Brawo, znalazłeś rozwiązanie! Jednakże, dla tego ćwiczenia i twojej nauki, "
"nie wolno ci używać {label}."

msgid "misc_terms.expected_mode_birdseye"
msgstr "Mając swój kod w edytorze, kliknij przycisk `birdseye`."

msgid "misc_terms.expected_mode_pythontutor"
msgstr "Mając swój kod w edytorze, kliknij przycisk Python Tutor."

msgid "misc_terms.expected_mode_shell"
msgstr "Wpisz swój kod bezpośrednio w shell po `>>>` i wciśnij Enter."

msgid "misc_terms.expected_mode_snoop"
msgstr "Mając swój kod w edytorze, kliknij przycisk `snoop`."

msgid "misc_terms.incorrect_mode"
msgstr "Kod jest poprawny, ale nie został uruchomiony zgodnie z instrukcją."

msgid "misc_terms.invalid_inputs"
msgstr ""
"Wartości twoich zmiennych wejściowych są niepoprawne, spróbuj użyć wartości "
"podobnych do przykładu."

msgid "misc_terms.must_define_function"
msgstr "Musisz zdefiniować funkcję `{function_name}`"

msgid "misc_terms.no_more_test_inputs"
msgstr ""
"Nie ma więcej testowych danych wejściowych - rozwiązanie powinno się już "
"zakończyć"

msgid "misc_terms.not_a_function"
msgstr "`{function_name}` nie jest funkcją."

msgid "misc_terms.q_wiz_debugger"
msgstr ""
"Świetnie, że używasz debugera! Rozwiązanie problemu samodzielnie jest "
"idealne. Jeśli nie możesz, użyj przycisku 'Run', aby wygenerować pytanie."

msgid "misc_terms.q_wiz_final_message"
msgstr ""
"\n"
"Świetnie! Oto kilka końcowych wskazówek:\n"
"\n"
"- Upewnij się, że wynik pokazuje problem, który masz, a nie coś innego.\n"
"- Zredukuj swój kod do **minimalnego** przykładu. Usuń wszelki kod, który nie jest bezpośrednio związany z problemem.\n"
"- Przeprowadź swój kod przez debugery `snoop`, `birdseye` i Python Tutor, aby zrozumieć, co robi.\n"
"- Poszukaj rozwiązania swojego problemu w internecie.\n"
"- Przeczytaj [Jak zadać dobre pytanie?](https://stackoverflow.com/help/how-to-ask)\n"
"\n"
"Jeśli jesteś naprawdę gotowy, skopiuj i wklej poniższe na stronę z pytaniem,\n"
"i zastąp pierwszą linię opisem swojego problemu.\n"
"\n"
"Możesz nadal zmieniać swój kod lub oczekiwany wynik i kliknąć Run ponownie, aby wygenerować pytanie na nowo.\n"
"\n"
"    __copyable__\n"
"    *Wyjaśnij, co próbujesz zrobić i dlaczego*\n"
"\n"
"    Oto mój kod:\n"
"\n"
"{}\n"
"\n"
"    To jest wynik:\n"
"\n"
"{}\n"
"\n"
"    Oczekiwany wynik to:\n"
"\n"
"{}\n"

msgid "misc_terms.q_wiz_input_and_add"
msgstr ""
"i dodaj\n"
"\n"
"    {list_line}\n"
"\n"
"na początku twojego kodu."

msgid "misc_terms.q_wiz_input_message_start"
msgstr ""
"`input()` utrudnia zadawanie pytań i udzielanie odpowiedzi dotyczących kodu."
" Zastąp wywołania funkcji input łańcuchami znaków, tak aby każdy mógł "
"natychmiast uruchomić kod oraz otrzymać te same wyniki."

msgid "misc_terms.q_wiz_input_replace_with"
msgstr ""
"Zastąp:\n"
"\n"
"{original_lines}\n"
"\n"
"tym:\n"
"\n"
"{replaced_lines}"

msgid "misc_terms.q_wiz_no_output"
msgstr ""
"Twój kod nic nie wyświetlił. Dodaj kilka wywołań `print()`, tak aby chociaż "
"coś zostało wyświetlone. Użyj kodu, aby pokazać czytelnikom dokładnie, gdzie"
" jest problem."

msgid "misc_terms.q_wiz_same_as_expected_output"
msgstr ""
"Twój wynik jest taki sam jak oczekiwany! Jeśli problem nadal istnieje, "
"dopasuj swój kod i/lub oczekiwany wynik, tak aby te dwa wyniki się nie "
"zgadzały. Wyraźnie pokaż, co by było inaczej, gdyby kod działał tak, jak "
"chcesz."

msgid "misc_terms.signature_should_be"
msgstr ""
"Sygnatura powinna wyglądać:\n"
"\n"
"    def {function_name}{needed_signature}:\n"
"\n"
"nie:\n"
"\n"
"    def {function_name}{actual_signature}:"

msgid "misc_terms.string_spaces_differ"
msgstr ""
"Sprawdź, czy ciągi znaków w twoim kodzie mają poprawne spacje. Na przykład, "
"`'Hello'` różni się od `'Hello '` ze względu na spację na końcu."

msgid "misc_terms.syntax_error_at_line"
msgstr "w linii"

msgid "misc_terms.when_it_should_output"
msgstr "gdy powinno wyświetlić:"

msgid "misc_terms.which_is_correct"
msgstr "co jest poprawne!"

msgid "misc_terms.your_code_outputs"
msgstr "Twój kod wypisuje:"

msgid "misc_terms.your_code_outputs_given_values"
msgstr ""
"Biorąc pod uwagę te wartości:\n"
"\n"
"{given_values}\n"
"\n"
"twój kod wypisuje:"

msgid "output_predictions.Error"
msgstr "Błąd"

msgid "pages.AddingStrings.steps.final_text.text"
msgstr ""
"Brawo! Każde z poniższych rozwiązań jest poprawne:\n"
"\n"
"__code0__"

msgid "pages.AddingStrings.steps.hello_world_concat.text"
msgstr ""
"Łańcuchy znaków można łączyć za pomocą '+', jednak oznacza to coś zupełnie innego niż dodawanie liczb. Na przykład, spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.AddingStrings.steps.hello_world_space.hints.0.text"
msgstr "Spacja to znak tak samo jak każdy inny, np. 'o' lub 'w'."

msgid "pages.AddingStrings.steps.hello_world_space.hints.1.text"
msgstr "Znak spacji musi znajdować się gdzieś wewnątrz cudzysłowów."

msgid ""
"pages.AddingStrings.steps.hello_world_space.messages.literal_answer.text"
msgstr "Wciąż musisz dodać dwa lub więcej łańcuchy znaków do siebie."

msgid "pages.AddingStrings.steps.hello_world_space.requirements"
msgstr ""
"Użyj '+', aby dodać dwa lub więcej łańcuchów znaków do siebie, tak aby "
"wynikiem było łańcuch `'hello world'`."

msgid "pages.AddingStrings.steps.hello_world_space.text"
msgstr ""
"Możesz zauważyć, że `+` łączy dwa łańcuchy znaków jeden po drugim. Technicznie jest to nazywane konkatenacją.\n"
"\n"
"Oto ćwiczenie: zmień nieznacznie poprzedni kod, tak aby wynikiem była łańcuch `'hello world'`, czyli ze spacją między słowami.\n"
"\n"
"Przy okazji, jeśli utkniesz, możesz kliknąć ikonę żarówki w prawym dolnym rogu, aby uzyskać podpowiedź."

msgid "pages.AddingStrings.title"
msgstr "Łączenie łańcuchów znaków"

msgid "pages.BasicForLoopExercises.steps.final_text.text"
msgstr ""
"Robimy naprawdę duże postępy! Rozwiązujesz problemy i piszesz nowy kod!\n"
"Przed nami jeszcze ciekawsze rzeczy."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_1.hints.0.text"
msgstr ""
"Powinieneś użyć tylko jednego `print`, ponieważ każdy print wypisuje w nowej"
" linii."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_1.hints.1.text"
msgstr "Będziesz musiał użyć `+`."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_1.text"
msgstr ""
"Czas na ćwiczenia! Zmodyfikuj ten program:\n"
"\n"
"__code0__\n"
"\n"
"aby zamiast tego wyświetlił:\n"
"\n"
"    __no_auto_translate__\n"
"    ---W\n"
"    ---o\n"
"    ---r\n"
"    ---l\n"
"    ---d"

msgid "pages.BasicForLoopExercises.steps.loop_exercise_2.hints.0.text"
msgstr ""
"Na chwilę zapomnij o pętlach. Jak byś napisał program, który wypisze `name` "
" 3 razy?"

msgid "pages.BasicForLoopExercises.steps.loop_exercise_2.hints.1.text"
msgstr ""
"Rozwiązanie wygląda bardzo podobnie do innych programów, które widzieliśmy w"
" tej sekcji."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_2.hints.2.text"
msgstr ""
"Pętla for stworzy zmienną taką jak `character`, ale program nie musi jej "
"wykorzystywać."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_2.text"
msgstr ""
"Świetnie! Napisz teraz program, który wypisze `name` tyle razy, ile ma liter. Na przykład dla `name = 'Amy'`, program powinien wypisać:\n"
"\n"
"    __no_auto_translate__\n"
"    Amy\n"
"    Amy\n"
"    Amy\n"
"\n"
"Dla `name = 'World'`, powinien program powinien wypisać:\n"
"\n"
"    __no_auto_translate__\n"
"    World\n"
"    World\n"
"    World\n"
"    World\n"
"    World\n"
"\n"
"Pamiętaj, że możesz ustawić jakąkolwiek wartość zmiennej `name` w pierwszej linii. Jedynie kod znajdujący się poniżej będzie sprawdzony."

msgid "pages.BasicForLoopExercises.title"
msgstr "Podstawowe ćwiczenia z pętlą for"

msgid "pages.BasicTerminology.steps.final_text.text"
msgstr ""
"Oto słowa, które powinieneś znać:\n"
"\n"
"***Wyrażenie*** (ang. expression) to fragment kodu, który ma wartość. Na przykład, w tej linii kodu:\n"
"\n"
"    __no_auto_translate__\n"
"    sentence = 'Hello ' + name\n"
"\n"
"mamy trzy wyrażenia:\n"
"\n"
"1. `'Hello '`\n"
"2. `name`\n"
"3. `'Hello ' + name`\n"
"\n"
"Natomiast pełna linia `sentence = ...` to ***instrukcja*** (ang. statement). To polecenie, które mówi komputerowi, by wykonał akcję. Samo w sobie nie ma wartości. Oznacza to na przykład, że nie można dodawać do siebie instrukcji. Ten kod jest błędny:\n"
"\n"
"    (word = 'Hello') + (name = 'Bob')\n"
"\n"
"Konkretnie, instrukcja taka jak `sentence = ...` w której zmiennej przypisywana jest wartość, nazywana jest ***przypisaniem*** (ang. assignment) - wartość jest *przypisana do* zmiennej.\n"
"\n"
"Program to lista instrukcji, które są wykonane w kolejności. Pętla `for` to *złożona instrukcja* (ang. compound statement), co oznacza, że posiada ciało, zawierające inne instrukcje. Większość instrukcji będzie również zawierać wyrażenia, i wyrażenia mogą zawierać inne, mniejsze wyrażenia, ale wyrażenia nie mogą zawierać instrukcji.\n"
"\n"
"Proces obliczania wartości wyrażenia nazywa się ***ewaluacją*** (ang. evaluation) - zauważ, jak niemal zawiera słowo 'wartość' (ang. value). Komputer *ewaluuje* `1 + 2`, by uzyskać wartość `3`.\n"
"\n"
"Proces wykonywania pętli nazywa się ***iteracją*** (ang. iteration). Kod taki jak `for char in 'Hello':` *iteruje po* (ang. iterating over) łańcuchu znaków `'Hello'`. Fakt, że jest to możliwe, oznacza, że łańcuchy znaków są *iterowalne* (ang. iterable). W przeciwieństwie do tego, liczby nie są iterowalne, co Python powie ci dosłownie, jeśli spróbujesz wykonać `for char in 3:`. Każde wykonanie pętli to *jedna iteracja*, więc w tym przykładzie będzie ich 5."

msgid "pages.BasicTerminology.title"
msgstr "Podstawowe pojęcia"
msgid "pages.BuildingNewLists.steps.double_numbers.hints.0.text"
msgstr "Pamiętaj, że możesz mnożyć liczby używając `*`."

msgid "pages.BuildingNewLists.steps.double_numbers.hints.1.text"
msgstr ""
"Ten program jest strukturalnie bardzo podobny do programów, które pisałeś, "
"budując łańcuchy znaków znak po znaku."

msgid "pages.BuildingNewLists.steps.double_numbers.hints.2.text"
msgstr ""
"Utwórz nową listę, a następnie zbuduj ją element po elemencie w pętli for."

msgid "pages.BuildingNewLists.steps.double_numbers.hints.3.text"
msgstr "Zacznij od pustej listy."

msgid "pages.BuildingNewLists.steps.double_numbers.hints.4.text"
msgstr "Możesz utworzyć listę z jednym elementem `x`, po prostu pisząc `[x]`."

msgid "pages.BuildingNewLists.steps.double_numbers.hints.5.text"
msgstr ""
"Możesz dodać element do listy, dodając listę zawierającą jeden element."

msgid "pages.BuildingNewLists.steps.double_numbers.text"
msgstr ""
"Listy i łańcuchy znaków mają wiele wspólnego.\n"
"Na przykład, możesz dodać dwie listy, aby połączyć je w nową listę.\n"
"Możesz także utworzyć pustą listę, która nie ma żadnych elementów.\n"
"Sprawdź to sam:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Z tą wiedzą, napisz program, który bierze listę liczb\n"
"i wyświetla listę, w której każda liczba została podwojona. Na przykład, mając:\n"
"\n"
"__code1__\n"
"\n"
"wypisałby:\n"
"\n"
"__code2__"

msgid "pages.BuildingNewLists.steps.filter_numbers.disallowed.0.message"
msgstr ""
"Brawo, to jest poprawne! Jednak powinieneś użyć `.append()` zamiast `+=`."

msgid "pages.BuildingNewLists.steps.filter_numbers.hints.0.text"
msgstr "To jest bardzo podobne do poprzedniego ćwiczenia."

msgid "pages.BuildingNewLists.steps.filter_numbers.hints.1.text"
msgstr ""
"Różnica polega na tym, że czasami powinieneś pominąć dodawanie do nowej "
"listy."

msgid "pages.BuildingNewLists.steps.filter_numbers.hints.2.text"
msgstr "Użyj instrukcji `if`."

msgid "pages.BuildingNewLists.steps.filter_numbers.hints.3.text"
msgstr ""
"Użyj operatora porównania, aby przetestować, czy liczba jest wystarczająco "
"duża, aby ją dodać."

msgid "pages.BuildingNewLists.steps.filter_numbers.text"
msgstr ""
"Świetnie!\n"
"\n"
"Gdy chcesz dodać pojedynczy element na koniec listy, zamiast:\n"
"\n"
"__code0__\n"
"\n"
"częściej pisze się:\n"
"\n"
"__code1__\n"
"\n"
"Nie ma naprawdę dużej różnicy między tymi dwoma sposobami, ale `.append`\n"
"będzie bardziej znajomy i czytelny dla większości osób.\n"
"\n"
"Teraz użyj `.append`, aby napisać program, który bierze listę liczb i\n"
"wyświetla nową listę zawierającą tylko te liczby, które są większe niż 5.\n"
"\n"
"Na przykład, mając:\n"
"\n"
"__code2__\n"
"\n"
"wypisałby:\n"
"\n"
"__code3__"

msgid "pages.BuildingNewLists.steps.final_text.text"
msgstr "Fantastycznie! Robimy duże postępy."

msgid "pages.BuildingNewLists.title"
msgstr "Budowanie nowych list"

msgid "pages.BuildingUpStrings.steps.empty_string.text"
msgstr ""
"Ostatni znak w `name` jest dodawany do `line` tylko na końcu pętli, po tym jak `print(line)` już zostało wykonane po raz ostatni. Więc ten znak i pełna `name` nigdy nie zostają wydrukowane na dole trójkąta. Jeśli jesteś zdezorientowany, spróbuj umieścić `print(line)` zarówno przed, jak i po `line = line + char`.\n"
"\n"
"Zróbmy coś z tymi znakami `-` na wyjściu. Możesz już być w stanie zgadnąć jak.\n"
"\n"
"*Pusty łańcuch* (ang. empty string) to łańcuch nie zawierający w ogóle znaków.\n"
"Jest zapisany jako para apostrofów otaczających nic: `''`.\n"
"To jest jak zero, tylko że dla łańcuchów znaków.\n"
"Dodanie go do innego łańcucha daje ci po prostu niezmieniony drugi łańcuch,\n"
"tak samo jak `0 + 5` to po prostu `5`.\n"
"\n"
"Spróbuj tego w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.BuildingUpStrings.steps.final_text.text"
msgstr ""
"Czyż to nie jest piękne?\n"
"\n"
"Wzór rozpoczęcia od czegoś pustego i budowania tego w pętli `for` jest *bardzo* częsty\n"
"i będziesz miał z tym dużo praktyki. Niektóre początkowe puste wartości to\n"
"`''`, `0` i `[]` - pusta lista, o której wkrótce się dowiesz."

msgid ""
"pages.BuildingUpStrings.steps.hello_plus_equals.output_prediction_choices.0"
msgstr ""
"Hello\n"
"Hello"

msgid ""
"pages.BuildingUpStrings.steps.hello_plus_equals.output_prediction_choices.1"
msgstr ""
"Hello\n"
"Hello!"

msgid ""
"pages.BuildingUpStrings.steps.hello_plus_equals.output_prediction_choices.2"
msgstr ""
"Hello!\n"
"Hello!"

msgid "pages.BuildingUpStrings.steps.hello_plus_equals.text"
msgstr ""
"Zanim przyjrzymy się kilku pętlom, musimy szybko poznać kolejne pojęcie. Spójrz na ten program:\n"
"\n"
"__program_indented__\n"
"\n"
"Co myślisz, robi linia `hello = hello + '!'`? Uruchom program, aby się dowiedzieć."

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.0"
msgstr ""
"-\n"
"W\n"
"-\n"
"o\n"
"-\n"
"r\n"
"-\n"
"l\n"
"-\n"
"d"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.1"
msgstr ""
"-W\n"
"-o\n"
"-r\n"
"-l\n"
"-d"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.2"
msgstr "-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.3"
msgstr "-W-o-r-l-d"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.4"
msgstr ""
"-W\n"
"-Wo\n"
"-Wor\n"
"-Worl\n"
"-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.5"
msgstr ""
"-World\n"
"-Worl\n"
"-Wor\n"
"-Wo\n"
"-W"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.6"
msgstr ""
"-World\n"
"-World\n"
"-World\n"
"-World\n"
"-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.7"
msgstr ""
"-World\n"
"--World\n"
"---World\n"
"----World\n"
"-----World"

msgid "pages.BuildingUpStrings.steps.name_triangle.text"
msgstr ""
"Pythonowi nie przeszkadza, że `hello` znajduje się zarówno po lewej, jak i prawej stronie `=`, po prostu robi to, co zawsze by zrobił, gdyby zmienne były inne: oblicza `hello + '!'`, co w tym przypadku jest `'Hello' + '!'`, co daje `'Hello!'`, i to staje się nową wartością `hello`. Jeśli to pomoże, możesz myśleć o tej linii jako podzielonej na dwa kroki:\n"
"\n"
"__code0__\n"
"\n"
"lub:\n"
"\n"
"__code1__\n"
"\n"
"To jest bardzo użyteczne w pętli. Wypróbuj ten program:\n"
"\n"
"__program_indented__"

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.0.text"
msgstr ""
"Najpierw upewnij się, że nie pracujesz na uszkodzonej wersji poprzedniego "
"programu na tej stronie."

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.1.text"
msgstr "Czyli `line = line + char` powinno być przed `print(line)`."

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.2.text"
msgstr "Poza tym musisz dokonać tylko jednej ***malutkiej*** zmiany."

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.3.text"
msgstr "Chcemy pozbyć się `-`. Więc po prostu to zrób. Dosłownie."

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.4.text"
msgstr "Użyj pustego łańcucha!"

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.text"
msgstr ""
"Nie myl pustego łańcucha z `' '`, który jest niepustym łańcuchem zawierającym jeden znak: spację.\n"
"\n"
"Teraz napraw oryginalny program, aby pozbyć się tych linii w wyjściu, tak aby\n"
"dla `name = 'World'` wydrukowało:\n"
"\n"
"    __no_auto_translate__\n"
"    W\n"
"    Wo\n"
"    Wor\n"
"    Worl\n"
"    World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle_missing_last_line.output_prediction_choices.0"
msgstr ""
"-W\n"
"-Wo\n"
"-Wor\n"
"-Worl\n"
"-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle_missing_last_line.output_prediction_choices.1"
msgstr ""
"-Wo\n"
"-Wor\n"
"-Worl\n"
"-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle_missing_last_line.output_prediction_choices.2"
msgstr ""
"-\n"
"-W\n"
"-Wo\n"
"-Wor\n"
"-Worl"

msgid "pages.BuildingUpStrings.steps.name_triangle_missing_last_line.text"
msgstr ""
"Poświęć czas, aby całkowicie zrozumieć ten program. Robi coś w rodzaju:\n"
"\n"
"    line = '-'\n"
"\n"
"    char = 'W'\n"
"    line = line + char\n"
"         = '-' + 'W'\n"
"         = '-W'\n"
"    print('-W')\n"
"\n"
"    char = 'o'\n"
"    line = line + char\n"
"         = '-W' + 'o'\n"
"         = '-Wo'\n"
"    print('-Wo')\n"
"\n"
"    char = 'r'\n"
"    line = line + char\n"
"         = '-Wo' + 'r'\n"
"         = '-Wor'\n"
"    print('-Wor')\n"
"\n"
"    ...\n"
"\n"
"Szczegóły są ważne. Co się stanie, jeśli zamienisz ostatnie dwie linie i uruchomisz ten program zamiast tego?\n"
"\n"
"__program_indented__"

msgid "pages.BuildingUpStrings.title"
msgstr "Budowanie łańcuchów tekstowych"

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.0.text"
msgstr ""
"Pierwsza litera powinna mieć 0 spacji przed nią, druga litera powinna mieć 1"
" spację przed nią, trzecia powinna mieć 2, itd."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.1.text"
msgstr ""
"Powinieneś trzymać spacje w zmiennej i budować je w pętli, jak wcześniej."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.2.text"
msgstr ""
"Różnica polega na tym, że musisz wydrukować litery jednocześnie z "
"zbudowaniem spacji."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.3.text"
msgstr "Innymi słowy, potrzebujesz pojedynczej pętli, która robi to i to."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.4.text"
msgstr "Ciało pętli musi wydrukować spacje i litery, a także dodać spację."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.5.text"
msgstr ""
"Ponieważ pierwsza litera nie powinna mieć spacji przed nią, musisz dodać "
"spację po wydrukowaniu litery."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.messages.add_space_first.text"
msgstr ""
"Prawie tam! Masz jedną spację za dużo przed każdą literą.\n"
"Upewnij się, że pierwszy raz gdy twoja pętla wywoła `print`\n"
"twoja zmienna, która będzie zawierać spacje, jest pustym ciągiem.\n"
"Sprawdź kolejność swojego kodu."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.text"
msgstr ""
"Cudownie! Naprawdę Łapiesz to!\n"
"\n"
"Jeśli chcesz, możesz zrobić jeden dodatkowy opcjonalny bonusowy wyzwanie poniżej.\n"
"Jeśli nie, możesz po prostu kontynuować do [następnej strony](#BasicTerminology) teraz.\n"
"Możesz wrócić i zrobić to później, jeśli chcesz.\n"
"\n"
"Spróbuj napisać program, który wyświetli podaną `name` w przekątnej linii, na przykład:\n"
"\n"
"    W\n"
"     o\n"
"      r\n"
"       l\n"
"        d"


msgid "pages.BuildingUpStringsExercises.steps.final_text.text"
msgstr "Wow, nic Cię nie powstrzyma!"

msgid "pages.BuildingUpStringsExercises.steps.name_box.disallowed.0.message"
msgstr ""
"Dobra robota, to rozwiązanie jest poprawne! Jednak można je ulepszyć.\n"
"Wystarczy użyć jednej pętli - użycie więcej jest nieefektywne.\n"
"Możesz ponownie użyć zmiennej zawierającej linię z `-` i `+`."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.0.text"
msgstr ""
"Zrobiłeś już wszystkie trudne rzeczy w poprzednim ćwiczeniu. Teraz to tylko "
"proste dodawanie łańcuchów."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.1.text"
msgstr ""
"Potrzebujesz tylko jednej pętli for - tej używanej do tworzenia linii "
"myślników z poprzedniego ćwiczenia."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.2.text"
msgstr ""
"Nie próbuj zrobić wszystkiego naraz. Podziel problem na mniejsze, łatwiejsze"
" podproblemy."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.3.text"
msgstr ""
"Spróbuj napisać program, który wyświetla:\n"
"\n"
"    -----\n"
"    World\n"
"    -----"

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.4.text"
msgstr ""
"Ponieważ musisz wydrukować trzy oddzielne linie tekstu, będziesz musiał "
"zadzwonić `print()` trzy razy."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.5.text"
msgstr ""
"Spróbuj napisać program, który wyświetla:\n"
"\n"
"    |World|"

msgid "pages.BuildingUpStringsExercises.steps.name_box.text"
msgstr ""
"Fantastycznie!\n"
"\n"
"Przy okazji, gdy nie potrzebujesz używać zmiennej, powszechną konwencją jest nazwanie tej zmiennej `_` (podkreślenie), na przykład `for _ in name:`. Nie zmienia to działania programu, ale jest pomocne dla czytelników.\n"
"\n"
"Zróbmy to bardziej wyszukane. Rozszerz swój program, aby narysować ramkę wokół nazwy, taką jak tutaj:\n"
"\n"
"    +-----+\n"
"    |World|\n"
"    +-----+"

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.disallowed.0.message"
msgstr ""
"Dobra robota, to rozwiązanie jest poprawne!\n"
"I użyłeś pętli zagnieżdżonej (pętli wewnątrz pętli), której jeszcze nie omawialiśmy!\n"
"Jednakże w tym przypadku pętla zagnieżdżona jest nieefektywna.\n"
"Możesz utworzyć zmienną zawierającą spacje i wykorzystać to w każdej linii."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.hints.0.text"
msgstr "Będziesz potrzebować dwóch oddzielnych pętli for nad `name`."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.hints.1.text"
msgstr ""
"Każda linia z wyjątkiem pierwszej i ostatniej ma te same znaki w środku. To "
"znaczy, że możesz coś wykorzystać ponownie."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.hints.2.text"
msgstr "Stwórz zmienną zawierającą spacje w środku i używaj jej wiele razy."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.hints.3.text"
msgstr ""
"Użyj jednej pętli, aby stworzyć wiele spacji, i drugiej pętli, aby "
"wydrukować wiele linii używając wcześniej stworzonych spacji."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.text"
msgstr ""
"Coraz lepiej Ci idzie! Wygląda na to, że potrzebujesz większego wyzwania... może zamiast umieszczać nazwę w ramce, sama nazwa powinna być ramką? Napisz program, który wyświetla to:\n"
"\n"
"    +World+\n"
"    W     W\n"
"    o     o\n"
"    r     r\n"
"    l     l\n"
"    d     d\n"
"    +World+"

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.0.text"
msgstr ""
"Rozwiązanie jest bardzo podobne do oryginalnego programu trójkąta, wystarczy"
" zrobić jedną małą zmianę."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.1.text"
msgstr ""
"Chcesz nadal dodawać po jednym znaku do `line`, to tylko kwestia tego, gdzie"
" dodajesz go."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.2.text"
msgstr "Chcesz, aby linie były odwrócone, więc musisz odwrócić coś."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.3.text"
msgstr "Potrzebujesz dodać znak przed ciągiem, zamiast po."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.4.text"
msgstr ""
"3 + 7 to to samo co 7 + 3. Tak samo dla wszystkich liczb. Czy to samo "
"dotyczy ciągów znaków?"

msgid "pages.BuildingUpStringsExercises.steps.name_triangle_backwards.text"
msgstr ""
"Świetnie! Teraz zmodyfikuj program tak, aby każda linia była odwrócona, na przykład tak:\n"
"\n"
"    __no_auto_translate__\n"
"    W\n"
"    oW\n"
"    roW\n"
"    lroW\n"
"    dlroW"

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_spaced.hints.0.text"
msgstr "Będziesz potrzebować użyć jednego `+` więcej."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_spaced.hints.1.text"
msgstr ""
"Będziesz potrzebować użyć ciągu składającego się z jednej spacji: `' '`."

msgid "pages.BuildingUpStringsExercises.steps.name_triangle_spaced.text"
msgstr ""
"Zmodyfikuj ten program:\n"
"\n"
"__code0__\n"
"\n"
"aby dodać spację po każdej literze w trójkącie, tak aby wyglądało to tak:\n"
"\n"
"    W\n"
"    W o\n"
"    W o r\n"
"    W o r l\n"
"    W o r l d"

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.hints.0.text"
msgstr "Spójrz na program w kształcie trójkąta w poszukiwaniu inspiracji."

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.hints.1.text"
msgstr ""
"Spójrz na program, w którym wydrukowałeś `name` raz dla każdego znaku w "
"poszukiwaniu inspiracji."

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.hints.2.text"
msgstr ""
"Będziesz musiał zbudować łańcuch myślników (`-`) dodając po jednym znaku na "
"raz."

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.hints.3.text"
msgstr ""
"Pętla for stworzy zmienną, taką jak `char`, ale program nie musi jej używać."

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.text"
msgstr ""
"Wspaniale!\n"
"\n"
"Kod taki jak:\n"
"\n"
"__code0__\n"
"\n"
"jest tak powszechny w Pythonie, że można go skrócić. Oznacza to samo:\n"
"\n"
"__code1__\n"
"\n"
"Zwróć uwagę, że nie ma skrótu dla `line = char + line`.\n"
"\n"
"Teraz użyj `+=` i pętli for, aby napisać własny program, który wydrukuje `name` podkreślone, jak tutaj:\n"
"\n"
"    World\n"
"    -----\n"
"\n"
"Powinien być jeden `-` dla każdej litery w `name`."

msgid "pages.BuildingUpStringsExercises.title"
msgstr "Ćwiczenia: Budowanie łańcuchów znaków"

msgid "pages.CallingFunctionsTerminology.steps.final_text.text"
msgstr ""
"Słowo 'atrybut' w komunikacie o błędzie odnosi się do użycia `.` - błąd "
"pochodzi właściwie tylko z `word.append`, nawet bez wywołania."

msgid "pages.CallingFunctionsTerminology.steps.introducing_callable.text"
msgstr ""
"Wyrażenie takie jak `len(things)` lub `print(things)` to ***wywołanie*** funkcji (ang. function call), - gdy to piszesz, ***wywołujesz*** funkcję `len` lub `print`. Fakt, że jest to możliwe, oznacza, że funkcje są ***wywoływalne*** (ang. callable):\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.len_of_none.text"
msgstr ""
"`None` to specjalna wartość 'null', która nie może zrobić nic ciekawego. To powszechny symbol zastępczy reprezentujący brak realnej, użytecznej wartości. Funkcje, które nie chcą niczego zwracać, domyślnie zwracają `None`. Jeśli widzisz komunikat o błędzie dotyczący `None` lub `NoneType`, często oznacza to, że przypisałeś coś niewłaściwego do zmiennej:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.methods_of_str.text"
msgstr ""
"***Metoda*** to funkcja należąca do typu, którą można wywołać na wszystkich wartościach tego typu, używając `.`. Na przykład `upper` i `lower` to metody ciągów znaków, które są wywoływane z użyciem np. `word.upper()`:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.no_append_for_str.text"
msgstr ""
"Kolejnym przykładem jest to, że `append` to metoda list. Ale nie możesz użyć `.upper` na liście ani `.append` na ciągu znaków:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.not_callable.text"
msgstr ""
"Większość rzeczy nie jest wywoływalna, więc próba ich wywołania spowoduje błąd:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.print_functions.text"
msgstr ""
"Nadszedł czas, by poszerzyć twoje słownictwo jeszcze bardziej.\n"
"\n"
"`print` i `len` to ***funkcje***. Zobacz sam:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.print_returns_none.text"
msgstr ""
"W wywołaniu `len(things)`, `things` to ***argument***. Czasami spotkasz się też ze słowem ***parametr***, które oznacza w zasadzie to samo co argument. To trochę jakbyś przekazywał argument funkcji - konkretnie mówimy, że argument `things` jest *przekazywany* do `len`, a `len` *akceptuje* lub *odbiera* argument.\n"
"\n"
"`len(things)` wyliczy się do liczby, takiej jak 3, w takim przypadku mówimy, że `len` ***zwrócił*** 3.\n"
"\n"
"Wszystkie wywołania muszą coś zwrócić... nawet jeśli to nic. Na przykład, zadaniem funkcji `print` jest wyświetlenie czegoś na ekranie, a nie zwracanie użytecznej wartości. Dlatego zwraca coś bezużytecznego zamiast tego:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.title"
msgstr "Terminologia: Wywoływanie funkcji i metod"

msgid "pages.CallingFunctionsWithinFunctions.steps.final_text.text"
msgstr ""
"`birdseye` pokazuje tylko jedną ramkę (wywołanie funkcji) na raz. Najpierw widać ramkę globalną.\n"
"Na dole jest wywołanie `print_twice`. Kliknij na małą niebieską strzałkę aby przejść\n"
"do tej ramki, a potem kliknij na następną, aby wejść do `print_many`."

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.print_twice_call_print_many.text"
msgstr ""
"Ciało funkcji może zawierać wszystko, w tym wywołania funkcji. Zresztą już to zrobiliśmy wywołując\n"
"print. Wywołanie naszej własnej funkcji niczym się nie różni - nasze funkcje mogą się wzajemnie wywoływać!\n"
"\n"
"Na przykład, możemy zaimplementować `print_twice` przy użyciu `print_many`:\n"
"\n"
"__program_indented__"

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.see_stack_in_birdseye.requirements"
msgstr "Uruchom ten sam program co powyżej, ale z `birdseye`."

msgid "pages.CallingFunctionsWithinFunctions.steps.see_stack_in_birdseye.text"
msgstr ""
"Za każdym razem, gdy funkcja jest wywołana, tworzona jest nowa *ramka* (ang. frame), która zawiera lokalne wartości zmiennych\n"
"w tym wywołaniu i inne informacje o tym, co się obecnie dzieje.\n"
"Gdy wywołanie funkcji się kończy, ramka jest usuwana.\n"
"\n"
"Można to zobaczyć w Python Tutor po prawej stronie pod \"Frames\". Na górze jest Globalna ramka,\n"
"główna ramka, w której działa cały program. Klikając Dalej, nowe ramki się pojawiają\n"
"i potem znikają. W każdej z nich można zobaczyć wartości zmiennych.\n"
"\n"
"Na koniec, uruchom program z `birdseye`."

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.see_stack_in_pythontutor.requirements"
msgstr "Uruchom ten sam program co powyżej, ale z Python Tutor."

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.see_stack_in_pythontutor.text"
msgstr ""
"`snoop` rozpoczyna każde wywołanie funkcji od:\n"
"\n"
"1. Nowego poziomu wcięcia w logach.\n"
"2. `>>> Call to <nazwa funkcji>`\n"
"3. Wartości argumentów.\n"
"4. Linii nagłówka funkcji.\n"
"\n"
"Kończy wywołanie z `<<< Return value from <nazwa funkcji>`. Niedługo dowiemy się więcej o wartościach zwracanych.\n"
"\n"
"Teraz uruchom program ponownie z Python Tutor."

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.see_stack_in_snoop.requirements"
msgstr "Uruchom ten sam program co powyżej, ale z `snoop`."

msgid "pages.CallingFunctionsWithinFunctions.steps.see_stack_in_snoop.text"
msgstr ""
"Jest ważne aby dobrze zrozumieć co się tutaj dzieje i wiedzieć jak\n"
"badać wywołania funkcji, więc spróbujemy to zrobić w naszych debuggerach.\n"
"\n"
"Najpierw, uruchom program ponownie z `snoop`."

msgid "pages.CallingFunctionsWithinFunctions.title"
msgstr "Wywoływanie Funkcji w Funkcjach"

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.0.text"
msgstr "How many diagonals are there on the board?"

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.1.text"
msgstr ""
"Which entries of the three sublists make up each diagonal? How can you "
"access these entries?"

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.2.text"
msgstr "Every list always has 3 entries, so no need for a loop."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.3.text"
msgstr ""
"There are two problems to solve here: checking for a win in a specific "
"diagonal, and combining the checks for each diagonal."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.4.text"
msgstr "One problem can be solved using `and`, the other using `or`."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.5.text"
msgstr ""
"There's a lot of similarity with the `all_equal` function. You can even call"
" that function to help! But then you have to include its definition."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.6.text"
msgstr ""
"Similar to `all_equal`, check that the 3 entries on a diagonal are equal to "
"each other, e.g. by using `and`."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.7.text"
msgstr "Check the two diagonals together, using `or`."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.text"
msgstr ""
"If you read it casually from left to right, you may think that:\n"
"\n"
"__code0__\n"
"\n"
"is equivalent to\n"
"\n"
"__code1__\n"
"\n"
"but it's actually equivalent to\n"
"\n"
"__code2__\n"
"\n"
"This is because `and` has a higher priority than `or`.\n"
"This is important because the first interpretation reduces to `True and False` which is `False`, while the second\n"
"interpretation reduces to `True or False` which is `True`!\n"
"You can try both options with parentheses in the shell to confirm.\n"
"\n"
"**The lesson here is to be extra careful when combining operators.** Either add parentheses to be safe or\n"
"break up your expression into smaller parts and assign each part to a variable.\n"
"This will make your code clear, readable, and unambiguous, and will save you from painful mistakes.\n"
"\n"
"Time for an exercise. Suppose you're writing a program to play tic-tac-toe,\n"
"also known as noughts and crosses or Xs and Os. If you've never heard of tic-tac-toe, you can read the rules\n"
"and play a few games [here](https://gametable.org/games/tic-tac-toe/).\n"
"\n"
"We need to check if someone has won a game. Our function `all_equal` is already helpful for checking rows.\n"
"\n"
"Write a function to check if someone has won a game by placing 3 of the same pieces on one of the diagonal lines.\n"
"The board is given as a nested list `board` of 3 sublists, each sublist containing 3 strings, representing a row. For example:\n"
"\n"
"__code3__\n"
"\n"
"The function should return a boolean: `True` if one of the diagonals have 3 of the same pieces, `False` otherwise.\n"
"Click the Copy button to get started with the code below.\n"
"We provided some tests for you, your job is to replace the `...` with your code.\n"
"\n"
"    __copyable__\n"
"__code4__"

msgid "pages.CombiningAndAndOr.steps.CombiningAndOr.text"
msgstr ""
"If you use both `and` and `or` in a single expression, it's a lot like combining `*` and `+`.\n"
"The operators are evaluated in a specific order.\n"
"\n"
"For example, try the following code in the shell.\n"
"What do you expect?\n"
"\n"
"__program_indented__"

msgid "pages.CombiningAndAndOr.steps.final_text.text"
msgstr ""
"Well done! This was a hard one. Here are some possible solutions:\n"
"\n"
"__code0__\n"
"\n"
"or:\n"
"\n"
"__code1__"

msgid "pages.CombiningAndAndOr.title"
msgstr "Combining `and` and `or`"

msgid "pages.CombiningCompoundStatements.steps.final_text.text"
msgstr ""
"Zauważ, że ciało instrukcji `if` (4 linie) jest wcięte jak zwykle, podczas gdy ciało\n"
"pętli `for` (1 linia) jest wcięte o dodatkowe 4 spacje w każdej linii, aby pokazać, że\n"
"te linie są wewnątrz pętli `for`. Strukturę całego programu można zobaczyć\n"
"po prostu patrząc na wcięcia.\n"
"\n"
"Alternatywnie, możesz umieścić `if` w środku `for`:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Te dwa programy dają dokładnie ten sam wynik. Jednak pierwszy z nich jest bardziej wydajny, ponieważ\n"
"iteruje po łańcuchu tylko wtedy, gdy jest to potrzebne, ponieważ gdy `excited = False` nic się nie zmienia."

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.0"
msgstr "Hello World"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.2"
msgstr "Hello World!!!!!!!!!!!"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.3"
msgstr "!!!!!!!!!!!Hello World"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.4"
msgstr "Hello World!"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.5"
msgstr "!Hello World"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.6"
msgstr "!Hello World!"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.7"
msgstr "H!e!l!l!o! !W!o!r!l!d!"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.8"
msgstr "!H!e!l!l!o! !W!o!r!l!d"

msgid "pages.CombiningCompoundStatements.steps.for_inside_if.text"
msgstr ""
"Instrukcje złożone takie jak pętle `for` i instrukcje warunkowe `if` mają ciała, które są listą\n"
"wnętrznych instrukcji. Te wewnętrzne instrukcje mogą być czymkolwiek, włącznie z innymi złożonymi instrukcjami.\n"
"Spróbuj tego przykładu pętli `for` wewnątrz instrukcji `if`, gdy chcesz pokazać,\n"
"że jesteś *naprawdę* podekscytowany:\n"
"\n"
"__program_indented__"

msgid "pages.CombiningCompoundStatements.title"
msgstr "Łączenie instrukcji złożonych"

msgid "pages.DefiningFunctions.steps.change_function_name.hints.0.text"
msgstr ""
"Musisz zmienić nazwę w nagłówku definicji funkcji, ale to nie wszystko."

msgid "pages.DefiningFunctions.steps.change_function_name.hints.1.text"
msgstr ""
"Jeśli zmienisz tylko nazwę w nagłówku definicji funkcji, co się stanie?"

msgid "pages.DefiningFunctions.steps.change_function_name.hints.2.text"
msgstr "Otrzymasz błąd. Spójrz na komunikat. Co Ci mówi? Skąd pochodzi błąd?"

msgid "pages.DefiningFunctions.steps.change_function_name.hints.3.text"
msgstr ""
"Jeśli twoja funkcja nazywa się `say_hello`, co oznacza `greet(\"Alice\")`?"

msgid "pages.DefiningFunctions.steps.change_function_name.hints.4.text"
msgstr "Musisz zmienić dokładnie 3 linijki programu."

msgid "pages.DefiningFunctions.steps.change_function_name.hints.5.text"
msgstr "W każdej linijce, którą zmieniasz, zmień dokładnie jedno słowo."

msgid "pages.DefiningFunctions.steps.change_function_name.hints.6.text"
msgstr ""
"Nie ruszaj treści funkcji. Powinna ona nadal zawierać `print(\"Jak się "
"masz?\")`."

msgid "pages.DefiningFunctions.steps.change_function_name.hints.7.text"
msgstr ""
"Nadal powinieneś(aś) wywołać funkcję dwukrotnie po jej zdefiniowaniu, z "
"argumentami `\"Alice\"` i `\"Bob\"`."

msgid "pages.DefiningFunctions.steps.change_function_name.text"
msgstr ""
"Zwróć uwagę, jak zmieniło się wyjście programu. `How are you?` jest wyświetlane dwukrotnie. Możesz myśleć o całym programie jako o czymś\n"
"równoważnym do tego:\n"
"\n"
"__code0__\n"
"\n"
"To pokazuje jedną z najbardziej użytecznych rzeczy odnośnie funkcji. Pozwalają one wielokrotnie używać tego samego kodu bez\n"
"konieczności powtarzania się. To jak pisanie programu wewnątrz programu.\n"
"\n"
"Linia nagłówka definicji funkcji zawsze zawiera te części:\n"
"\n"
"1. Specjalne słowo kluczowe `def`, po którym następuje spacja.\n"
"2. Nazwa funkcji. Jest to jak nazwa zmiennej - możesz wybrać nazwę, którą chcesz, ale istnieją pewne ograniczenia,\n"
"np. nie może zawierać spacji.\n"
"3. Para nawiasów `(` i `)`\n"
"4. Zero lub więcej nazw parametrów pomiędzy nawiasami, oddzielonych przecinkami, jeśli jest ich więcej niż jeden. Tutaj mamy\n"
"jeden parametr o nazwie `name`.\n"
"5. Dwukropek `:`\n"
"\n"
"Zróbmy kilka prostych ćwiczeń. Zmień nazwę funkcji z `greet` na `say_hello`.\n"
"Upewnij się, że cały program nadal działa jak przedtem, ale nie zmieniaj niczego innego."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.0.text"
msgstr ""
"Musisz zmienić nazwę parametru w nagłówku definicji funkcji, ale to nie "
"wszystko."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.1.text"
msgstr ""
"Jeśli zmienisz tylko nazwę parametru w nagłówku definicji funkcji, co się "
"stanie?"

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.2.text"
msgstr "Otrzymasz błąd. Spójrz na komunikat. Co Ci mówi? Skąd pochodzi błąd?"

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.3.text"
msgstr ""
"Jeśli parametr nazywa się `person_name`, co oznacza `print(f\"Hello "
"{name}!\")`?"

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.4.text"
msgstr "Musisz zmienić dokładnie 2 linijki programu."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.5.text"
msgstr "W każdej linijce, którą zmieniasz, zmień dokładnie jedno słowo."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.6.text"
msgstr ""
"Nie ruszaj części po definicji funkcji, tzn. `say_hello(\"Alice\")` i "
"`say_hello(\"Bob\")`."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.7.text"
msgstr ""
"W treści funkcji powinieneś(aś) nadal mieć dwie instrukcje, w tym "
"`print(\"Jak się masz?\")`."

msgid "pages.DefiningFunctions.steps.change_parameter_name.text"
msgstr ""
"Dobrze! Teraz wykonaj podobne ćwiczenie: zmień nazwę parametru z `name` na "
"`person_name`."

msgid "pages.DefiningFunctions.steps.define_greet.text"
msgstr ""
"Zobaczyłeś(aś) już, jak wywoływać funkcje takie jak `print()` i `len()`. Teraz nauczysz się pisać własne\n"
"funkcje, z których możesz korzystać Ty lub ktokolwiek inny. Jest to bardzo ważne, kiedy mamy do czynienia z programami które są większe i bardziej skomplikowane.\n"
"\n"
"Oto prosty przykład:\n"
"\n"
"__program_indented__\n"
"\n"
"To definiuje funkcję o nazwie `greet`, która akceptuje jeden parametr. Poniżej definicji wywołujemy funkcję dwukrotnie.\n"
"Uruchom kod, aby zobaczyć co się stanie."

msgid "pages.DefiningFunctions.steps.final_text.text"
msgstr "Doskonale! Teraz masz solidne podstawy definiowania funkcji."

msgid "pages.DefiningFunctions.steps.how_are_you.output_prediction_choices.0"
msgstr ""
"Hello Alice!\n"
"How are you?\n"
"Hello Bob!\n"
"How are you?"

msgid "pages.DefiningFunctions.steps.how_are_you.output_prediction_choices.1"
msgstr ""
"Hello Alice!\n"
"Hello Bob!\n"
"How are you?"

msgid "pages.DefiningFunctions.steps.how_are_you.output_prediction_choices.2"
msgstr ""
"Hello Alice!\n"
"How are you?\n"
"Hello Bob!"

msgid "pages.DefiningFunctions.steps.how_are_you.requirements"
msgstr ""
"Dodaj `print(\"How are you?\")` po `print(f\"Hello {name}!\")` z takim samym wcięciem.\n"
"Zachowaj dwa wywołania `greet` po definicji jak są."

msgid "pages.DefiningFunctions.steps.how_are_you.text"
msgstr ""
"Definicja funkcji to instrukcja złożona (ang. compound statement). Podobnie jak `if` i `for`, ma linię nagłówkową, po której następuje wcięty blok\n"
"zawierający jedną lub więcej instrukcji.\n"
"\n"
"Dodaj kolejną instrukcję do funkcji, aby wyglądała ona tak:\n"
"\n"
"__code0__\n"
"\n"
"Następnie uruchom program ponownie."

msgid "pages.DefiningFunctions.steps.print_many.output_prediction_choices.2"
msgstr ""
"Hello\n"
"Hello\n"
"Hello"

msgid "pages.DefiningFunctions.steps.print_many.output_prediction_choices.3"
msgstr "Hello"

msgid "pages.DefiningFunctions.steps.print_many.output_prediction_choices.4"
msgstr ""
"H\n"
"e\n"
"l\n"
"l\n"
"o"

msgid "pages.DefiningFunctions.steps.print_many.text"
msgstr ""
"Funkcje mogą mieć wiele parametrów. Tutaj jest przykład:\n"
"\n"
"__program_indented__"

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.0.text"
msgstr ""
"Nie ma tu żadnych szczególnych zagadek, chodzi tylko o przestrzeganie "
"receptury na definiowanie funkcji."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.1.text"
msgstr "Upewnij się, że masz wszystkie części funkcji wymienione powyżej."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.2.text"
msgstr "To obejmuje `def`, `()`, i `:`."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.3.text"
msgstr "Upewnij się, że twoja funkcja nazywa się `print_twice`."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.4.text"
msgstr ""
"Upewnij się, że przyjmuje ona jeden parametr o nazwie `x` pomiędzy nawiasami"
" `()`."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.5.text"
msgstr "Spójrz na inne funkcje zdefiniowane powyżej, aby uzyskać pomoc."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.6.text"
msgstr "Użyj parametru wewnątrz treści funkcji."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.7.text"
msgstr "Upewnij się, że treść jest wcięta."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.8.text"
msgstr "Treść powinna zawierać dwie instrukcje lub bardzo prostą pętlę."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.9.text"
msgstr ""
"Upewnij się, że nie wywołujesz `print_twice` wewnątrz treści funkcji "
"`print_twice`. Sprawdź swoje wcięcia."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.requirements"
msgstr ""
"Napisz program definiujący funkcję o nazwie `print_twice` zgodnie z opisem "
"powyżej."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.text"
msgstr ""
"Świetnie!\n"
"\n"
"Teraz napisz własną funkcję o nazwie `print_twice`, która przyjmuje jeden argument `x` i drukuje ten argument dwukrotnie\n"
"na dwóch liniach.\n"
"\n"
"Na przykład, `print_twice(\"Hello\")` powinno wyjść:\n"
"\n"
"__code0__\n"
"\n"
"Możesz przetestować swoją funkcję, wywołując ją po definicji funkcji, ale nie jest to wymagane."

msgid "pages.DefiningFunctions.steps.swap_parameters.hints.0.text"
msgstr ""
"Jedyna zmiana w definicji funkcji powinna dotyczyć zamiany miejscami "
"parametrów, zgodnie z instrukcją, nic więcej."

msgid "pages.DefiningFunctions.steps.swap_parameters.hints.1.text"
msgstr "Musisz naprawić wywołanie `print_many`."

msgid "pages.DefiningFunctions.steps.swap_parameters.hints.2.text"
msgstr ""
"Jeśli funkcja jest zdefiniowana jako `def print_many(n, thing)`, co oznacza "
"`print_many(\"Hello\", 3)`?"

msgid "pages.DefiningFunctions.steps.swap_parameters.hints.3.text"
msgstr "Nadal chcemy, aby `thing = \"Hello\"` i `n = 3`."

msgid "pages.DefiningFunctions.steps.swap_parameters.text"
msgstr ""
"Zauważ przecinki używane do oddzielania parametrów w definicji funkcji i argumentów w wywołaniu funkcji,\n"
"oraz podobieństwo między definicją a wywołaniem:\n"
"\n"
"    def print_many(thing, n):\n"
"                     ^    ^\n"
"                     |    |\n"
"      print_many(\"Hello\", 3)\n"
"\n"
"Więc wywołanie `print_many(\"Hello\", 3)` jest jak uruchomienie:\n"
"\n"
"__code0__\n"
"\n"
"Teraz kolejne proste ćwiczenie. Zamień miejscami parametry w nagłówku definicji funkcji, aby było:\n"
"\n"
"__code1__\n"
"\n"
"Jeśli to zrobisz i nic więcej, otrzymasz błąd. Napraw resztę programu, aby zachowywał się jak wcześniej.\n"
"*Nie zmieniaj treści funkcji*."

msgid "pages.DefiningFunctions.title"
msgstr "Definiowanie funkcji"

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.hints.0.text"
msgstr ""
"Remember that we previously had `for item in cart` in the function, but "
"`cart` is no longer an argument."

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.hints.1.text"
msgstr ""
"Now `quantities` is the only argument that defines what the customer is "
"buying."

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.hints.2.text"
msgstr ""
"You need to iterate over the keys of `quantities` instead. Remember that "
"'iterate' here means 'loop over' with a `for` loop."

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.hints.3.text"
msgstr "You can use `.keys()`, but you don't have to."

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.text"
msgstr ""
"Now you can use this to modify our function on the previous page to remove the `cart` argument:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.DictionaryKeysAndValues.steps.english_to_french.hints.0.text"
msgstr "You will need to iterate (loop) over the dictionary."

msgid "pages.DictionaryKeysAndValues.steps.english_to_french.hints.1.text"
msgstr ""
"You need to print both the key (English word) and the value (French word) of"
" each dictionary entry."

msgid "pages.DictionaryKeysAndValues.steps.english_to_french.hints.2.text"
msgstr "You can get the value using the key in the same way as always."

msgid "pages.DictionaryKeysAndValues.steps.english_to_french.text"
msgstr ""
"That looks nice! We've fully solved the problem of adding up the total cost.\n"
"\n"
"Coming back to our first example: write a function\n"
"which prints out each word in an English-to-French dictionary and its translation, labeling them with their languages.\n"
"Here's your starting code:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"For example, the last line of code above should print:\n"
"\n"
"    English: apple\n"
"    French: pomme\n"
"    ---\n"
"    English: box\n"
"    French: boite\n"
"    ---"

msgid "pages.DictionaryKeysAndValues.steps.english_to_german.hints.0.text"
msgstr ""
"This is still very similar to the previous exercise, nothing special yet."

msgid "pages.DictionaryKeysAndValues.steps.english_to_german.hints.1.text"
msgstr ""
"You can reuse your previous solution, just add another argument and a tiny "
"bit of code inside."

msgid "pages.DictionaryKeysAndValues.steps.english_to_german.hints.2.text"
msgstr "You now have to print one dictionary key and two dictionary values."

msgid "pages.DictionaryKeysAndValues.steps.english_to_german.text"
msgstr ""
"Great! Now let's add a German dictionary as well:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"That should print:\n"
"\n"
"    English: apple\n"
"    French: pomme\n"
"    German: apfel\n"
"    ---\n"
"    English: box\n"
"    French: boite\n"
"    German: kasten\n"
"    ---\n"
"\n"
"The two dictionaries will always have the same keys, just different values."

msgid "pages.DictionaryKeysAndValues.steps.final_text.text"
msgstr ""
"Congratulations! You've reached the end of the course so far. More is on the"
" way!"

msgid "pages.DictionaryKeysAndValues.steps.introducing_keys.requirements"
msgstr "Run `print(quantities.keys())` where `quantities` is a dictionary."

msgid "pages.DictionaryKeysAndValues.steps.introducing_keys.text"
msgstr ""
"Copy this code into the editor:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Then change `print(quantities)` to `print(quantities.keys())`, and run the whole program."

msgid "pages.DictionaryKeysAndValues.steps.keys_are_iterable.text"
msgstr ""
"The `.keys()` method of `dict` does basically what you'd expect. You can iterate over the value it returns\n"
"just like you'd iterate over a list:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.DictionaryKeysAndValues.steps.keys_are_iterable2.requirements"
msgstr ""
"Run the same code as the previous step, but without `.keys()`. after "
"`quantities`, so the middle line is `for key in quantities:`"

msgid "pages.DictionaryKeysAndValues.steps.keys_are_iterable2.text"
msgstr ""
"Actually, you don't even need `.keys()`. Iterating directly over a dictionary automatically iterates over its keys.\n"
"Sometimes it's nice to write `.keys()` to make your code more readable, but you don't have to.\n"
"Remove the `.keys()` and run the code again."

msgid "pages.DictionaryKeysAndValues.steps.nested_dictionaries.text"
msgstr ""
"Beautiful! There's a pattern emerging here. The two languages could be merged into one big nested dictionary:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.DictionaryKeysAndValues.title"
msgstr "Iterating over Dictionary Keys"

msgid "pages.EqualsVsIs.steps.final_text.text"
msgstr ""
"Teraz `list1 is list2` to `True`, ponieważ *jest tylko jedna lista*, i obie zmienne\n"
"`list1` i `list2` odnoszą się do tej samej listy. `list1.append(4)` dodaje do jednej listy\n"
"i wynik można zobaczyć zarówno w `print(list1)`, jak i w `print(list2)`, ponieważ obie linie\n"
"są teraz po prostu różnymi sposobami wypisywania tej samej listy.\n"
"\n"
"Polecam uruchomić obie wersje z Python Tutor, aby zobaczyć, jak wizualizuje on różnicę.\n"
"W drugim przypadku obie zmienne mają strzałki wskazujące na jeden obiekt listy.\n"
"\n"
"`list2 = list1` nie tworzy wiecznego połączenia między zmiennymi. Jeśli przypiszesz nową wartość\n"
"*którejkolwiek* z zmiennych, np. `list1 = [7, 8, 9]`, druga zmienna nie będzie miała wpływu\n"
"i nadal będzie wskazywać na pierwotną listę.\n"
"\n"
"Najprościej - przypisanie takie jak:\n"
"\n"
"    list2 = <wyrażenie>\n"
"\n"
"oznacza 'spraw, by zmienna `list2` odnosiła się do tego, do czego zewaluuje się `<wyrażenie>`'.\n"
"Wartość nie jest kopiowana, co pozwala na to, że obie zmienne mogą wskazywać na tę samą listę.\n"
"Ale jak już wcześniej nauczyliśmy się, `list2` nie pamięta `<wyrażenie>`, tylko wartość.\n"
"Zmienna nie wie o innych zmiennych.\n"
"\n"
"Możesz skopiować listę za pomocą metody `copy`:\n"
"\n"
"__code0__\n"
"\n"
"To spowoduje, że program znów będzie się zachowywał jak pierwsza wersja.\n"
"\n"
"Jeśli napotkasz taki rodzaj problemu i nadal będziesz mieć trudności z zrozumieniem tych spraw, przeczytaj esej [Fakty i mity na temat nazw i wartości w Pythonie](https://nedbatchelder.com/text/names.html)."

msgid "pages.EqualsVsIs.steps.same_list.requirements"
msgstr ""
"Uruchom ten sam program co powyżej, ale zastąp *drugie* `[1, 2, 3]` przez "
"`list1`."

msgid "pages.EqualsVsIs.steps.same_list.text"
msgstr ""
"Ten program jest dość prosty i w większości składa się z rzeczy, które już znasz.\n"
"Tworzymy dwie zmienne, które odnoszą się do list.\n"
"Listy mają te same elementy, więc są one równe: `list1 == list2` to `True`.\n"
"\n"
"Ale jest tu nowy operator porównania: `is`. Tutaj `list1 is list2` to `False`.\n"
"Oznacza to, że mimo że dwie listy są równe,\n"
"są to nadal dwie oddzielne, odrębne, indywidualne listy.\n"
"W rezultacie, gdy dodajesz 4 do `list1`, zmienia się tylko `list1`.\n"
"\n"
"Teraz zmień `list2 = [1, 2, 3]` na `list2 = list1` i zobacz, jakie to robi różnice."

msgid "pages.EqualsVsIs.steps.two_separate_lists.text"
msgstr ""
"Nadszedł czas, aby nauczyć się niektórych szczegółów technicznych, które są często źle rozumiane i prowadzą do błędów.\n"
"Uruchom ten program:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.EqualsVsIs.title"
msgstr "`==` vs `is` i posiadanie wielu nazw dla jednej wartości"

msgid "pages.FunctionsAndMethodsForLists.steps.append_vs_concatenate.text"
msgstr ""
"Przyjrzyjmy się, jak pracować z listami. Załóżmy, że mamy listę `nums = [1, 2, 3]`. Możemy użyć:\n"
"\n"
"- **`append`**: Dodaje element na końcu listy. `nums.append(4)` zmienia listę na `[1, 2, 3, 4]`.\n"
"- **`len`**: Zwraca liczbę elementów. `len(nums)` wynosi `3`.\n"
"- **`range`**: `range(n)` to obiekt podobny do listy liczb od `0` do `n - 1`. Oznacza to, że zawiera `n` liczb. W szczególności, `range(len(nums))` jest jak `[0, 1, 2]`, które są indeksami każdego elementu w `nums`.\n"
"- **`[]` (indeksowanie)**: Pobiera wartość o danym indeksie. `nums[0]` to `1`, `nums[1]` to `2`, `nums[2]` to `3`.\n"
"- **`+`**: Konkatenacja list. `nums + [4, 5]` to `[1, 2, 3, 4, 5]`.\n"
"\n"
"Zauważ, że `nums.append(4)` modyfikuje istniejącą listę `nums`, podczas gdy `nums + [4, 5]` tego nie robi.\n"
"Aby zachować wartość `nums + [4, 5]`, można ją przypisać do *nowej zmiennej*.\n"
"Uruchom następujący kod:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.FunctionsAndMethodsForLists.steps.final_text.text"
msgstr "Świetna robota!"

msgid "pages.FunctionsAndMethodsForLists.steps.index_predict_exercise.text"
msgstr ""
"**`index`**: Znajduje pierwszy element o podanej wartości w liście i zwraca jego indeks\n"
"\n"
"__code0__\n"
"\n"
"Jeżeli podanej wartości nie ma w liście, interpreter zwróci błąd. Uruchom poniższy kod w shellu:\n"
"\n"
"__program_indented__"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno mieć dokładnie trzy instrukcje: `x = ['a', 'b', "
"'c']`, `y = ` po której następuje jedna linia dokładnie skopiowana z listy, "
"oraz `print(y)`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.1.text"
msgstr "Które linie kodu tworzą nową listę zamiast modyfikować?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.2.text"
msgstr "`x` to lista. Każdy element `x` to łańcuch znaków."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.3.text"
msgstr ""
"Możesz dodawać listy do siebie, możesz dodawać łańcuchy znaków do siebie, "
"ale nie możesz dodawać łańcucha znaków do listy."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.4.text"
msgstr "Jak zrobić listę zawierającą jeden element?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.requirements"
msgstr ""
"Skopiuj trzy powyższe linie, a następnie zastąp "
"`(wstaw_jedną_linię_z_powyżej)` dokładnie jedną linią z długiej listy linii "
"wcześniejszych. Musisz wybrać poprawną linię, jest tylko jedna właściwa "
"odpowiedź. Wpisz linię dokładnie. Nie zastępuj części `y = `, powinna być "
"tam przed linią, którą wpiszesz, w tej samej linii."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.text"
msgstr ""
"Świetnie!\n"
"\n"
"Możesz zdać sobie sprawę, że praca z ostatnim elementem za pomocą `x[len(x) - 1]` jest nieco kłopotliwa.\n"
"To samo można osiągnąć przez `x[-1]`.\n"
"Podobnie, przedostatni element `x[len(x) - 2]` można zapisać jako `x[-2]`, i tak dalej.\n"
"Python pozwala nam także liczyć indeks do tyłu, zaczynając od ostatniego elementu z `-1`:\n"
"\n"
"| Indeks     | Pierwszy el. | Drugi el.   | Trzeci el.  | ... | Przedostatni el. | Ostatni el.  |\n"
"|-----------|---------------|--------------|--------------|-----|-------------------|---------------|\n"
"| Do przodu  | `0`           | `1`          | `2`          | ... | `len(x) - 2`      |`len(x) - 1`   |\n"
"| Do tyłu    | `-len(x)`     |`-len(x) + 1` |`-len(x) + 2` | ... | `-2`              |  `-1`         |\n"
"\n"
"Następne ćwiczenie:\n"
"\n"
"Tym razem, zamiast modyfikować listę `x`, utworzysz nową listę `y`:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"`y` powinno być takie samo jak `x`, ale powinno mieć też pierwszy element powtórzony na końcu.\n"
"Dlatego program wydrukuje `['a', 'b', 'c', 'a']`."

msgid "pages.FunctionsAndMethodsForLists.steps.pop_predict_exercise.text"
msgstr ""
"**`pop`**: Usuwa i zwraca element o danym *indeksie* używając składni\n"
"\n"
"__code0__\n"
"\n"
"Bez argumentu, tzn. po prostu `some_list.pop()`, usunie i zwróci ostatni element.\n"
"Powoduje błąd, jeśli `index` nie jest prawidłowym indeksem `some_list`. Na przykład uruchom ten program:\n"
"\n"
"__program_indented__"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno mieć dokładnie trzy instrukcje: `x = ['a', 'b', "
"'c']`, jedna linia dokładnie skopiowana z listy (bez dodatków), oraz "
"`print(x)`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.1.text"
msgstr "Przesunięcie pierwszego elementu na koniec wymaga dwóch rzeczy."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.2.text"
msgstr "Usunięcie pierwszego elementu..."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.3.text"
msgstr "i dodanie go na koniec."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.4.text"
msgstr "Które funkcje/metody możesz użyć do tego?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.5.text"
msgstr "Pamiętaj, że pierwszy indeks to 0."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.requirements"
msgstr ""
"Skopiuj trzy powyższe linie, a następnie zastąp "
"`(wstaw_jedną_linię_z_powyżej)` dokładnie jedną linią z długiej listy tuż "
"przed tym. Musisz wybrać poprawną linię, jest tylko jedna właściwa "
"odpowiedź. Wpisz linię dokładnie."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.text"
msgstr ""
"Teraz rozwiążesz cztery krótkie ćwiczenia związane z tymi pojęciami.\n"
"Poniżej znajduje się lista poprawnych i niepoprawnych linii kodu wymieszanych ze sobą.\n"
"Każde nadchodzące ćwiczenie ma rozwiązanie, które zawiera dokładnie jedną z poniższych linii,\n"
"a ty musisz znaleźć poprawną linię z listy.\n"
"\n"
"__code0__\n"
"\n"
"Oto niekompletny program:\n"
"\n"
"    __copyable__\n"
"__code1__\n"
"\n"
"Zastąp środkową linię jedną linią z powyższej listy. Ostateczny program powinien zmodyfikować `x` tak, aby przenieść pierwszy element na koniec, tak aby drukował `['b', 'c', 'a']`."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno mieć dokładnie trzy instrukcje: `x = [1, 2, 0, "
"3]`, jedna linia dokładnie skopiowana z listy (bez dodatków), oraz "
"`print(x)`."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.1.text"
msgstr "Co robi `x.remove(0)`?"

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.2.text"
msgstr "Usuwa element!"

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.3.text"
msgstr "Która funkcja/metoda może także usunąć element?"

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.4.text"
msgstr ""
"Inna funkcja/metoda nie może po prostu dostać informacji 'usuń 0', "
"potrzebuje innego rodzaju informacji."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.5.text"
msgstr "Dokładniej, musi wiedzieć, gdzie jest 0."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.6.text"
msgstr "Która funkcja/metoda dostarcza tego rodzaju informacji?"

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.requirements"
msgstr ""
"Skopiuj trzy powyższe linie, a następnie zastąp `x.remove(0)` dokładnie "
"jedną linią z długiej listy linii wcześniejszych. Linia, którą wybierzesz, "
"powinna mieć ten sam efekt co `x.remove(0)`, tak żeby program wydrukował "
"`[1, 2, 3]`."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.text"
msgstr ""
"Świetna robota. Teraz ostatnie ćwiczenie:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Zastąp środkową linię `x.remove(0)` jedną linią z listy, która robi to samo."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_predict_exercise.text"
msgstr ""
"**`remove`**: Usuwa pierwsze wystąpienie podanej *wartości* za pomocą składni\n"
"\n"
"__code0__\n"
"\n"
"Powoduje błąd, jeśli wartość nie znajduje się na liście. Na przykład uruchom ten program:\n"
"\n"
"__program_indented__"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno mieć dokładnie trzy instrukcje: `x = ['a', 'b', "
"'c']`, jedna linia dokładnie skopiowana z listy (bez dodatków), oraz "
"`print(x)`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.1.text"
msgstr "Musisz pobrać wartość pierwszego elementu w `x`..."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.2.text"
msgstr "i przypisać tę wartość do ostatniej pozycji w `x`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.3.text"
msgstr "Jak przypisujesz wartość na konkretnym indeksie na liście?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.4.text"
msgstr "Jakie są indeksy pierwszego i ostatniego elementu w `x`?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.requirements"
msgstr ""
"Skopiuj trzy powyższe linie, a następnie zastąp "
"`(wstaw_jedną_linię_z_powyżej)` dokładnie jedną linią z poprzedniej długiej "
"listy. Musisz wybrać poprawną linię, jest tylko jedna właściwa odpowiedź. "
"Wpisz linię dokładnie."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.text"
msgstr ""
"Dobra robota. W kolejnym ćwiczeniu, zacznij od tego samego niekompletnego programu:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Wybierz linię kodu z listy, która nadpisuje ostatni element `x` pierwszym elementem,\n"
"tak aby drukowało `['a', 'b', 'a']`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_predict.text"
msgstr ""
"Jak widać, `+` nie modyfikuje `nums`, ale `append` tak.\n"
"\n"
"Oto kilka nowych rzeczy.\n"
"\n"
"**`przypisanie wartości do elementu`**: Ustawia wartość o danym indeksie (zastępując wartość, która była tam wcześniej) za pomocą składni\n"
"\n"
"__code0__\n"
"\n"
"Jeśli `index` nie jest prawidłowym indeksem `some_list`, interpreter zwróci błąd. Na przykład uruchom ten program:\n"
"\n"
"__program_indented__"

msgid "pages.FunctionsAndMethodsForLists.title"
msgstr "Funkcje i metody dla list"

msgid "pages.GettingElementsAtPosition.steps.final_text.text"
msgstr ""
"Jeśli nadal nie czujesz się komfortowo z funkcją `range` i/lub `len`, poćwicz i eksperymentuj z nimi przez chwilę.\n"
"Oto kilka prostych ćwiczeń, które możesz spróbować wykonać samodzielnie, jeśli chcesz.\n"
"\n"
"- Wypisz liczby od `1` do `100` włącznie.\n"
"- Wypisz swoje imię 100 razy.\n"
"- Wypisz każde słowo z listy `words` oprócz ostatniego.\n"
"- Wypisz każde słowo z `words` w odwrotnej kolejności, czyli wypisz ostatnie słowo, potem przedostatnie słowo itp.\n"
"- Powróć do bonusowego problemu na końcu strony [Wprowadzenie do List](#IntroducingLists),\n"
"niezależnie od tego, czy go rozwiązałeś. Jest teraz znacznie łatwiejsze z `range` i `len`!\n"
"\n"
"Gdy będziesz gotowy, kontynuuj na następną stronę, gdzie czeka na ciebie coś trochę bardziej wymagającego."

msgid "pages.GettingElementsAtPosition.steps.index_error.program"
msgstr "words[4]"

msgid "pages.GettingElementsAtPosition.steps.index_error.requirements"
msgstr "Uruchom coś takiego jak `words[3]`, ale zastąp `3` większą liczbą."

msgid "pages.GettingElementsAtPosition.steps.index_error.text"
msgstr ""
"Ogólnie rzecz biorąc, możesz pobrać element na miejscu `i` używając `words[i]`. Operacja ta nazywa się *indeksowanie*, a miejsce to *indeks*.\n"
"\n"
"Prawdopodobnie zauważyłeś, że pierwszy indeks to 0, a nie 1. W programowaniu liczenie zaczyna się od 0. To wydaje się dziwne, ale tak właśnie działa większość języków programowania i ogólnie uznaje się to za lepsze.\n"
"\n"
"To również oznacza, że ostatni indeks w tej liście 4 elementów to 3. Co się stanie, jeśli spróbujesz uzyskać indeks większy niż ten?"

msgid "pages.GettingElementsAtPosition.steps.indices_out_of_bounds.text"
msgstr "Teraz spróbuj `__program__` w konsoli."

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.0"
msgstr ""
"This\n"
"is\n"
"a\n"
"list"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.2"
msgstr ""
"0\n"
"This\n"
"1\n"
"is\n"
"2\n"
"a\n"
"3\n"
"list"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.3"
msgstr ""
"This\n"
"0\n"
"is\n"
"1\n"
"a\n"
"2\n"
"list\n"
"3"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.4"
msgstr ""
"0\n"
"1\n"
"2\n"
"3\n"
"This\n"
"is\n"
"a\n"
"list"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.5"
msgstr ""
"This\n"
"is\n"
"a\n"
"list\n"
"0\n"
"1\n"
"2\n"
"3"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"indices = [0, 1, 2, 3]\n"
"\n"
"for index in indices:\n"
"    print(index)\n"
"    print(words[index])"

msgid "pages.GettingElementsAtPosition.steps.introducing_len_and_range.text"
msgstr ""
"I oto jest. `words[4]` oraz reszta nie istnieje, więc próba ich uzyskania skończy się błędem.\n"
"Ten pierwszy program jest trochę powtarzalny. Ulepszmy go za pomocą listy i pętli!\n"
"\n"
"__program_indented__"

msgid "pages.GettingElementsAtPosition.steps.introducing_subscripting.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"\n"
"print(words[0])\n"
"print(words[1])\n"
"print(words[2])\n"
"print(words[3])"

msgid "pages.GettingElementsAtPosition.steps.introducing_subscripting.text"
msgstr ""
"Pętla jest świetna, ale często chcesz po prostu pobrać pojedynczy element z listy na znanym miejscu.\n"
"Oto jak:\n"
"\n"
"__program_indented__"

msgid ""
"pages.GettingElementsAtPosition.steps.print_indices_and_words.hints.0.text"
msgstr "Pamiętaj, że wcześniej użyliśmy `range(4)`."

msgid ""
"pages.GettingElementsAtPosition.steps.print_indices_and_words.hints.1.text"
msgstr ""
"Tym razem powinno to działać dla dowolnej listy. Co jeśli lista ma 5 "
"elementów albo 10?"

msgid ""
"pages.GettingElementsAtPosition.steps.print_indices_and_words.hints.2.text"
msgstr "Połącz dwie funkcje, których się nauczyłeś!"

msgid "pages.GettingElementsAtPosition.steps.print_indices_and_words.text"
msgstr ""
"Zatem ogólnie rzecz biorąc, prawidłowe indeksy to:\n"
"\n"
"__code0__\n"
"\n"
"Teraz możemy naprawić program z wcześniej tak, aby działał z dowolną listą. Uzupełnij `...`:\n"
"\n"
"    __copyable__\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"\n"
"    for index in ...:\n"
"        print(index)\n"
"        print(words[index])\n"
"\n"
"Dla podanej wartości przykładowej `words` program powinien wypisać:\n"
"\n"
"    0\n"
"    This\n"
"    1\n"
"    is\n"
"    2\n"
"    a\n"
"    3\n"
"    list"

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.0.text"
msgstr ""
"Aby uzyskać dostęp do ostatniego elementu listy, potrzebujesz indeksu "
"ostatniej pozycji."

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.1.text"
msgstr ""
"Jeśli lista ma 2 elementy, pierwszy element znajduje się na indeksie 0, więc"
" ostatni element jest na indeksie 1."

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.2.text"
msgstr ""
"Podobnie, gdyby lista miała 3 elementy, ostatni element byłby na indeksie 2."

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.3.text"
msgstr "Czy widzisz wzór pomiędzy tymi numerami? Jak możesz to wyrazić?"

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.4.text"
msgstr ""
"Czy potrafisz wymyślić ogólne rozwiązanie, które działa na każdym rozmiarze?"

msgid "pages.GettingElementsAtPosition.steps.print_last_element.text"
msgstr ""
"Ćwiczenie: dla dowolnej niepustej listy `words`, wydrukuj ostatni element. Na przykład, jeśli\n"
"\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"\n"
"twój program powinien wydrukować `list`."

msgid ""
"pages.GettingElementsAtPosition.steps.printing_the_range.output_prediction_choices.4"
msgstr ""
"This\n"
"is\n"
"a\n"
"list"

msgid "pages.GettingElementsAtPosition.steps.printing_the_range.text"
msgstr ""
"Jak widzisz, wynik jest taki sam. Spróbuj tego:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.GettingElementsAtPosition.steps.range_almost_the_same_as_list.text"
msgstr ""
"`range(4)` to to samo, co `[0, 1, 2, 3]` ... prawie. Spróbuj `__program__` w"
" konsoli."

msgid "pages.GettingElementsAtPosition.steps.range_len.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"indices = range(4)\n"
"\n"
"for index in indices:\n"
"    print(index)\n"
"    print(words[index])"

msgid "pages.GettingElementsAtPosition.steps.range_len.requirements"
msgstr ""
"Uruchom ten sam program z poprzedniego kroku, ale zamień drugą linię "
"`indices = [0, 1, 2, 3]` na `indices = range(4)`."

msgid "pages.GettingElementsAtPosition.steps.range_len.text"
msgstr ""
"To wygląda nieco lepiej, ale wypisywanie `[0, 1, 2, ...]` to nie jest najlepsze rozwiązanie, szczególnie, gdy lista jest długa.\n"
"Istnieje przydatna funkcja `range`, która zrobi to za ciebie. Zamień `[0, 1, 2, 3]` na `range(4)`,\n"
"czyli `indices = range(4)`."

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.0"
msgstr "range(4)"

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.1"
msgstr "range(0, 4)"

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.2"
msgstr "list(range(4))"

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.3"
msgstr "list(range(0, 4))"

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.4"
msgstr "range(0, 1, 2, 3)"

msgid "pages.GettingElementsAtPosition.steps.range_versus_list.text"
msgstr ""
"To jest może być zaskakujące. Jeśli jesteś ciekawy, `0` reprezentuje początek zakresu.\n"
"`0` to domyślny początek, więc `range(4)` jest równy `range(0, 4)`.\n"
"`4` to koniec zakresu, ale koniec jest zawsze wykluczony, więc ostatnia wartość to `3`.\n"
"Jeśli teraz jesteś zdezorientowany, nie martw się.\n"
"\n"
"Istnieje dobry powód, dla którego `range(4)` nie jest właściwie listą - sprawia, że programy działają szybciej i są bardziej wydajne.\n"
"W tej chwili nie warto tego bardziej wyjaśniać.\n"
"\n"
"Ale łatwo możesz to przekonwertować na listę: spróbuj `__program__` w konsoli."

msgid "pages.GettingElementsAtPosition.steps.using_len_first_time.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"print(len(words))"

msgid "pages.GettingElementsAtPosition.steps.using_len_first_time.text"
msgstr ""
"To tylko demonstracja, żebyś mógł zobaczyć zakres w bardziej znajomej formie.\n"
"Nigdy właściwie nie powinieneś tego robić.\n"
"\n"
"Jeśli czujesz się przytłoczony, nie martw się! Wszystko, co musisz wiedzieć, to że `range(n)`\n"
"jest bardzo podobne do listy:\n"
"\n"
"__code0__\n"
"\n"
"Tak przy okazji, możesz uzyskać liczbę elementów listy (często nazywaną *długością*) używając funkcji `len`.\n"
"Spróbuj to, uruchamiając ten kod:\n"
"\n"
"    __copyable__\n"
"__code1__"

msgid "pages.GettingElementsAtPosition.title"
msgstr "Pobieranie elementów, `range()`, i `len()`"

msgid "pages.GettingElementsAtPositionExercises.steps.final_text.text"
msgstr "Fantastycznie! Zrób sobie przerwę, zasłużyłeś na to!"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.0.text"
msgstr ""
"Będziesz musiał spojrzeć na wszystkie możliwe indeksy `things` i sprawdzić, "
"który z nich jest odpowiedzią."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.1.text"
msgstr ""
"Aby przejrzeć wszystkie możliwe indeksy, będziesz potrzebował pętli po "
"`range(len(things))`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.2.text"
msgstr "Aby sprawdzić, czy indeks jest odpowiedzią, będziesz musiał użyć:"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.3.text"
msgstr "- `if`"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.4.text"
msgstr "- indeksu w subskrypcie"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.5.text"
msgstr "- `==`"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.6.text"
msgstr ""
"Ponieważ szukasz pierwszego indeksu, musisz zatrzymać pętlę, gdy go "
"znajdziesz."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.7.text"
msgstr "Niedawno nauczyłeś się, jak zatrzymać pętlę w połowie."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.8.text"
msgstr "Potrzebujesz użyć `break`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.messages.all_indices.text"
msgstr ""
"Jesteś prawie na miejscu! Jednak to drukuje wszystkie indeksy,\n"
" nie tylko pierwszy."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.messages.last_index.text"
msgstr ""
"Jesteś prawie na miejscu! Jednak to drukuje *ostatni* indeks,\n"
" nie pierwszy."

msgid "pages.GettingElementsAtPositionExercises.steps.index_exercise.text"
msgstr ""
"Zakładając, że masz listę `things` oraz wartość `to_find`,\n"
"wydrukuj pierwszy indeks `to_find` na liście, tzn. najmniejszą liczbę `i` taką, że\n"
"`things[i]` jest `to_find`. Na przykład, dla\n"
"\n"
"    __no_auto_translate__\n"
"    things = ['on', 'the', 'way', 'to', 'the', 'store']\n"
"    to_find = 'the'\n"
"\n"
"twój program powinien wydrukować `1`.\n"
"\n"
"Możesz założyć, że `to_find` pojawia się przynajmniej raz."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.0.text"
msgstr ""
"Czy eksperymentowałeś z indeksowaniem i `len()` ze stringami w shellu?"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.1.text"
msgstr ""
"Na moment zapomnij o pętlach. Jak byś wydrukował tylko pierwszą linię, która"
" zawiera pierwszy znak każdego z dwóch stringów?"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.2.text"
msgstr ""
"W drugiej linii chcesz wydrukować drugi znak każdego stringa, i tak dalej."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.3.text"
msgstr "Będziesz potrzebować pętli `for`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.4.text"
msgstr "Będziesz potrzebować indeksowania (subskrypcji)."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.5.text"
msgstr "Będziesz potrzebować `range`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.6.text"
msgstr "Będziesz potrzebować `len`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.7.text"
msgstr "Będziesz potrzebować `+`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.8.text"
msgstr "Będziesz musiał zindeksować oba stringi."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.9.text"
msgstr ""
"Będziesz musiał przekazać ten sam indeks do obu stringów za każdym razem, "
"aby pobierać odpowiadające sobie znaki."

msgid "pages.GettingElementsAtPositionExercises.steps.zip_exercise.text"
msgstr ""
"Świetnie!\n"
"\n"
"Tak na marginesie, indeksowanie i `len()` również działają na stringach. Wypróbuj je w shellu.\n"
"\n"
"Oto kolejne ćwiczenie. Mając dwa stringi o równych długościach, np:\n"
"\n"
"    __no_auto_translate__\n"
"    string1 = 'Hello'\n"
"    string2 = 'World'\n"
"\n"
"wydrukuj je pionowo, obok siebie, z odstępem między każdą parą znaków:\n"
"\n"
"    H W\n"
"    e o\n"
"    l r\n"
"    l l\n"
"    o d"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.0.text"
msgstr ""
"Rozwiązanie ma tę samą ogólną strukturę i kluczowe elementy co poprzednie "
"rozwiązanie, jednak jest znacznie dłuższe i będzie wymagać kilku dodatkowych"
" pomysłów i części."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.1.text"
msgstr ""
"W szczególności powinno nadal zawierać coś w stylu:\n"
"\n"
"__code0__"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.2.text"
msgstr ""
"Co powinno się znaleźć w `range()`? Ani `len(string1)`, ani `len(string2)` "
"nie są wystarczająco dobre."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.3.text"
msgstr "Chcesz iteracji pętli dla każdego znaku w dłuższym stringu."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.4.text"
msgstr "To oznacza, że potrzebujesz `range(<długość najdłuższego stringu>)`"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.5.text"
msgstr ""
"Innymi słowy, potrzebujesz znaleźć większą z dwóch wartości `len(string1)` i"
" `len(string2)`. Już wykonałeś podobne ćwiczenie."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.6.text"
msgstr ""
"Kiedy już rozwiążesz kwestię pętli `for i in range(...)`, `i` czasami będzie"
" za duże, żeby było ważnym indeksem dla obu stringów. Będziesz musiał "
"sprawdzić, czy nie jest za duże przed indeksowaniem."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.7.text"
msgstr ""
"Pamiętaj, że największy ważny indeks dla `string1` to `len(string1) - 1`. "
"`len(string1)` jest za duże."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.8.text"
msgstr ""
"Będziesz potrzebować dwóch instrukcji `if`, jednej dla każdego stringu."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.9.text"
msgstr ""
"Będziesz musiał ustawić np. `char1 = ' '` gdy `string1[i]` nie jest ważny."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.text"
msgstr ""
"Niesamowite!\n"
"\n"
"Twoje rozwiązanie prawdopodobnie wyglądało mniej więcej tak:\n"
"\n"
"__code0__\n"
"\n"
"To nie działa zbyt dobrze, jeśli stringi mają różne długości.\n"
"W rzeczywistości, błędy pojawiają się na różne sposoby w zależności od tego, czy `string1` czy `string2` jest dłuższy.\n"
"Twoje kolejne wyzwanie polega na rozwiązaniu tego problemu poprzez wypełnienie 'brakujących' znaków spacjami.\n"
"\n"
"Na przykład, dla:\n"
"\n"
"    __no_auto_translate__\n"
"    string1 = 'Goodbye'\n"
"    string2 = 'World'\n"
"\n"
"wypisz:\n"
"\n"
"    G W\n"
"    o o\n"
"    o r\n"
"    d l\n"
"    b d\n"
"    y\n"
"    e\n"
"\n"
"i dla:\n"
"\n"
"    __no_auto_translate__\n"
"    string1 = 'Hello'\n"
"    string2 = 'Elizabeth'\n"
"\n"
"wypisz:\n"
"\n"
"    H E\n"
"    e l\n"
"    l i\n"
"    l z\n"
"    o a\n"
"      b\n"
"      e\n"
"      t\n"
"      h"

msgid "pages.GettingElementsAtPositionExercises.title"
msgstr "Ćwiczenia z `range()` i `len()`"

msgid "pages.HowToFindInformationWithGoogleAndMore.steps.dir_list.text"
msgstr ""
"Świetnie!\n"
"\n"
"Może być również przydatne wyszukiwanie takich rzeczy jak \"python list tutorial\", na przykład gdy:\n"
"\n"
"- Wyszukiwanie konkretnej metody się nie powiodło i chcesz ją znaleźć ręcznie.\n"
"- Nadal masz wątpliwości dotyczące list po tym kursie.\n"
"- Minęło trochę czasu odkąd uczyłeś się o listach i potrzebujesz przypomnienia.\n"
"- Zmagasz się z rozwiązaniem problemu z listami i musisz wrócić do podstaw i wzmocnić swoje podstawy.\n"
"\n"
"Są również sposoby na znalezienie informacji bez googlowania. Spróbuj `__program__` w konsoli."

msgid "pages.HowToFindInformationWithGoogleAndMore.steps.final_text.text"
msgstr ""
"`dir()` zwraca listę atrybutów argumentu, które są przeważnie metodami. "
"Wiele z nich zaczyna się od `__` , które na razie możesz zignorować - "
"przewiń do końca listy, a zobaczysz kilka znajomych metod."

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.hints.0.text"
msgstr "Użyj słów 'python' i 'lista' w zapytaniu wyszukiwania."

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.hints.1.text"
msgstr ""
"Zamiast umieszczać wartość na początku lub na końcu, chcemy ją umieścić "
"____________?"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.hints.2.text"
msgstr "'w środku' lub 'na indeksie' lub 'w określonej pozycji'"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.hints.3.text"
msgstr "'python dodaj wartość na indeksie'"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.requirements"
msgstr ""
"Uruchom kod podobny do trzech powyższych linii, ale zmień `nums.append(9)` na odpowiednie wywołanie funkcji/metody,\n"
"aby umieścić 9 zaraz po drugim elemencie (2 w przykładzie `nums = [1, 2, 3, 4, 5]`) zamiast na końcu.\n"
"Istnieje tylko jedna poprawna odpowiedź na to, co powinna być środkowa linia.\n"
"Musisz przeszukać internet, aby dowiedzieć się, jakiej funkcji/metody użyć i jak jej używać."

msgid "pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.text"
msgstr ""
"Dobrze ci poszło! Zróbmy jeszcze jedno zadanie. Rozważ ten program:\n"
"\n"
"__code0__\n"
"\n"
"To zmieni `nums`, tak że wypisze:\n"
"\n"
"__code1__\n"
"\n"
"Ale załóżmy, że nie chcesz, aby 9 było na końcu, chcesz by znalazła się między drugim a trzecim elementem, aby wynik był:\n"
"\n"
"__code2__\n"
"\n"
"Zastąp środkową linię `nums.append(9)` odpowiednim wywołaniem funkcji/metody, aby to osiągnąć."

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.hints.0.text"
msgstr "Użyj słów 'python' i 'lista' w zapytaniu wyszukiwania."

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.hints.1.text"
msgstr ""
"Jednym słowem, co jest szczególnego w `91` na liście `[21, 55, 4, 91, 62, "
"49]`?"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.hints.2.text"
msgstr "'największy' lub 'największa'"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.hints.3.text"
msgstr "'python największa wartość na liście'"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.requirements"
msgstr ""
"Uruchom kod podobny do `sum([21, 55, 4, 91, 62, 49])`, ale zastąp `sum` nazwą innej konkretnej funkcji.\n"
"Istnieje tylko jedna poprawna odpowiedź na to, jaka funkcja powinna zostać użyta. Musisz przeszukać internet,\n"
"aby dowiedzieć się, której użyć. Jest to powszechnie używana wbudowana funkcja w Pythonie."

msgid "pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.text"
msgstr ""
"Przydatne jest znać funkcje, które właśnie omówiliśmy, ale nie jest łatwo je wszystkie zapamiętać, a jest ich jeszcze więcej. Ważniejszą umiejętnością jest potrafić wyszukać informacje. Na przykład, oto kilka typowych sposobów jak byś mógł wyszukać wyżej wymienione funkcje w Google, jeśli zapomniałeś ich nazw:\n"
"\n"
"- `append`\n"
"    - python dodaj element do listy\n"
"    - python dodaj element na końcu listy\n"
"- `len`\n"
"    - python rozmiar listy\n"
"    - python liczba elementów na liście\n"
"    - python ile znaków w ciągu\n"
"- `sum`\n"
"    - python dodaj listę liczb\n"
"    - python suma liczb\n"
"- `in`\n"
"    - python sprawdź czy lista zawiera wartość\n"
"    - python sprawdź czy lista ma element\n"
"- `index`\n"
"    - python znajdź pozycję elementu\n"
"    - python uzyskaj indeks wartości\n"
"\n"
"Ćwiczymy teraz tę umiejętność. Znajdź funkcję/metodę, która zwraca wartość na liście, która jest większa niż jakakolwiek inna wartość. Na przykład, podana lista `[21, 55, 4, 91, 62, 49]`, powinna zwrócić `91`. Powinieneś napisać odpowiedź w konsoli jako pojedyncze, małe wyrażenie. Na przykład, jeśli szukałbyś funkcji `sum`, moglibyśmy napisać `sum([21, 55, 4, 91, 62, 49])`. Nie rozwiązuj tego ręcznie za pomocą pętli. Zauważ, że funkcja, której szukasz, nie była wcześniej tutaj wspomniana."

msgid "pages.HowToFindInformationWithGoogleAndMore.title"
msgstr "Jak szukać informacji z pomocą Google, i nie tylko"

msgid "pages.IfAndElse.steps.capitalise.hints.0.text"
msgstr ""
"Nauczyłeś się wszystkich narzędzi, których potrzebujesz. Wierzę w Ciebie! "
"Szukaj inspiracji w poprzednich programach."

msgid "pages.IfAndElse.steps.capitalise.hints.1.text"
msgstr "Będziesz potrzebować pętli, aby zbudować nowe zdanie znak po znaku."

msgid "pages.IfAndElse.steps.capitalise.hints.2.text"
msgstr ""
"Będziesz potrzebował `if/else`, aby zdecydować, czy dodać wielką literę, czy"
" małą."

msgid "pages.IfAndElse.steps.capitalise.hints.3.text"
msgstr ""
"Twoje `if/else` musi wykonać różne bloki kodu w zależności od iteracji "
"pętli, w której się znajduje."

msgid "pages.IfAndElse.steps.capitalise.hints.4.text"
msgstr ""
"To oznacza, że warunek Twojego `if` musi być zmienną, która zmienia się "
"wewnątrz pętli."

msgid "pages.IfAndElse.steps.capitalise.hints.5.text"
msgstr ""
"W pierwszej iteracji potrzebujesz wielkiej litery. W kolejnych iteracjach "
"potrzebujesz małej litery."

msgid "pages.IfAndElse.steps.capitalise.text"
msgstr ""
"Czas na wyzwanie!\n"
"\n"
"Napisz program, który, mając dany ciąg `sentence`, wydrukuje zmodyfikowaną wersję z\n"
"tymi samymi literami, gdzie pierwsza litera jest wielka, a reszta małe.\n"
"Na przykład, wynik powinien być `Hello world`, niezależnie czy wejście `sentence = 'hello world'`\n"
"czy `'HELLO WORLD'`."

msgid "pages.IfAndElse.steps.else_full_stop.hints.0.text"
msgstr ""
"Nie zmieniaj niczego, co jest już tam, dodaj tylko trochę więcej kodu."

msgid "pages.IfAndElse.steps.else_full_stop.hints.1.text"
msgstr ""
"`else` musi znajdować się bezpośrednio po ciele `if`, z niczym pomiędzy."

msgid "pages.IfAndElse.steps.else_full_stop.hints.2.text"
msgstr ""
"`sentence += char` musi zostać wykonane zarówno, gdy `excited` jest `True`, "
"jak i `False`."

msgid "pages.IfAndElse.steps.else_full_stop.hints.3.text"
msgstr ""
"Mógłbyś mieć kopię `sentence += char` zarówno w bloku `if`, jak i `else`, "
"ale jest lepszy sposób."

msgid "pages.IfAndElse.steps.else_full_stop.hints.4.text"
msgstr "Użyj `else`, aby przypisać inną wartość dla `char`."

msgid "pages.IfAndElse.steps.else_full_stop.hints.5.text"
msgstr ""
"Jeśli `excited` jest `False`, wtedy `char` powinien być `'.'` zamiast `'!'`."

msgid "pages.IfAndElse.steps.else_full_stop.text"
msgstr ""
"Jeśli `excited` ma wartość prawda, to `char` zostało zdefiniowane i wszystko działa poprawnie. W przeciwnym razie\n"
"`char` nigdy nie zostaje przypisane wartość, więc próba użycia go w `sentence += char` kończy się niepowodzeniem.\n"
"\n"
"Napraw to, dodając klauzulę `else` do `if`, tak aby jeśłi `excited` jest nieprawdziwe, kropka (`.`)\n"
"została dodana na końcu zdania zamiast wykrzyknika (`!`)."

msgid "pages.IfAndElse.steps.final_text.text"
msgstr ""
"Doskonale! Zatrzymaj się na chwilę i ciesz się z tego, co osiągnąłeś. Czy "
"czujesz, że Twój mózg rośnie?"

msgid "pages.IfAndElse.steps.first_if_else.text"
msgstr ""
"Instrukcja `if` może opcjonalnie mieć część `else`. Uruchom ten przykład:\n"
"\n"
"__program_indented__"

msgid "pages.IfAndElse.steps.first_if_else_false.requirements"
msgstr ""
"Uruchom ten sam program z poprzedniego kroku, ale zastąp `True` na `False`, "
"więc `condition = False`."

msgid "pages.IfAndElse.steps.first_if_else_false.text"
msgstr ""
"Teraz zmień pierwszą linię na `condition = False` i uruchom to ponownie."

msgid "pages.IfAndElse.steps.if_upper_else_lower.text"
msgstr ""
"Pomyśl o `else` jako o sformułowaniu 'w przeciwnym razie'. Oznacza to, że jeśli warunek w `if` jest fałszywy, to zostanie wykonany kod w `else`. Bez względu na to, czy warunek jest prawdziwy czy fałszywy, dokładnie jeden z dwóch bloków zostanie wykonany.\n"
"\n"
"Oto bardziej interesujący przykład do uruchomienia:\n"
"\n"
"__program_indented__"

msgid "pages.IfAndElse.steps.if_upper_else_lower_false.requirements"
msgstr ""
"Uruchom ten sam program z poprzedniego kroku, ale zastąp `True` na `False`, "
"więc `excited = False`."

msgid "pages.IfAndElse.steps.if_upper_else_lower_false.text"
msgstr ""
"`sentence.upper()` to nowy rodzaj wyrażenia, z którym się jeszcze nie spotkaliśmy. Chodzi o to, że `sentence` to ciąg znaków i ciągi znaków mają różne *metody*, które pozwalają wygodnie obliczać nowe wartości, w tym `upper` i `lower`. Nazwy odnoszą się do wielkich liter (uppercase) i małych liter (lowercase). `'Hello World'.upper()` zwraca `'HELLO WORLD'`. Nie zmienia to jednak zawartości `sentence`, więc musisz przypisać nową wartość ponownie za pomocą `sentence = sentence.upper()`.\n"
"\n"
"Teraz zmień `excited` na `False` i uruchom to ponownie."

msgid "pages.IfAndElse.steps.spongebob.hints.0.text"
msgstr ""
"To podobne do poprzedniego ćwiczenia. Różnica polega na tym, kiedy i gdzie "
"ustawiasz zmienną warunkową."

msgid "pages.IfAndElse.steps.spongebob.hints.1.text"
msgstr ""
"Będziesz potrzebować zmiennej typu boolean, która zmienia się z każdą "
"iteracją."

msgid "pages.IfAndElse.steps.spongebob.hints.2.text"
msgstr ""
"Najpierw napisz mały program, który bierze zmienną typu boolean i odwraca "
"ją, np. jeśli zmienna jest `True`, staje się `False` i odwrotnie, jeśli "
"zaczyna sie od `False`, zmienia się na `True`. Bez pętli, tylko z `if/else`."

msgid "pages.IfAndElse.steps.spongebob.hints.3.text"
msgstr ""
"Będziesz musiał użyć tej zmiennej w warunku `if` oraz przypisać do tej samej"
" zmiennej w ciele."

msgid "pages.IfAndElse.steps.spongebob.hints.4.text"
msgstr ""
"Połącz to odwracające `if/else` z tym, które wybiera wielką lub małą literę."

msgid "pages.IfAndElse.steps.spongebob.text"
msgstr ""
"Wspaniale!!!\n"
"\n"
"Jeszcze jedno ćwiczenie, a potem możesz się zrelaksować.\n"
"\n"
"Napisz program, który wypisuje `sentence` w sposób kpiący, np.:\n"
"\n"
"    OnE MoRe eXeRcIsE, aNd tHeN YoU CaN ReLaX.\n"
"\n"
"Co drugi znak powinien być małą literą, reszta wielkimi literami."

msgid "pages.IfAndElse.steps.undefined_char.output_prediction_choices.0"
msgstr "Hello World"

msgid "pages.IfAndElse.steps.undefined_char.output_prediction_choices.1"
msgstr "Hello World!"

msgid "pages.IfAndElse.steps.undefined_char.requirements"
msgstr ""
"Skopiuj program powyżej. Uruchom go tak, jak jest jeśli chcesz. Następnie "
"zmień `excited = True` na `excited = False` i uruchom to ponownie."

msgid "pages.IfAndElse.steps.undefined_char.text"
msgstr ""
"Oto zepsuty program:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Czy widzisz problem? Jeśli uruchomisz ten kod, wszystko wydaje się być w porządku. Co może pójść nie tak?\n"
"\n"
"Odpowiedzi poniżej! Czy już to rozgryzłeś?\n"
"\n"
"Co się dzieje, jeśli zmienisz `excited` na `False`?"

msgid "pages.IfAndElse.title"
msgstr "`if` i `else`"

msgid "pages.Indentation.steps.final_text.text"
msgstr ""
"Kiedy używasz wcięć, powinieneś zawsze wciąć o 4 spacje. Wprawdzie każde "
"spójne wcięcie jest akceptowalne, ale 4 spacje to konwencja, której "
"przestrzega prawie każdy. Zauważ, że edytor na ogół ci to ułatwia. "
"Na przykład, jeśli naciśniesz klawisz 'Tab' na klawiaturze w edytorze, "
"zostaną wstawione 4 spacje."

msgid "pages.Indentation.steps.mismatched_indentations.program"
msgstr ""
"for character in name:\n"
"    print(character)\n"
"  print('---')"

msgid "pages.Indentation.steps.mismatched_indentations.text"
msgstr ""
"Ponieważ `print('---')` nie jest wcięte, nie jest częścią ciała pętli. Oznacza to, że jest wykonywane tylko raz, po zakończeniu całej pętli. Obydwa programy są poprawne, po prostu robią różne rzeczy.\n"
"\n"
"Poniższy program jest niepoprawny. Obie linie w ciele pętli są wcięte, ale o różnych ilościach. Pierwsza linia zaczyna się od 4 spacji, druga linia zaczyna się od 2. Spróbuj go uruchomić.\n"
"\n"
"__program_indented__"

msgid "pages.Indentation.steps.missing_indentation.program"
msgstr ""
"for character in name:\n"
"print(character)"

msgid "pages.Indentation.steps.missing_indentation.text"
msgstr ""
"Ta pętla przykładowa:\n"
"\n"
"__code0__\n"
"\n"
"działa, ale zazwyczaj jest (i powinna) być napisana tak:\n"
"\n"
"__code1__\n"
"\n"
"Konkretnie, kod do powtórzenia (znany jako *ciało*) zaczyna się w nowej linii po dwukropku (`:`), i musi być *wcięty*, tzn. mieć kilka spacji przed nim. Kod poniżej bez wcięcia jest nieprawidłowy, uruchom go, aby przekonać się sam:\n"
"\n"
"__program_indented__"

msgid "pages.Indentation.steps.one_indented_line.text"
msgstr ""
"Są dwie linie z wcięciem, więc obie są częścią ciała, więc `---` zostanie wydrukowane po każdym znaku. Teraz spróbuj uruchomić ten sam kod bez wcięcia w ostatniej linii:\n"
"\n"
"__code0__"

msgid "pages.Indentation.steps.two_indented_lines.text"
msgstr ""
"Spacje są wymagane, aby powiedzieć Pythonowi, które linie kodu należą do ciała pętli for. Jest to kluczowe, kiedy pętla zawiera kilka linii, co często ma miejsce. Na przykład, uruchom ten kod:\n"
"\n"
"__code0__"

msgid "pages.Indentation.title"
msgstr "Wcięcia"

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.0.text"
msgstr "`input()` always returns a string."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.1.text"
msgstr "A string that looks like a number is still a string, not a number."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.2.text"
msgstr "In `super_secret_number = 7`, `7` is a number, not a string."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.3.text"
msgstr "That makes `super_secret_number` also a number."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.4.text"
msgstr "A string cannot equal a number."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.5.text"
msgstr ""
"To check that two values are equal, make sure they're the same type first."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.6.text"
msgstr ""
"So to compare a number and a string, first convert the number to a string or"
" convert the string to a number."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.7.text"
msgstr ""
"You learned how to convert between strings and numbers in the previous page."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.8.text"
msgstr ""
"Use `int()` to convert to an integer (whole number) or `str()` to convert to"
" a string."

msgid "pages.InteractiveProgramsWithInput.steps.convert_input_to_int.text"
msgstr ""
"Whatever you typed in (not including pressing Enter at the end) is returned from the `input()` function as a string.\n"
"\n"
"It's essential to understand that `input()` ***always returns a string***, no matter what the user typed in.\n"
"It's up to you to convert that string to the type you need.\n"
"Forgetting this detail is a common source of confusing bugs.\n"
"\n"
"For example, this program looks fine at a glance, but if you try it out you'll see that it doesn't actually work:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Fix the program so that when the user inputs the value of `super_secret_number` (`7` in this example)\n"
"the program prints `Amazing! Are you psychic?` as expected.\n"
"It should work when `super_secret_number` is any whole number (`int`)."

msgid "pages.InteractiveProgramsWithInput.steps.final_text.text"
msgstr ""
"Perfect!\n"
"\n"
"There's two main fixes that would work here. You can convert the input to a number:\n"
"\n"
"__code0__\n"
"\n"
"or convert the correct answer to a string:\n"
"\n"
"__code1__\n"
"\n"
"An important difference between these two approaches is that the first approach will raise an error\n"
"if the user types something that isn't a number, which may or may not be what you want."

msgid "pages.InteractiveProgramsWithInput.steps.first_input.text"
msgstr ""
"The programs we have written so far are not interactive.\n"
"To make our interactive Tic-tac-toe game, we will need a method of receiving input from the players.\n"
"Python allows us to do that with the built-in `input` function. Run this program:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"When `name = input()` runs, the program actually stops and waits for you to type in the shell and press Enter,\n"
"so you will need to do that for it to complete."

msgid "pages.InteractiveProgramsWithInput.title"
msgstr "Interactive Programs with `input()`"

msgid "pages.IntroducingAnd.steps.AndExercise.hints.0.text"
msgstr ""
"Jeśli masz coś takiego jak `x < 0 and x > 100`, to jesteś na złym tropie. To"
" będzie `False` dla *każdej* wartości `x`!"

msgid "pages.IntroducingAnd.steps.AndExercise.hints.1.text"
msgstr ""
"Rozwiązanie z `and` różni się na wiele sposobów od rozwiązania z `or`."

msgid "pages.IntroducingAnd.steps.AndExercise.hints.2.text"
msgstr ""
"Nasze rozwiązanie z `or` najpierw określa, czy `x` jest nieprawidłowym "
"procentem, w przeciwnym razie zakłada ważność. Używając `and` to zrobi "
"odwrotnie."

msgid "pages.IntroducingAnd.steps.AndExercise.hints.3.text"
msgstr "Będziesz musiał odwrócić instrukcje `return` odpowiednio."

msgid "pages.IntroducingAnd.steps.AndExercise.hints.4.text"
msgstr "Będziesz musiał również zmienić operatory porównania."

msgid "pages.IntroducingAnd.steps.AndExercise.text"
msgstr ""
"Ćwiczmy teraz. Wcześniej napisaliśmy funkcję `is_valid_percentage` używając `or`. Oto przykład\n"
"rozwiązania:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Przepisz tę funkcję używając `and`."

msgid "pages.IntroducingAnd.steps.FalseAndFalse.text"
msgstr ""
"W końcu, spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.0.text"
msgstr "Lista będzie zawsze miała 3 elementy."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.1.text"
msgstr "To oznacza, że nie musisz używać pętli."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.2.text"
msgstr "Pamiętaj, że możesz uzyskać pierwszy element używając `row[0]`."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.3.text"
msgstr ""
"Pierwszy element, drugi element i trzeci element muszą być takie same."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.4.text"
msgstr ""
"To oznacza, że pierwszy element powinien być równy drugiemu elementowi oraz "
"trzeciemu elementowi."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.text"
msgstr ""
"Świetnie! Oto jedno z możliwych rozwiązań:\n"
"\n"
"__code0__\n"
"\n"
"Tak jak wcześniej, możemy to rozwiązanie uprościć:\n"
"\n"
"__code1__\n"
"\n"
"Jest inny sposób, aby to jeszcze bardziej ulepszyć, nazywa się to łączeniem porównań (ang. _comparison chaining_). Każdy warunek taki jak:\n"
"\n"
"__code2__\n"
"\n"
"może być skrócony przez usunięcie dodatkowego `and b`:\n"
"\n"
"__code3__\n"
"\n"
"To działa dla wszystkich operatorów porównania, włączając `==`, i nawet można używać różnych operatorów.\n"
"Więc rozwiązanie można uprościć do:\n"
"\n"
"__code4__\n"
"\n"
"Kolejne ćwiczenie: mając listę trzech elementów, sprawdź czy wszystkie trzy elementy są takie same.\n"
"\n"
"    __copyable__\n"
"__code5__"

msgid "pages.IntroducingAnd.steps.TrueAndFalse.text"
msgstr ""
"Dobrze, teraz spróbuj:\n"
"\n"
"__program_indented__\n"
"\n"
"Czego się spodziewasz?"

msgid "pages.IntroducingAnd.steps.TrueAndTrue.text"
msgstr ""
"Inny operatorem logicznym w Pythonie jest `and`.\n"
"Wyrażenie `A and B` jest `True` tylko jeżeli zarówno `A` i `B` są `True`. W przeciwnym przypadku jest `False`.\n"
"Spróbuj w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingAnd.steps.final_text.text"
msgstr ""
"Dobra robota. Istnieje wiele możliwych prawidłowych rozwiązań tutaj:\n"
"\n"
"__code0__\n"
"\n"
"lub używając ponownie łańcucha porównań:\n"
"\n"
"__code1__\n"
"\n"
"lub sprawdzając, czy równa się liście zawierającej trzy razy pierwszy element:\n"
"\n"
"__code2__"

msgid "pages.IntroducingAnd.title"
msgstr "Wprowadzenie `and`"

msgid "pages.IntroducingBirdseye.steps.birdseye_loop_example.text"
msgstr ""
"Inne narzędzia pokazują, jak kod wykonuje się linia po linii oraz jakie są wartości zmiennych, `birdseye` pokazuje wartość każdego wyrażenia w programie. Pozwala to zobaczyć, jak skomplikowane wyrażenie jest rozbijane na mniejsze podwyrażenia\n"
"i jakie są ich wartości.\n"
"\n"
"Najedź kursorem na różne wyrażenia w ramkach w ostatniej linii programu.\n"
"Gdy każda ramka jest podświetlona, wartość zostaje pokazana na dole ekranu. Po kliknięciu na ramkę zostaje ona przymocowana do panelu, dzięki czemu możesz zobaczyć kilka wartości wyrażeń na raz i swobodnie poruszać kursorem.\n"
"\n"
"W tym przypadku `birdseye` pokazuje, że wyrażenie:\n"
"\n"
"__code0__\n"
"\n"
"jest rozbijane na\n"
"\n"
"__code1__\n"
"\n"
"a nie na\n"
"\n"
"__code2__\n"
"\n"
"Innymi słowy, Python przestrzega zwykłej kolejności operacji w matematyce, a nie po prostu oceniając od lewej do prawej.\n"
"\n"
"Zauważ, że istnieją wyrażenia, które `birdseye` nie umieszcza w ramkach. W tym przypadku `2`, `3`, `4`, `5` i `print` to także wyrażenia, ale ich wartości są oczywiste i umieszczenie ich w ramkach tylko by je zaśmiecało.\n"
"\n"
"Oto bardziej skomplikowany przykład do wypróbowania:\n"
"\n"
"    __copyable__\n"
"__code3__"

msgid "pages.IntroducingBirdseye.steps.final_text.text"
msgstr ""
"Zauważ, że:\n"
"\n"
"1. Obok pętli for jest para strzałek. Kliknij je, aby nawigować przez pętlę w czasie i zobaczyć, co działo się w różnych iteracjach.\n"
"2. Kod, który nie został wykonany w iteracji z powodu `if`, jest wyszarzony. Wyrażenia w środku nie mają wartości, ponieważ nie zostały ocenione.\n"
"3. Wartości zapisane dla wyrażeń `vowels` i `consonants` zależą od tego, na którą ramkę patrzysz. W linijkach po pętli zawierają wszystkie litery, ale wewnątrz pętli mają tylko niektóre, i dokładnie ile, zależy od tego, która iteracja jest aktualnie wyświetlana.\n"
"4. W `vowels.append(letter)`, widzisz, jakie były wartości tych zmiennych *w tym momencie*. Oznacza to, że `letter` zaraz zostanie dołączony do `vowels`, ale to jeszcze się nie stało, więc `vowels` nie zawiera jeszcze `letter`."

msgid "pages.IntroducingBirdseye.steps.first_birdseye_example.text"
msgstr ""
"Widziałeś już `snoop` i Python Tutor. futurecoder jest wyposażony jeszcze w jedno narzędzie do analizowania programów w trakcie ich działania, nazywane `birdseye`.\n"
"\n"
"Oto przykładowy program do uruchomienia. Skopiuj go do edytora i kliknij przycisk `birdseye`. Spowoduje to otwarcie nowej karty przeglądarki z wizualizacją.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingBirdseye.title"
msgstr "Zrozumienie Programów przy Pomocy `birdseye`"

msgid ""
"pages.IntroducingDictionaries.steps.dict_access.special_messages.bad_french_value.text"
msgstr ""
"Oops, you need to set `french = {'apple': 'pomme', 'box': 'boite'}` before "
"we can continue."

msgid "pages.IntroducingDictionaries.steps.dict_access.text"
msgstr ""
"`french` is a dictionary with two key-value pairs:\n"
"\n"
"- `'apple': 'pomme'` where `'apple'` is the key and `'pomme'` is the value.\n"
"- `'box': 'boite'` where `'box'` is the key and `'boite'` is the value.\n"
"\n"
"Like lists, a comma (`,`) is used to separate items (key-value pairs) from each other. A colon (`:`) separates the keys from the values.\n"
"Note that curly brackets (`{}`) are used to create the dictionary instead of the square brackets (`[]`) used when writing lists.\n"
"\n"
"Remember that with lists, you get values based on their *index*, i.e. their position in the list.\n"
"So if `words = ['apple', 'box']`, then `words[0]` is `'apple'` and `words[1]` is `'box'`.\n"
"Try this in the shell:\n"
"\n"
"__program_indented__"

msgid ""
"pages.IntroducingDictionaries.steps.dict_access2.special_messages.bad_french_value.text"
msgstr ""
"Oops, you need to set `french = {'apple': 'pomme', 'box': 'boite'}` before "
"we can continue."

msgid "pages.IntroducingDictionaries.steps.dict_access2.text"
msgstr ""
"That doesn't work because the position of items in a dictionary usually doesn't matter.\n"
"You don't usually care what's the 2nd or 5th or 100th word of the dictionary,\n"
"you just want to find a specific word like 'apple'. So try that instead:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingDictionaries.steps.dict_access3.requirements"
msgstr ""
"Run the same code as the previous step (`french['apple']`) in the shell, but"
" replace `'apple'` with `'box'`."

msgid ""
"pages.IntroducingDictionaries.steps.dict_access3.special_messages.bad_french_value.text"
msgstr ""
"Oops, you need to set `french = {'apple': 'pomme', 'box': 'boite'}` before "
"we can continue."

msgid "pages.IntroducingDictionaries.steps.dict_access3.text"
msgstr ""
"That's better!\n"
"\n"
"Now run a similar line in the shell to look up the translation for `'box'`."

msgid ""
"pages.IntroducingDictionaries.steps.dict_access4.special_messages.bad_french_value.text"
msgstr ""
"Oops, you need to set `french = {'apple': 'pomme', 'box': 'boite'}` before "
"we can continue."

msgid "pages.IntroducingDictionaries.steps.dict_access4.text"
msgstr ""
"And now you know both Python and French!\n"
"\n"
"Now let's translate from French to English:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingDictionaries.steps.final_text.text"
msgstr ""
"Sorry, you can't do that either. You can only look up a key to get its value, not the other way around.\n"
"The dictionary `french` only has 2 keys: `'apple'` and `'box'`. `'pomme'` is a value, not a key.\n"
"We'll soon learn why you can't just look up values directly, and what you can do about it.\n"
"\n"
"Note that both `french[0]` and `french['pomme']` raised the same type of error: a `KeyError`.\n"
"This error means that the provided key (`0` or `'pomme'` in this case) wasn't found in the dictionary.\n"
"It's not that `french[0]` isn't *allowed*, it's just that it means the same thing as always:\n"
"find the value associated with the key `0`. In this case it finds that no such key exists.\n"
"But `0` *could* be a key, because many types of keys are allowed, including strings and numbers."

msgid "pages.IntroducingDictionaries.steps.first_dict.text"
msgstr ""
"We've seen several types: `str`, `int`, `float`, `bool`, and `list`.\n"
"Only one of these types can contain multiple values: `list`.\n"
"Now we're going to learn about another container type: `dict`, short for ***dictionary***.\n"
"\n"
"Think of the familiar kind of dictionary where you look up a word to find its definition or a translation in another language.\n"
"Dictionaries in Python are similar, but more general. You look up a *key* (e.g. a word) to get the associated *value* (e.g. a definition or translation).\n"
"\n"
"For example, here's a little dictionary translating English words to French:\n"
"\n"
"__code0__\n"
"\n"
"Run the line above in the shell."

msgid "pages.IntroducingDictionaries.title"
msgstr "Introducing Dictionaries"

msgid "pages.IntroducingElif.steps.dna_example.text"
msgstr ""
"Szybka lekcja biologii! Większość komórek w twoim ciele zawiera pełny kod genetyczny w DNA.\n"
"Składa się on z nici zbudowanych z molekularnych jednostek zwanych nukleobazami, które występują w czterech rodzajach:\n"
"Adenina, Cytozyna, Guanina i Tymina, czyli w skrócie ACGT.\n"
"Część pojedynczej nici może wyglądać na przykład tak:\n"
"\n"
"    AGTAGCGTCCTTAGTTACAGGATGGCTTAT...\n"
"\n"
"Będzie ona sparowana z inną nicią, gdzie A jest zastępowane przez T i odwrotnie,\n"
"a C jest zastępowane przez G i odwrotnie, np.:\n"
"\n"
"    TCATCGCAGGAATCAATGTCCTACCGAATA...\n"
"\n"
"Dwie nici są 'zamykane' razem w słynną strukturę podwójnej helisy,\n"
"łącząc się poprzez pasujące pary A-T i C-G. Te połączenia są istotne w kopiowaniu DNA, gdy\n"
"komórki się dzielą i rozmnażają. Podwójna helisa jest rozpinana, a kod jest przepisywany\n"
"na jego przeciwną wersję, aby utworzyć kopię.\n"
"\n"
"Zamierzamy powtórzyć ten proces. Spróbujmy napisać podobny program, jak ten, który właśnie napisaliśmy:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingElif.steps.dna_example_with_elif.requirements"
msgstr ""
"Skopiuj program z pierwszego kroku na tej stronie, ale zamień 4 bloki `if` na kombinację bloków `if` i `elif` stąd.\n"
"Innymi słowy, zamień każde z ostatnich trzech `if` na `elif`, ale pozostaw pierwszy `if` bez zmian."

msgid "pages.IntroducingElif.steps.dna_example_with_elif.text"
msgstr ""
"Świetnie! Naśladowałeś właśnie to, co robią twoje komórki na co dzień.\n"
"\n"
"`if` wewnątrz `else` można zastąpić pojedynczym słowem kluczowym `elif`. Na przykład,\n"
"poprzedni kod można zmienić na:\n"
"\n"
"__code0__"

msgid "pages.IntroducingElif.steps.dna_example_with_else.hints.0.text"
msgstr ""
"Zmień:\n"
"\n"
"__code0__\n"
"\n"
"aby wyglądało jak poprawiony fragment. To tylko mała zmiana, wykonaj ją bez kopiowania i wklejania."

msgid "pages.IntroducingElif.steps.dna_example_with_else.hints.1.text"
msgstr "Teraz dokonaj tej samej zmiany w kodzie zamieniającym G i C."

msgid "pages.IntroducingElif.steps.dna_example_with_else.text"
msgstr ""
"Ojej, to nie do końca działa. `T` zostaje zamienione na `A`, ale `A` nie jest zamienione na nic.\n"
"Czy rozumiesz dlaczego?\n"
"\n"
"Gdy `char == 'A'`, wtedy instrukcja `char = 'T'` rzeczywiście jest wykonywana. Ale to oznacza, że kolejny\n"
"warunek `char == 'T'` również jest spełniony, więc `char = 'A'` i wracamy do punktu wyjścia.\n"
"Musimy zmienić `char` z `T` na `A` tylko wtedy, gdy `char` nie było wcześniej `A`,\n"
"czyli gdy `char == 'A'` było `False`. Możemy to zrobić za pomocą `else`, tak jak tutaj:\n"
"\n"
"__code0__\n"
"\n"
"Teraz popraw program, aby zamieniał wszystkie znaki poprawnie."

msgid "pages.IntroducingElif.steps.final_text.text"
msgstr ""
"Często mamy do czynienia z łańcuchem klauzul `elif`, gdy chcemy, by jeden z wielu\n"
"bloków kodu się wykonał, tak jak w tym przypadku. Ogólnie kod taki jak ten:\n"
"\n"
"__code0__\n"
"\n"
"można przepisać jako:\n"
"\n"
"__code1__\n"
"\n"
"co jest krótsze i oszczędza nam skomplikowanego zagnieżdżania. Różnica jest tylko kosmetyczna:\n"
"gdy komputer wykonuje ten kod, nie potrafi odróżnić jednej wersji od drugiej.\n"
"\n"
"Zauważ, że za `elif`(ami) opcjonalnie można dodać jeden ostatni `else`. Nie umieściliśmy go\n"
"w naszym przykładzie z DNA, ale moglibyśmy dodać go, aby ostrzec nas o wszelkich nieoczekiwanych znakach\n"
"w danych wejściowych lub zmienić `elif char == 'C':` na `else:`, gdybyśmy byli pewni\n"
"że dane wejściowe są poprawne."

msgid "pages.IntroducingElif.title"
msgstr "Wprowadzenie do `elif`"

msgid "pages.IntroducingForLoops.steps.final_text.text"
msgstr ""
"Kod można czytać prawie jak zwykły angielski:\n"
"\n"
"> For each character in the string `name`, print that character.\n"
"\n"
"> Dla każdego znaku w ciągu `name`, wydrukuj ten znak.\n"
"\n"
"Każdy znak to również normalny ciąg znaków (ang. string). `character` to normalna zmienna, której przed wykonaniem kodu po `:` przypisywana jest nowa wartość. Więc kod powyżej jest równoważny:\n"
"\n"
"    __no_auto_translate__\n"
"    name = 'World'\n"
"\n"
"    character = 'W'\n"
"    print(character)\n"
"\n"
"    character = 'o'\n"
"    print(character)\n"
"\n"
"    character = 'r'\n"
"    print(character)\n"
"\n"
"    character = 'l'\n"
"    print(character)\n"
"\n"
"    character = 'd'\n"
"    print(character)\n"
"\n"
"Zauważ, że moglibyśmy użyć innej nazwy zmiennej, `character` po prostu sprawia, że jest to jaśniejsze.\n"
"\n"
"Pętla for zazwyczaj stosuje się w następującej strukturze:\n"
"\n"
"    for <zmienna> in <kolekcja>: <kod do powtórzenia>\n"
"\n"
"Elementy `for`, `in`, i `:` są niezbędne."

msgid "pages.IntroducingForLoops.steps.first_for_loop.text"
msgstr ""
"Dobre wiadomości! Udało Ci się przebrnąć przez nudne podstawy. Możemy zacząć pisać niektóre ciekawe programy i trochę się bawić. Jednym z najpotężniejszych pojęć w programowaniu jest *pętla* (ang. loop), która pozwala powtarzać ten sam kod wielokrotnie. Python ma dwa rodzaje pętli: pętle `for` i pętle `while`. Oto przykład pętli for, spróbuj uruchomić ten program:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingForLoops.title"
msgstr "Wprowadzenie do pętli for"

msgid "pages.IntroducingFstrings.steps.basic_f_string_exercise.hints.0.text"
msgstr "To jest podobne do podanego przykładu f-stringa."

msgid "pages.IntroducingFstrings.steps.basic_f_string_exercise.hints.1.text"
msgstr "Czy zapomniałeś o `f`?"

msgid "pages.IntroducingFstrings.steps.basic_f_string_exercise.hints.2.text"
msgstr "Ile par nawiasów klamrowych potrzebujesz?"

msgid "pages.IntroducingFstrings.steps.basic_f_string_exercise.text"
msgstr ""
"Nie powiedzie się, ponieważ nie możemy użyć `+` między ciągiem znaków `\"Cześć Alice. Masz \"` a liczbą `age`.\n"
"\n"
"Napraw to, zastępując wszystkie konkatenacje ciągów znaków (+) jednym f-stringiem."

msgid ""
"pages.IntroducingFstrings.steps.concatenate_string_number.output_prediction_choices.0"
msgstr "\"Hello \" + name + \". You are \" + age + \" years old.\""

msgid ""
"pages.IntroducingFstrings.steps.concatenate_string_number.output_prediction_choices.1"
msgstr "Hello name. You are age years old."

msgid ""
"pages.IntroducingFstrings.steps.concatenate_string_number.output_prediction_choices.2"
msgstr "Hello Alice. You are 20 years old."

msgid ""
"pages.IntroducingFstrings.steps.concatenate_string_number.output_prediction_choices.3"
msgstr "Hello 'Alice'. You are 20 years old."

msgid "pages.IntroducingFstrings.steps.concatenate_string_number.text"
msgstr ""
"Składnia f-stringa zaczyna się od `f` po czym następuje ciąg znaków.\n"
"F-string może zawierać nazwy zmiennych w nawiasach klamrowych `{}`.\n"
"Będą one zastępowane wartościami tych zmiennych przekształconymi na ciągi znaków.\n"
"Zmienne mogą być dowolne: ciągi znaków, liczby, listy i tak dalej.\n"
"\n"
"W związku z tym f-stringi pozwalają łatwo łączyć ciągi znaków z liczbami, które nie mogą\n"
"po prostu zostać dodane do siebie. Na przykład, uruchom poniższy program:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingFstrings.steps.eval_expr_inside_f_string.text"
msgstr ""
"Ponadto, f-string może zawierać w nawiasach klamrowych dowolne wyrażenie Pythona.\n"
"Spróbuj tego w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingFstrings.steps.final_text.text"
msgstr ""
"Świetnie!\n"
"\n"
"Od teraz zachęcamy do używania f-stringów zamiast `+` do budowania ciągów znaków tam, gdzie to możliwe."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.0.text"
msgstr "Są cztery problemy z wyrażeniem wewnątrz `print`."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.1.text"
msgstr "Jest problem z syntaksem znalezienia liczby ludzi."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.2.text"
msgstr "Potem jeden z ciągów znaków ma problem z cudzysłowami."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.3.text"
msgstr "Jest też problem z syntaksem znalezienia imienia pierwszej osoby."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.4.text"
msgstr "Nie możesz dodać ciągu znaków do liczby!"

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.5.text"
msgstr "Czy poprawnie użyłeś nawiasów klamrowych w twoim f-stringu?"

msgid "pages.IntroducingFstrings.steps.fix_broken_program.text"
msgstr ""
"Jak widać, możemy także zdefiniować f-string używając cudzysłowów, tak jak w przypadku zwykłego ciągu znaków.\n"
"I podobnie jak w przypadku cudzysłowów, f-stringi są tylko notacją. Po ich wyliczeniu komputer zapomina,\n"
"że użyto f-stringa, przechowuje tylko końcowy wynik jako zwykły ciąg znaków.\n"
"\n"
"Oto bardzo zepsuty program:\n"
"\n"
"    __copyable__\n"
"    people = [\"Alice\", \"Bob\", \"Charlie\"]\n"
"    print('There are' + people.length() + 'people waiting, the first one's name is' + people.1 + '.')\n"
"\n"
"Napraw to!\n"
"Twoje rozwiązanie powinno działać dla dowolnej listy ciągów znaków o nazwie `ludzie`.\n"
"Na przykład w powyższym przypadku powinno wypisać:\n"
"\n"
"    There are 3 people waiting, the first one's name is Alice."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.0"
msgstr "f\"{name} went to {meal} with {friend}.\""

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.1"
msgstr "\"{name} went to {meal} with {friend}.\""

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.2"
msgstr "{name} went to {meal} with {friend}."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.3"
msgstr "'name' went to 'meal' with 'friend'."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.4"
msgstr "name went to meal with friend."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.5"
msgstr "\"Alice\" went to \"lunch\" with 'Bob'."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.6"
msgstr "'Alice' went to 'lunch' with 'Bob'."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.7"
msgstr "\"Alice went to lunch with Bob.\""

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.8"
msgstr "Alice went to lunch with Bob."

msgid "pages.IntroducingFstrings.steps.introduce_f_strings.requirements"
msgstr ""
"Uruchom program powyżej, ale zastąp ten kod wewnątrz `print()`:\n"
"\n"
"__code0__\n"
"\n"
"przez:\n"
"\n"
"__code1__"

msgid "pages.IntroducingFstrings.steps.introduce_f_strings.text"
msgstr ""
"Do tej pory łączyliśmy ciągi znaków, konkatenując je za pomocą `+`, na przykład:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Jednak jest to trochę niewygodne. Możemy napisać to samo w bardziej elegancki sposób, używając *f-stringa*.\n"
"Zastąp ostatnią linię programu powyżej poniższą linią i uruchom ją.\n"
"Upewnij się, że uwzględnisz `f` przed ciągiem znaków.\n"
"\n"
"__code1__"

msgid "pages.IntroducingFstrings.title"
msgstr "f-stringi"

msgid ""
"pages.IntroducingIfStatements.steps.excited_confused_exercise.hints.0.text"
msgstr ""
"Do istniejącego programu trzeba tylko dodać kilka linii. Wszystkie "
"istniejące kody powinny pozostać takie, jakie są."

msgid ""
"pages.IntroducingIfStatements.steps.excited_confused_exercise.hints.1.text"
msgstr ""
"Kod, który dodajesz, powinien być bardzo podobny do istniejącego kodu."

msgid "pages.IntroducingIfStatements.steps.excited_confused_exercise.text"
msgstr ""
"Czas na ćwiczenie. Zmodyfikuj powyższy program, aby dodać dodatkowy\n"
"parametr logiczny `confused`, tak aby program zaczynał się tak:\n"
"\n"
"__code0__\n"
"\n"
"(`sentence` może być dowolnym łańcuchem znaków, a dwie wartości logiczne mogą być albo `True`, albo `False`)\n"
"\n"
"Gdy `confused` jest prawdziwe (`True`), wypisane zdanie powinno mieć na końcu znak zapytania.\n"
"Jeśli zarówno `confused`, jak i `excited` są prawdziwe (`True`), zdanie powinno kończyć się na `!?`."

msgid ""
"pages.IntroducingIfStatements.steps.excited_example.output_prediction_choices.0"
msgstr "Hello World"

msgid ""
"pages.IntroducingIfStatements.steps.excited_example.output_prediction_choices.1"
msgstr "Hello World!"

msgid "pages.IntroducingIfStatements.steps.excited_example.text"
msgstr ""
"Zauważ, że kod znajdujący się wewnątrz pierwszej instrukcji `if` został wykonany, ale kod drugiej nie.\n"
"\n"
"Generalnie instrukcja `if` wygląda tak:\n"
"\n"
"    if <warunek>:\n"
"        <ciało>\n"
"\n"
"gdzie `<warunek>` to dowolne wyrażenie, które daje wynik w postaci wartości logicznej, a `<ciało>` to **wcięta** lista\n"
"jednego lub więcej stwierdzeń. Struktura jest dość podobna do pętli `for`. Zwróć uwagę na dwukropek (`:`), który\n"
"jest niezbędny.\n"
"\n"
"Gdy komputer widzi `if <warunek>:`, sprawdza, czy `<warunek>` jest `True`. Jeśli tak, wykonuje ciało.\n"
"Jeśli nie, pomija je i kontynuuje resztę programu.\n"
"\n"
"Oto bardziej interesujący przykład, który możesz uruchomić:\n"
"\n"
"__program_indented__"

msgid ""
"pages.IntroducingIfStatements.steps.excited_false_example.output_prediction_choices.0"
msgstr "Hello World"

msgid ""
"pages.IntroducingIfStatements.steps.excited_false_example.output_prediction_choices.1"
msgstr "Hello World!"

msgid "pages.IntroducingIfStatements.steps.excited_false_example.requirements"
msgstr ""
"Uruchom program z poprzedniego kroku, ale zamień `True` na `False`, tak żeby"
" było `excited = False`."

msgid "pages.IntroducingIfStatements.steps.excited_false_example.text"
msgstr ""
"(Pamiętaj, że `sentence += '!'` oznacza `sentence = sentence + '!'`)\n"
"\n"
"Zmień `excited = True` na `excited = False` i uruchom program ponownie, aby zobaczyć różnicę."

msgid "pages.IntroducingIfStatements.steps.final_text.text"
msgstr ""
"Brawo! Ten program może robić 4 różne rzeczy w zależności od tego, jak łączysz `excited`\n"
"i `confused`. Wypróbuj je, jeśli chcesz."

msgid "pages.IntroducingIfStatements.steps.first_if_statements.text"
msgstr ""
"Wartości logiczne są przeznaczone do użycia wewnątrz *instrukcji warunkowych* (ang. if statements). Nazywane są też czasami *warunkami* (ang. conditionals).\n"
"\n"
"Oto prosty przykład, który możesz uruchomić:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingIfStatements.steps.introducing_booleans.text"
msgstr ""
"Teraz nauczymy się, jak powiedzieć komputerowi, aby podejmował decyzje i wykonywał kod\n"
"tylko pod pewnymi warunkami. Do tego będziemy potrzebować nowego rodzaju wartości. Widziałeś już\n"
"liczby i łańcuchy znaków, teraz spotkaj się z *wartościami logicznymi* (ang. booleans). Istnieją tylko dwie wartości logiczne:\n"
"`True` i `False`. Wypróbuj ten program:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingIfStatements.title"
msgstr "Wprowadzenie do instrukcji warunkowych"

msgid "pages.IntroducingLists.steps.can_contain_anything.text"
msgstr ""
"Lista to rodzaj *sekwencji* (uporządkowanej kolekcji), która może zawierać dowolną liczbę wartości.\n"
"Nazywamy je często *elementami*.\n"
"Mogą to być przeróżne rzeczy: liczby, ciągi znaków, wartości logiczne, a nawet inne listy! Mogą również stanowić kombinację różnych typów.\n"
"\n"
"Żeby utworzyć listę bezpośrednio, tak jak w przykładzie:\n"
"\n"
"1. Zacznij od nawiasów kwadratowych: `[]`\n"
"2. Jeśli nie chcesz mieć pustej listy, umieść wewnątrz nawiasów wyrażenia, które staną się elementami listy.\n"
"3. Oddziel elementy przecinkami (`,`) by je od siebie rozdzielić.\n"
"\n"
"Oto inny przykład tworzenia listy:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingLists.steps.final_text.text"
msgstr ""
"Gratulacje! To było bardzo trudne! Jedno z możliwych rozwiązań wygląda tak:\n"
"\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"    separator = ' - '\n"
"    total = ''\n"
"    not_first = False\n"
"\n"
"    for word in words:\n"
"        if not_first:\n"
"            total += separator\n"
"        total += word\n"
"        not_first = True\n"
"\n"
"    print(total)"

msgid "pages.IntroducingLists.steps.first_list.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"\n"
"for word in words:\n"
"    print(word)"

msgid "pages.IntroducingLists.steps.first_list.text"
msgstr ""
"Nadszedł czas, aby dowiedzieć się o potężnym nowym typie wartości, zwanym *listami*. Oto przykład:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingLists.steps.numbers_sum.text"
msgstr ""
"Jak widziałeś powyżej, listy są *iterowalne*, co oznacza, że możesz iterować po nich przy użyciu `pętli for`.\n"
"Oto program, który sumuje wszystkie liczby w liście:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingLists.steps.strings_sum.hints.0.text"
msgstr ""
"To jest bardzo podobne do ćwiczeń, które wykonałeś, tworząc ciągi znaków "
"znak po znaku."

msgid "pages.IntroducingLists.steps.strings_sum.hints.1.text"
msgstr "Rozwiązanie jest bardzo podobne do programu, który sumuje liczby."

msgid "pages.IntroducingLists.steps.strings_sum.hints.2.text"
msgstr ""
"Tak naprawdę, co się stanie, jeśli spróbujesz uruchomić ten program z listą "
"ciągów znaków?"

msgid "pages.IntroducingLists.steps.strings_sum.hints.3.text"
msgstr ""
"Problem polega na tym, że 0. Nie możesz dodać 0 do ciągu znaków, ponieważ "
"liczby i ciągi znaków są niekompatybilne."

msgid "pages.IntroducingLists.steps.strings_sum.hints.4.text"
msgstr ""
"Czy jest podobne pojęcie wśród ciągów znaków do 0? Pusta początkowa wartość?"

msgid "pages.IntroducingLists.steps.strings_sum.text"
msgstr ""
"Teraz zmodyfikuj program, tak aby mógł sumować listę ciągów znaków zamiast liczb.\n"
"Na przykład, mając:\n"
"\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"\n"
"powinien wydrukować:\n"
"\n"
"    __no_auto_translate__\n"
"    Thisisalist"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.0.text"
msgstr ""
"To jest podobne do poprzedniego ćwiczenia. Możesz zacząć od swojego "
"rozwiązania z tego."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.1.text"
msgstr ""
"To ćwiczenie nie wymaga niczego wyjątkowego, a ostateczne rozwiązanie może "
"być dość proste. Ale wymaga starannego przemyślenia podejścia."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.10.text"
msgstr ""
"Możesz napisać program, który sprawdza, czy jesteś w *pierwszej* iteracji "
"pętli."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.11.text"
msgstr ""
"Wystarczy zrobić zmienną typu bool do śledzenia tego. Nie ma potrzeby "
"używania żadnych operatorów porównania ani liczb."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.12.text"
msgstr ""
"Spojrzeliśmy na programy, które robiły coś takiego "
"[tutaj](#UnderstandingProgramsWithSnoop)."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.13.text"
msgstr ""
"Więc jeśli pominięto dodawanie separatora tylko w pierwszej iteracji, będzie"
" miał `n - 1` separatorów. Teraz wystarczy tylko przemyśleć ostrożnie, jak "
"upewnić się, że separatory są we właściwym miejscu."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.14.text"
msgstr ""
"Zapominając na chwilę o pętli, musisz dodać do ciągu znaków w tej "
"kolejności: pierwsze słowo, separator, drugie słowo, separator, trzecie "
"słowo itd."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.15.text"
msgstr ""
"To oznacza, że w pierwszej iteracji dodajesz tylko pierwsze słowo. W drugiej"
" iteracji dodajesz separator, potem drugie słowo. W trzeciej iteracji "
"dodajesz separator, potem trzecie słowo. I tak dalej."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.16.text"
msgstr "Więc w swojej pętli najpierw dodaj separator, następnie dodaj słowo."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.17.text"
msgstr ""
"Pomiń dodawanie separatora w pierwszej iteracji, sprawdzając zmienną typu "
"bool."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.18.text"
msgstr ""
"Utwórz zmienną typu bool przed pętlą, później zmień ją wewnątrz pętli."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.19.text"
msgstr ""
"Zmieniaj ją dopiero po sprawdzeniu w pętli, inaczej nie będziesz w stanie "
"pominąć pierwszej iteracji."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.2.text"
msgstr ""
"W każdej iteracji, oprócz słowa z listy, musisz również dodać separator."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.3.text"
msgstr ""
"Ale nie chcesz dodawać separatora po dodaniu ostatniego słowa na liście."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.4.text"
msgstr ""
"Niestety nie ma \"odejmowania\" w ciągach znaków; nie możesz dodać "
"ostatniego separatora, a następnie go usunąć."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.5.text"
msgstr ""
"Zróbmy krok wstecz. Ostateczny wynik powinien zawierać każde słowo i `n - 1`"
" separatorów, gdzie `n` to liczba słów."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.6.text"
msgstr "Chcesz dodać separator w każdej iteracji oprócz jednej."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.7.text"
msgstr ""
"Możesz pominąć dodawanie separatora w jednej konkretnej iteracji używając "
"instrukcji `if`."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.8.text"
msgstr ""
"Później nauczysz się sposobu iterowania po liście i sprawdzania, czy jesteś "
"w ostatniej iteracji, ale na razie nie masz możliwości tego zrobienia."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.9.text"
msgstr "Jednak iteracja, którą pomijasz, nie musi być ostatnia!"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.text"
msgstr ""
"Wspaniale!\n"
"\n"
"Jeśli chcesz, możesz kontynuować [następnej stronie](#BuildingNewLists).\n"
"\n"
"Dla dodatkowego, opcjonalnego wyzwania: rozszerz program tak, aby dodawał łańcuch separatorów *pomiędzy* każdym słowem.\n"
"Na przykład, mając\n"
"\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"    separator = ' - '\n"
"\n"
"wypisałby:\n"
"\n"
"    __no_auto_translate__\n"
"    This - is - a - list"

msgid "pages.IntroducingLists.title"
msgstr "Wprowadzenie do list"

msgid "pages.IntroducingNestedLists.steps.double_subscripting.requirements"
msgstr ""
"Uruchom `print(strings[1][0])` lub coś podobnego używając `birdseye`, aby "
"zobaczyć jak to działa."

msgid "pages.IntroducingNestedLists.steps.double_subscripting.text"
msgstr ""
"Możesz to rozwiązać tak:\n"
"\n"
"__code0__\n"
"\n"
"Istnieje krótszy sposób. `strings[1]` to wyrażenie jak każde inne i indeksowanie jak `[0]`\n"
"może być użyte na dowolnym wyrażeniu, nie tylko na zmiennych.\n"
"Więc możesz pominąć zmienną pośrednią i zrobić to jedną linią:\n"
"\n"
"__code1__\n"
"\n"
"Przyjrzyj się dobrze tej składni. Jeśli wygląda na nową i wyszukaną, to nie jest.\n"
"To tylko zwykła składnia indeksowania, zastosowana dwa razy.\n"
"Spróbuj użyć `birdseye`, aby zobaczyć jak Python rozkłada to na mniejsze części."

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.0.text"
msgstr "To jest bardzo podobne do poprzedniego ćwiczenia."

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.1.text"
msgstr ""
"Czy pamiętasz jak uzyskać dostęp do ostatniej pozycji na liście (bez użycia "
"`len`)?"

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.2.text"
msgstr "Podobnie jak uzyskujesz dostęp do przedostatniej pozycji na liście?"

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.3.text"
msgstr "Jeśli nie pamiętasz, możesz wyszukać to w Google!"

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.4.text"
msgstr "Indeksowanie działa podobnie na listach i ciągach znaków."

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.5.text"
msgstr ""
"Czy otrzymujesz błąd `index out of range`? Czy dotyczy on ciągu czy listy? "
"Dlaczego?"

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.6.text"
msgstr "Upewnij się, że nie mylisz kolejności indeksu listy i indeksu ciągu."

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.7.text"
msgstr "Użyj `birdseye` jeśli masz problemy."

msgid "pages.IntroducingNestedLists.steps.double_subscripting_exercise.text"
msgstr ""
"Używając tej składni, zmodyfikuj program tak, aby wydrukować ostatnią literę przedostatniego ciągu na liście `strings`.\n"
"Musisz użyć pojedynczego wyrażenia podobnie jak powyżej i nie wolno ci używać `len`.\n"
"Twoje rozwiązanie powinno działać dla dowolnej niepustej listy ciągów znaków.\n"
"Przy poprzednim przykładzie wejściowym powinno wydrukować `f`."

msgid "pages.IntroducingNestedLists.steps.final_text.text"
msgstr ""
"Świetnie! Teraz bardzo dobrze rozumiesz zagnieżdżone indeksowanie.\n"
"\n"
"Cały czas możemy używać wszystkich metod i funkcji list, które wcześniej poznaliśmy.\n"
"Na przykład możemy dodać nowe słowo do ostatniej podlisty `strings` używając `append`,\n"
"żeby umieścić je po `'you'`:\n"
"\n"
"__code0__\n"
"\n"
"Przecież podlista `strings[1]` to wciąż lista jak każda inna!\n"
"\n"
"Na następnej stronie dowiemy się, jak iterować po zagnieżdżonych listach."

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.0"
msgstr "hello"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.1"
msgstr "there"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.10"
msgstr "a"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.2"
msgstr "how"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.3"
msgstr "are"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.4"
msgstr "you"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.5"
msgstr "['hello', 'there']"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.6"
msgstr "['how', 'are', 'you']"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.7"
msgstr "h"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.8"
msgstr "t"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.9"
msgstr "e"

msgid "pages.IntroducingNestedLists.steps.first_nested_list_example.program"
msgstr ""
"strings = [['hello', 'there'], ['how', 'are', 'you']]\n"
"print(strings[1][0])"

msgid "pages.IntroducingNestedLists.steps.first_nested_list_example.text"
msgstr ""
"Dobra robota!\n"
"\n"
"Zastosowanie indeksowania dwa razy może być nawet bardziej potężne.\n"
"Możemy użyć go nie tylko na liście ciągów znaków, ale także na *liście list*.\n"
"Na przykład, co wydrukuje poniższy program?\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingNestedLists.steps.string_list_exercise.hints.0.text"
msgstr "Jak możesz uzyskać dostęp do drugiego ciągu na liście?"

msgid "pages.IntroducingNestedLists.steps.string_list_exercise.hints.1.text"
msgstr "A jak uzyskujesz dostęp do konkretnego znaku w ciągu?"

msgid "pages.IntroducingNestedLists.steps.string_list_exercise.hints.2.text"
msgstr "Pamiętaj, że indeksowanie list i ciągów znaków jest bardzo podobne."

msgid "pages.IntroducingNestedLists.steps.string_list_exercise.text"
msgstr ""
"Ćwiczenie: mając daną listę ciągów znaków, wydrukuj pierwszą literę drugiego ciągu na liście. Na przykład, mając:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"powinieneś wydrukować `d`."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.0.text"
msgstr "To jest bardzo podobne do poprzednich ćwiczeń."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.1.text"
msgstr "Ile razy musisz użyć indeksowania?"

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.2.text"
msgstr "Najpierw musisz uzyskać dostęp do podlisty."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.3.text"
msgstr "Potem ciągu na tej podliście."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.4.text"
msgstr "Potem litery w tym ciągu."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.5.text"
msgstr "Użyj `birdseye` jeśli masz problemy."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.text"
msgstr ""
"Jak widzisz Python pozwala nam mieć *zagnieżdżone listy*: listę, w której każdy element to inna lista (nazywamy je *podlistami*).\n"
"\n"
"Możemy używać indeksowania nawet więcej niż dwa razy.\n"
"Napisz program który bierze zagnieżdżoną listę `strings` jak powyżej,\n"
"i wydrukuje **pierwszą literę trzeciego ciągu na drugiej podliście**.\n"
"Użyj tylko pojedynczego wyrażenia, jak w poprzednim ćwiczeniu.\n"
"Dla listy podanej powyżej powinno wydrukować `y`."

msgid "pages.IntroducingNestedLists.title"
msgstr "Wprowadzenie do zagnieżdżonych list"

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.0.text"
msgstr ""
"Pomyśl, jak byś to zrobił ręcznie i systematycznie, używając ołówka"
" i papieru."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.1.text"
msgstr ""
"Fakt, że hasło musi składać się z czterech liter jest bardzo ważny. To"
" byłoby znacznie trudniejsze do rozwiązania, gdyby hasło mogło mieć dowolną długość."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.2.text"
msgstr "Ale ciąg `letters` może mieć dowolną liczbę znaków."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.3.text"
msgstr ""
"Jeśli mamy `n` różnych liter, to liczba możliwych haseł to"
" `n^4 == n*n*n*n`, ponieważ dla każdej pozycji mamy `n` możliwych liter"
" i są one niezależne."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.4.text"
msgstr ""
"Załóżmy ponownie, że `letters = \"ABCD\"`. Wyobraź sobie, że masz wszystkie możliwe"
" trzyliterowe hasła. Teraz do każdego z nich dodaj na końcu A, lub B,"
" lub C, lub D. Tak otrzymasz wszystkie możliwe czteroliterowe hasła."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.5.text"
msgstr ""
"Pamiętaj, pętla for może zawierać dowolną instrukcję, w tym inną pętlę for."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.6.text"
msgstr "Dotyczy to wszystkich pętli for."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.7.text"
msgstr "Jedna pętla for wewnątrz innej pętli for już nie wystarczy."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.8.text"
msgstr "Musisz pójść głębiej."

msgid "pages.IntroducingNestedLoops.steps.crack_password_exercise.text"
msgstr ""
"Na następne ćwiczenie musisz złamać hasło. Wiesz, że ma dokładnie cztery litery i że możliwe są tylko niektóre litery, które zapisałeś:\n"
"\n"
"__code0__\n"
"\n"
"Musisz wydrukować wszystkie możliwe hasła:\n"
"\n"
"    AAAA\n"
"    AAAB\n"
"    AAAC\n"
"    AAAD\n"
"    AABA\n"
"    AABB\n"
"    ...pomijając kilka...\n"
"    DDDA\n"
"    DDDB\n"
"    DDDC\n"
"    DDDD"

msgid "pages.IntroducingNestedLoops.steps.final_text.text"
msgstr ""
"Świetnie! Rozwiązanie wygląda tak:\n"
"\n"
"__code0__"

msgid "pages.IntroducingNestedLoops.steps.first_nested_loop.text"
msgstr ""
"Zobaczyłeś, że wcięte ciało instrukcji `if` lub pętli może zawierać dowolny rodzaj instrukcji, w tym więcej instrukcji `if` i pętli. W szczególności pętla może zawierać inną pętlę. Oto przykład:\n"
"\n"
"__program_indented__\n"
"\n"
"To nazywa się *zagnieżdżoną pętlą*. Nic w tym nie jest naprawdę nowe, warto to jednak dobrze zrozumieć, ponieważ może być bardzo przydatne do pisania interesujących programów."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.0.text"
msgstr "Będziesz potrzebować pętli for wewnątrz pętli for, tak jak wcześniej."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.1.text"
msgstr "Tym razem coś w stylu `for player1 in players:` nie będzie wystarczające."

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.10.text"
msgstr "Musisz użyć operatora porównania."

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.11.text"
msgstr ""
"Kiedy już rozgryziesz zależność, możesz wyrazić ją za pomocą instrukcji `if`."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.2.text"
msgstr "Twój program musi używać *pozycji* graczy na liście."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.3.text"
msgstr ""
"To oznacza, że musisz iterować po pozycjach i używać indeksowania "
"(subskrypcji) do dostępu do wpisów na liście."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.4.text"
msgstr "Aby iterować po pozycjach, użyj `range`..."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.5.text"
msgstr "...i `len`."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.6.text"
msgstr ""
"Spójrz na oczekiwane wyjście: `Charlie vs Alice`: `Charlie` występuje przed "
"`Alice` na liście `players`."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.7.text"
msgstr ""
"Nie chcemy wydrukować `Alice vs Charlie`, ponieważ `Alice` występuje PO "
"`Charlie` na liście `players`."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.8.text"
msgstr ""
"Chcemy wydrukować tylko te pary, gdzie lewy gracz występuje przed prawym "
"graczem na liście."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.9.text"
msgstr ""
"Jak możemy wyrazić tę zależność w terminach indeksów listy dla dwóch "
"pętli for? "

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.text"
msgstr ""
"Wow, jesteś także artystą!\n"
"\n"
"Jeśli chcesz, możesz teraz przejść do [następnej strony](#IntroducingBirdseye). Albo możesz podjąć dodatkowe wyzwanie!\n"
"\n"
"Podobnie jak w poprzednim ćwiczeniu, organizujesz turniej dla gry. Masz listę nazwisk graczy:\n"
"\n"
"__code0__\n"
"\n"
"Tym razem każda para graczy powinna pojawić się tylko raz. Konkretnie, wydrukuj tylko te pary, które są\n"
"w tej samej kolejności od lewej do prawej, jak są na liście `players`, zaczynając od par zawierających najbardziej lewą osobę\n"
"na liście `players` i przesuwając się w prawo. Na przykład, dla powyższego, Twój program powinien wydrukować\n"
"\n"
"    Charlie vs Alice\n"
"    Charlie vs Dylan\n"
"    Charlie vs Bob\n"
"    Alice vs Dylan\n"
"    Alice vs Bob\n"
"    Dylan vs Bob"

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_exercise.hints.0.text"
msgstr ""
"Pomyśl, jak byś to zrobił ręcznie i systematycznie, używając ołówka"
" i papieru."

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_exercise.hints.1.text"
msgstr "Musisz użyć pętli for wewnątrz innej pętli for."

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_exercise.hints.2.text"
msgstr ""
"Potrzebujesz instrukcji `if`, aby sprawdzić, czy dwaj gracze to nie ta sama "
"osoba."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_exercise.text"
msgstr ""
"Świetnie!\n"
"\n"
"Następne ćwiczenie: organizujesz turniej dla gry, takiej jak szachy czy tenis. Masz listę nazwisk graczy:\n"
"\n"
"__code0__\n"
"\n"
"Każdy gracz będzie grał z każdym innym graczem dwa razy: raz, gdy ma przewagę (np. ruszając się lub serwując jako pierwszy) i raz bez tej przewagi. Wydrukuj wszystkie kombinacje meczów tak jak to:\n"
"\n"
"    Alice vs Bob\n"
"    Alice vs Charlie\n"
"    Bob vs Alice\n"
"    Bob vs Charlie\n"
"    Charlie vs Alice\n"
"    Charlie vs Bob\n"
"\n"
"Zauważ, że \"Alice vs Bob\" i \"Bob vs Alice\" są obie na liście, ale nie ma \"Alice vs Alice\" - nie chcemy, aby ktoś grał sam ze sobą."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.0.text"
msgstr "Musisz użyć pętli for wewnątrz innej pętli for."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.1.text"
msgstr "Potrzebujesz liczb od 1 do 12."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.2.text"
msgstr "Kiedykolwiek potrzebujesz sekwencji kolejnych numerów, użyj `range`."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.3.text"
msgstr "Chcesz czegoś w stylu `for x in range(n):`."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.4.text"
msgstr ""
"To zacznie się od `x = 0`, ale jest na to łatwe rozwiązanie."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.5.text"
msgstr "Możesz po prostu dodać 1 do `x`."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.6.text"
msgstr "Użyj `*` do mnożenia liczb."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.7.text"
msgstr "Użyj f-stringa z kilkoma zmiennymi."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.8.text"
msgstr ""
"Pamiętaj, aby wydrukować linię z odpowiednią ilością kresek po każdej "
"sekcji."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.9.text"
msgstr ""
"Upewnij się, że każda linia jest we właściwej pętli i ma odpowiedni poziom "
"wcięcia."

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.messages.added_str_and_int.text"
msgstr "Nie możesz dodawać do siebie stringów i liczb. Użyj f-stringa."

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.messages.adding_one_in_wrong_loop.text"
msgstr ""
"Dodałeś 1 do zmiennej swojej zewnętrznej pętli w złym miejscu!\n"
"Gdzie powinieneś to zrobić, aby to naprawić?"

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.messages.too_long.text"
msgstr ""
"Twoje rozwiązanie jest za długie. Do tego problemu potrzebujesz tylko kilku linii kodu.\n"
"Użyj zagnieżdżonej pętli, aby nie musieć się powtarzać.\n"
"Komputer zrobi powtórzenie za ciebie!"

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.messages.used_times_instead_of_x.text"
msgstr ""
"To prawie poprawne! Upewnij się, że wyświetlasz prawidłowy znak `x` w swojej tabeli.\n"
"Na przykład twoje rozwiązanie powinno wyświetlać `3 x 4 = 12` a nie `3 * 4 = 12`."

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.special_messages.multiply_with_x.text"
msgstr "Aby mnożyć liczby, użyj `*`"

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.text"
msgstr ""
"Upewnij się, że w pełni rozumiesz, co się dzieje. `print(letter)` i `print('---')` są wykonywane 3 razy, ponieważ ich wcięcie umieszcza je w *zewnętrznej pętli*. `print(f'{letter} {number}')` jest wywoływane 3 × 4 = 12 razy, ponieważ znajduje się w *wewnętrznej pętli* `for number in range(4):`, która ma 4 iteracje, ale sama znajduje się w zewnętrznej pętli, więc wykonuje się 3 razy.\n"
"\n"
"Zastosujmy to! Załóżmy, że jesteś nauczycielem i musisz wydrukować wszystkie tabliczki mnożenia od 1 do 12 dla swoich uczniów. Nie chcesz ich pisać ręcznie, ale możesz napisać program, który zrobi to za ciebie! Wyjście twojego programu powinno wyglądać tak, włącznie z liniami kresek:\n"
"\n"
"    1 x 1 = 1\n"
"    1 x 2 = 2\n"
"    1 x 3 = 3\n"
"    1 x 4 = 4\n"
"    1 x 5 = 5\n"
"    1 x 6 = 6\n"
"    1 x 7 = 7\n"
"    1 x 8 = 8\n"
"    1 x 9 = 9\n"
"    1 x 10 = 10\n"
"    1 x 11 = 11\n"
"    1 x 12 = 12\n"
"    ---\n"
"    2 x 1 = 2\n"
"    2 x 2 = 4\n"
"    2 x 3 = 6\n"
"    2 x 4 = 8\n"
"    2 x 5 = 10\n"
"    2 x 6 = 12\n"
"    2 x 7 = 14\n"
"    2 x 8 = 16\n"
"    2 x 9 = 18\n"
"    2 x 10 = 20\n"
"    2 x 11 = 22\n"
"    2 x 12 = 24\n"
"    ---\n"
"    3 x 1 = 3\n"
"    3 x 2 = 6\n"
"    3 x 3 = 9\n"
"    (you get the idea...)\n"
"    11 x 10 = 110\n"
"    11 x 11 = 121\n"
"    11 x 12 = 132\n"
"    ---\n"
"    12 x 1 = 12\n"
"    12 x 2 = 24\n"
"    12 x 3 = 36\n"
"    12 x 4 = 48\n"
"    12 x 5 = 60\n"
"    12 x 6 = 72\n"
"    12 x 7 = 84\n"
"    12 x 8 = 96\n"
"    12 x 9 = 108\n"
"    12 x 10 = 120\n"
"    12 x 11 = 132\n"
"    12 x 12 = 144\n"
"    ---"

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.0.text"
msgstr ""
"Jak opisałbyś instrukcje wpisywania tego trójkąta ręcznie?"

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.1.text"
msgstr ""
"Drukuj linię `size` plusów, potem `size - 1` plusów, itd. aż do "
"1 plusa. Na przykład drukuj 5 `+`, potem 4 `+`, potem 3, 2 i 1."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.2.text"
msgstr "Podziel to na podproblemy."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.3.text"
msgstr ""
"Jak drukujesz jedną linię `+` o danej długości, i jak przechodzisz "
"przez wszystkie długości?"

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.4.text"
msgstr ""
"Budowanie linii znaków powinno być bardzo znajome z poprzednich "
"ćwiczeń, jedyna różnica polega na tym, że musisz ją zrobić o danej długości "
"zamiast tylko tej samej długości co inny ciąg."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.5.text"
msgstr "Łatwym sposobem na zrobienie czegoś `n` razy jest pętla po `range(n)`."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.6.text"
msgstr "Musisz użyć pętli for wewnątrz innej pętli for."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.7.text"
msgstr ""
"Potrzebujesz liczb, które zmniejszają się, jak 5, 4, 3, 2, 1. Jest sposób, aby "
"to zrobić za pomocą `range`, i łatwo go znaleźć, ale równie łatwo jest użyć "
"normalnego zakresu i zrobić bardzo proste obliczenia, aby przekształcić liczby "
"rosnące w liczby malejące."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.8.text"
msgstr "Jaka formuła przekształca 0 na 5, 1 na 4, 2 na 3, itd.?"

msgid "pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.text"
msgstr ""
"Wow, jesteś teraz prawie hakerem!\n"
"\n"
"Jeszcze jedno ćwiczenie. Mając daną wielkość:\n"
"\n"
"__code0__\n"
"\n"
"Wydrukuj 'odwrócony' trójkąt zrobiony ze znaku plus `+`, którego boki są tak długie jak podana wielkość, np.:\n"
"\n"
"    +++++\n"
"    ++++\n"
"    +++\n"
"    ++\n"
"    +"

msgid "pages.IntroducingNestedLoops.title"
msgstr "Wprowadzenie do zagnieżdżonych pętli"

msgid "pages.IntroducingNotPage.steps.IntroducingNot.text"
msgstr ""
"Unlike the other two boolean operators `and` and `or`,\n"
"which are used in between two booleans (called *binary* operators),\n"
"`not` is used before only one boolean (called a *unary* operator).\n"
"It negates the expression to which it is applied, a bit like a minus sign. Try in the shell:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingNotPage.steps.NotFalse.text"
msgstr ""
"Now try the following:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.0.text"
msgstr ""
"What if you were instead asked to simplify this related but opposite function?\n"
"\n"
"__code0__"

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.1.text"
msgstr ""
"In that case there is a standard simplification trick you can apply that we "
"discussed a few pages ago."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.2.text"
msgstr ""
"In particular the `returns` are redundant because "
"`filename.endswith(\".png\") or filename.endswith(\".jpg\")` is already the "
"desired boolean."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.3.text"
msgstr ""
"So you can just write:\n"
"\n"
"__code0__"

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.4.text"
msgstr "For the real exercise, you can do something similar."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.5.text"
msgstr "The difference in the real exercise is that the result is reversed."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.6.text"
msgstr ""
"That is, `invalid_image` returns `True` when `valid_image` returns `False` "
"and vice versa."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.7.text"
msgstr "Remember what `not` does?"

msgid "pages.IntroducingNotPage.steps.NotPriority.text"
msgstr ""
"You can see in `birdseye` that\n"
"\n"
"__code0__\n"
"\n"
"is interpreted by Python as\n"
"\n"
"__code1__\n"
"\n"
"rather than:\n"
"\n"
"__code2__\n"
"\n"
"So, `not` has higher priority than `or` if there are no parentheses. It's the same as how\n"
"\n"
"__code3__\n"
"\n"
"means:\n"
"\n"
"__code4__\n"
"\n"
"rather than\n"
"\n"
"__code5__\n"
"\n"
"`not` also has higher priority than `and`.\n"
"\n"
"Again, the main thing to remember is to use parentheses or extra variables when in doubt.\n"
"\n"
"Exercise: Suppose you're writing a program which processes images. Only certain types of file can be processed.\n"
"If the user gives you a file that can't be processed, you want to show an error:\n"
"\n"
"__code6__\n"
"\n"
"Suppose that .png and .jpg files can be processed, but other file types cannot.\n"
"Here's an example function to do that:\n"
"\n"
"    __copyable__\n"
"__code7__\n"
"\n"
"This is longer than it needs to be. Rewrite `invalid_image` so that the body is a single line `return <expression>`,\n"
"i.e. no `if` statement. It should pass the same tests."

msgid "pages.IntroducingNotPage.steps.NotTrueOrTrue.text"
msgstr ""
"What is the priority of `not` compared to `and` and `or`? Try the following in `birdseye`:\n"
"\n"
"__code0__"

msgid "pages.IntroducingNotPage.steps.final_text.text"
msgstr ""
"Well done! Here are two valid solutions:\n"
"\n"
"__code0__\n"
"\n"
"(if you're curious, these are equivalent because of something called De Morgan's law)\n"
"\n"
"Also notice that this is another general pattern that can be simplified: if your code has the form:\n"
"\n"
"__code1__\n"
"\n"
"where `x` itself is a boolean, then it can be simplified to:\n"
"\n"
"__code2__"

msgid "pages.IntroducingNotPage.title"
msgstr "Introducing `not`"

msgid "pages.IntroducingOr.steps.ACommonMistake.requirements"
msgstr ""
"Uruchom program z poprzedniego kroku, ale zamień:\n"
"\n"
"__code0__\n"
"\n"
"na:\n"
"\n"
"__code1__"

msgid "pages.IntroducingOr.steps.ACommonMistake.text"
msgstr ""
"Zwróć szczególną uwagę, jak napisaliśmy warunek:\n"
"\n"
"__code0__\n"
"\n"
"Typowym błędem jest napisanie tego zamiast:\n"
"\n"
"__code1__\n"
"\n"
"To ma sens, jeśli czytasz to jak po angielsku:\n"
"\n"
"> `return` czy `name` jest równy albo `\"Alice\"` lub `\"Bob\"`\n"
"\n"
"Ale Python nie jest angielskim, i nie tak działa `or`.\n"
"\n"
"Zamień linię `return` w kodzie powyższą linią, i spróbuj uruchomić to ponownie."

msgid "pages.IntroducingOr.steps.AnExercise.disallowed.3.label"
msgstr "łańcuchowe porównanie"

msgid "pages.IntroducingOr.steps.AnExercise.hints.0.text"
msgstr ""
"Pamiętaj, możesz użyć operatorów porównujących `<, >, <=, >=, ==` do "
"wytworzenia booleanów."

msgid "pages.IntroducingOr.steps.AnExercise.hints.1.text"
msgstr "Musisz sprawdzić, jak `x` porównuje się do 0 i jak do 100."

msgid "pages.IntroducingOr.steps.AnExercise.hints.2.text"
msgstr "Musisz połączyć dwa porównania w jeden boolean używając `or`."

msgid "pages.IntroducingOr.steps.AnExercise.hints.3.text"
msgstr ""
"Powżej użyliśmy triku, aby całe ciało funkcji było po prostu `return "
"<porównanie> or <porównanie>`. Ale to nie zadziała tutaj!"

msgid "pages.IntroducingOr.steps.AnExercise.hints.4.text"
msgstr "Musisz użyć instrukcji `if`."

msgid "pages.IntroducingOr.steps.AnExercise.hints.5.text"
msgstr "Musisz mieć `return False` i `return True`."

msgid "pages.IntroducingOr.steps.AnExercise.hints.6.text"
msgstr ""
"Jeśli masz coś w rodzaju `x >= 0 or x <= 100`, jesteś na złym tropie. To "
"będzie prawdą dla *dowolnej* wartości `x`. W końcu 101 jest większe niż 0!"

msgid "pages.IntroducingOr.steps.AnExercise.text"
msgstr ""
"Gdy zbadamy to z pomocą `birdseye`, widzimy, że:\n"
"\n"
"__code0__\n"
"\n"
"nie jest tłumaczone na\n"
"\n"
"__code1__\n"
"\n"
"tak jak myślimy po angielsku, ale raczej:\n"
"\n"
"__code2__\n"
"\n"
"co ocenia się jako `\"Bob\"`, gdy `name == \"Alice\"` jest `False`.\n"
"\n"
"Może czujesz się tak:\n"
"\n"
"[![Mam teraz dodatkowe pytania](https://i.imgur.com/jN57tGt.png)](https://imgur.com/a/icKzI)\n"
"\n"
"Jedyna rzecz, którą naprawdę musisz wiedzieć to: dopóki nie wiesz, co robisz, zawsze\n"
"upewnij się, że po obu stronach `or` są booleany, ponieważ to jest operator boolean.\n"
"`name == \"Alice\" or \"Bob\"` łamie tę zasadę.\n"
"\n"
"Jeśli jesteś ciekawy, odpowiedzi są poniżej, ale możesz je pominąć, jeśli chcesz, i przejść do ćwiczenia poniżej.\n"
"\n"
"----\n"
"\n"
"> Dlaczego `(name == \"Alice\") or (\"Bob\")` równa się `\"Bob\"`? Dlaczego równa się cokolwiek? `\"Bob\"` nawet nie jest booleanem!\n"
"\n"
"Definicja \"`A or B` jest `True` jeśli `A` lub `B` jest `True`\" była uproszczeniem. Jest to najłatwiejszy\n"
"sposób myślenia o `or` większość czasu, szczególnie przy pisaniu instrukcji `if`.\n"
"Prawdziwa definicja jest taka, że jeśli `A` jest prawdziwe, to `A or B` to po prostu `A` (w rzeczywistości `B` nawet nie jest oceniane),\n"
"w przeciwnym razie to `B`.\n"
"Możesz samemu sprawdzić, że jeśli `A` i `B` są booleanami, to obie definicje są równoważne.\n"
"W tym przykładzie `A` to `name == \"Alice\"`, co jest `False`, więc `A or B` to `B`, które jest `\"Bob\"`.\n"
"\n"
"> Czy jest lepszy sposób na napisanie warunku bez powtarzania `name ==` za każdym razem?\n"
"\n"
"Tak! W [Funkcje i Metody dla List](#FunctionsAndMethodsForLists) wspomnieliśmy o operatorze `in`,\n"
"którego możesz użyć z listą w taki sposób:\n"
"\n"
"__code3__\n"
"\n"
"Ale nie zawsze możesz pozbyć się `or` w ten sposób.\n"
"\n"
"----\n"
"\n"
"Ćwiczenie: Napisz funkcję o nazwie `is_valid_percentage`, przyjmującą jeden argument numeryczny `x`.\n"
"Powinna zwracać `True`, jeśli `x` jest między 0 a 100 (włącznie), oraz zwracać `False` w przeciwnym przypadku.\n"
"Twoja funkcja powinna używać `or` i spełniać te testy:\n"
"\n"
"    __copyable__\n"
"__code4__"

msgid "pages.IntroducingOr.steps.FalseOrFalse.text"
msgstr ""
"Na koniec spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.FurtherImprovement.requirements"
msgstr ""
"Uruchom program z poprzedniego kroku, ale zamień:\n"
"\n"
"__code0__\n"
"\n"
"na:\n"
"\n"
"__code1__"

msgid "pages.IntroducingOr.steps.FurtherImprovement.text"
msgstr ""
"Możemy zrobić jeszcze lepiej. Zauważ, że\n"
"\n"
"__code0__\n"
"\n"
"jest booleanem, i oba `return` zwracają booleany `True` lub `False`.\n"
"Funkcja:\n"
"\n"
" - zwraca `True` gdy `name == \"Alice\" or name == \"Bob\"` jest `True`, oraz\n"
" - zwraca `False` gdy `name == \"Alice\" or name == \"Bob\"` jest `False`.\n"
"\n"
"Więc moglibyśmy po prostu zwrócić boolean `name == \"Alice\" or name == \"Bob\"` jako taki w obu przypadkach!\n"
"\n"
"To jest częsty sposób na uproszczenie twojego kodu. Jeśli kiedykolwiek znajdziesz się w sytuacji pisania kodu takiego jak:\n"
"\n"
"__code1__\n"
"\n"
"gdzie `x` sam w sobie jest booleanem, zawsze możesz uprościć ten blok kodu do:\n"
"\n"
"__code2__\n"
"\n"
"Zastosuj tę uproszczenie do kodu sam, i uruchom go ponownie."

msgid "pages.IntroducingOr.steps.ImprovingWithOr.requirements"
msgstr ""
"Skopiuj program z początku strony, a następnie zmień pierwsze cztery linijki"
" funkcji tak, aby użyć `or` zgodnie z sugestią."

msgid "pages.IntroducingOr.steps.ImprovingWithOr.text"
msgstr ""
"W edytorze zamień:\n"
"\n"
"__code0__\n"
"\n"
"na:\n"
"\n"
"__code1__\n"
"\n"
"Jak widzisz, `is_friend` zwróci `True` tylko wtedy, gdy `name` to Alice lub Bob.\n"
"Operator `or` używany jest między dwoma booleanami `name == \"Alice\"` i `name == \"Bob\"`."

msgid "pages.IntroducingOr.steps.InputAliceBob.text"
msgstr ""
"Dowiedzieliśmy się o *booleanach* (`True` i `False`), gdy wprowadzaliśmy instrukcje warunkowe If.\n"
"Nauczyliśmy się również o operatorach porównujących `==`, `<`, `>`, `<=`, `>=`, które zwracają booleany.\n"
"Teraz chcemy połączyć booleany, aby sprawdzać bardziej złożone warunki.\n"
"\n"
"Oto prosty przykład: wyobraź sobie, że masz dwóch przyjaciół, Alice i Boba.\n"
"Funkcja poniżej przyjmuje jeden parametr, `name`, i sprawdza, czy osoba o danym imieniu jest wśród twoich przyjaciół.\n"
"Skopiuj i uruchom kod w edytorze:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingOr.steps.InspectWithBirdseye.requirements"
msgstr "Uruchom ten sam kod co w poprzednim kroku, ale użyj `birdseye`."

msgid "pages.IntroducingOr.steps.InspectWithBirdseye.text"
msgstr ""
"Drugi i trzeci test zawiodły! Nasza funkcja wydaje się robić coś nie tak:\n"
"zwraca `\"Bob\"` (łańcuch znaków, a nie boolean!) gdy `name` to `\"Bob\"` lub `\"Charlie\"`. Co się dzieje?\n"
"Uruchom ten sam problematyczny kod ponownie z `birdseye`. Dokładnie sprawdź instrukcje `return` każdego wywołania `is_friend`.\n"
"(Użyj niebieskich przycisków ze strzałką)"

msgid "pages.IntroducingOr.steps.TrueOrFalse.text"
msgstr ""
"Dobrze, teraz spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.TrueOrTrue.text"
msgstr ""
"Zobaczmy, czy możemy to zrobić lepiej.\n"
"Możemy połączyć instrukcje `if` i `elif`, używając **`or`**. `or` jest *operatorem boolean*,\n"
"co znaczy, że jest to operator (tak jak `+` lub `-`), który łączy dwa booleany (`True` lub `False`).\n"
"\n"
"Wyrażenie `A or B` jest `True`, jeśli `A` lub `B` jest `True`, to znaczy jeśli `A` jest `True` lub `B` jest `True`, albo oba.\n"
"Jest `False` tylko wtedy, gdy ani `A` ani `B` nie jest `True`, to znaczy oba są `False`.\n"
"\n"
"Wypróbuj poniższe w konsoli.\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.final_text.text"
msgstr "Dobra robota!"

msgid "pages.IntroducingOr.title"
msgstr "Wprowadzenie do `or`"

msgid "pages.IntroducingStrings.steps.final_text.text"
msgstr ""
"Shell zwraca dokładnie to samo, ponieważ nie ma nic więcej do obliczenia. `'hello'` po prostu równa się `'hello'`.\n"
"\n"
"Znak to pojedynczy symbol taki jak litera, cyfra, znak interpunkcyjny, spacja itd. W tym przypadku łańcuch `hello` zawiera 5 znaków. Apostrofy nie są częścią łańcucha - są tam, żeby pokazać zarówno ludziom, jak i komputerom, że jest to łańcuch składający się z jakichkolwiek znaków pomiędzy apostrofami."

msgid "pages.IntroducingStrings.steps.hello_string.text"
msgstr ""
"Python pozwala na dużo więcej niż tylko obliczenia. W rzeczywistości, nie będziemy zajmować się liczbami czy matematyką przez jakiś czas. Zamiast tego przyjrzymy się *łańcuchom znaków* (ang. strings). Łańcuchy znaków to w zasadzie fragmenty tekstu. Na przykład, wprowadź następujący kod do konsoli, razem z apostrofami (`'`):\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingStrings.title"
msgstr "Wprowadzenie do łańcuchów znaków (ang. Strings)"

msgid "pages.IntroducingTheShell.steps.final_text.text"
msgstr ""
"Doskonale! Kontynuuj eksperymentowanie. Gdy będziesz gotowy, kliknij "
"'Dalej', aby kontynuować."

msgid ""
"pages.IntroducingTheShell.steps.first_expression.messages.anything_else.text"
msgstr ""
"Wspaniale, próbujesz własnych eksperymentów!\n"
"To dobry znak. Kontynuuj w tym duchu.\n"
"Tylko informuję, że ostatecznie musisz wpisać `1+2`, aby książka mogła przejść dalej."

msgid "pages.IntroducingTheShell.steps.first_expression.text"
msgstr ""
"Po prawej stronie znajduje się *shell*. To miejsce do uruchamiania niewielkich fragmentów kodu Pythona. Wystarczy wpisać jakiś kod, nacisnąć enter, i to wszystko działa! Spróbuj teraz:\n"
"\n"
"1. Kliknij gdziekolwiek na shellu (czarny obszar).\n"
"2. Wpisz `__program__`\n"
"3. Naciśnij klawisz Enter na klawiaturze."

msgid "pages.IntroducingTheShell.steps.more_calculation.requirements"
msgstr ""
"Uruchom kod w shellu podobny do `1 + 2`, ale zamiast `+` użyj `*`, `/`, lub "
"`-`."

msgid ""
"pages.IntroducingTheShell.steps.more_calculation.special_messages.multiply_with_x.text"
msgstr ""
"Widzę 'x'. Jeśli próbujesz mnożyć, użyj gwiazdki, np.:\n"
"\n"
"__code0__"

msgid "pages.IntroducingTheShell.steps.more_calculation.text"
msgstr ""
"Świetnie! Python wykonał `1+2` i otrzymał wynik `3`, więc shell to wyświetlił.\n"
"\n"
"Shell to prawdopodobnie najważniejsze narzędzie do nauki Pythona i powinieneś spędzać dużo czasu na eksperymentowaniu i odkrywaniu go. Bądź ciekawy! Nieustannie zadawaj sobie pytanie \"Co by się stało, gdybym uruchomił X?\" i natychmiast odpowiadaj na to pytanie, uruchamiając to. Nigdy nie bój się próbować czegoś nowego - jeśli zrobisz coś nie tak, nic złego się nie stanie.\n"
"\n"
"Spróbuj teraz wykonać więcej obliczeń. Możesz mnożyć liczby używając `*`, dzielić za pomocą `/`, a odejmować z `-`. Możesz także użyć nawiasów, czyli `(` i `)`."

msgid "pages.IntroducingTheShell.title"
msgstr "Wprowadzenie do shella"


msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.0.text"
msgstr ""
"You can start by imitating `row_winner` above, then change it to make it "
"work with columns."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.1.text"
msgstr "You can't loop through the columns of `board` as simply as its rows."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.10.text"
msgstr ""
"Define a boolean for each column, then update it accordingly inside the "
"inner loop."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.11.text"
msgstr "The rest of the logic is very similar to `row_winner`."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.12.text"
msgstr "Watch out for `' '`."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.13.text"
msgstr "Remember to return `False` at the end if needed."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.2.text"
msgstr ""
"What *is* a column of a nested list? The first column consists of the first "
"element of the first row, the first element of the second row, etc."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.3.text"
msgstr ""
"Looping through all columns means looking at the first element of every row,"
" then the second element of every row, etc."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.4.text"
msgstr ""
"So you need to loop through numbers representing the positions first, "
"second, etc."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.5.text"
msgstr "How do you find the number of columns in `board`?"

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.6.text"
msgstr ""
"That covers the outer loop, which goes through each column. Then you need an"
" inner loop to go through each element in the column."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.7.text"
msgstr ""
"The different entries of a column are NOT on the same row. So how can you "
"access them?"

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.8.text"
msgstr ""
"You can loop through rows of the board and find the element corresponding to"
" that row and the current column."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.9.text"
msgstr ""
"To access all the entries of, say, the 5th column, you can loop through all "
"the rows, and access the 5th element in each row."

msgid "pages.IntroducingTicTacToe.steps.column_winner.text"
msgstr ""
"Great job!\n"
"\n"
"Now write a similar function `column_winner` which checks for a winning *column* (a vertical line) of either piece:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Here `O` won in the second column of the second board."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.0.text"
msgstr "How many diagonals are there on a square board of arbitrary size?"

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.1.text"
msgstr ""
"Even if the size of the board changes, the number of diagonals remains the "
"same!"

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.10.text"
msgstr ""
"You can use one loop and check both diagonals at the same time. Or you can "
"use one loop for each diagonal."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.2.text"
msgstr ""
"You can't do something like `middle == board[0][0] and middle == "
"board[2][2]` this time, because you don't know how long a diagonal is."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.3.text"
msgstr ""
"Moreover the two diagonals might not have anything in common like `middle`."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.4.text"
msgstr "First, focus on the diagonal that goes from top left to bottom right."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.5.text"
msgstr "How can you access those entries with double subscripting?"

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.6.text"
msgstr ""
"Do you see a pattern in those double subscripts? Get some paper and pen, "
"work it out on some examples."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.7.text"
msgstr ""
"Now focus on the other diagonal (from top right to bottom left). There is a "
"pattern in the subscripts again, but it's a little bit more difficult."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.8.text"
msgstr "Do you remember negative indexing? It might be helpful here."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.9.text"
msgstr ""
"Once you get the hang of the patterns, use the same ideas from before to "
"check if all entries are equal."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.text"
msgstr ""
"Excellent! That was challenging.\n"
"\n"
"Finally we need to check for winning diagonals. You already wrote a function to do just that in the previous chapter, for 3-by-3 boards:\n"
"\n"
"__code0__\n"
"\n"
"Now write a `diagonal_winner` that works for square boards of any size: 4-by-4, 5-by-5, and so on...\n"
"\n"
"    __copyable__\n"
"__code1__\n"
"\n"
"In the first example, `X` won in the diagonal going from the bottom left to the top right."

msgid "pages.IntroducingTicTacToe.steps.final_text.text"
msgstr ""
"Great work!\n"
"\n"
"Now we have the code to determine a winning state on the board."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.0.text"
msgstr ""
"You need to check every row in the board, so you'll need a loop for that."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.1.text"
msgstr "How can you check if all entries in a row are equal to each other?"

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.10.text"
msgstr "Make sure you return `False` if there are no winning rows"

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.2.text"
msgstr ""
"That's a self contained problem on its own. You can start by forgetting "
"about the whole board and just checking a single row."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.3.text"
msgstr ""
"You could even write a function which just does this, although you don't "
"have to."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.4.text"
msgstr ""
"Since the row could have any size, you'll have to loop all the way through "
"it."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.5.text"
msgstr ""
"For each row, define a boolean. Then loop through that row, updating the "
"boolean accordingly."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.6.text"
msgstr ""
"You can use the first entry `row[0]` in a row to compare all the row entries"
" to it."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.7.text"
msgstr ""
"Think carefully about what the initial value of the boolean should be, and "
"under what conditions you should change its value."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.8.text"
msgstr ""
"After looping through a row, if you determined that all its entries are "
"equal, then return `True` (ending the outer loop early)."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.9.text"
msgstr "Make sure you don't return `True` for a row filled with spaces."

msgid ""
"pages.IntroducingTicTacToe.steps.intro_row_winner.messages.catch_empty_row.text"
msgstr ""
"Keep in mind that some entries might be `' '`. An empty row is not a winning"
" row."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.text"
msgstr ""
"You've done many short exercises solving one little problem. Now we're going to tackle a larger, more complex\n"
"project which will really test your knowledge and require combining many smaller parts together.\n"
"It's going to be so fun!\n"
"\n"
"You will develop a text-based interactive tic-tac-toe game to be played by 2 human players.\n"
"Here is a small preview of what the finished game will look like in play:\n"
"\n"
"      1 2 3\n"
"    1  | |\n"
"      -+-+-\n"
"    2  | |\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"    X to play:\n"
"    1\n"
"    1\n"
"\n"
"      1 2 3\n"
"    1 X| |\n"
"      -+-+-\n"
"    2  | |\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"    O to play:\n"
"    2\n"
"    2\n"
"\n"
"      1 2 3\n"
"    1 X| |\n"
"      -+-+-\n"
"    2  |O|\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"    X to play:\n"
"    1\n"
"    3\n"
"\n"
"      1 2 3\n"
"    1 X| |X\n"
"      -+-+-\n"
"    2  |O|\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"We will break up the project into several small functions, which will be exercises.\n"
"\n"
"You will use many of the concepts you have learned so far: strings,\n"
"nested lists, nested loops, `range`, calling functions within functions, comparisons, and booleans.\n"
"\n"
"Along the way you will also learn some new concepts, including newline characters, types, and `input()`.\n"
"\n"
"Here is a rough outline of the project:\n"
"\n"
"- three functions `row_winner`, `column_winner`,  `diagonal_winner`  that check the whole board for winning rows, columns, and diagonals\n"
"- a function `winner` that checks the whole board for a winner, combining the above functions\n"
"- a function `format_board` that displays the current state of the game\n"
"- a function `play_move` that takes user input to play a move,\n"
"- finally a `play_game` function that puts it all together and runs the game interactively.\n"
"- Later on we will add further improvements.\n"
"\n"
"Let's get started!\n"
"\n"
"As in the last chapter, we will represent the tic-tac-toe board as a nested list of strings.\n"
"For a typical game this will be a 3x3 list, i.e. 3 lists each containing 3 strings, with players represented by `'X'` or `'O'`.\n"
"Empty squares will be represented by a space, i.e. `' '`. For example:\n"
"\n"
"__code0__\n"
"\n"
"However to make things more interesting your code will need to work for square boards of any size\n"
"(4x4, 5x5, etc) where players can be represented by any strings, e.g.\n"
"\n"
"__code1__\n"
"\n"
"Write a function `row_winner` which returns `True` if `board` contains\n"
"a winning row, i.e. a horizontal line which has the same character in all its entries (except `' '`):\n"
"\n"
"    __copyable__\n"
"__code2__\n"
"\n"
"In the second example, `O` wins in the bottom row."

msgid "pages.IntroducingTicTacToe.steps.winner.disallowed.0.message"
msgstr ""
"Your solution should work by calling the three functions. `winner` itself should not do any\n"
"looping, subscripting, etc. It should be very short.\n"
"\n"
"Copy the `row_winner` and other functions and leave them as they are. Don't copy code from them\n"
"into the `winner` function, just call those functions."

msgid "pages.IntroducingTicTacToe.steps.winner.hints.0.text"
msgstr ""
"The solution is quite short! Simply use the three functions correctly."

msgid "pages.IntroducingTicTacToe.steps.winner.hints.1.text"
msgstr ""
"Think about possible cases. When does `winner(board)` return `False`? When "
"does it return `True`?"

msgid "pages.IntroducingTicTacToe.steps.winner.hints.2.text"
msgstr ""
"How can you use the three functions and a boolean operator together to get "
"the result you need?"

msgid "pages.IntroducingTicTacToe.steps.winner.text"
msgstr ""
"Bravo! That was quite tough.\n"
"\n"
"Now we can put the three functions together! Write a function `winner` that takes an argument `board` as before,\n"
"and returns `True` if `board` contains either a winning row, column or diagonal, `False` otherwise.\n"
"\n"
"Your solution should work by calling the three functions. `winner` itself should not do any\n"
"looping, subscripting, etc.\n"
"\n"
"Here is some code for `row_winner`, `column_winner` and `diagonal_winner`, along with some tests for `winner`.\n"
"Click the Copy button, and fill in the blanks for your `winner` function.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingTicTacToe.title"
msgstr "Checking the board for winners"

msgid "pages.IntroducingVariables.steps.final_text.text"
msgstr ""
"Odpowiedź brzmi, że `sunshine` wygląda na zmienną, więc Python próbuje "
"znaleźć jej wartość, ale ponieważ nigdy nie zdefiniowaliśmy zmiennej o tej "
"nazwie, otrzymujemy błąd."

msgid ""
"pages.IntroducingVariables.steps.sunshine_undefined_check.output_prediction_choices.0"
msgstr "sunshine"

msgid ""
"pages.IntroducingVariables.steps.sunshine_undefined_check.output_prediction_choices.1"
msgstr "'sunshine'"

msgid ""
"pages.IntroducingVariables.steps.sunshine_undefined_check.output_prediction_choices.2"
msgstr "Hello"

msgid ""
"pages.IntroducingVariables.steps.sunshine_undefined_check.output_prediction_choices.3"
msgstr "'Hello'"

msgid "pages.IntroducingVariables.steps.sunshine_undefined_check.text"
msgstr ""
"Jak widać, apostrofy są bardzo istotne. `'word'` jest dosłownie tylko `'word'`, stąd technicznie nazywa się to *literałem łańcucha znaków* (ang. string literal). Z drugiej strony, `word` to zmienna, której wartość może być dowolna.\n"
"\n"
"Podobnie, `'sunshine'` to `'sunshine'`, ale co to jest `__program__` bez apostrofów?"

msgid "pages.IntroducingVariables.steps.word_assign.text"
msgstr ""
"Aby tworzyć interesujące programy, nie możemy zawsze manipulować tymi samymi wartościami. Potrzebujemy sposobu na odniesienie się do wartości, które nie są znane z góry i mogą się zmieniać. To właśnie są *zmienne* (ang. variables).\n"
"\n"
"Uruchom ten kod:\n"
"\n"
"__program_indented__"

msgid ""
"pages.IntroducingVariables.steps.word_check.special_messages.bad_word.text"
msgstr ""
"Ups, musisz ustawić `word = 'Hello'` zanim będziemy mogli kontynuować."

msgid "pages.IntroducingVariables.steps.word_check.text"
msgstr ""
"To tworzy zmienną o nazwie `word`, która odnosi się do wartości ciągu znaków `'Hello'`.\n"
"\n"
"Teraz zobacz, co się stanie, gdy uruchomisz jedynie `__program__` w shellu."

msgid ""
"pages.IntroducingVariables.steps.word_string_check.output_prediction_choices.0"
msgstr "word"

msgid ""
"pages.IntroducingVariables.steps.word_string_check.output_prediction_choices.1"
msgstr "'word'"

msgid ""
"pages.IntroducingVariables.steps.word_string_check.output_prediction_choices.2"
msgstr "Hello"

msgid ""
"pages.IntroducingVariables.steps.word_string_check.output_prediction_choices.3"
msgstr "'Hello'"

msgid "pages.IntroducingVariables.steps.word_string_check.text"
msgstr ""
"Dobrze. Dla porównania, uruchom jedynie `__program__` w shellu, z "
"apostrofami."

msgid "pages.IntroducingVariables.title"
msgstr "Wprowadzenie do zmiennych"


msgid "pages.LoopingOverNestedLists.steps.final_text.text"
msgstr ""
"Opanowałeś zagnieżdżone listy i jak je połączyć z zagnieżdżonymi pętlami.\n"
"Brawo! Teraz masz w swoim arsenale bardzo potężne narzędzia programistyczne."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.0.text"
msgstr "To jest bardzo podobne do poprzedniego ćwiczenia."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.1.text"
msgstr "Kiedy powinieneś wydrukować zmienną boolean?"

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.2.text"
msgstr "Pamiętaj, że chcesz wydrukować ją tylko raz."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.3.text"
msgstr ""
"Zamiast definiować zmienną boolean dla każdej podlisty, zdefiniuj tylko "
"jedną zmienną boolean dla całej listy."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.4.text"
msgstr "Kiedy i jak powinieneś modyfikować zmienną boolean?"

msgid "pages.LoopingOverNestedLists.steps.list_contains_word_exercise.text"
msgstr ""
"Dobra robota!\n"
"\n"
"Następnie, wydrukuj tylko jeden boolean, aby wskazać, czy `word` jest obecne w jakimkolwiek ciągu całej zagnieżdżonej listy. Na przykład, jeśli\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"twój program powinien wypisać `False`."

msgid ""
"pages.LoopingOverNestedLists.steps.nested_list_loop_python_tutor.requirements"
msgstr ""
"Uruchom pojedynczy program składający się z dwóch powyższych części połączonych.\n"
"Są one oddzielone, aby nie musieć wpisywać części `numbers = [...]`,\n"
"ale wpisanie części z zagnieżdżoną pętlą jest najlepsze dla nauki.\n"
"Upewnij się, że wcięcia są poprawne."

msgid "pages.LoopingOverNestedLists.steps.nested_list_loop_python_tutor.text"
msgstr ""
"Teraz uruchom ten sam program ponownie w Python Tutor.\n"
"\n"
"Zbadaj, jak wygląda `numbers` i co oznaczają `numbers[0]` aż do `numbers[3]`.\n"
"Spójrz, jak zmieniają się zmienne `sublist` i `num`."

msgid ""
"pages.LoopingOverNestedLists.steps.nested_list_nested_loop_example.requirements"
msgstr ""
"Uruchom pojedynczy program składający się z dwóch powyższych części połączonych.\n"
"Są one oddzielone, aby nie musieć wpisywać części `numbers = [...]`,\n"
"ale wpisanie części z zagnieżdżoną pętlą jest najlepsze dla nauki.\n"
"Upewnij się, że wcięcia są poprawne."

msgid ""
"pages.LoopingOverNestedLists.steps.nested_list_nested_loop_example.text"
msgstr ""
"Możesz użyć zagnieżdżonej pętli do iteracji przez każdy element i pod-element zagnieżdżonej listy.\n"
"Na przykład, rozważ taką zagnieżdżoną listę.\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Kliknij przycisk, aby skopiować listę do edytora, a następnie wpisz następującą zagnieżdżoną pętlę.\n"
"\n"
"__code1__\n"
"\n"
"Przyjrzyj się uważnie kodowi. Zauważ, że zewnętrzna pętla tworzy zmienną `sublist`\n"
"i wewnętrzna pętla iteruje przez tę samą zmienną. To jest często używany wzorzec.\n"
"Teraz uruchom kod."

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.0.text"
msgstr "Jak sprawdzić, czy ciąg zawiera słowo?"

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.1.text"
msgstr ""
"Upewnij się, że sprawdzasz, czy **ciąg tekstowy** zawiera słowo, a nie "
"podlista."

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.2.text"
msgstr ""
"Jak można uzyskać dostęp do każdego ciągu w każdej podliście zagnieżdżonej "
"listy?"

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.3.text"
msgstr "Musisz użyć zagnieżdżonej pętli."

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.4.text"
msgstr ""
"Pętle powinny podążać za tym samym wzorcem co przykład na początku strony."

msgid "pages.LoopingOverNestedLists.steps.string_contains_word_exercise.text"
msgstr ""
"Teraz rozwiążmy kilka problemów, używając tego rodzaju pętli.\n"
"\n"
"Załóżmy, że mamy zagnieżdżoną listę ciągów tekstowych jak poniższa,\n"
"i chcemy szukać konkretnego `word` głęboko w listach.\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Możesz wyobrazić sobie, że `strings` reprezentuje książkę, gdzie każda podlista to strona i każdy ciąg znaków wewnątrz\n"
"to linia na tej stronie.\n"
"Może to również reprezentować bibliotekę, gdzie każda lista to książka, a każdy ciąg znaków to strona.\n"
"\n"
"Napisz program, który wydrukuje każdy ciąg zawierający `word`.\n"
"Powinno to działać dla dowolnego `word` i `strings`. Dla przykładu powyżej, powinien wydrukować\n"
"\n"
"    hello there\n"
"    hello world\n"
"\n"
"Pamiętaj, że istnieje konkretny sposób na sprawdzenie, czy ciąg zawiera inny ciąg. Jeśli nie pamiętasz jak, poszukaj w Google!"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.0.text"
msgstr "Dla każdej podlisty zdefiniuj zmienną boolean."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.1.text"
msgstr "Przechodząc przez podlistę, aktualizuj zmienną boolean odpowiednio."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.2.text"
msgstr "Wydrukuj zmienną boolean tylko raz dla każdej podlisty."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.3.text"
msgstr "Jaka powinna być początkowa wartość dla zmiennej boolean?"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.4.text"
msgstr ""
"Co jeśli jedna z podlist jest pusta? Co powinieneś wydrukować dla tej "
"podlisty?"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.5.text"
msgstr ""
"Jeśli znajdziesz słowo w ciągu, zmienna boolean powinna zostać ustawiona na "
"`True`."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.6.text"
msgstr "Co jeśli ciąg nie zawiera słowa?"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.7.text"
msgstr "Nie szkodzi! To nie zmienia faktu, że inny ciąg może zawierać słowo."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.8.text"
msgstr ""
"Innymi słowy, nie ustawiaj zmiennej boolean na `False` oprócz na początku."

msgid "pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.text"
msgstr ""
"Super!\n"
"\n"
"Teraz zmieńmy nieco ćwiczenie. Tym razem wyjście powinno powiedzieć nam, które *podlisty* zawierają `word`,\n"
"zamiast tego, które wewnętrzne ciągi. W szczególności chcemy wydrukować boolean dla każdej podlisty:\n"
"`True`, jeśli podlista zawiera słowo w którymkolwiek z jej ciągów, `False`, jeśli go tam wcale nie ma.\n"
"\n"
"Mając te przykładowe dane wejściowe:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"twój program powinien wypisać\n"
"\n"
"__code1__\n"
"\n"
"Zauważ, że `word in sublist` nie zadziała. Na przykład, `\"hello\" in [\"hello there\", \"how are you\"]` jest `False`\n"
"ponieważ `\"hello\"` nie jest *równa* żadnemu z dwóch elementów tej listy, mimo że znajduje się w jednym z nich."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.0.text"
msgstr "Ponieważ ciągi mogą mieć różne długości, to jest trochę trudne."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.1.text"
msgstr "Jak długo powinna trwać twoja zewnętrzna pętla tym razem?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.2.text"
msgstr ""
"Zanim zaczniesz obsługiwać ciągi, może być dobrym pomysłem najpierw znaleźć "
"najdłuższą długość ciągu."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.3.text"
msgstr "Reszta jest bardzo podobna do poprzedniego ćwiczenia."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.4.text"
msgstr ""
"Jedyna różnica polega na tym, że teraz musisz zdecydować, czy dodać literę z"
" ciągu, czy spację."

msgid "pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.text"
msgstr ""
"Świetnie! Jeśli chcesz, możesz już teraz przejść do [następnej strony](#DefiningFunctions).\n"
"Albo możesz spróbować dodatkowego wyzwania!\n"
"\n"
"Teraz uogólnijmy poprzednie ćwiczenie do ciągów o różnej długości. Znowu masz daną listę ciągów tekstowych.\n"
"Tak jak poprzednio, napisz program, który wydrukuje pierwszą literę każdego ciągu razem w jednej linii,\n"
"następnie drugie litery razem w następnej linii i tak dalej.\n"
"Ale tym razem, jeśli ciąg nie ma wystarczającej liczby liter, powinien wydrukować spację.\n"
"\n"
"Na przykład, jeśli\n"
"\n"
"    __no_auto_translate__\n"
"    strings = [\"abcqwe\", \"def\", \"ghiq\"]\n"
"\n"
"twój program powinien wypisać\n"
"\n"
"    adg\n"
"    beh\n"
"    cfi\n"
"    q q\n"
"    w\n"
"    e"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.0.text"
msgstr "To NIE jest podobne do poprzednich ćwiczeń na tej stronie."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.1.text"
msgstr ""
"Pomyśl o rozwiązaniu, gdy są tylko dwa ciągi. Jak możesz uogólnić to do "
"listy ciągów?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.2.text"
msgstr "Musisz przejść przez pierwsze litery, następnie drugie litery itd."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.3.text"
msgstr "Będziesz musiał użyć pętli, ale jak długo powinna trwać pętla?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.4.text"
msgstr "Pamiętaj, że ciągi na liście mają równe długości."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.5.text"
msgstr ""
"Dla każdej pozycji (pierwszej, drugiej itd.) zdefiniuj nowy ciąg tekstowy."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.6.text"
msgstr "Jaki powinien być początkowo ten ciąg tekstowy?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.7.text"
msgstr ""
"Dla każdej pozycji (pierwszej, drugiej itd.) będziesz musiał przejść przez "
"każdy ciąg na liście."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.8.text"
msgstr "Będziesz potrzebował kolejnej pętli wewnątrz tej, którą już masz."

msgid "pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.text"
msgstr ""
"Świetnie!\n"
"\n"
"[Wcześniej w kursie](#GettingElementsAtPositionExercises) było ćwiczenie\n"
"na wydrukowanie dwóch ciągów tekstowych pionowo, obok siebie, jak niżej:\n"
"\n"
"    H W\n"
"    e o\n"
"    l r\n"
"    l l\n"
"    o d\n"
"\n"
"Teraz będziemy to uogólniać do listy ciągów, a nie tylko dwóch.\n"
"\n"
"W tym ćwiczeniu otrzymujesz listę ciągów tekstowych o **równej długości**.\n"
"Napisz program, który wydrukuje pierwszą literę każdego ciągu w jednej linii,\n"
"następnie drugą literę każdego ciągu w następnej linii i tak dalej. Na przykład, jeśli\n"
"\n"
"__code0__\n"
"\n"
"twój program powinien wypisać\n"
"\n"
"    __no_auto_translate__\n"
"    adg\n"
"    beh\n"
"    cfi\n"
"\n"
"Twój program powinien działać dla dowolnej takiej listy. Szczególnie jeśli użyjesz następującej listy,\n"
"odkryjesz ukrytą wiadomość z Zen Pythona!\n"
"\n"
"    __copyable__\n"
"    __no_auto_translate__\n"
"    strings = [\"  b n\", \"f ete\", \"liths\", \"astat\", \"t ene\", \"  r d\"]\n"
"\n"
"Zauważ, że tym razem nie powinieneś dodawać spacji między literami w wyjściu."

msgid "pages.LoopingOverNestedLists.title"
msgstr "Iterowanie po zagnieżdżonych listach"

msgid "pages.MakingTheBoard.steps.final_text.text"
msgstr ""
"Well done!\n"
"\n"
"This could be solved by moving the first loop inside the second to make a new `row` each time:\n"
"\n"
"__code0__\n"
"\n"
"Another way is to make a copy of `row` each time, e.g. keep the original code but change one line:\n"
"\n"
"__code1__\n"
"\n"
"You can also copy `row` with `row[:]` or `list(row)`. But it's important to know that\n"
"all these methods make a *shallow copy* of the list.\n"
"That means they copy the whole list at the top level, without making copies of each element.\n"
"That's fine in this case where `row` only contains strings which can't be modified\n"
"and don't need copying. But if the elements are mutable objects like lists,\n"
"as is the case with `board`, you may run into the same problem again.\n"
"Here's an example:\n"
"\n"
"    __copyable__\n"
"__code2__\n"
"\n"
"Here each element of `cube` is a separate list, a copy of `board`.\n"
"And within each of those copies, each element is also a separate list, a copy of `row`.\n"
"But the shallow copies of `board` all have the same first element as each other (the first copy of `row`),\n"
"the same second element, and so on.\n"
"Changing `make_board` won't fix anything here, the solution is to either:\n"
"\n"
"- Call `make_board` repeatedly to make a new `board` each time, or\n"
"- Use the `deepcopy` function instead of `board.copy()`.\n"
"  `deepcopy` makes copies at every level of nested objects.\n"
"\n"
"If you're still confused, don't worry.\n"
"This is just preparing you to deal with your code behaving weirdly in the future.\n"
"You're not required to understand this right now and this lesson will still be valuable.\n"
"\n"
"Either way, we're ready to make the full game. You can do it!"

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.0.text"
msgstr "The existing code is almost correct."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.1.text"
msgstr "There are several ways to solve this."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.2.text"
msgstr "Some solutions involve adding something small."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.3.text"
msgstr ""
"You can also rearrange the code without adding or removing anything (except "
"spaces)."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.4.text"
msgstr "The problem is that a single list `row` is used several times."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.5.text"
msgstr ""
"So one solution is to make copies of `row` which will all be separate."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.6.text"
msgstr "Another solution is to make a new `row` from scratch each time."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.7.text"
msgstr ""
"There are a few ways to copy a list in Python with a tiny bit of code."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.8.text"
msgstr "Making a new row each time can be done by just rearranging the code."

msgid ""
"pages.MakingTheBoard.steps.fix_make_board.special_messages.not_separate.text"
msgstr "However, the sublists in the result are not all separate objects."

msgid "pages.MakingTheBoard.steps.fix_make_board.text"
msgstr ""
"Can you see what happened?\n"
"\n"
"Every row got an `'X'` in the first position!\n"
"It's as if the code actually did this:\n"
"\n"
"__code0__\n"
"\n"
"Try and figure out what's wrong by yourself.\n"
"But again, it's tricky, so don't drive yourself crazy over it.\n"
"\n"
"If you want, here's some hints:\n"
"\n"
" - Try running the code through some debuggers.\n"
" - Experiment. Make changes to the code and see what happens.\n"
" - No, the code didn't do 3 assignments like I suggested above. There was just one list assignment.\n"
" - There's no hidden loops or anything.\n"
" - How many lists does `board` contain? 3?\n"
" - The previous page has a subtle hint at what happened.\n"
" - There is a page from a previous chapter where this kind of problem is explained directly.\n"
" - Specifically [this page](#EqualsVsIs).\n"
" - Try running the code with Python Tutor.\n"
"\n"
"OK, if you're ready, here's the answer.\n"
"\n"
"The list `row` was only created once, and reused several times.\n"
"`board` contains the same list three times. Not copies, just one list in three places.\n"
"It's like it did this:\n"
"\n"
"__code1__\n"
"\n"
"Which means that this code:\n"
"\n"
"__code2__\n"
"\n"
"is equivalent to:\n"
"\n"
"__code3__\n"
"\n"
"which affects 'all the lists' in `board` because they're all just the one list `row`.\n"
"In other words, the above line is *also* equivalent to each of these two lines:\n"
"\n"
"__code4__\n"
"\n"
"because `row` is `board[0]`, `board[1]`, and `board[2]` all at once.\n"
"\n"
"Your job now is to fix `make_board` to not have this problem.\n"
"It should still return a list of length `size` where each\n"
"element is also list of length `size` where each element is the string `' '`.\n"
"The sublists should all be separate list objects, not the same\n"
"list repeated."

msgid "pages.MakingTheBoard.steps.naive_make_board.text"
msgstr ""
"So far the board has been provided for you as a nested list.\n"
"But for the full program, you need to create it yourself.\n"
"Should be easy, right? Here's some code to do that:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"It's close, but there's a subtle problem with it.\n"
"Make sure you understand the code,\n"
"and bonus points if you can spot the bug!\n"
"If not, don't feel bad or waste too much time on it."

msgid "pages.MakingTheBoard.title"
msgstr "Making the Board"

msgid "pages.ModifyingWhileIterating.steps.final_text.text"
msgstr ""
"Powtórzmy raz jeszcze, ***nigdy nie modyfikuj czegoś podczas iteracji nad tym***. Twoje opcje to:\n"
"\n"
"- Modyfikuj kopię\n"
"- Iteruj przez kopię\n"
"- Nie modyfikuj niczego, zamiast tego stwórz nową wersję."

msgid "pages.ModifyingWhileIterating.steps.make_copy.requirements"
msgstr ""
"Uruchom ten sam program co wyżej, ale zmień drugą linię:\n"
"\n"
"__code0__\n"
"\n"
"na:\n"
"\n"
"__code1__\n"
"\n"
"czyli dodaj `.copy()` po `numbers`, ale przed `:`."

msgid "pages.ModifyingWhileIterating.steps.make_copy.text"
msgstr ""
"Ale okazuje się, że robi to niemal to samo - nie kończy się błędem, ale nadal nie usuwa 7 ani 3.\n"
"Dzieje się tak z tego samego powodu - iteracja przez listę wciąż odbywa się pod spodem przez indeksy.\n"
"\n"
"Morał z tego taki aby ***nigdy nie modyfikować czegoś, po czym się iteruje***. Oddzielaj mutację i iterację.\n"
"\n"
"Dobra wiadomość jest taka, że istnieje wiele innych sposobów aby do tego podejść. Możesz zamiast tego po prostu iterować przez kopię, jak tutaj:\n"
"\n"
"__code0__"

msgid "pages.ModifyingWhileIterating.steps.make_copy2.text"
msgstr ""
"Teraz lista, która jest modyfikowana i lista, która jest iterowana, to oddzielne obiekty, nawet jeśli zaczynają z równą zawartością.\n"
"\n"
"Podobnie, możesz iterować przez oryginał i modyfikować kopię:\n"
"\n"
"__program_indented__"

msgid "pages.ModifyingWhileIterating.steps.make_new_list.text"
msgstr ""
"Albo możesz zbudować nową listę od zera. Zrobiliśmy już coś podobnego w ćwiczeniu:\n"
"\n"
"__program_indented__"

msgid "pages.ModifyingWhileIterating.steps.remove_instead_of_pop.text"
msgstr ""
"W trakcie działania programu widać, że nawet nie bierze pod uwagę 7 lub 3 i nie usuwa ich. Na końcu kończy się niepowodzeniem, kiedy próbuje uzyskać dostęp do indeksu, który jest za wysoki. Czy rozumiesz, dlaczego się tak dzieje?\n"
"\n"
"Zmienna indeksowa `i` przechodzi przez typowe wartości 0, 1, 2, ... jak powinna, ale w miarę zmiany listy te pozycje już nie są tymi, których chcemy. Na przykład w pierwszej iteracji `i` jest 0 i `number` to 10, który zostaje usunięty. Przesuwa to pozostałe numery o jedną pozycję w lewo, więc teraz 7 jest na pozycji 0. Ale w następnej iteracji `i` jest 1, a `numbers[i]` to 8. 7 został pominięty.\n"
"\n"
"Moglibyśmy spróbować napisać program używając `remove` zamiast `pop`, aby nie korzystać z indeksów. Nawet wygląda to ładniej w ten sposób.\n"
"\n"
"__program_indented__"

msgid "pages.ModifyingWhileIterating.steps.run_broken_with_python_tutor.text"
msgstr ""
"Spójrz na ten program. Przeszukuje on listę liczb i usuwa te mniejsze niż 10. Przynajmniej próbuje to zrobić.\n"
"Uruchom go z Python Tutor.\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"(pamiętaj, że `numbers.pop(i)` usuwa element z `numbers` o indeksie `i`)"

msgid "pages.ModifyingWhileIterating.title"
msgstr "Modyfikowanie podczas iteracji"

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno zawierać dokładnie trzy instrukcje: `x = [15, 12, "
"-6, 3]`, `y = ` stanowione przez jedną linię dokładnie skopiowaną z listy, i"
" `print(y)`."

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.1.text"
msgstr ""
"Jeśli nie jesteś pewien, sprawdź, jak oblicza się średnią/średnią "
"arytmetyczną."

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.2.text"
msgstr "Do obliczenia średniej liczb w `x` potrzebujemy dwóch rzeczy."

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.3.text"
msgstr "Które dwie funkcje/metody dają ci te dwie rzeczy?"

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.4.text"
msgstr "Jak połączyć te dwie rzeczy, aby obliczyć średnią?"

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.requirements"
msgstr ""
"Skopiuj trzy linie powyżej, a następnie zastąp "
"`(insert_one_line_from_above)` dokładnie jedną linią z długiej listy linii "
"powyżej. Środkowa linia powinna nadal zaczynać się od `y = `."

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.text"
msgstr ""
"Dobra robota! Do następnego ćwiczenia zacznij od tego niekompletnego programu:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Zastąp partię po `y = ` jedną linią z listy powyżej.\n"
"Końcowy program powinien wydrukować średnią (technicznie *średnią arytmetyczną*) liczb w `x`."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno zawierać dokładnie trzy instrukcje: `x = ['a', "
"'b', 'c']`, `y = ` stanowione przez jedną linię dokładnie skopiowaną z "
"listy, i `print(y)`."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.1.text"
msgstr "Kiedy `1 in x` jest prawdziwe?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.2.text"
msgstr "Kiedy `1` jest w `x`!"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.3.text"
msgstr "Może to być, że `1` jest na `x` raz, albo dwa razy, albo trzy razy..."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.4.text"
msgstr "...ale nie zero razy!"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.requirements"
msgstr ""
"Skopiuj trzy linie powyżej, a następnie zastąp `1 in x` dokładnie jedną "
"linią z długiej listy linii powyżej. Środkowa linia powinna nadal zaczynać "
"się od `y = `. Wybrana linia powinna mieć taki sam efekt jak `1 in x`, aby "
"program wydrukował `True`."

msgid "pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.text"
msgstr ""
"Możesz rozpoznać niektóre z nich z poprzednich ćwiczeń. Zapewniam, że te ćwiczenia nie były bezcelowe,\n"
"ponieważ nauczyłeś się teraz cennych podstawowych umiejętności. Na przykład, możesz użyć `in` do sprawdzenia, czy lista zawiera 5,\n"
"ale nie ma podobnie łatwego sposobu na sprawdzenie, czy w liście jest liczba większa niż 5.\n"
"\n"
"Teraz rozwiążesz kolejny zestaw czterech ćwiczeń dotyczących tych nowych pojęć.\n"
"Znowu, poprawne i niepoprawne linie kodu są ze sobą wymieszane,\n"
"i musisz wybrać poprawną linię z listy.\n"
"\n"
"__code0__\n"
"\n"
"Oto program:\n"
"\n"
"    __copyable__\n"
"__code1__\n"
"\n"
"Zastąp część `1 in x` (zostaw `y = `) jedną linią z listy powyżej, która robi to samo."

msgid "pages.MoreListFunctionsAndMethods.steps.count_predict_exercise.text"
msgstr ""
"**`count`**: Zwraca liczbę wystąpień argumentu na liście używając składni\n"
"\n"
"__code0__\n"
"\n"
"Na przykład uruchom tę linię w shellu:\n"
"\n"
"__program_indented__"

msgid "pages.MoreListFunctionsAndMethods.steps.final_text.text"
msgstr "Gratulacje! Jesteś teraz mistrzem metod i funkcji list!"

msgid "pages.MoreListFunctionsAndMethods.steps.in_predict_exercise.text"
msgstr ""
"**`in`**: Operator porównania, który sprawdza, czy wartość znajduje się na liście, używając składni\n"
"\n"
"__code0__\n"
"\n"
"Na przykład uruchom ten program:\n"
"\n"
"__program_indented__"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno zawierać dokładnie trzy instrukcje: `x = [12, -6, "
"2, -1, 3]`, `y = ` stanowione przez jedną linię dokładnie skopiowaną z "
"listy, i `print(y)`."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.1.text"
msgstr ""
"Liczby w `x` wydają się być wszystkie pomieszane. Czy możesz z tym coś "
"zrobić?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.2.text"
msgstr ""
"Jeśli to zrozumiałeś, spróbuj użyć tej funkcji w shellu, aby pobawić się "
"nią."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.3.text"
msgstr ""
"Jak użyjesz tej funkcji, aby uzyskać najmniejszą wartość na liście? A "
"największą?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.4.text"
msgstr "Potem jak możesz uzyskać *drugą* najmniejszą wartość?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.requirements"
msgstr ""
"Skopiuj trzy linie powyżej, a następnie zastąp "
"`(insert_one_line_from_above)` dokładnie jedną linię z długiej listy linii "
"powyżej. Środkowa linia powinna nadal zaczynać się od `y = `."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.text"
msgstr ""
"Doskonale. I ostatnie:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Zastąp partię po `y = ` jedną linią z listy powyżej.\n"
"Końcowy program powinien wydrukować *drugą najmniejszą wartość* w `x`."

msgid "pages.MoreListFunctionsAndMethods.steps.sorted_predict_exercise.text"
msgstr ""
"Oto kilka bardziej użytecznych funkcji/metod.\n"
"\n"
"**`sorted`**: Bierze iterowalny obiekt i zwraca listę elementów w kolejności od najmniejszego do największego, używając składni\n"
"\n"
"__code0__\n"
"\n"
"Na przykład uruchom tę linię w shellu:\n"
"\n"
"__program_indented__"

msgid "pages.MoreListFunctionsAndMethods.steps.sum_predict_exercise.text"
msgstr ""
"**`sum`**: Sumuje iterowalny zbiór liczb używając składni\n"
"\n"
"__code0__\n"
"\n"
"Na przykład uruchom tę linię w shellu:\n"
"\n"
"__program_indented__"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.hints.0.text"
msgstr ""
"Twoje rozwiązanie powinno zawierać dokładnie trzy instrukcje: `x = 100`, `y "
"= ` stanowione przez jedną linię dokładnie skopiowaną z listy, i `print(y)`."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.hints.1.text"
msgstr "Jaką funkcję/metodę można użyć do sumowania rzeczy?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.hints.2.text"
msgstr "Która funkcja/metoda daje nam liczby `1, 2, 3, ..., x`?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.hints.3.text"
msgstr ""
"Musisz wprowadzić małą zmianę, inaczej ta ostatnia liczba `x` zostanie "
"pominięta."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.requirements"
msgstr ""
"Skopiuj trzy linie powyżej, a następnie zastąp "
"`(insert_one_line_from_above)` dokładnie jedną linię z długiej listy linii "
"powyżej. Środkowa linia powinna nadal zaczynać się od `y = `."

msgid "pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.text"
msgstr ""
"Dobra robota! Do następnego ćwiczenia zacznij od tego niekompletnego programu:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Zastąp partię po `y = ` jedną linią z listy powyżej.\n"
"Końcowy program powinien wydrukować wynik sumowania wszystkich liczb od `1` do `x` włącznie, czyli `1 + 2 + 3 + ... + x`."

msgid "pages.MoreListFunctionsAndMethods.title"
msgstr "Więcej Funkcji i Metod List"

msgid "pages.MoreOnReturn.steps.break_vs_return.requirements"
msgstr ""
"Uruchom ten sam kod co w poprzednim kroku, ale zastąp całą ostatnią linię "
"funkcji (`return letter`) tylko instrukcją `break`."

msgid "pages.MoreOnReturn.steps.break_vs_return.text"
msgstr ""
"Jak już wcześniej, `return` ***zatrzymuje całą funkcję***, łącznie z wszelkimi pętlami.\n"
"\n"
"Wcześniej pokazywaliśmy [jak zatrzymać pętlę za pomocą `break`](#UsingBreak).\n"
"Zmien `return letter` na `break` i zobacz jaka jest różnica."

msgid "pages.MoreOnReturn.steps.cannot_return_multiple_values.text"
msgstr ""
"Po wykonaniu instrukcji `return`, funkcja zostaje zakończona, a dalsza część kodu jest ignorowana.\n"
"Oznacza to, że jakikolwiek kod bezpośrednio po `return` w tym samym bloku jest *nieosiągalny*:\n"
"`return 2` nigdy nie może zostać osiągnięty, bez względu na to, ile razy uruchomimy tę funkcję!\n"
"\n"
"***Tylko jeden `return` może być wykonany na wywołanie funkcji, a następnie wykonywanie zostaje zatrzymane.***\n"
"\n"
"Wielokrotne instrukcje `return` mogą być jednak użyteczne, jeśli są stosowane we właściwy sposób, np. w bloku `if-else`:\n"
"\n"
"__code0__\n"
"\n"
"Typowym błędem jest niezrozumienie działania `return` w pętlach `for`. Wypróbuj następujący kod:\n"
"\n"
"    __copyable__\n"
"__code1__"

msgid "pages.MoreOnReturn.steps.double_return_in_one_function.text"
msgstr ""
"Czasami słowo kluczowe `return` może być źródłem zamieszania i błędów wśród początkujących.\n"
"Nauczmy się więcej na ten temat.\n"
"\n"
"Uruchom ten kod:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.MoreOnReturn.steps.final_text.text"
msgstr ""
"W przeciwieństwie do `return`, `break` zatrzymuje tylko najbardziej wewnętrzną pętlę, w której jest użyty, w tym przypadku `for number in range(3):`.\n"
"Oto, co dokładnie się dzieje:\n"
"\n"
"- Dla `letter = b`, linia `print(f\"{letter} {number}\")` jest wykonana tylko dla `number = 0`,\n"
"- następnie wewnętrzna pętla jest zatrzymywana przez `break`, ale\n"
"- zewnętrzna pętla kontynuuje swoje wykonanie, przechodząc do następnej litery `c`\n"
"- która jest wykonywana w pełni, ponieważ nie powoduje aktywacji instrukcji `break`."

msgid "pages.MoreOnReturn.steps.return_ends_whole_function.text"
msgstr ""
"Na pierwszy rzut oka może się wydawać intuicyjne, by `return` zwracał jedną wartość dla każdej iteracji w pętli `for`.\n"
"Ale to nie działa w ten sposób!\n"
"Jeśli przeanalizujesz kod za pomocą `snoop` lub Python tutor, zobaczysz, że funkcja zwraca 2 w pierwszej\n"
"iteracji pętli, a następnie kończy się natychmiast.\n"
"\n"
"Nawet gdy jest tylko jedna instrukcja `return`, zostanie ona wykonana tylko raz i zwróci jedną wartość.\n"
"Jeśli chcesz zwrócić kilka wartości, zwróć listę:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Co się stanie, jeśli są zagnieżdżone pętle? Wypróbuj następującą funkcję:\n"
"\n"
"    __copyable__\n"
"__code1__"

msgid "pages.MoreOnReturn.title"
msgstr "`return` kończy wywołanie funkcji"

msgid "pages.MultiLineExpressions.steps.final_text.text"
msgstr ""
"So if you get a mysterious `SyntaxError`, make sure that you haven't "
"improperly broken up any lines!"

msgid "pages.MultiLineExpressions.steps.invalid_multiline.program"
msgstr ""
"is_friend = name == \"Alice\" or\n"
"            name == \"Bob\""

msgid "pages.MultiLineExpressions.steps.invalid_multiline.text"
msgstr ""
"Our code lines are starting to get quite long.\n"
"Thankfully Python offers a few ways to spread out one statement across many lines,\n"
"but it's not automatic. You have to make sure Python understands that's what you're doing.\n"
"For example, this code is invalid syntax and will give you an error:\n"
"\n"
"__program_indented__"

msgid "pages.MultiLineExpressions.steps.valid_multiline.text"
msgstr ""
"Python tries to intepret this as two separate lines of code and gets confused. You need to tell it that\n"
"the first line is continuing onto the second line.\n"
"\n"
"One way to do this is by adding `\\` at the end of the line to 'escape' the line break.\n"
"\n"
"Another way is to ensure that the line break is contained within some kind of brackets. Then the line\n"
"continuation is implied because Python will wait till all brackets have been closed before\n"
"considering a line to be complete. If you already have brackets because for example you're calling a function\n"
"or making a list, you may not need to do anything! Otherwise you can add brackets to any expression\n"
"to imply the line continuation.\n"
"\n"
"Here are some examples. Pay close attention to the details.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.MultiLineExpressions.title"
msgstr "Multi-line statements"

msgid "pages.NavigatingShellHistory.steps.final_text.text"
msgstr ""
"Oto wskazówka: często będziesz chciał ponownie uruchomić wcześniej "
"wprowadzony kawałek kodu lub jego nieco zmodyfikowaną wersję. Możesz "
"skopiować i wkleić, ale to żmudne i przeszkadza w eksperymentowaniu. Lepszą "
"metodą jest naciśnięcie strzałki w górę na klawiaturze. "
"Spowoduje to wstawienie poprzedniej linii kodu do shella. Kontynuuj "
"naciskanie, aby cofnąć się dalej w historii, a jeśli przejdziesz za daleko, "
"naciśnij strzałkę w dół, aby przejść w drugą stronę. Spróbuj teraz tego użyć."

msgid "pages.NavigatingShellHistory.title"
msgstr "Poruszanie się po historii shella"


msgid "pages.NestedListAssignment.steps.final_text.text"
msgstr "Brilliant! You're almost ready to put it all together, keep going!"

msgid "pages.NestedListAssignment.steps.modify_list_in_function.text"
msgstr ""
"We've seen how to get input from the user, now let's use that to actually put pieces\n"
"on the board and play the game. For starters, try out this code:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.0.text"
msgstr ""
"Your function needs to call `input()` twice. Input isn't passed to "
"`play_move` as an argument."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.1.text"
msgstr "`input()` always returns a string."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.10.text"
msgstr ""
"Once you've got two numbers, you need to modify the nested list `board` with"
" them."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.11.text"
msgstr "The code for this has been shown to you above."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.12.text"
msgstr ""
"You just need to use the numbers from user input instead of the hardcoded 1 "
"and 0."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.13.text"
msgstr "You can use nested subscripting in one line, or do it in two steps."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.2.text"
msgstr "A string that looks like a number is still a string, not a number."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.3.text"
msgstr "List indices have to be numbers, not strings."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.4.text"
msgstr ""
"If the board is 3x3, the user might input 1, 2, or 3 for each coordinate."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.5.text"
msgstr "What are the valid indices of a list of length 3?"

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.6.text"
msgstr "You need to take the input of 1, 2, or 3 and turn it into 0, 1, or 2."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.7.text"
msgstr "You also need to be able to handle bigger boards, like 9x9 or beyond."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.8.text"
msgstr "You can't do maths with strings, only numbers."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.9.text"
msgstr "How can you convert a string to a number?"

msgid "pages.NestedListAssignment.steps.nested_assignment_input.requirements"
msgstr ""
"Your function should modify the `board` argument. It doesn't need to "
"`return` or `print` anything."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.text"
msgstr ""
"These two lines:\n"
"\n"
"__code0__\n"
"\n"
"can be combined into one:\n"
"\n"
"__code1__\n"
"\n"
"The two pieces of code are pretty much exactly equivalent. Python first evaluates\n"
"`board[1]` to *get* the inner list, while the `[0] = ...` sets an element of `board[1]`.\n"
"You can see the value of `board[1]` in `birdseye` because it's an expression,\n"
"and you could actually replace it with any other expression.\n"
"\n"
"Now you know how to set elements in nested lists, it's time to make this interactive!\n"
"Write your own version of `play_move` that takes input from the user\n"
"to determine where to play, instead of always playing at `board[1][0]`.\n"
"It should call `input()` twice, so the user can give the row and the column\n"
"as two separate numbers. Also, our users are not programmers, so they start counting from 1,\n"
"not 0.\n"
"\n"
"For example, if the user types in these inputs:\n"
"\n"
"__code2__\n"
"\n"
"that means they want to play a move in the second row and first column, which is the same\n"
"as our original example.\n"
"\n"
"Here is some starting code:\n"
"\n"
"    __copyable__\n"
"__code3__\n"
"\n"
"This calls `play_move` twice so the user will need to enter two pairs of numbers.\n"
"Here's an example of what a 'game' should look like:\n"
"\n"
"     123\n"
"    1\n"
"    2\n"
"    3\n"
"\n"
"    X to play:\n"
"\n"
"__code2__\n"
"     123\n"
"    1\n"
"    2X\n"
"    3\n"
"\n"
"    O to play:\n"
"\n"
"    1\n"
"    3\n"
"     123\n"
"    1  O\n"
"    2X\n"
"    3\n"
"\n"
"You don't need to use the provided code exactly, it's just to give you a feeling of what's happening.\n"
"The important thing is that your `play_move` function modifies the `board` argument correctly.\n"
"It doesn't need to return or print anything, that will not be checked.\n"
"\n"
"You can assume that the user will always enter valid numbers. Later we will learn how to deal\n"
"with invalid inputs, like numbers out of range or inputs that aren't numbers at all."

msgid "pages.NestedListAssignment.steps.nested_assignment_two_lines.text"
msgstr ""
"Note how calling `play_move(game_board, 'X')` actually *modifies* `game_board` directly.\n"
"The variable `board` inside the call to `play_move` and\n"
"the variable `game_board` inside the call to `play_game` point to the same list object.\n"
"There's no copying. Python Tutor is good at showing this with arrows.\n"
"\n"
"This also means that in this case there's no need for `play_move` to return anything,\n"
"it can just modify `board` and the caller (`play_game` in this case) will see the effect.\n"
"\n"
"However, our board is two dimensional, represented by a nested list.\n"
"So we need to assign `player` to an element of an inner list, something like this:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.NestedListAssignment.title"
msgstr "Nested List Assignment: Playing Moves on the Board"

msgid ""
"pages.NewlinesAndFormatBoard.steps.discovering_newline.special_messages.bad_string.text"
msgstr ""
"Oops, `string` doesn't have the right value. Run the program from the "
"previous step again."

msgid "pages.NewlinesAndFormatBoard.steps.discovering_newline.text"
msgstr ""
"Hooray! A *triple quoted string* is allowed to span many lines and they will be shown in the output.\n"
"\n"
"Like single and double quotes, triple quotes are just another kind of notation, not a new kind of string.\n"
"`\"\"\"abc\"\"\"` is the same thing as `\"abc\"`.\n"
"\n"
"However `string` does contain something new. Run `__program__` in the shell to see."

msgid "pages.NewlinesAndFormatBoard.steps.final_text.text"
msgstr ""
"Great work! That was quite challenging.\n"
"\n"
"Now you have mastered how to build up a string of multiple lines of text, and solved the problem of displaying the board to the players.\n"
"\n"
"Next you will learn more about types in Python and how to convert them, and how to get input from the players.\n"
"You are already about halfway done with the project. Keep going!"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.0.text"
msgstr ""
"There are two types of lines to be displayed: one type has the pieces joined"
" by `|`s in between them, the other type has `-`s joined by `+`s in between "
"them."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.1.text"
msgstr ""
"Both of these types of lines can be built up by using `join` appropriately."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.10.text"
msgstr "Then apply `join` to that list, with the `+-` line as separator."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.11.text"
msgstr ""
"To add the newlines to the `+-` line correctly, take a look at the test case"
" we provided."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.2.text"
msgstr ""
"For example, how can you convert a row `['X', 'O', 'X']` into `'X|O|X'` "
"using `join`?"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.3.text"
msgstr ""
"Similarly, how can you obtain `'-+-+-'` using `join`? To what list should "
"you apply `join`?"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.4.text"
msgstr ""
"Once you figured out how to build up both types of lines, how can you "
"combine them to obtain the final result?"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.5.text"
msgstr "Notice that the lines with the `+-`  signs are always the same."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.6.text"
msgstr ""
"And there is one line with `+-` separating every consecutive pair of lines "
"with pieces."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.7.text"
msgstr "You can use `join` on the lines themselves!"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.8.text"
msgstr ""
"The lines with the pieces can be joined together with the `+-` line in "
"between them (with newlines added in appropriate places)."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.9.text"
msgstr ""
"To do that, first you need to keep the lines with the pieces stored in a "
"list as you are building them."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.text"
msgstr ""
"Excellent! A typical solution looks like:\n"
"\n"
"__code0__\n"
"\n"
"If you looked up how `join` works and used it in your solution, that's great!\n"
"You might have solved it with something like this:\n"
"\n"
"__code1__\n"
"\n"
"If you'd like, you can just continue to the [next page](#Types) now. Or you can do a bonus challenge!\n"
"\n"
"Write an improved version of `format_board` that displays row and column separators. For example, if\n"
"\n"
"__code2__\n"
"\n"
"then `print(format_board(board))` should print\n"
"\n"
"    X|O|X\n"
"    -+-+-\n"
"     |O|O\n"
"    -+-+-\n"
"     |X|\n"
"\n"
"Once again it should work for a square `board` of *any size*.\n"
"\n"
"You are strongly encouraged to use `join` on this exercise. We provide one test as before, you can write additional tests:\n"
"\n"
"    __copyable__\n"
"__code3__"

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.0.text"
msgstr ""
"Look carefully at the test case we provided. It shows you all you need!"

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.1.text"
msgstr ""
"You need to build up a string for the whole board. Start with an empty "
"string."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.2.text"
msgstr "For each row, add the characters from that row to the string."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.3.text"
msgstr "You'll need a nested loop."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.4.text"
msgstr ""
"When you reach the end of a row, you need to add a newline before the next "
"row."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.5.text"
msgstr ""
"`'\\n'` is just like any other character! You can add it as usual with `+`."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.6.text"
msgstr "Notice that the end of the last row is different than the others."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.7.text"
msgstr ""
"Before you add a newline, you'll need to check if it's the last row or not."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.8.text"
msgstr "Your outer loop should loop over the length of the board."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.9.text"
msgstr "Then check if you are at the last index or not."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.text"
msgstr ""
"Now use the newline character to write the function `format_board` (your solution should work for a square `board` of any size):\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.NewlinesAndFormatBoard.steps.introducing_newline.text"
msgstr ""
"There's the secret!\n"
"\n"
"`\\n` represents a ***newline*** character. This is just another character, like a letter or a space (`' '`).\n"
"It's the character between two separate lines that you type in by pressing Enter on your keyboard.\n"
"\n"
"Again, `\\n` *represents* the newline character within a Python string literal.\n"
"The string doesn't actually contain `\\` and `n`, it just contains one character. Check this in the shell:\n"
"\n"
"__code0__"

msgid "pages.NewlinesAndFormatBoard.steps.invalid_multi_line_string.program"
msgstr ""
"assert_equal(\n"
"    format_board([\n"
"        ['X', 'O', 'X'],\n"
"        [' ', 'O', 'O'],\n"
"        [' ', 'X', ' ']\n"
"    ]),\n"
"    \"XOX\n"
"      OO\n"
"      X \"\n"
")"

msgid "pages.NewlinesAndFormatBoard.steps.invalid_multi_line_string.text"
msgstr ""
"This is a good start but ideally we'd like a function which *returns* a string rather than printing it.\n"
"This way other code can make easy use of the string in different ways. We might want to manipulate the string\n"
"(e.g. draw a box around it or extract only the first few lines), we might want to send it somewhere other than the screen\n"
"(e.g. a file) and in this particular case we want to be able to test it with `assert_equal`. This doesn't work:\n"
"\n"
"__code0__\n"
"\n"
"because `print_board` doesn't use `return` so it just returns `None` by default.\n"
"So instead we want code like this:\n"
"\n"
"__code1__\n"
"\n"
"Then `print(format_board(board))` should print something like what we saw at the beginning.\n"
"But how do we return a string with multiple lines? And how do we test it? We'd like to do something like this:\n"
"\n"
"    __copyable__\n"
"__code2__\n"
"\n"
"See for yourself how this doesn't work."

msgid ""
"pages.NewlinesAndFormatBoard.steps.multi_line_strings_triple_quotes.program"
msgstr ""
"string = \"\"\"First line\n"
"Second line\"\"\"\n"
"print(string)"

msgid ""
"pages.NewlinesAndFormatBoard.steps.multi_line_strings_triple_quotes.text"
msgstr ""
"Normally a string literal has to be on one line, so this is invalid:\n"
"\n"
"    string = \"First line\n"
"    Second line\"\n"
"    print(string)\n"
"\n"
"But Python provides a way! The solution is to use *triple quotes*, i.e. three quote characters in a row\n"
"(either `'''` or `\"\"\"`) around the contents of the string. Run the following:\n"
"\n"
"__program_indented__"

msgid "pages.NewlinesAndFormatBoard.steps.one_way_to_print_board.text"
msgstr ""
"Next we want to tackle the problem of displaying the tic-tac-toe board. Here's one way to do this:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"(What's `\"\".join`? Google it!)"

msgid "pages.NewlinesAndFormatBoard.title"
msgstr "The newline character, `format_board`"

msgid "pages.OtherComparisonOperators.steps.brokn_kyboard.text"
msgstr ""
"Oto uroczy mały programik używający `!=`:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.0.text"
msgstr ""
"To prawie dokładnie to samo co w poprzednim kroku, tyle że użyj ciągów "
"znaków zamiast liczb."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.1.text"
msgstr "Musisz tylko uruchomić jedną bardzo małą, prostą linię w shellu."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.2.text"
msgstr ""
"Możesz to również zrobić poprzez uruchomienie wielu linii w shellu, "
"najpierw definiując zmienne a następnie porównując je, ale nie musisz tego "
"robić, możesz to zrobić bez zmiennych."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.3.text"
msgstr "Pamiętasz dodawanie dwóch ciągów znaków w shellu na początku kursu?"

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.4.text"
msgstr "Na przykład robiliśmy `'hello' + 'world'`"

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.5.text"
msgstr ""
"Do tego zadania musisz zrobić właściwie to samo, ale zamiast dodawać, "
"porównuj je."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.requirements"
msgstr ""
"Uruchom dowolny kod w shellu używający albo `<` albo `>` na dwóch ciągach "
"znaków."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.text"
msgstr ""
"Można także używać tych operatorów do porównywania ciągów znaków. Jeśli "
"ustawisz dwa ciągi znaków w kolejności alfabetycznej, pierwszy jest "
"'mniejszy niż' drugi. Sprawdź to sam."

msgid "pages.OtherComparisonOperators.steps.final_text.text"
msgstr ""
"Wspaniale!\n"
"\n"
"Istnieje wiele sposobów rozwiązania tego problemu. Oto jedno z rozwiązań:\n"
"\n"
"__code0__\n"
"\n"
"Oto inne:\n"
"\n"
"__code1__\n"
"\n"
"Te programy (i twój również) działają równie dobrze zarówno z liczbami, jak i ciągami znaków. Więc dla:\n"
"\n"
"__code2__\n"
"\n"
"wypiszą `Alice`, ponieważ to jest pierwszy ciąg znaków w kolejności alfabetycznej.\n"
"\n"
"`<` oraz `>` dają wynik False, gdy porównywane wartości są równe. Na przykład, 3 nie jest mniejsze od 3, więc `3 < 3` oraz `3 > 3` są oba False.\n"
"Aby uwzględnić równe wartości, użyj `<=` oraz `>=`.\n"
"Jeśli się przyjrzeć, przypominają one trochę ≤ oraz ≥.\n"
"Zauważ, że `=` znajduje się na końcu - nie istnieją takie operatory jak `=<` czy `=>`.\n"
"Aby to zapamiętać, przeczytaj je na głos jako \"mniejsze równe\"\n"
"i \"większe równe\".\n"
"\n"
"Podsumowując, główne operatory porównania to `==`, `!=`, `<`, `>`, `<=` oraz `>=`.\n"
"Jeśli masz kiedykolwiek wątpliwości co do tego, co one robią, pobaw się nimi w shellu!"

msgid "pages.OtherComparisonOperators.steps.grades_example.text"
msgstr ""
"Oto praktyczny przykład użycia `<`:\n"
"\n"
"__program_indented__\n"
"\n"
"Pamiętaj, że `elif percentage < 60` po `if percentage < 40` oznacza \"jeśli procent nie był mniejszy niż 40 oraz równocześnie jest mniejszy niż 60\", więc zostanie spełnione dla wszystkich liczb od 40 do 59 włącznie. Podobnie ocena 'B' jest dla procentów od 60 do 79, a ocena 'A' jest dla każdej liczby 80 i więcej."

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.hints.0.text"
msgstr "Musisz tylko uruchomić jedną bardzo małą, prostą linię w shellu."

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.hints.1.text"
msgstr "Jak byś dodał dwie liczby w shellu?"

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.hints.2.text"
msgstr "Na przykład spróbuj `123 + 456`"

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.hints.3.text"
msgstr ""
"Do tego zadania musisz zrobić właściwie to samo, ale zamiast dodawać, "
"porównuj je."

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.requirements"
msgstr ""
"Uruchom dowolny kod w shellu używający albo `<` albo `>` na dwóch liczbach."

msgid "pages.OtherComparisonOperators.steps.introducing_less_than.text"
msgstr ""
"Innymi przydatnymi operatorami są `<` (mniejsze niż) oraz `>` (większe niż)."
" Na przykład `a < b` oznacza \"`a` jest mniejsze od `b`\". Wypróbuj użycie "
"jednego z nich w shellu, aby porównać dwie liczby."

msgid "pages.OtherComparisonOperators.steps.min_three_exercise.hints.0.text"
msgstr ""
"Spróbuj napisać program, który wypisze najmniejszą z wartości `x1` i `x2`."

msgid "pages.OtherComparisonOperators.steps.min_three_exercise.hints.1.text"
msgstr "wszystko czego potrzebujesz to użyć kilka razy `<`, `if`, a może `else`."

msgid "pages.OtherComparisonOperators.steps.min_three_exercise.text"
msgstr ""
"Teraz zadanie: napisz program, który bierze trzy zmienne `x1`, `x2` i `x3`, oraz drukuje wartość najmniejszej z nich. Więc dla:\n"
"\n"
"__code0__\n"
"\n"
"powinien wypisać `10`."

msgid "pages.OtherComparisonOperators.steps.try_not_equals.text"
msgstr ""
"Przeciwieństwem operatora równości `==` jest operator *nierówności* `!=`. "
"Jeśli się przyjrzeć, to trochę przypomina ≠. Zwraca `True`, kiedy dwie "
"wartości są... nie równe. Wypróbuj `__program__` samodzielnie w shellu "

msgid "pages.OtherComparisonOperators.title"
msgstr "Inne operatory porównania"

msgid "pages.ReturningValuesFromFunctions.steps.final_text.text"
msgstr ""
"Brawo! Oto dwie możliwe rozwiązania:\n"
"\n"
"__code0__"

msgid "pages.ReturningValuesFromFunctions.steps.first_return.text"
msgstr ""
"Funkcje mogą być szczególnie użyteczne, kiedy *zwracają* wartości, zamiast je tylko wyświetlać. Wypróbuj ten przykład:\n"
"\n"
"__program_indented__"

msgid "pages.ReturningValuesFromFunctions.steps.losing_return_value.text"
msgstr ""
"Tu przekazaliśmy `number` (które ma wartość `5`) jako argument `x` do funkcji `double`, a funkcja `double` *zwróciła*\n"
"`x * 2`, to jest `5 * 2`, to jest `10`, co stało się wartością zmiennej `twice`. Specjalne słowo kluczowe `return` wewnątrz\n"
"`double` sprawia, że `double(number)` jest wyrażeniem o wartości - konkretnie wartości, która została zwrócona.\n"
"To trochę tak, jakby `twice = double(number)` było równoważne `twice = number * 2`, chociaż to nie jest\n"
"dokładnie to, co się dzieje.\n"
"\n"
"Zauważ, że `double(number)` *nie zmieniło `number`*. Na końcu `number` wciąż jest `5`. Raczej, `double(number)`\n"
"zwróciło nową wartość. Istotne jest, aby program wykorzystał tę zwróconą wartość, w tym przypadku przechowując ją\n"
"w zmiennej. Natychmiastowe wydrukowanie jej z `print(double(number))` również działa. Z drugiej strony, \n"
"spróbuj to:\n"
"\n"
"__program_indented__"

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.0.text"
msgstr "Aby pomnożyć przez 4, pomnóż przez 2 dwa razy."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.1.text"
msgstr "To oznacza, że musisz wywołać `double` dwa razy."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.10.text"
msgstr "Spojrzyj na definicję funkcji `double` jako przykład."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.11.text"
msgstr ""
"Upewnij się, że nie wywołujesz funkcji `quadruple` w ciele funkcji "
"`quadruple`. Sprawdź swoje wcięcia."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.2.text"
msgstr ""
"Upewnij się, że używasz wartości zwracanej przez `double` za każdym razem."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.3.text"
msgstr "Upewnij się, że posiadasz wszystkie elementy definicji funkcji."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.4.text"
msgstr "To obejmuje `def`, `()`, oraz `:`."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.5.text"
msgstr "Upewnij się, że twoja funkcja jest nazwana `quadruple`."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.6.text"
msgstr ""
"Upewnij się, że przyjmuje jeden parametr o nazwie `x` pomiędzy nawiasami "
"`()`."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.7.text"
msgstr "Użyj parametru w ciele funkcji."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.8.text"
msgstr "Upewnij się, że ciało jest wcięte."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.9.text"
msgstr "Upewnij się, że coś zwracasz na końcu."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.messages.used_multiply.text"
msgstr ""
"Nie możesz używać `*`, `+`, ani nawet żadnych liczb wewnątrz `quadruple`.\n"
"Musisz rozwiązać problem wywołując funkcję `double`."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.requirements"
msgstr ""
"Napisz program, który definiuje funkcję o nazwie `quadruple` zgodnie z "
"powyższym opisem."

msgid "pages.ReturningValuesFromFunctions.steps.quadruple_exercise.text"
msgstr ""
"Tu `double(number)` nadal zwróciło `10`, ale nie wykorzystaliśmy tego, więc zostało to utracone. `number` jest nadal `5`.\n"
"\n"
"Napisz funkcję `quadruple`, która bierze jeden argument `x` i zwraca ten argument pomnożony przez 4.\n"
"Możesz użyć wyłącznie funkcji `double` - bezpośrednio w ciele funkcji `quadruple` zakazane są liczby lub mnożenie."

msgid "pages.ReturningValuesFromFunctions.title"
msgstr "Zwracanie Wartości z Funkcji"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.hints.0.text"
msgstr "Jak powinieneś zdefiniować ciąg znaków?"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.hints.1.text"
msgstr "Z pojedynczymi cudzysłowami, czy z podwójnymi?"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.hints.2.text"
msgstr "Potrzebujesz tylko jednego ciągu znaków."

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.hints.3.text"
msgstr "Nie ma potrzeby dodawać ciągów znaków do siebie."

msgid "pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.text"
msgstr ""
"Jak widzisz, Python traktuje ten sam ciąg znaków zdefiniowany pojedynczymi lub podwójnymi cudzysłowami jako ten sam.\n"
"\n"
"Teraz napisz program, który wydrukuje następujący tekst z Zen of Python:\n"
"\n"
"    __copyable__\n"
"    Special cases aren't special enough to break the rules.\n"
"\n"
"Program powinien być jednolinijkowy używając `print()`, bez zmiennych."

msgid "pages.SingleAndDoubleQuotesInStrings.steps.double_quotes.text"
msgstr ""
"Więc nie możemy użyć apostrofu tak jak nam się podoba w ciągu znaków z pojedynczymi cudzysłowami.\n"
"Apostrof jest traktowany jak pojedynczy cudzysłów i dlatego działa jako *zamykający cudzysłów* definicji ciągu znaków `'Alice'`.\n"
"Potem pozostała część tekstu `s Diner'` jest niepoprawną składnią i Python tego nie rozumie.\n"
"\n"
"Na szczęście Python pozwala nam definiować ciągi znaków inaczej, używając podwójnych cudzysłowów `\"` zamiast tego:\n"
"\n"
"__program_indented__"

msgid "pages.SingleAndDoubleQuotesInStrings.steps.final_text.text"
msgstr ""
"Dobra robota!\n"
"\n"
"W większości przypadków możesz użyć pojedynczych lub podwójnych cudzysłowów do definiowania swoich ciągów znaków, tak jak ci się podoba.\n"
"Ale jeśli ciąg zawiera `'`, to użyj `\"` do jego zdefiniowania i odwrotnie."

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_double_quotes_equal.text"
msgstr ""
"Pamiętaj, że cudzysłowy to tylko część ludzkiej notacji ciągów znaków.\n"
"Nie są przechowywane jako rzeczywista część ciągu znaków.\n"
"Spróbuj tego w powłoce:\n"
"\n"
"__program_indented__"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quote_exercise.hints.0.text"
msgstr "Pomyśl prostym sposobem! Jak zwykle to robisz?"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quote_exercise.hints.1.text"
msgstr ""
"Jeśli ciąg znaków zawiera pojedynczy cudzysłów, musimy użyć podwójnych "
"cudzysłowów do jego zdefiniowania."

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quote_exercise.hints.2.text"
msgstr "Co jeśli ciąg zawiera podwójne cudzysłowy?"

msgid "pages.SingleAndDoubleQuotesInStrings.steps.single_quote_exercise.text"
msgstr ""
"Doskonale!\n"
"\n"
"Teraz wydrukuj następujący cytat dosłownie (łącznie z podwójnymi cudzysłowami):\n"
"\n"
"    __copyable__\n"
"    \"Talk is cheap. Show me the code.\" - Linus Torvalds\n"
"\n"
"Program powinien być jednolinijkowy używając `print()`, bez zmiennych."

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quotes_apostrophe.program"
msgstr "print('Alice's Diner')"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quotes_apostrophe.text"
msgstr ""
"Do tej pory definiowaliśmy ciągi znaków używając pojedynczych cudzysłowów, takich jak:\n"
"\n"
"__code0__\n"
"\n"
"Co jeśli chcemy zdefiniować ciąg znaków zawierający apostrof? Spróbuj tego:\n"
"\n"
"__program_indented__"

msgid "pages.SingleAndDoubleQuotesInStrings.title"
msgstr "Pojedyncze i podwójne cudzysłowy w ciągach znaków"

msgid "pages.StoringCalculationsInVariables.steps.final_text.text"
msgstr ""
"W przeciwieństwie do arkusza kalkulacyjnego, gdzie formuły aktualizują się "
"automatycznie, zmienna taka jak `sentence` nie pamięta, jak została "
"obliczona i nie zmieni się, jeśli zmienione zostaną wartości leżące u "
"podstawy `word` lub `name`."

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.output_prediction_choices.0"
msgstr ""
"Hello World\n"
"Hello World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.output_prediction_choices.1"
msgstr ""
"Hello World\n"
"Goodbye World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.output_prediction_choices.2"
msgstr ""
"Goodbye World\n"
"Goodbye World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.requirements"
msgstr ""
"Uruchom program składający się z czterech linii z poprzedniego kroku, a "
"następnie z dwóch linii tutaj."

msgid "pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.text"
msgstr ""
"Teraz `sentence` ma wartość `'Hello World'`, której można używać wielokrotnie. Zauważ, że będzie ona kontynuowała posiadanie tej wartości aż do jej bezpośredniego przypisania, np. za pomocą innego polecenia takiego jak `sentence = <coś>`. Na przykład, dodaj te dwie linie na końcu programu:\n"
"\n"
"__code0__"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.0"
msgstr "sentence"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.1"
msgstr "word + ' ' + name"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.2"
msgstr "Hello + ' ' + World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.3"
msgstr "'Hello' + ' ' + 'World'"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.4"
msgstr "Hello World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.5"
msgstr "'Hello World'"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.text"
msgstr ""
"Często będziesz używać zmiennych, aby przechowywać wyniki obliczeń. Pomoże to budować bardziej złożone programy. Na przykład, wypróbuj ten program:\n"
"\n"
"__code0__"

msgid "pages.StoringCalculationsInVariables.title"
msgstr "Przechowywanie obliczeń w zmiennych"

msgid "pages.StringMethodsUnderstandingMutation.steps.final_text.text"
msgstr ""
"Zauważ, że `sentence.upper()` nie zmienia oryginalnego `sentence`.\n"
"\n"
"Możesz również użyć `word.lower()` bezpośrednio w większym wyrażeniu, np.\n"
"\n"
"__code0__"

msgid ""
"pages.StringMethodsUnderstandingMutation.steps.mutation_string_append.text"
msgstr ""
"Te dwie metody także działają na łańcuchach znaków podobnie do list.\n"
"`index` zwraca *indeks początkowy* wyszukiwanego słowa `'the'` w dłuższym łańcuchu\n"
"`'feed the dog and the cat'`, który wynosi `5`.\n"
"\n"
"|  0   |  1   |  2   |  3   |  4   | **5** |  6   |  7   |  8   | ...  |\n"
"| :--: | :--: | :--: | :--: | :--: | :---: | :--: | :--: | :--: | :--: |\n"
"|  f   |  e   |  e   |  d   |      | **t** |  h   |  e   |      | ...  |\n"
"\n"
"Zauważ, że w większości przypadków metody, które *modyfikują listę in situ* (`append`, `insert`, `remove`) po prostu zwracają `None`,\n"
"podczas gdy pozostałe funkcje/metody zwracają nową użyteczną wartość bez zmiany oryginalnego argumentu.\n"
"Jedynym wyjątkiem jest metoda `pop`.\n"
"\n"
"Modyfikowanie wartości bezpośrednio nazywa się *mutacją* - typy wartości które mogą być mutowane są *mutowalne* (ang. mutable),\n"
"a te które nie mogą są *niemutowalne* (ang. immutable). Listy są mutowalne.\n"
"Łańcuchy znaków są niemutowalne - nie mają żadnych metod takich jak `append` czy nawet przypisanie do indeksu.\n"
"Zobacz sam:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.StringMethodsUnderstandingMutation.steps.string_count_index.program"
msgstr ""
"string = 'feed the dog and the cat'\n"
"print(string.count('the'))\n"
"print(string.index('the'))"

msgid "pages.StringMethodsUnderstandingMutation.steps.string_count_index.text"
msgstr ""
"`in` działa na łańcuchach znaków tak, jak na listach! Komenda zwróciła `True`, ponieważ `the` występuje w `feed the dog and the cat` jako *podłańcuch*.\n"
"Co z `count` i `index`?\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.StringMethodsUnderstandingMutation.steps.string_in_step.program"
msgstr "print('the' in 'feed the dog and the cat')"

msgid "pages.StringMethodsUnderstandingMutation.steps.string_in_step.text"
msgstr ""
"Widziałeś już, że `len` oraz indeksowanie działają na łańcuchach znaków trochę tak, jakby były one listami znaków.\n"
"Łańcuchy znaków wspierają również niektóre z nowych metod, które poznaliśmy, nie tylko dla pojedynczych znaków, ale również dla dowolnych podłańcuchów.\n"
"Na przykład, wypróbuj poniższe:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.StringMethodsUnderstandingMutation.steps.string_lower_upper.text"
msgstr ""
"Nie można po prostu zmienić łańcucha znaków - możesz jedynie tworzyć nowe łańcuchy i używać ich zamiast starych.\n"
"To oznacza, że to jest bezużyteczne stwierdzenie samo w sobie:\n"
"\n"
"__code0__\n"
"\n"
"Łańcuch pod zmienną `word` nie jest modyfikowany, zamiast tego `word.lower()` zwraca nowy łańcuch, który w tym przypadku przepada.\n"
"Jeśli chcesz zmienić wartość, do której odnosi się `word`, musisz przypisać do zmiennej nową wartość:\n"
"\n"
"    __copyable__\n"
"__code1__"

msgid "pages.StringMethodsUnderstandingMutation.title"
msgstr "Metody łańcuchów znaków i niemutowalność"

msgid "pages.TestingFunctions.steps.alert_exercise.hints.0.text"
msgstr ""
"`string` powinien być otoczony jedną spacją i `level` wykrzyknikami (`!`) z "
"obu stron."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.1.text"
msgstr ""
"Dołącz definicję `surround` z poprzedniej części do swojego programu i "
"wywołaj ją w `alert`."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.10.text"
msgstr ""
"Pomyśl, jak budujesz łańcuchy znaków z `+=`. Kolejno aktualizuj tę samą "
"zmienną, budując swój wynik."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.11.text"
msgstr "Czyli napisz `something = surround(something, '!')` w swojej pętli."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.12.text"
msgstr "Upewnij się, że zwracasz coś na końcu `alert`."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.13.text"
msgstr ""
"Upewnij się, że nie `zwracasz` wewnątrz pętli, ale po niej. Sprawdź swoje "
"wcięcia."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.14.text"
msgstr ""
"Upewnij się, że nie wywołujesz `alert` w ciele funkcji `alert`. Sprawdź "
"swoje wcięcia."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.2.text"
msgstr "Użyj `surround` dla spacji."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.3.text"
msgstr "Użyj `surround` dla wykrzykników."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.4.text"
msgstr ""
"Nie wolno łączyć kilku wykrzykników w jeden ciąg znaków, więc wywołaj "
"`surround` kilka razy."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.5.text"
msgstr "Czyli wywołaj `surround` raz dla każdej pary wykrzykników."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.6.text"
msgstr "Więc wywołaj `surround(..., '!')` kilka razy."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.7.text"
msgstr "Użyj pętli, aby wywołać to kilka razy."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.8.text"
msgstr "Użyj `range(n)`, aby twoja pętla miała `n` iteracji."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.9.text"
msgstr "Upewnij się, że używasz wartości zwracanej przez `surround`."

msgid ""
"pages.TestingFunctions.steps.alert_exercise.messages.catch_return_inside_loop.text"
msgstr ""
"W funkcji `alert` umieściłeś swoją instrukcję `return` w złym miejscu!\n"
"Zwróć uwagę na swoje wcięcia w `alert`. Możesz kończyć pętlę za wcześnie za pomocą `return`."

msgid "pages.TestingFunctions.steps.alert_exercise.messages.used_format.text"
msgstr ""
"Nie możesz używać konkatenacji, formatowania, interpolacji ani mnożenia łańcuchów znakowych ani f-stringów w `alert`.\n"
"Musisz rozwiązać problem, wywołując `surround`."

msgid "pages.TestingFunctions.steps.alert_exercise.text"
msgstr ""
"Doskonale! Teraz napisz funkcję `alert`, która przejdzie te testy:\n"
"\n"
"__code0__\n"
"\n"
"Ciało funkcji `alert` nie może zawierać `+`. Użyj zamiast tego `surround`. Twoja funkcja powinna zaczynać się tak:\n"
"\n"
"__code1__"

msgid "pages.TestingFunctions.steps.complete_quadruple_tests.requirements"
msgstr ""
"Wpisz program powyżej.\n"
"Następnie zmień ostatnie dwie linie, dodając po jednym argumencie do każdego wywołania `assert_equal`, aby testy przeszły.\n"
"Nie dotykaj definicji funkcji."

msgid "pages.TestingFunctions.steps.complete_quadruple_tests.text"
msgstr ""
"Świetnie! Nasze testy nie przeszły! Oczywiście to zazwyczaj nie jest dobra rzecz, ale mówi nam, że testy\n"
"sprawdzają swoje zadanie. Upewnią się, że nasza implementacja `double` jest poprawna.\n"
"\n"
"Praktykujmy ten nowy koncept. Poniżej znajduje się funkcja `quadruple` z wcześniej z niektórymi niekompletnymi testami.\n"
"Napraw program, dodając brakujące argumenty do wywołania `assert_equal`.\n"
"\n"
"__code0__"

msgid "pages.TestingFunctions.steps.final_text.text"
msgstr ""
"Świetna robota! Te narzędzia będą bardzo przydatne w kolejnych rozdziałach."

msgid "pages.TestingFunctions.steps.introducing_assert_equal.text"
msgstr ""
"Ważnym elementem pisania programów jest sprawdzanie, czy działają poprawnie. Możesz to zrobić ręcznie, np. sprawdzając, czy\n"
"`print(double(5))` wypisuje `10`, ale tego typu czynności mogą szybko stać się męczące.\n"
"Przydatne jest pisanie programów, które testują twoje programy. To nazywa się *automatycznym testowaniem*,\n"
"a programy to *testy*.\n"
"\n"
"Oto prosta funkcja `assert_equal` (ang. _zapewnij o równości_), która pomoże nam pisać testy:\n"
"\n"
"__code0__\n"
"\n"
"\n"
"(Co to za funkcja `repr`? Spróbuj `print(f\"{'abc'} {repr('abc')}\")`, żeby zobaczyć jedną różnicę, ale nie martw się tym zbytnio.)\n"
"\n"
"To nie jest standardowa część Pythona (choć podobne funkcje istnieją), ale dodaliśmy ją do twojego środowiska programistycznego\n"
"żebyś zawsze mógł z niej korzystać. Oto przykład użycia, który możesz wypróbować:\n"
"\n"
"__program_indented__"

msgid "pages.TestingFunctions.steps.make_tests_fail.requirements"
msgstr ""
"Uruchom program z poprzedniego kroku, zamieniając `x * 2` na `x * 3`. Resztę"
" zostaw bez zmian."

msgid "pages.TestingFunctions.steps.make_tests_fail.text"
msgstr ""
"Komunikaty OK mówią nam, że testy przeszły. Nasza funkcja `double` wydaje się działać poprawnie. Zmień ją tak, żeby zwracała\n"
"`x * 3` i zobacz co się stanie."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.0.text"
msgstr "Argument `sides` powinien być dodany przed i po `string`."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.1.text"
msgstr "Użyj konkatenacji łańcuchów znaków, aby to osiągnąć."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.2.text"
msgstr "Upewnij się, że treść jest z wcięciem."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.3.text"
msgstr "Spraw, aby na końcu zwracać coś za pomocą `return`."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.4.text"
msgstr ""
"Upewnij się, że nie wywołujesz `surround` wewnątrz ciała funkcji `surround`."
" Sprawdź swoje wcięcia."

msgid "pages.TestingFunctions.steps.surround_exercise.text"
msgstr ""
"Kolejną przydatną rzeczą dotyczącą testów jest to, że każdy może je przeczytać i zobaczyć jasne, jednoznaczne przykłady\n"
"tego, co funkcja robi. Jest to pomocne, gdy funkcja jest skomplikowana i trudna do opisania po angielsku.\n"
"\n"
"Na przykład, oto kilka testów:\n"
"\n"
"__code0__\n"
"\n"
"Nie muszę wyjaśniać, co robi `surround`, możesz zobaczyć sam.\n"
"\n"
"Napisz funkcję `surround`, która przejdzie te testy i zaczyna się tak:\n"
"\n"
"__code1__"

msgid "pages.TestingFunctions.title"
msgstr "Testowanie Funkcji"

msgid "pages.TheEqualityOperator.steps.equality_vs_assignment.program"
msgstr "print(1 + 2 = 3)"

msgid "pages.TheEqualityOperator.steps.equality_vs_assignment.requirements"
msgstr ""
"Uruchom program z poprzedniego kroku, ale zamień którykolwiek z `==` na po "
"prostu `=`."


msgid "pages.TheEqualityOperator.steps.equality_vs_assignment.text"
msgstr ""
"Jak widzisz, jeśli wartości są równe, wyrażenie równości daje wynik `True`,\n"
"w przeciwnym razie jest to `False`.\n"
"\n"
"Zwróć uwagę na różnicę między operatorem równości `==` a pojedynczym `=`, które mają różne znaczenia,\n"
"szczególnie w instrukcjach przypisania, jakie do tej pory widzieliśmy. Co się stanie, jeśli spróbujesz\n"
"usunąć pojedynczy `=` z poprzedniego programu?"

msgid "pages.TheEqualityOperator.steps.final_text.text"
msgstr "Dobra robota!"

msgid "pages.TheEqualityOperator.steps.if_equals_replacing_characters.text"
msgstr ""
"Użyjmy `==` w instrukcji `if`. W tym programie ciało `if` uruchamia się tylko wtedy, gdy `c` to znak `'s'`. Przekonaj się sam.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.TheEqualityOperator.steps.if_equals_replacing_characters_exercise.hints.0.text"
msgstr ""
"Musisz tylko dodać kilka linii kodu, które są bardzo podobne do "
"istniejących."

msgid ""
"pages.TheEqualityOperator.steps.if_equals_replacing_characters_exercise.text"
msgstr ""
"Rozszerz teraz program, aby również zamieniał `e` na `3` i `a` na `@`."

msgid "pages.TheEqualityOperator.steps.introducing_equality.text"
msgstr ""
"Istnieje kilka sposobów uzyskania wartości boolowskich bez ich bezpośredniego przypisywania,\n"
"co pozwala konstruować bardzo przydatne instrukcje `if`. W szczególności istnieje wiele\n"
"*operatorów porównania*, które porównują wartości dwóch wyrażeń.\n"
"Najczęściej stosowany jest operator równości, który sprawdza, czy dwie wartości są równe.\n"
"Jest on oznaczony dwoma znakami równości: `==`. Spróbuj uruchomić to:\n"
"\n"
"__program_indented__"

msgid "pages.TheEqualityOperator.title"
msgstr "Operator równości"

msgid "pages.TheFullTicTacToeGame.steps.final_text.text"
msgstr ""
"### ***CONGRATULATIONS!!!***\n"
"\n"
"You did it!"

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.0.text"
msgstr ""
"You should use all of the functions `winner`, `format_board` (not counting "
"its use in `play_move`), `play_move`, `make_board`, `print_winner`, and "
"`print_draw` somewhere."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.1.text"
msgstr ""
"You only need to mention each of those functions once in your code, although"
" some of them will be called several times as the program runs."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.10.text"
msgstr "Whichever function is called, it must be called exactly once."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.11.text"
msgstr ""
"One easy way to make sure you don't call a function multiple times is to "
"call it outside of any loop."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.12.text"
msgstr "We've learned about two ways to make a loop stop."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.13.text"
msgstr "One way is `break`, which specifically ends one loop and no more."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.14.text"
msgstr "The second way ends not just the loop but the whole function call."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.15.text"
msgstr "The second way is `return`."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.16.text"
msgstr ""
"Don't play moves in pairs like `play_move(board, player1)` and "
"`play_move(board, player2)` in the sample code."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.17.text"
msgstr "Instead, each loop iteration should play one move."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.18.text"
msgstr "You need a variable to keep track of which player's turn it is."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.19.text"
msgstr "The player should be switched in each loop iteration."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.2.text"
msgstr "You will need a for loop to repeatedly play moves."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.20.text"
msgstr "An `if` statement is a good way to do this."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.21.text"
msgstr "Especially combined with an `else`."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.22.text"
msgstr "Make sure `player1` plays the first move."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.23.text"
msgstr ""
"Only call `print_winner` after checking `winner` with an `if` statement."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.24.text"
msgstr ""
"You need to check for the winner inside the loop since you don't know when a"
" player might win."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.25.text"
msgstr ""
"Once you call `print_winner`, you can use `return` to end the function."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.26.text"
msgstr ""
"Just `return` by itself is fine, `play_game` isn't meant to return a value."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.27.text"
msgstr ""
"Don't use `else` after checking for a winner to call `print_draw` if there "
"isn't a winner. Just because no one has won yet doesn't mean it's a draw "
"already."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.28.text"
msgstr ""
"`print_draw` should only be called after all moves have been played and "
"there's still no winner."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.29.text"
msgstr "So it should be called after the loop, outside of it."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.3.text"
msgstr ""
"You don't need to check if the board has been filled up, because you can "
"always calculate how many moves it takes to fill up the board."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.30.text"
msgstr ""
"Check the indentation to make sure `print_draw` isn't in the body of the for"
" loop."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.4.text"
msgstr ""
"So you can just use a loop that will run a fixed number of iterations, and "
"inside the loop check if the loop needs to be ended early."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.5.text"
msgstr ""
"What's the maximum number of moves that can be played in a 3x3 board? 4x4?"

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.6.text"
msgstr ""
"A loop over a `range` is an easy way to iterate a fixed number of times."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.7.text"
msgstr "So you can use `for _ in range(N):` to play at most `N` moves."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.8.text"
msgstr "Once there's a winner, you need to end the loop and the game."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.9.text"
msgstr "Either `print_winner` or `print_draw` should be called, not both."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.text"
msgstr ""
"It's time to put it all together! Below is some code to get started.\n"
"\n"
"It includes implementations of the various functions we defined in previous pages for solving parts\n"
"of the problem, using some tricks you haven't learned yet to make them shorter. Don't change them.\n"
"\n"
"Your task is to implement `play_game` correctly. The current implementation shows what\n"
"should happen at the start of the game, but it's obviously incomplete.\n"
"The solution should work for any board size and continue the game until it's finished.\n"
"The last thing that `play_game` should do is either call `print_winner(player)`\n"
"if `winner(board)` is true, or call `print_draw()` if the board is filled up with no winner.\n"
"\n"
"You can assume that the user will only enter valid inputs,\n"
"i.e. numbers from 1 to `board_size` to choose a cell on the board that isn't already taken.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.TheFullTicTacToeGame.title"
msgstr "The Full Tic-Tac-Toe Game"

msgid "pages.Types.steps.check_type_manually.text"
msgstr ""
"Python reports first that `type('Hello World')` is `<class 'str'>`. Don't worry about `class` for now.\n"
"`str` is short for *string*.\n"
"\n"
"Then `True` is a `bool` (short for *boolean*) and `[1, 2, 3]` has type `list`.\n"
"\n"
"Note that there are two types for numbers:\n"
"\n"
"- `int`, short for 'integer', is for whole numbers, meaning no fractions or decimal points.\n"
"- `float`, short for 'floating point number', is for numbers with a decimal point and maybe a fractional part\n"
"\n"
"In most cases you don't have to worry about the different types of number, as you can mix the two when doing maths.\n"
"\n"
"Types are values which can be used in various ways, just like other values.\n"
"For example, try this in the shell:\n"
"\n"
"__program_indented__"

msgid "pages.Types.steps.common_type_errors.text"
msgstr ""
"What happens if you use an operator between a `str` and an `int`? Try in the shell:\n"
"\n"
"__program_indented__"

msgid "pages.Types.steps.different_types_look_same.text"
msgstr ""
"Values with different types are usually quite different from each other, but they can look the same when printed,\n"
"which can be confusing. Try this:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"(You can use `print(repr(123))` and `print(repr('123'))` to tell the difference. What's `repr`? Google it!)"

msgid "pages.Types.steps.final_text.text"
msgstr ""
"Excellent!\n"
"\n"
"By the way, when you need to concatenate strings and numbers, remember that you can also\n"
"use f-strings. They often look nicer.\n"
"\n"
"You've learned about types in Python and how to avoid common errors by converting types.\n"
"Keep going with the rest of the project!"

msgid "pages.Types.steps.five_different_types.text"
msgstr ""
"So far we've seen various kinds of data: strings, lists, numbers and booleans.\n"
"These are called *types*. Every value has a type which affects how it behaves\n"
"and can be revealed with the `type` function:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.Types.steps.fixing_type_errors_with_conversion.disallowed.0.label"
msgstr "f-strings"

msgid "pages.Types.steps.fixing_type_errors_with_conversion.hints.0.text"
msgstr "At what points is this code broken?"

msgid "pages.Types.steps.fixing_type_errors_with_conversion.hints.1.text"
msgstr "There are values that need to be converted to a different type."

msgid "pages.Types.steps.fixing_type_errors_with_conversion.hints.2.text"
msgstr "Specifically there's a `str` that needs to be converted to an `int`."

msgid "pages.Types.steps.fixing_type_errors_with_conversion.hints.3.text"
msgstr "And an `int` that needs to be converted to a `str`."

msgid "pages.Types.steps.fixing_type_errors_with_conversion.text"
msgstr ""
"Using a string instead of an integer in `range` like `range('5')`,\n"
"or in list subscripting like `list['3']` will also lead to an error.\n"
"\n"
"Most of these problems can be solved by converting the string to an integer by using `int` as a function:\n"
"`int('5')` will return the integer `5`.\n"
"Similarly an integer can be converted to a string by using `str` as a function:\n"
"`str(5)` will return the string `'5'`.\n"
"\n"
"Using this new knowledge, fix this broken program:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"The correct program should print:\n"
"\n"
"    Starting... 1\n"
"    Starting... 2\n"
"    Starting... 3\n"
"    Go!\n"
"\n"
"Your solution should work for any value of the variable `number`."

msgid "pages.Types.steps.format_board_with_numbers.hints.0.text"
msgstr ""
"You can start by using the ideas from your previous solution to "
"`format_board`. Using `join` is highly recommended!"

msgid "pages.Types.steps.format_board_with_numbers.hints.1.text"
msgstr "The first line has to be treated separately from the rest."

msgid "pages.Types.steps.format_board_with_numbers.hints.2.text"
msgstr "Remember that `range` yields numbers in the way: 0, 1, 2, ..."

msgid "pages.Types.steps.format_board_with_numbers.hints.3.text"
msgstr "We want numbers on the first line like this: 1, 2, 3..."

msgid "pages.Types.steps.format_board_with_numbers.hints.4.text"
msgstr ""
"Each number has to be converted to a string before being added to the first "
"row!"

msgid "pages.Types.steps.format_board_with_numbers.hints.5.text"
msgstr "For the rows of the board itself, do something similar."

msgid "pages.Types.steps.format_board_with_numbers.hints.6.text"
msgstr ""
"Start with a list consisting only of the first line that you built above."

msgid "pages.Types.steps.format_board_with_numbers.hints.7.text"
msgstr ""
"Add each row's string to the list, then join the list with a newline "
"character."

msgid "pages.Types.steps.format_board_with_numbers.text"
msgstr ""
"Write an improved version of `format_board` that has row and column numbers like this:\n"
"\n"
"     123\n"
"    1XOX\n"
"    2 OO\n"
"    3 X\n"
"\n"
"It should work for boards of any single-digit size. Here's a test case:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.Types.steps.less_than_has_two_meanings.text"
msgstr ""
"For two integers `+` acts as addition, whereas for two strings it acts as string concatenation.\n"
"Python automatically figures out the meaning of `+` from the types of the inputs.\n"
"Similarly `<` acts differently on two strings and two integers:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.Types.steps.less_than_sorting_strings.text"
msgstr ""
"So `<` acts as the usual 'less than' between two integers, because `13` is less than `120`,\n"
"but it acts as the dictionary ordering between two strings: `13` is 'alphabetically' after `120`\n"
"because `3` comes after `2`.\n"
"\n"
"See what difference this makes when sorting a list:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.Types.steps.plus_has_two_meanings.text"
msgstr ""
"Different types have different methods and support different operators.\n"
"The same method or operator can also mean different things.\n"
"For example, see how `+` has different meanings for `str` and `int`:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.Types.title"
msgstr "Types"

msgid "pages.UnderstandingProgramsWithPythonTutor.steps.final_text.text"
msgstr ""
"Zwróć uwagę, że kod wykonuje się dwukrotnie oddzielnie: raz tutaj, a raz na stronie pythontutor.com.\n"
"W zależności od Twojego programu, oba uruchomienia mogą dać różne wyniki."

msgid ""
"pages.UnderstandingProgramsWithPythonTutor.steps.run_with_python_tutor.text"
msgstr ""
"Nadszedł czas, aby poznać kolejne narzędzie do eksploracji programów.\n"
"Skopiuj poniższy kod do edytora, a następnie kliknij nowy przycisk \"Python Tutor\".\n"
"Przycisk otworzy nową kartę z wizualizacją na stronie [pythontutor.com](http://pythontutor.com).\n"
"Tam możesz przeglądać program krok po kroku, korzystając z przycisków \"Prev\" lub \"Next\",\n"
"lub przeciągając suwak w lewo lub w prawo. Możesz także obserwować wartości zmiennych po prawej stronie.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.UnderstandingProgramsWithPythonTutor.title"
msgstr "Zrozumienie programów z Python Tutor"

msgid "pages.UnderstandingProgramsWithSnoop.steps.final_text.text"
msgstr "Świetna robota! Pracujesz z coraz bardziej skomplikowanymi programami."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.0.text"
msgstr ""
"Kod powinien być prawie taki sam, wystarczy zrobić kilka małych zmian."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.1.text"
msgstr ""
"Upewnij się, że kod wewnątrz `jeśli zawiera:` działa na początku pętli, w "
"pierwszej iteracji."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.2.text"
msgstr "To znaczy, że `zawiera` powinno być `True` w tym momencie."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.3.text"
msgstr ""
"Upewnij się, że kod wewnątrz `jeśli zawiera:` *nie* działa po pierwszej "
"iteracji."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.4.text"
msgstr "To znaczy, że `zawiera` powinno być `False` po pierwszej iteracji."

msgid "pages.UnderstandingProgramsWithSnoop.steps.print_first_character.text"
msgstr ""
"Tada! Przewiń na początek terminala i przeanalizujmy, co pokazuje `snoop`.\n"
"Zaczyna się bardzo prosto:\n"
"\n"
"        1 | sentence = 'Hello World'\n"
"        3 | include = False\n"
"        4 | new_sentence = ''\n"
"        5 | for char in sentence:\n"
"     ...... char = 'H'\n"
"\n"
"Pierwsze linie po prostu pokazują ci linie programu, które komputer wykonał.\n"
"Po lewej stronie jest numer linii widziany w edytorze.\n"
"\n"
"Uruchomienie `for char in sentence:` przypisuje wartość do zmiennej `char`, więc `snoop` pokazuje tę wartość.\n"
"Linie zaczynające się od `......` wskazują na nową zmienną lub zmianę wartości istniejącej zmiennej.\n"
"Takie linie nie będą pokazywane, gdy są zbędne, dlatego wynik `snoop` nie zaczyna się tak:\n"
"\n"
"        1 | sentence = 'Hello World'\n"
"     ...... sentence = 'Hello World'\n"
"        3 | include = False\n"
"     ...... include = False\n"
"        4 | new_sentence = ''\n"
"     ...... new_sentence = ''\n"
"        5 | for char in sentence:\n"
"     ...... char = 'H'\n"
"\n"
"Następne dwie linie to:\n"
"\n"
"        6 |     if include:\n"
"        8 |     include = True\n"
"\n"
"Ważne jest to, czego nie widać: ponieważ `include` jest `False`, linia 7 (`new_sentence += char`) zostaje pominięta. Ale potem `include` jest ustawione na `True`, więc kolejne iteracje pętli są inne:\n"
"\n"
"        5 | for char in sentence:\n"
"     ...... char = 'e'\n"
"        6 |     if include:\n"
"        7 |         new_sentence += char\n"
"     .............. new_sentence = 'e'\n"
"\n"
"`new_sentence += char` działa po raz pierwszy i zmienna `new_sentence` otrzymuje nową wartość.\n"
"\n"
"Teraz zmodyfikuj program, aby zrobić odwrotnie: wydrukuj tylko pierwszy znak, resztę pomijając."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.0"
msgstr "Hello World"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.1"
msgstr "ello World"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.2"
msgstr "Hello Worl"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.3"
msgstr "H"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.4"
msgstr "d"

msgid "pages.UnderstandingProgramsWithSnoop.steps.print_tail.text"
msgstr ""
"Uruchom ten program:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail_snoop.requirements"
msgstr ""
"Uruchom ten sam program z poprzedniego kroku, ale użyj przycisku `snoop` "
"zamiast przycisku 'Uruchom'. Skopiuj program jeszcze raz, jeśli mogłeś go "
"zmienić."

msgid "pages.UnderstandingProgramsWithSnoop.steps.print_tail_snoop.text"
msgstr ""
"Programy zaczynają być skomplikowane!\n"
"Czas przedstawić nowe narzędzie, które pomoże ci zrozumieć programy. Kliknij przycisk `snoop`, aby uruchomić ten sam program i pokazać co się dzieje."

msgid "pages.UnderstandingProgramsWithSnoop.title"
msgstr "Zrozumienie programów z `snoop`"

msgid "pages.UsingBreak.steps.final_text.text"
msgstr ""
"Świetnie!\n"
"\n"
"Typowe rozwiązanie wygląda mniej więcej tak:\n"
"\n"
"__code0__\n"
"\n"
"Twoje rozwiązanie prawdopodobnie jest podobne. Jest w porządku, ale trochę niewydajne.\n"
"To dlatego, że pętla będzie iterować przez całą listę nawet jeśli znajdzie element na początku.\n"
"Możesz zatrzymać dowolną pętlę używając instrukcji `break`, na przykład:\n"
"\n"
"__code1__\n"
"\n"
"To jest równie poprawne, ale pomija niepotrzebne iteracje i sprawdzenia po znalezieniu elementu.\n"
"Możesz użyć `snoop`, żeby zobaczyć różnicę."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.0.text"
msgstr "Będziesz potrzebować pętli."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.1.text"
msgstr "Będziesz potrzebować instrukcji `if`."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.2.text"
msgstr "Będziesz potrzebować operatora porównania."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.3.text"
msgstr "Konkretnie `==`."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.4.text"
msgstr "Potrzebujesz zmiennej logicznej, którą wydrukujesz na końcu."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.5.text"
msgstr ""
"Jeśli znajdziesz element na liście, powinieneś ustawić tą zmienną na `True`."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.6.text"
msgstr "Gdy już znajdziesz element, nie możesz go 'odnaleźć'."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.7.text"
msgstr ""
"To oznacza, że raz ustawiona zmienna na `True`, nigdy nie powinna być "
"ustawiona na coś innego po tym."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.8.text"
msgstr "Nie używaj `else`."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.9.text"
msgstr ""
"Nie ma powodu, aby kiedykolwiek ustawiać zmienną na `False` wewnątrz pętli."

msgid "pages.UsingBreak.steps.list_contains_exercise.text"
msgstr ""
"Ćwiczenie: napisz program, który przyjmuje listę i wartość i sprawdza,\n"
"czy lista zawiera daną wartość. Na przykład, dla:\n"
"\n"
"    __no_auto_translate__\n"
"    things = ['This', 'is', 'a', 'list']\n"
"    thing_to_find = 'is'\n"
"\n"
"powinien wyświetlić `True`, ale dla:\n"
"\n"
"    __no_auto_translate__\n"
"    thing_to_find = 'other'\n"
"\n"
"powinien wyświetlić `False`."

msgid "pages.UsingBreak.title"
msgstr "Użycie `break` do wcześniejszego zakończenia pętli"

msgid "pages.UsingDictionaries.steps.dna_part1.text"
msgstr ""
"Not bad! But you may have noticed that it looks a bit awkward. Why do we have to specify `'dog'` and `'box'` in both the `cart` and the `quantities`?\n"
"On the next page we'll look at how to loop directly over the keys of a dictionary,\n"
"so we can get rid of the `cart` argument.\n"
"\n"
"But first, let's practice what we've learned a bit more.\n"
"\n"
"[Earlier in the course](#IntroducingElif) we looked at converting one strand of DNA\n"
"into a new strand with matching nucleotides.\n"
"Here's a version of that code using a function. It substitutes each letter in the input `string`\n"
"with a different one.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.UsingDictionaries.steps.dna_part2.hints.0.text"
msgstr ""
"This is still very similar to the previous exercises, but with strings "
"instead of numbers."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.1.text"
msgstr "You just have to think about the keys and values of `d`."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.2.text"
msgstr "You need to obtain the correct values to build up a string to return."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.3.text"
msgstr ""
"You can basically replace the whole `if/elif` chain with a single line."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.4.text"
msgstr "That line simply needs to use `d` to get the correct value."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.5.text"
msgstr "Remember that the keys of `d` are the characters in `string`."

msgid "pages.UsingDictionaries.steps.dna_part2.text"
msgstr ""
"Now we can use dictionaries to make this code both shorter and more general so it can be used for other purposes.\n"
"\n"
"Your job is to add another argument to the `substitute` function: a dictionary called `d`.\n"
"The keys of `d` represent characters\n"
"in the first argument `string` that should be replaced by the corresponding values of `d`. For example, `'A': 'T'`\n"
"means that `'A'` should be replaced by `'T'`:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"This version of `substitute` should work for any arguments where all the characters in `string` are keys in `d`.\n"
"No more `if` statements needed!"

msgid "pages.UsingDictionaries.steps.final_text.text"
msgstr ""
"Nice! Here's an example of how this function can also be used to encrypt and decrypt secret messages:\n"
"\n"
"    __copyable__\n"
"    __no_auto_translate__\n"
"    def substitute(string, d):\n"
"        result = \"\"\n"
"        for letter in string:\n"
"            result += d[letter]\n"
"        return result\n"
"\n"
"    plaintext = 'helloworld'\n"
"    encrypted = 'qpeefifmez'\n"
"    letters = {'h': 'q', 'e': 'p', 'l': 'e', 'o': 'f', 'w': 'i', 'r': 'm', 'd': 'z'}\n"
"    reverse = {'q': 'h', 'p': 'e', 'e': 'l', 'f': 'o', 'i': 'w', 'm': 'r', 'z': 'd'}\n"
"    assert_equal(substitute(plaintext, letters), encrypted)\n"
"    assert_equal(substitute(encrypted, reverse), plaintext)\n"
"\n"
"The same function works in both directions, we just need to pass it different dictionaries.\n"
"\n"
"The two dictionaries are almost the same, we just swap around the key and value in each pair.\n"
"So to encrypt, we replace `e` with `p`, and to decrypt we change `p` back to `e`.\n"
"\n"
"Note that `'e'` is both a key and a value in `letters`.\n"
"\n"
"Looking up `letters['e']` means that we're asking about `'e'` as a *key*, so it gives `'p'`.\n"
"Remember, we can't use `letters` to ask which key is associated with `'e'` as a *value*.\n"
"But in this case we can use the other dictionary for that: `reverse['e']` gives `'l'`,\n"
"and `letters['l']` gives `'e'` again.\n"
"\n"
"Soon you'll write a function to create a dictionary like `reverse` automatically,\n"
"i.e. `reverse = swap_keys_values(letters)`."

msgid "pages.UsingDictionaries.steps.shopping_cart1.hints.0.text"
msgstr "Remember that `prices` is a dictionary."

msgid "pages.UsingDictionaries.steps.shopping_cart1.hints.1.text"
msgstr "To access a value in a dictionary, you need a key."

msgid "pages.UsingDictionaries.steps.shopping_cart1.hints.2.text"
msgstr "The keys for `prices` are the items in the `cart`."

msgid "pages.UsingDictionaries.steps.shopping_cart1.text"
msgstr ""
"Let's see dictionaries in a real life problem. Imagine you're building an online shopping website.\n"
"You keep the prices of all your items in a dictionary:\n"
"\n"
"__code0__\n"
"\n"
"Here you can see one reason why looking up values in a dictionary could be a problem.\n"
"What would `prices[100]` be? `'dog'`? `'cat'`? `['dog', 'cat']`?\n"
"The same value can be repeated any number of times in a dictionary.\n"
"On the other hand, keys have to be unique. Imagine if your prices started like this:\n"
"\n"
"__code1__\n"
"\n"
"How much does an apple cost? We know it's `prices['apple']`, but is that `2` or `3`?\n"
"Clearly there should only be one price, so duplicate keys aren't allowed.\n"
"\n"
"Anyway, this is a normal shop where things have one price.\n"
"This normal shop has normal customers with normal shopping lists like `['apple', 'box', 'cat']`.\n"
"And even though your customers have calculators in their pockets, they still expect you to add up all the prices\n"
"yourself and tell them how much this will all cost, because that's what normal shops do.\n"
"\n"
"So let's write a function that does that. Complete the function below, particularly the line `price = ...`\n"
"\n"
"    __copyable__\n"
"__code2__"

msgid "pages.UsingDictionaries.steps.shopping_cart4.hints.0.text"
msgstr "Remember that the keys for `prices` and `quantities` are the same."

msgid "pages.UsingDictionaries.steps.shopping_cart4.hints.1.text"
msgstr "This is very similar to the previous exercise, we're just practicing."

msgid "pages.UsingDictionaries.steps.shopping_cart4.hints.2.text"
msgstr ""
"`price` should be a value from `prices`, and similarly for `quantity`."

msgid "pages.UsingDictionaries.steps.shopping_cart4.hints.3.text"
msgstr "What key should be used to obtain each value?"

msgid "pages.UsingDictionaries.steps.shopping_cart4.text"
msgstr ""
"Perfect! You publish your website and start dreaming about how rich you're going to be.\n"
"\n"
"But soon you get a complaint from a customer who wants to buy 5 million dogs...and 2 boxes to put them in.\n"
"\n"
"Your website allows buying the same items several times, e.g. `total_cost(['box', 'box'], {...})` works,\n"
"but they have to add each item one at a time, and for some reason this customer doesn't want to click\n"
"'Add to Cart' 5 million times. People are so lazy!\n"
"\n"
"Here's the new code for you to fix:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"We've added another parameter called `quantities` to `total_cost`.\n"
"Now `cart` is still a list of strings, but it doesn't have any duplicates.\n"
"`quantities` is a dictionary where the keys are the items in `cart` and the corresponding values are the quantity\n"
"of that item that the customer wants to buy."

msgid "pages.UsingDictionaries.title"
msgstr "Using Dictionaries in Practice"

msgid "pages.UsingVariables.steps.final_text.text"
msgstr ""
"Hurra! Już bez apostrofów! Wyjaśnimy, co dzieje się w tym kodzie później. "
"Na razie wystarczy wiedzieć, że `print(<coś>)` wyświetla `<coś>` w konsoli. "
"W szczególności pokazuje rzeczywistą zawartość napisów, na której nam "
"zazwyczaj zależy, zamiast przedstawienia napisów odpowiednich dla kodu, "
"które zawierają rzeczy takie jak cudzysłowy. Słowo `print` tutaj nie ma nic "
"wspólnego z drukarką czy drukowaniem."

msgid "pages.UsingVariables.steps.first_print.text"
msgstr ""
"Te cudzysłowy przy napisach zaczynają być irytujące. Spróbuj uruchomić to:\n"
"\n"
"__code0__"

msgid "pages.UsingVariables.steps.goodbye_plus_name.text"
msgstr "Obserwuj efekt tej zmiany uruchamiając `__program__` ponownie."

msgid "pages.UsingVariables.steps.hello_plus_name.text"
msgstr ""
"Możesz używać zmiennych w obliczeniach dokładnie tak samo, jak używałbyś literałów. Na przykład spróbuj:\n"
"\n"
"__program_indented__"

msgid ""
"pages.UsingVariables.steps.name_assign.messages.assigned_something_else.text"
msgstr ""
"Umieść `your_name` przed `=` aby stworzyć zmienną o nazwie `your_name`."

msgid "pages.UsingVariables.steps.name_assign.messages.empty_string.text"
msgstr "Do tego ćwiczenia wybierz niepusty napis (string)"

msgid ""
"pages.UsingVariables.steps.name_assign.messages.name_equals_something_else.text"
msgstr ""
"Masz prawidłową część `your_name = `, teraz po prawej stronie `=` umieść "
"napis (użyj apostrofów)."

msgid "pages.UsingVariables.steps.name_assign.messages.starts_with_space.text"
msgstr "Do tego ćwiczenia wybierz imię, które nie zaczyna się od spacji."

msgid "pages.UsingVariables.steps.name_assign.requirements"
msgstr ""
"Uruchom coś podobnego do `word = 'Hello'`, ale zamień `word` na `your_name`."

msgid "pages.UsingVariables.steps.name_assign.text"
msgstr ""
"Wcześniej utworzyliśmy zmienną o nazwie `word` z wartością `'Hello'` przy użyciu tego kodu:\n"
"\n"
"__code0__\n"
"\n"
"Teraz utwórz zmienną o nazwie `your_name`, której wartością jest inny napis (string).\n"
"\n"
"(Znak `_` w `your_name` to *podkreślnik*. Używaj go do rozdzielenia słów, kiedy potrzebujesz nazwy zmiennej zawierającej kilka słów. Możesz go wpisać na większości klawiatur, naciskając Shift oraz myślnik/pauza/minus (`-`).)"

msgid "pages.UsingVariables.steps.word_assign_goodbye.text"
msgstr ""
"Doskonale!\n"
"\n"
"Zmienne mogą również zmieniać swoje wartości w czasie. Aktualnie zmienna `word` ma wartość `'Hello'`. Możesz zmienić jej wartość w ten sam sposób, w jaki ją ustawiałeś po raz pierwszy. Uruchom to:\n"
"\n"
"__code0__"

msgid ""
"pages.UsingVariables.steps.word_plus_name.special_messages.bad_word.text"
msgstr ""
"Ups, musisz ustawić `word = 'Hello'` zanim będziemy mogli kontynuować."

msgid "pages.UsingVariables.steps.word_plus_name.text"
msgstr ""
"Ewentualnie możesz po prostu dodać zmienne do siebie. Spróbuj:\n"
"\n"
"__code0__"

msgid "pages.UsingVariables.steps.word_plus_name_with_space.hints.0.text"
msgstr "Musisz użyć `+` dwa razy, tak jak w 1+2+3."

msgid "pages.UsingVariables.steps.word_plus_name_with_space.hints.1.text"
msgstr ""
"Twoja odpowiedź powinna zawierać mieszankę zmiennych (bez cudzysłowu) i "
"literałów łańcuchowych (w cudzysłowie)."

msgid "pages.UsingVariables.steps.word_plus_name_with_space.hints.2.text"
msgstr "Musisz mieć znak spacji wewnątrz cudzysłowów."

msgid ""
"pages.UsingVariables.steps.word_plus_name_with_space.special_messages.bad_word.text"
msgstr ""
"Ups, musisz ustawić `word = 'Hello'` zanim będziemy mogli kontynuować."

msgid "pages.UsingVariables.steps.word_plus_name_with_space.text"
msgstr ""
"Ups... to nie wygląda ładnie. Czy możesz zmodyfikować powyższy kod tak, aby "
"między słowem a twoim imieniem była spacja?"

msgid "pages.UsingVariables.title"
msgstr "Używanie zmiennych i `print()`"


msgid "pages.WritingPrograms.steps.editor_hello_world.text"
msgstr ""
"Nadszedł czas, aby przestać robić wszystko w konsoli. W prawym górnym rogu można zobaczyć *edytor*. Jest to miejsce, w którym możesz pisać i uruchamiać dłuższe programy. Konsola jest świetna i powinieneś nadal z niej korzystać do eksploracji, ale to w edytorze żyją prawdziwe programy.\n"
"\n"
"Wpisz poniższy program do edytora, a następnie kliknij przycisk 'Uruchom':\n"
"\n"
"__code0__"

msgid "pages.WritingPrograms.steps.final_text.text"
msgstr ""
"Gratulacje, uruchomiłeś swój pierwszy rzeczywisty program!\n"
"\n"
"Poświęć trochę czasu, aby zrozumieć ten program. Python wykonuje każdą linię po kolei, od góry do dołu. Powinieneś spróbować symulować ten proces w swojej głowie - zastanów się, co robi każda linia. Zobacz, jak zmieniła się wartość zmiennej `word` i jakie to miało konsekwencje. Zauważ, że gdy używane jest wielokrotnie `print`, każda rzecz (w tym przypadku `Hello World` i `Goodbye World`) jest wypisywana na własnej linii.\n"
"\n"
"Kilka rzeczy, które warto zauważyć o programach w edytorze:\n"
"\n"
"1. Program jest uruchamiany w konsoli, co oznacza, że zmienne zdefiniowane w programie istnieją teraz w konsoli z ostatnimi wartościami, które miały w programie. Pozwala Ci to badać w konsoli po zakończeniu programu. Na przykład `name` ma teraz wartość `'World'` w konsoli.\n"
"2. Programy uruchamiają się w izolacji - nie zależą od żadnych wcześniej zdefiniowanych zmiennych. Konsola jest resetowana i wszystkie poprzednie zmienne są czyszczone. Więc pomimo że `word` obecnie istnieje w konsoli, jeśli usuniesz pierwszą linię programu i uruchomisz go ponownie, otrzymasz błąd o niezdefiniowanej zmiennej `word`.\n"
"3. Jeśli wpiszesz kod w konsoli i ma on wartość, ta wartość zostanie automatycznie wyświetlona. Nie dzieje się tak w przypadku programów w edytorze - musisz wydrukować wartości. Jeśli usuniesz `print()` z programu, zmieniając dwie linie na po prostu `word + ' ' + name`, nic nie zostanie wyświetlone.\n"
"\n"
"Najlepiej samodzielnie sprawdź te wszystkie rzeczy."

msgid "pages.WritingPrograms.title"
msgstr "Pisanie programów"
