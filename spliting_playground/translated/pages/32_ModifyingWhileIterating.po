#
msgid ""
msgstr ""

msgid "pages.ModifyingWhileIterating.steps.final_text.text"
msgstr ""
"To reiterate, ***never modify something while you iterate over it***. Your options are:\n"
"\n"
"- Modify a copy\n"
"- Iterate over a copy\n"
"- Don't modify anything, make a new version instead."

msgid "pages.ModifyingWhileIterating.steps.make_copy.requirements"
msgstr ""
"Run the same program as above, but change the second line:\n"
"\n"
"__code0__\n"
"\n"
"to:\n"
"\n"
"__code1__\n"
"\n"
"i.e. add `.copy()` after `numbers` but before `:`."

msgid "pages.ModifyingWhileIterating.steps.make_copy.text"
msgstr ""
"But it turns out this does nearly the same thing - it doesn't end in an error, but it still doesn't remove 7 or 3.\n"
"This happens for the same reason - iterating over a list still goes through the indices under the hood.\n"
"\n"
"The lesson here is to ***never modify something while you iterate over it***. Keep mutation and looping separate.\n"
"\n"
"The good news is that there are many ways to solve this. You can instead just loop over a copy, as in:\n"
"\n"
"__code0__"

msgid "pages.ModifyingWhileIterating.steps.make_copy2.text"
msgstr ""
"Now the list being modified and the list being iterated over are separate objects, even if they start out with equal contents.\n"
"\n"
"Similarly, you could loop over the original and modify a copy:\n"
"\n"
"__program_indented__"

msgid "pages.ModifyingWhileIterating.steps.make_new_list.text"
msgstr ""
"Or you could build up a new list from scratch. In this case, we've already done a similar thing in an exercise:\n"
"\n"
"__program_indented__"

msgid "pages.ModifyingWhileIterating.steps.remove_instead_of_pop.text"
msgstr ""
"As it runs, it clearly skips even looking at 7 or 3 and doesn't remove them, and at the end it fails when it tries to access an index that's too high. Can you see why this happens?\n"
"\n"
"The index variable `i` runs through the usual values 0, 1, 2, ... as it's supposed to, but as the list changes those are no longer the positions we want. For example in the first iteration `i` is 0 and `number` is 10, which gets removed. This shifts the rest of the numbers left one position, so now 7 is in position 0. But then in the next iteration `i` is 1, and `numbers[i]` is 8. 7 got skipped.\n"
"\n"
"We could try writing the program to use `remove` instead of `pop` so we don't have to use indices. It even looks nicer this way.\n"
"\n"
"__program_indented__"

msgid "pages.ModifyingWhileIterating.steps.run_broken_with_python_tutor.text"
msgstr ""
"Consider this program. It loops through a list of numbers and removes the ones smaller than 10. Or at least, it tries to.\n"
"Run it with Python Tutor.\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"(remember that `numbers.pop(i)` removes the element from `numbers` at index `i`)"

msgid "pages.ModifyingWhileIterating.title"
msgstr "Modifying While Iterating"
