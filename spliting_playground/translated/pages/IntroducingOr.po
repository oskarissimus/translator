#
msgid ""
msgstr ""

msgid "pages.IntroducingOr.steps.ACommonMistake.requirements"
msgstr ""
"Uruchom program z poprzedniego kroku, ale zamień:\n"
"\n"
"__code0__\n"
"\n"
"na:\n"
"\n"
"__code1__"

msgid "pages.IntroducingOr.steps.ACommonMistake.text"
msgstr ""
"Zwróć szczególną uwagę, jak napisaliśmy warunek:\n"
"\n"
"__code0__\n"
"\n"
"Typowym błędem jest napisanie tego zamiast:\n"
"\n"
"__code1__\n"
"\n"
"To ma sens, jeśli czytasz to jak po angielsku:\n"
"\n"
"> `return` czy `name` jest równy albo `\"Alice\"` lub `\"Bob\"`\n"
"\n"
"Ale Python nie jest angielskim, i nie tak działa `or`.\n"
"\n"
"Zamień linię `return` w kodzie powyższą linią, i spróbuj uruchomić to ponownie."

msgid "pages.IntroducingOr.steps.AnExercise.disallowed.3.label"
msgstr "łańcuchowe porównanie"

msgid "pages.IntroducingOr.steps.AnExercise.hints.0.text"
msgstr ""
"Pamiętaj, możesz użyć operatorów porównujących `<, >, <=, >=, ==` do "
"wytworzenia booleanów."

msgid "pages.IntroducingOr.steps.AnExercise.hints.1.text"
msgstr "Musisz sprawdzić, jak `x` porównuje się do 0 i jak do 100."

msgid "pages.IntroducingOr.steps.AnExercise.hints.2.text"
msgstr "Musisz połączyć dwa porównania w jeden boolean używając `or`."

msgid "pages.IntroducingOr.steps.AnExercise.hints.3.text"
msgstr ""
"Powżej użyliśmy triku, aby całe ciało funkcji było po prostu `return "
"<porównanie> or <porównanie>`. Ale to nie zadziała tutaj!"

msgid "pages.IntroducingOr.steps.AnExercise.hints.4.text"
msgstr "Musisz użyć instrukcji `if`."

msgid "pages.IntroducingOr.steps.AnExercise.hints.5.text"
msgstr "Musisz mieć `return False` i `return True`."

msgid "pages.IntroducingOr.steps.AnExercise.hints.6.text"
msgstr ""
"Jeśli masz coś w rodzaju `x >= 0 or x <= 100`, jesteś na złym tropie. To "
"będzie prawdą dla *dowolnej* wartości `x`. W końcu 101 jest większe niż 0!"

msgid "pages.IntroducingOr.steps.AnExercise.text"
msgstr ""
"Gdy zbadamy to z pomocą `birdseye`, widzimy, że:\n"
"\n"
"__code0__\n"
"\n"
"nie jest tłumaczone na\n"
"\n"
"__code1__\n"
"\n"
"tak jak myślimy po angielsku, ale raczej:\n"
"\n"
"__code2__\n"
"\n"
"co ocenia się jako `\"Bob\"`, gdy `name == \"Alice\"` jest `False`.\n"
"\n"
"Może czujesz się tak:\n"
"\n"
"[![Mam teraz dodatkowe pytania](https://i.imgur.com/jN57tGt.png)](https://imgur.com/a/icKzI)\n"
"\n"
"Jedyna rzecz, którą naprawdę musisz wiedzieć to: dopóki nie wiesz, co robisz, zawsze\n"
"upewnij się, że po obu stronach `or` są booleany, ponieważ to jest operator boolean.\n"
"`name == \"Alice\" or \"Bob\"` łamie tę zasadę.\n"
"\n"
"Jeśli jesteś ciekawy, odpowiedzi są poniżej, ale możesz je pominąć, jeśli chcesz, i przejść do ćwiczenia poniżej.\n"
"\n"
"----\n"
"\n"
"> Dlaczego `(name == \"Alice\") or (\"Bob\")` równa się `\"Bob\"`? Dlaczego równa się cokolwiek? `\"Bob\"` nawet nie jest booleanem!\n"
"\n"
"Definicja \"`A or B` jest `True` jeśli `A` lub `B` jest `True`\" była uproszczeniem. Jest to najłatwiejszy\n"
"sposób myślenia o `or` większość czasu, szczególnie przy pisaniu instrukcji `if`.\n"
"Prawdziwa definicja jest taka, że jeśli `A` jest prawdziwe, to `A or B` to po prostu `A` (w rzeczywistości `B` nawet nie jest oceniane),\n"
"w przeciwnym razie to `B`.\n"
"Możesz samemu sprawdzić, że jeśli `A` i `B` są booleanami, to obie definicje są równoważne.\n"
"W tym przykładzie `A` to `name == \"Alice\"`, co jest `False`, więc `A or B` to `B`, które jest `\"Bob\"`.\n"
"\n"
"> Czy jest lepszy sposób na napisanie warunku bez powtarzania `name ==` za każdym razem?\n"
"\n"
"Tak! W [Funkcje i Metody dla List](#FunctionsAndMethodsForLists) wspomnieliśmy o operatorze `in`,\n"
"którego możesz użyć z listą w taki sposób:\n"
"\n"
"__code3__\n"
"\n"
"Ale nie zawsze możesz pozbyć się `or` w ten sposób.\n"
"\n"
"----\n"
"\n"
"Ćwiczenie: Napisz funkcję o nazwie `is_valid_percentage`, przyjmującą jeden argument numeryczny `x`.\n"
"Powinna zwracać `True`, jeśli `x` jest między 0 a 100 (włącznie), oraz zwracać `False` w przeciwnym przypadku.\n"
"Twoja funkcja powinna używać `or` i spełniać te testy:\n"
"\n"
"    __copyable__\n"
"__code4__"

msgid "pages.IntroducingOr.steps.FalseOrFalse.text"
msgstr ""
"Na koniec spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.FurtherImprovement.requirements"
msgstr ""
"Uruchom program z poprzedniego kroku, ale zamień:\n"
"\n"
"__code0__\n"
"\n"
"na:\n"
"\n"
"__code1__"

msgid "pages.IntroducingOr.steps.FurtherImprovement.text"
msgstr ""
"Możemy zrobić jeszcze lepiej. Zauważ, że\n"
"\n"
"__code0__\n"
"\n"
"jest booleanem, i oba `return` zwracają booleany `True` lub `False`.\n"
"Funkcja:\n"
"\n"
" - zwraca `True` gdy `name == \"Alice\" or name == \"Bob\"` jest `True`, oraz\n"
" - zwraca `False` gdy `name == \"Alice\" or name == \"Bob\"` jest `False`.\n"
"\n"
"Więc moglibyśmy po prostu zwrócić boolean `name == \"Alice\" or name == \"Bob\"` jako taki w obu przypadkach!\n"
"\n"
"To jest częsty sposób na uproszczenie twojego kodu. Jeśli kiedykolwiek znajdziesz się w sytuacji pisania kodu takiego jak:\n"
"\n"
"__code1__\n"
"\n"
"gdzie `x` sam w sobie jest booleanem, zawsze możesz uprościć ten blok kodu do:\n"
"\n"
"__code2__\n"
"\n"
"Zastosuj tę uproszczenie do kodu sam, i uruchom go ponownie."

msgid "pages.IntroducingOr.steps.ImprovingWithOr.requirements"
msgstr ""
"Skopiuj program z początku strony, a następnie zmień pierwsze cztery linijki"
" funkcji tak, aby użyć `or` zgodnie z sugestią."

msgid "pages.IntroducingOr.steps.ImprovingWithOr.text"
msgstr ""
"W edytorze zamień:\n"
"\n"
"__code0__\n"
"\n"
"na:\n"
"\n"
"__code1__\n"
"\n"
"Jak widzisz, `is_friend` zwróci `True` tylko wtedy, gdy `name` to Alice lub Bob.\n"
"Operator `or` używany jest między dwoma booleanami `name == \"Alice\"` i `name == \"Bob\"`."

msgid "pages.IntroducingOr.steps.InputAliceBob.text"
msgstr ""
"Dowiedzieliśmy się o *booleanach* (`True` i `False`), gdy wprowadzaliśmy instrukcje warunkowe If.\n"
"Nauczyliśmy się również o operatorach porównujących `==`, `<`, `>`, `<=`, `>=`, które zwracają booleany.\n"
"Teraz chcemy połączyć booleany, aby sprawdzać bardziej złożone warunki.\n"
"\n"
"Oto prosty przykład: wyobraź sobie, że masz dwóch przyjaciół, Alice i Boba.\n"
"Funkcja poniżej przyjmuje jeden parametr, `name`, i sprawdza, czy osoba o podanej nazwie jest wśród twoich przyjaciół.\n"
"Skopiuj i uruchom kod w edytorze:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingOr.steps.InspectWithBirdseye.requirements"
msgstr "Uruchom ten sam kod co w poprzednim kroku, ale użyj `birdseye`."

msgid "pages.IntroducingOr.steps.InspectWithBirdseye.text"
msgstr ""
"Drugi i trzeci test zawiodły! Nasza funkcja wydaje się robić coś nie tak:\n"
"zwraca `\"Bob\"` (łańcuch znaków, a nie boolean!) gdy `name` to `\"Bob\"` lub `\"Charlie\"`. Co się dzieje?\n"
"Uruchom ten sam problematyczny kod ponownie z `birdseye`. Dokładnie sprawdź instrukcje `return` każdego wywołania `is_friend`.\n"
"(Użyj niebieskich przycisków ze strzałką)"

msgid "pages.IntroducingOr.steps.TrueOrFalse.text"
msgstr ""
"Dobrze, teraz spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.TrueOrTrue.text"
msgstr ""
"Zobaczmy, czy możemy to zrobić lepiej.\n"
"Możemy połączyć instrukcje `if` i `elif`, używając **`or`**. `or` jest *operatorem boolean*,\n"
"co znaczy, że jest to operator (tak jak `+` lub `-`), który łączy dwa booleany (`True` lub `False`).\n"
"\n"
"Wyrażenie `A or B` jest `True`, jeśli `A` lub `B` jest `True`, to znaczy jeśli `A` jest `True` lub `B` jest `True`, albo oba.\n"
"Jest `False` tylko wtedy, gdy ani `A` ani `B` nie jest `True`, to znaczy oba są `False`.\n"
"\n"
"Wypróbuj poniższe w konsoli.\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.final_text.text"
msgstr "Dobra robota!"

msgid "pages.IntroducingOr.title"
msgstr "Wprowadzenie do `or`"
