msgid "pages.NestedListAssignment.steps.final_text.text"
msgstr ""
"Świetnie! Jesteś prawie gotowy, żeby to wszystko ze sobą połączyć, idź "
"dalej!"

msgid "pages.NestedListAssignment.steps.modify_list_in_function.text"
msgstr ""
"Widzieliśmy już, jak uzyskać dane wejściowe od użytkownika, teraz użyjmy tego do faktycznegorozmieszczania elementów na planszy i granie w grę. Na początek wypróbuj ten kod:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.0.text"
msgstr ""
"Twoja funkcja musi wywołać `input()` dwa razy. Dane wejściowe nie są "
"przekazywane do `play_move` jako argument."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.1.text"
msgstr "`input()` zawsze zwraca ciąg znaków."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.10.text"
msgstr ""
"Kiedy masz już dwie liczby, musisz zmodyfikować zagnieżdżoną listę `board` "
"przy pomocy nich."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.11.text"
msgstr "Kod do tego został ci pokazany powyżej."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.12.text"
msgstr ""
"Wystarczy użyć liczb z wejścia użytkownika zamiast zakodowanego na sztywno 1"
" i 0."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.13.text"
msgstr ""
"Możesz użyć zagnieżdżonego indeksowania w jednej linii lub zrobić to w dwóch"
" krokach."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.2.text"
msgstr ""
"Ciąg znaków wyglądający jak liczba jest nadal ciągiem znaków, a nie liczbą."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.3.text"
msgstr "Indeksy listy muszą być liczbami, a nie ciągami znaków."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.4.text"
msgstr ""
"Jeśli plansza ma rozmiar 3x3, użytkownik może wprowadzić 1, 2 lub 3 dla "
"każdej współrzędnej."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.5.text"
msgstr "Jakie są prawidłowe indeksy listy o długości 3?"

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.6.text"
msgstr "Musisz zamienić wejściowe 1, 2 lub 3 na 0, 1 lub 2."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.7.text"
msgstr ""
"Musisz także umieć obsłużyć większe plansze, takie jak 9x9 lub większe."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.8.text"
msgstr "Nie możesz robić matematyki na ciągach znaków, tylko na liczbach."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.9.text"
msgstr "Jak możesz przekształcić ciąg znaków w liczbę?"

msgid "pages.NestedListAssignment.steps.nested_assignment_input.requirements"
msgstr ""
"Twoja funkcja powinna zmodyfikować argument `board`. Nie ma potrzeby, aby "
"`return` albo `print` coś."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.text"
msgstr ""
"Te dwie linijki:\n"
"\n"
"__code0__\n"
"\n"
"mogą być połączone w jedną:\n"
"\n"
"__code1__\n"
"\n"
"Dwa kawałki kodu są praktycznie równoznaczne. Python najpierw oblicza\n"
"`board[1]`, aby *uzyskać* wewnętrzną listę, podczas gdy `[0] = ...` ustawia element `board[1]`.\n"
"Możesz zobaczyć wartość `board[1]` w `birdseye`, ponieważ jest to wyrażenie,\n"
"i możesz je faktycznie zastąpić dowolnym innym wyrażeniem.\n"
"\n"
"Teraz wiesz, jak ustawiać elementy w zagnieżdżonych listach, czas zrobić to interaktywnie!\n"
"Napisz swoją własną wersję funkcji `play_move`, która przyjmuje dane wejściowe od użytkownika\n"
"by określić, gdzie grać, zamiast zawsze grać na `board[1][0]`.\n"
"Funkcja powinna wywołać `input()` dwa razy, aby użytkownik mógł podać wiersz i kolumnę\n"
"jako dwie oddzielne liczby. Ponadto nasi użytkownicy nie są programistami, więc zaczynają liczyć od 1,\n"
"nie od 0.\n"
"\n"
"Na przykład, jeśli użytkownik wpisze te dane wejściowe:\n"
"\n"
"__code2__\n"
"\n"
"to oznacza, że chce zagrać ruch w drugim wierszu i pierwszej kolumnie, co jest tym samym\n"
"co w naszym oryginalnym przykładzie.\n"
"\n"
"Oto jakieś początkowe kody:\n"
"\n"
"    __copyable__\n"
"__code3__\n"
"\n"
"To wywołuje funkcję `play_move` dwa razy, więc użytkownik będzie musiał wprowadzić dwie pary liczb.\n"
"Oto przykład, jak powinna wyglądać gra:\n"
"\n"
"     123\n"
"    1\n"
"    2\n"
"    3\n"
"\n"
"    X do gry:\n"
"\n"
"__code2__\n"
"     123\n"
"    1\n"
"    2X\n"
"    3\n"
"\n"
"    O do gry:\n"
"\n"
"    1\n"
"    3\n"
"     123\n"
"    1  O\n"
"    2X\n"
"    3\n"
"\n"
"Nie musisz używać podanego kodu dosłownie, to tylko ma dać ci wyobrażenie, co się dzieje.\n"
"Co ważne, twoja funkcja `play_move` musi poprawnie modyfikować argument `board`.\n"
"Nie musi niczego zwracać ani drukować, to nie będzie sprawdzane.\n"
"\n"
"Możesz założyć, że użytkownik zawsze wprowadzi prawidłowe liczby. Później nauczymy się, jak radzić sobie\n"
"z nieprawidłowymi danymi wejściowymi, takimi jak liczby poza zakresem lub dane, które w ogóle nie są liczbami."

msgid "pages.NestedListAssignment.steps.nested_assignment_two_lines.text"
msgstr ""
"Zauważ, jak wywołanie `play_move(game_board, 'X')` *modyfikuje* bezpośrednio `game_board`.\n"
"Zmienna `board` wewnątrz wywołania funkcji `play_move` i\n"
"zmienna `game_board` wewnątrz wywołania `play_game` wskazują na ten sam obiekt listy. \n"
"Nie ma kopiowania. Python Tutor dobrze to pokazuje za pomocą strzałek.\n"
"\n"
"To również oznacza, że w tym przypadku nie ma potrzeby, aby `play_move` zwracało cokolwiek,\n"
"wystarczy, że funkcja zmodyfikuje `board`, a wywołujący (w tym przypadku `play_game`) zobaczy efekt.\n"
"\n"
"Jednak nasza plansza jest dwuwymiarowa, reprezentowana przez zagnieżdżoną listę.\n"
"Więc musimy przypisać `player` do elementu listy wewnętrznej, coś takiego:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.NestedListAssignment.title"
msgstr "Przypisanie Zagnieżdżonej Listy: Umieszczanie Ruchów na Planszy"
