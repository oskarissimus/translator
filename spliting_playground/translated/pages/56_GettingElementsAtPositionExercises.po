#
msgid ""
msgstr ""

msgid "pages.GettingElementsAtPositionExercises.steps.final_text.text"
msgstr "Fantastycznie! Zrób sobie przerwę, na to zasłużyłeś!"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.0.text"
msgstr ""
"Będziesz musiał spojrzeć na wszystkie możliwe indeksy `things` i sprawdzić,"
" który z nich jest odpowiedzią."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.1.text"
msgstr ""
"Aby przejrzeć wszystkie możliwe indeksy, będziesz potrzebował pętli po "
"`range(len(things))`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.2.text"
msgstr "Aby sprawdzić, czy indeks jest odpowiedzią, będziesz musiał użyć:"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.3.text"
msgstr "- `if`"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.4.text"
msgstr "- indeksu w subskrypcie"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.5.text"
msgstr "- `==`"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.6.text"
msgstr ""
"Ponieważ szukasz pierwszego indeksu, musisz zatrzymać pętlę, gdy go znajdziesz."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.7.text"
msgstr "Niedawno nauczyłeś się, jak zatrzymać pętlę w połowie."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.8.text"
msgstr "Potrzebujesz użyć `break`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.messages.all_indices.text"
msgstr ""
"Jesteś prawie na miejscu! Jednak to drukuje wszystkie indeksy,\n"
" nie tylko pierwszy."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.messages.last_index.text"
msgstr ""
"Jesteś prawie na miejscu! Jednak to drukuje *ostatni* indeks,\n"
" nie pierwszy."

msgid "pages.GettingElementsAtPositionExercises.steps.index_exercise.text"
msgstr ""
"Zakładając, że masz listę `things` oraz wartość `to_find`,\n"
"wydrukuj pierwszy indeks `to_find` na liście, tzn. najmniejszą liczbę `i` taką, że\n"
"`things[i]` jest `to_find`. Na przykład, dla\n"
"\n"
"    __no_auto_translate__\n"
"    things = ['on', 'the', 'way', 'to', 'the', 'store']\n"
"    to_find = 'the'\n"
"\n"
"twój program powinien wydrukować `1`.\n"
"\n"
"Możesz założyć, że `to_find` pojawia się przynajmniej raz."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.0.text"
msgstr ""
"Czy eksperymentowałeś z indeksowaniem i `len()` ze stringami w powłoce (shell)?"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.1.text"
msgstr ""
"Na moment zapomnij o pętlach. Jak byś wydrukował tylko pierwszą linię, która "
"zawiera pierwszy znak każdego z dwóch stringów?"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.2.text"
msgstr ""
"W drugiej linii chcesz wydrukować drugi znak każdego stringa, "
"i tak dalej."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.3.text"
msgstr "Będziesz potrzebować pętli `for`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.4.text"
msgstr "Będziesz potrzebować indeksowania (subskrypcji)."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.5.text"
msgstr "Będziesz potrzebować `range`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.6.text"
msgstr "Będziesz potrzebować `len`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.7.text"
msgstr "Będziesz potrzebować `+`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.8.text"
msgstr "Będziesz musiał zindeksować oba stringi."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.9.text"
msgstr ""
"Będziesz musiał przekazać ten sam indeks do obu stringów za każdym razem, aby pobierać "
"odpowiadające sobie znaki."

msgid "pages.GettingElementsAtPositionExercises.steps.zip_exercise.text"
msgstr ""
"Świetnie!\n"
"\n"
"Tak na marginesie, indeksowanie i `len()` również działają na stringach. Wypróbuj je w powłoce.\n"
"\n"
"Oto kolejne ćwiczenie. Mając dwa stringi o równych długościach, np:\n"
"\n"
"    __no_auto_translate__\n"
"    string1 = 'Hello'\n"
"    string2 = 'World'\n"
"\n"
"wydrukuj je pionowo, obok siebie, z odstępem między każdą parą znaków:\n"
"\n"
"    H W\n"
"    e o\n"
"    l r\n"
"    l l\n"
"    o d"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.0.text"
msgstr ""
"Rozwiązanie ma tę samą ogólną strukturę i kluczowe elementy co poprzednie rozwiązanie, "
"jednak jest znacznie dłuższe i będzie wymagać kilku dodatkowych pomysłów i części."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.1.text"
msgstr ""
"W szczególności powinno nadal zawierać coś w stylu:\n"
"\n"
"__code0__"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.2.text"
msgstr ""
"Co powinno się znaleźć w `range()`? Ani `len(string1)`, ani `len(string2)` "
"nie są wystarczająco dobre."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.3.text"
msgstr "Chcesz iteracji pętli dla każdego znaku w dłuższym stringu."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.4.text"
msgstr "To oznacza, że potrzebujesz `range(<długość najdłuższego stringu>)`"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.5.text"
msgstr ""
"Innymi słowy, potrzebujesz znaleźć większą z dwóch wartości `len(string1)` "
"i `len(string2)`. Już wykonałeś podobne ćwiczenie."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.6.text"
msgstr ""
"Kiedy już rozwiążesz kwestię pętli `for i in range(...)`, `i` czasami będzie za duże, "
"żeby było ważnym indeksem dla obu stringów. Będziesz musiał sprawdzić, czy nie jest za duże "
"przed indeksowaniem."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.7.text"
msgstr ""
"Pamiętaj, że największy ważny indeks dla `string1` to `len(string1) - 1`. "
"`len(string1)` jest za duże."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.8.text"
msgstr "Będziesz potrzebować dwóch instrukcji `if`, jednej dla każdego stringu."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.9.text"
msgstr ""
"Będziesz musiał ustawić np. `char1 = ' '` gdy `string1[i]` nie jest ważny."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.text"
msgstr ""
"Niesamowite!\n"
"\n"
"Twoje rozwiązanie prawdopodobnie wyglądało mniej więcej tak:\n"
"\n"
"__code0__\n"
"\n"
"To nie działa zbyt dobrze, jeśli stringi mają różne długości.\n"
"W rzeczywistości, błędy pojawiają się na różne sposoby w zależności od tego, czy `string1` czy `string2` jest dłuższy.\n"
"Twoje kolejne wyzwanie polega na rozwiązaniu tego problemu poprzez wypełnienie 'brakujących' znaków spacjami.\n"
"\n"
"Na przykład, dla:\n"
"\n"
"    __no_auto_translate__\n"
"    string1 = 'Goodbye'\n"
"    string2 = 'World'\n"
"\n"
"wypisz:\n"
"\n"
"    G W\n"
"    o o\n"
"    o r\n"
"    d l\n"
"    b d\n"
"    y\n"
"    e\n"
"\n"
"i dla:\n"
"\n"
"    __no_auto_translate__\n"
"    string1 = 'Hello'\n"
"    string2 = 'Elizabeth'\n"
"\n"
"wypisz:\n"
"\n"
"    H E\n"
"    e l\n"
"    l i\n"
"    l z\n"
"    o a\n"
"      b\n"
"      e\n"
"      t\n"
"      h"

msgid "pages.GettingElementsAtPositionExercises.title"
msgstr "Ćwiczenia z `range()` i `len()`"
