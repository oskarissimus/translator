msgid "pages.IntroducingNotPage.steps.IntroducingNot.text"
msgstr ""
"W przeciwieństwie do dwóch innych operatorów boolowskich `and` i `or`,\n"
"które są używane między dwoma wartościami boolowskimi (nazywanymi *operatorami binarnymi*),\n"
"`not` jest używany przed tylko jedną wartością boolowską (nazywanym *operatorem unarnym*).\n"
"Neguje on wyrażenie, do którego jest stosowany, trochę jak znak minus. Spróbuj w powłoce:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingNotPage.steps.NotFalse.text"
msgstr ""
"Teraz spróbuj następującego:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.0.text"
msgstr ""
"Co by było, gdybyś miał za zadanie uproszczenie tej powiązanej, ale przeciwnej funkcji?\n"
"\n"
"__code0__"

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.1.text"
msgstr ""
"W takim przypadku jest standardowy trik upraszczający, który omówiliśmy "
"kilka stron temu."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.2.text"
msgstr ""
"Ogólnie rzecz ujmując, `returns` są zbędne, bo `filename.endswith(\".png\") "
"or filename.endswith(\".jpg\")` jest już pożądaną wartością boolowską."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.3.text"
msgstr ""
"Więc możesz po prostu napisać:\n"
"\n"
"__code0__"

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.4.text"
msgstr "Dla prawdziwego ćwiczenia możesz zrobić coś podobnego."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.5.text"
msgstr ""
"Różnica w prawdziwym ćwiczeniu polega na tym, że wynik jest odwrócony."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.6.text"
msgstr ""
"To znaczy, że `invalid_image` zwraca `True` kiedy `valid_image` zwraca "
"`False` i na odwrót."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.7.text"
msgstr "Pamiętasz, co robi `not`?"

msgid "pages.IntroducingNotPage.steps.NotPriority.text"
msgstr ""
"Możesz zobaczyć w `birdseye`, że\n"
"\n"
"__code0__\n"
"\n"
"jest interpretowane przez Pythona jako\n"
"\n"
"__code1__\n"
"\n"
"zamiast:\n"
"\n"
"__code2__\n"
"\n"
"Więc, `not` ma wyższy priorytet niż `or`, jeśli nie ma nawiasów. Jest to takie samo jak w przypadku, gdy\n"
"\n"
"__code3__\n"
"\n"
"oznacza:\n"
"\n"
"__code4__\n"
"\n"
"zamiast\n"
"\n"
"__code5__\n"
"\n"
"`not` ma również wyższy priorytet niż `and`.\n"
"\n"
"Znowu, główną rzeczą do zapamiętania jest używanie nawiasów lub dodatkowych zmiennych w razie wątpliwości.\n"
"\n"
"Ćwiczenie: Załóżmy, że piszesz program przetwarzający obrazy. Tylko niektóre typy plików można przetworzyć.\n"
"Jeśli użytkownik poda ci plik, którego nie można przetworzyć, chcesz wyświetlić błąd:\n"
"\n"
"__code6__\n"
"\n"
"Załóżmy, że pliki .png i .jpg można przetwarzać, ale inne typy plików nie mogą być przetwarzane.\n"
"Oto przykładowa funkcja do tego:\n"
"\n"
"    __copyable__\n"
"__code7__\n"
"\n"
"To jest dłuższe niż potrzeba. Przepisz funkcję `invalid_image`, aby treść była jednoliniowa `return <expression>`,\n"
"tzn. bez instrukcji `if`. Powinna przejść te same testy."

msgid "pages.IntroducingNotPage.steps.NotTrueOrTrue.text"
msgstr ""
"Jaki jest priorytet `not` w porównaniu z `and` i `or`? Spróbuj następującego w `birdseye`:\n"
"\n"
"__code0__"

msgid "pages.IntroducingNotPage.steps.final_text.text"
msgstr ""
"Brawo! Oto dwie poprawne rozwiązania:\n"
"\n"
"__code0__\n"
"\n"
"(jeśli jesteś ciekawy, te rozwiązania są równoważne dzięki czemuś, co nazywa się prawem De Morgana)\n"
"\n"
"Zauważ także, że jest to kolejny ogólny wzorzec, który można uprościć: jeśli twój kod ma formę:\n"
"\n"
"__code1__\n"
"\n"
"gdzie `x` sam w sobie jest wartością boolowską, wówczas można go uprościć do:\n"
"\n"
"__code2__"

msgid "pages.IntroducingNotPage.title"
msgstr "Wprowadzenie do `not`"
