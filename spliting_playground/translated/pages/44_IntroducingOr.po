#
msgid ""
msgstr ""

msgid "pages.IntroducingOr.steps.ACommonMistake.requirements"
msgstr ""
"Run the program from the previous step, but replace:\n"
"\n"
"__code0__\n"
"\n"
"with:\n"
"\n"
"__code1__"

msgid "pages.IntroducingOr.steps.ACommonMistake.text"
msgstr ""
"Take careful note of how we wrote the condition:\n"
"\n"
"__code0__\n"
"\n"
"A common mistake is to write this instead:\n"
"\n"
"__code1__\n"
"\n"
"It makes sense if you read it like English:\n"
"\n"
"> `return` whether `name` is equal to either `\"Alice\"` or `\"Bob\"`\n"
"\n"
"But Python is not English, and that's not how `or` works.\n"
"\n"
"Replace the `return` line in the code with the above line, and try running it again."

msgid "pages.IntroducingOr.steps.AnExercise.disallowed.3.label"
msgstr "comparison chaining"

msgid "pages.IntroducingOr.steps.AnExercise.hints.0.text"
msgstr ""
"Remember, you can use comparison operators `<, >, <=, >=, ==` to produce "
"booleans."

msgid "pages.IntroducingOr.steps.AnExercise.hints.1.text"
msgstr "You need to check how `x` compares to 0 and how it compares to 100."

msgid "pages.IntroducingOr.steps.AnExercise.hints.2.text"
msgstr "You need to combine the two comparisons into one boolean using `or`."

msgid "pages.IntroducingOr.steps.AnExercise.hints.3.text"
msgstr ""
"Above we used a trick so that the whole function body was just `return "
"<comparison> or <comparison>`. But that won't work here!"

msgid "pages.IntroducingOr.steps.AnExercise.hints.4.text"
msgstr "You need to use an `if` statement."

msgid "pages.IntroducingOr.steps.AnExercise.hints.5.text"
msgstr "You need to have a `return False` and a `return True`."

msgid "pages.IntroducingOr.steps.AnExercise.hints.6.text"
msgstr ""
"If you have something like `x >= 0 or x <= 100`, you're on the wrong track. "
"That's going to be true for *any* value of `x`. After all, 101 is greater "
"than 0!"

msgid "pages.IntroducingOr.steps.AnExercise.text"
msgstr ""
"When we inspect it with `birdseye`, we can see that:\n"
"\n"
"__code0__\n"
"\n"
"is not translated into\n"
"\n"
"__code1__\n"
"\n"
"the way we think in English, but rather:\n"
"\n"
"__code2__\n"
"\n"
"which evaluates to `\"Bob\"` when `name == \"Alice\"` is `False`.\n"
"\n"
"Perhaps you feel like this:\n"
"\n"
"[![I now have additional questions](https://i.imgur.com/jN57tGt.png)](https://imgur.com/a/icKzI)\n"
"\n"
"The only thing you really need to know is this: Until you know what you're doing, always\n"
"make sure you put booleans on both sides of `or`, because it's a boolean operator.\n"
"`name == \"Alice\" or \"Bob\"` breaks that rule.\n"
"\n"
"If you're curious, the answers are below, but you can skip them if you want and move onto the exercise below.\n"
"\n"
"----\n"
"\n"
"> Why does `(name == \"Alice\") or (\"Bob\")` equal `\"Bob\"`? Why does it equal anything? `\"Bob\"` isn't even a boolean!\n"
"\n"
"The definition \"`A or B` is `True` if either `A` or `B` is `True`\" was a simplification. It's the easiest\n"
"way to think about `or` most of the time, especially for writing `if` statements.\n"
"The real definition is that if `A` is true then `A or B` is just `A` (in fact `B` is not even evaluated),\n"
"otherwise it's `B`.\n"
"You can see for yourself that if `A` and `B` are booleans then the two definitions are equivalent.\n"
"In this example `A` is `name == \"Alice\"` which is `False`, so `A or B` is `B` which is `\"Bob\"`.\n"
"\n"
"> Is there a better way to write the condition without repeating `name ==` each time?\n"
"\n"
"Yes! In [Functions and Methods for Lists](#FunctionsAndMethodsForLists) we mentioned the `in`\n"
"operator, which you can use with a list like this:\n"
"\n"
"__code3__\n"
"\n"
"But you can't always get rid of `or` like that.\n"
"\n"
"----\n"
"\n"
"Exercise: Write a function named `is_valid_percentage`, accepting one numerical argument `x`.\n"
"It should return `True` if `x` is between 0 and 100 (inclusive), and return `False` otherwise.\n"
"Your function should use `or`, and pass these tests:\n"
"\n"
"    __copyable__\n"
"__code4__"

msgid "pages.IntroducingOr.steps.FalseOrFalse.text"
msgstr ""
"Finally, try:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.FurtherImprovement.requirements"
msgstr ""
"Run the program from the previous step, but replace:\n"
"\n"
"__code0__\n"
"\n"
"with:\n"
"\n"
"__code1__"

msgid "pages.IntroducingOr.steps.FurtherImprovement.text"
msgstr ""
"We can do even better. Notice that\n"
"\n"
"__code0__\n"
"\n"
"is a boolean, and both `return` statements are returning booleans `True` or `False`.\n"
"The function:\n"
"\n"
" - returns `True` when `name == \"Alice\" or name == \"Bob\"` is `True`, and\n"
" - returns `False` when `name == \"Alice\" or name == \"Bob\"` is `False`.\n"
"\n"
"So we could simply return the boolean `name == \"Alice\" or name == \"Bob\"` itself in both cases!\n"
"\n"
"This is a common pattern for simplifying your code. If you ever find yourself writing code like:\n"
"\n"
"__code1__\n"
"\n"
"where `x` itself is a boolean, you can always simplify this block of code to:\n"
"\n"
"__code2__\n"
"\n"
"Apply this simplification to the code yourself, and run it again."

msgid "pages.IntroducingOr.steps.ImprovingWithOr.requirements"
msgstr ""
"Copy the program from the top of the page, then change the first four lines "
"of the function to use `or` as suggested."

msgid "pages.IntroducingOr.steps.ImprovingWithOr.text"
msgstr ""
"In the editor, replace:\n"
"\n"
"__code0__\n"
"\n"
"with:\n"
"\n"
"__code1__\n"
"\n"
"As you can see, `is_friend` will return `True` only when `name` is Alice or Bob.\n"
"The `or` is used in between the two booleans `name == \"Alice\"` and `name == \"Bob\"`."

msgid "pages.IntroducingOr.steps.InputAliceBob.text"
msgstr ""
"We learned about *booleans* (`True` and `False`) when we introduced If statements.\n"
"We also learned about comparison operators `==`, `<`, `>`, `<=`, `>=` which return booleans.\n"
"Now we want to combine booleans to check for more complex conditions.\n"
"\n"
"Here's a simple example: imagine you have two friends, Alice and Bob.\n"
"The function below accepts one parameter, `name`, and checks if the person with the given name is among your friends.\n"
"Copy and run the code in the editor:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingOr.steps.InspectWithBirdseye.requirements"
msgstr "Run the same code as in the previous step, but with `birdseye`."

msgid "pages.IntroducingOr.steps.InspectWithBirdseye.text"
msgstr ""
"The second and third tests fail! Our function seems to be doing the wrong thing:\n"
"it returns `\"Bob\"` (a string, not a boolean!) when `name` is `\"Bob\"` or `\"Charlie\"`. What is going on?\n"
"Run the same problematic code again with `birdseye`. Inspect the `return` statements of each `is_friend` call carefully.\n"
"(Use the blue arrow buttons)"

msgid "pages.IntroducingOr.steps.TrueOrFalse.text"
msgstr ""
"Good, now try:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.TrueOrTrue.text"
msgstr ""
"Let's see if we can do better.\n"
"We can combine the `if` and `elif` statements using **`or`**. `or` is a *boolean operator*,\n"
"meaning it's an operator (like `+` or `-`) which combines two booleans (`True` or `False`).\n"
"\n"
"The expression `A or B` is `True` if either `A` or `B` is `True`, i.e. if `A` is `True` or `B` is `True`, or both.\n"
"It's only `False` if neither `A` nor `B` is `True`, i.e. both are `False`.\n"
"\n"
"Try the following in the shell.\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.final_text.text"
msgstr "Good job!"

msgid "pages.IntroducingOr.title"
msgstr "Introducing `or`"
