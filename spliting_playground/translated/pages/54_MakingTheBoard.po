msgid "pages.MakingTheBoard.steps.final_text.text"
msgstr ""
"Brawo!\n"
"\n"
"To mogło zostać rozwiązane przez przeniesienie pierwszej pętli do wewnątrz drugiej, aby stworzyć nowy `row` za każdym razem:\n"
"\n"
"__code0__\n"
"\n"
"Inną metodą jest tworzenie kopii `row` za każdym razem, np. zachowując oryginalny kod, ale zmieniając jedną linię:\n"
"\n"
"__code1__\n"
"\n"
"Możesz również skopiować `row` za pomocą `row[:]` lub `list(row)`. Ale ważne jest, aby wiedzieć, że\n"
"wszystkie te metody tworzą *płytką kopię* listy.\n"
"To znaczy, że kopiują całą listę na najwyższym poziomie, bez tworzenia kopii każdego elementu.\n"
"To jest w porządku w tym przypadku, gdy `row` zawiera tylko ciągi, które nie mogą być modyfikowane\n"
"i nie potrzebują kopiowania. Ale jeśli elementy są mutowalnymi obiektami, takimi jak listy,\n"
"tak jak to ma miejsce z `board`, możesz znów napotkać ten sam problem.\n"
"Oto przykład:\n"
"\n"
"    __copyable__\n"
"__code2__\n"
"\n"
"Tu każdy element `cube` jest oddzielną listą, kopią `board`.\n"
"I w każdej z tych kopii, każdy element jest również oddzielną listą, kopią `row`.\n"
"Ale płytkie kopie `board` wszystkie mają taki sam pierwszy element względem siebie (pierwszą kopię `row`),\n"
"ten sam drugi element itd.\n"
"Zmiana `make_board` nie naprawi niczego tu, rozwiązaniem jest albo:\n"
"\n"
"- Powtórne wywołanie `make_board` aby stworzyć nową `board` za każdym razem, lub\n"
"- Użycie funkcji `deepcopy` zamiast `board.copy()`.\n"
"  `deepcopy` tworzy kopie na każdym poziomie zagnieżdżonych obiektów.\n"
"\n"
"Jeśli nadal jesteś zdezorientowany, nie martw się.\n"
"To jest tylko przygotowanie do radzenia sobie z dziwnym zachowaniem twojego kodu w przyszłości.\n"
"Nie musisz rozumieć tego teraz i ta lekcja będzie wciąż wartościowa.\n"
"\n"
"Tak czy inaczej, jesteśmy gotowi do stworzenia pełnej gry. Możesz to zrobić!"

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.0.text"
msgstr "Istniejący kod jest prawie poprawny."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.1.text"
msgstr "Jest kilka sposobów na rozwiązanie tego."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.2.text"
msgstr "Niektóre rozwiązania obejmują dodanie czegoś małego."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.3.text"
msgstr ""
"Możesz także przearanżować kod bez dodawania lub usuwania czegokolwiek "
"(oprócz spacji)."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.4.text"
msgstr ""
"Problem polega na tym, że pojedyncza lista `row` jest używana kilka razy."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.5.text"
msgstr ""
"Więc jednym z rozwiązań jest stworzenie kopii `row`, które będą wszystkie "
"oddzielne."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.6.text"
msgstr ""
"Inne rozwiązanie to stworzenie nowego `row` od podstaw za każdym razem."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.7.text"
msgstr ""
"Istnieje kilka sposobów na skopiowanie listy w Pythonie za pomocą "
"niewielkiego fragmentu kodu."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.8.text"
msgstr ""
"Stworzenie nowego rzędu za każdym razem można zrobić przez przearanżowanie "
"kodu."

msgid ""
"pages.MakingTheBoard.steps.fix_make_board.special_messages.not_separate.text"
msgstr "Jednakże podlisty w wyniku nie są wszystkie oddzielne obiekty."

msgid "pages.MakingTheBoard.steps.fix_make_board.text"
msgstr ""
"Czy widzisz co się stało?\n"
"\n"
"Każdy rząd dostał `'X'` na pierwszej pozycji!\n"
"To tak, jakby kod faktycznie zrobił to:\n"
"\n"
"__code0__\n"
"\n"
"Spróbuj samodzielnie rozgryźć co jest źle.\n"
"Ale ponownie, to jest zawiłe, więc nie zwariuj na tym punkcie.\n"
"\n"
"Jeśli chcesz, oto kilka wskazówek:\n"
"\n"
" - Przetestuj kod w debugerach.\n"
" - Eksperymentuj. Dokonuj zmian w kodzie i sprawdź co się stanie.\n"
" - Nie, kod nie zrobił 3 przypisań, jak sugerowałem wyżej. Było tylko jedno przypisanie listy.\n"
" - Nie ma żadnych ukrytych pętli ani niczego podobnego.\n"
" - Ile list zawiera `board`? 3?\n"
" - Poprzednia strona zawiera subtelną wskazówkę co się stało.\n"
" - Jest strona z poprzedniego rozdziału, gdzie ten rodzaj problemu jest wyjaśniony bezpośrednio.\n"
" - W szczególności [ta strona](#EqualsVsIs).\n"
" - Próbuj uruchomić kod z Python Tutor.\n"
"\n"
"OK, jeśli jesteś gotowy, oto odpowiedź.\n"
"\n"
"Lista `row` została stworzona tylko raz i używana wiele razy.\n"
"`board` zawiera tę samą listę trzy razy. Nie kopie, tylko jedna lista w trzech miejscach.\n"
"To tak, jakby zrobił to:\n"
"\n"
"__code1__\n"
"\n"
"Co oznacza, że ten kod:\n"
"\n"
"__code2__\n"
"\n"
"jest równoważny:\n"
"\n"
"__code3__\n"
"\n"
"który wpływa 'na wszystkie listy' w `board`, ponieważ wszystkie są tylko jedną listą `row`.\n"
"Innymi słowy, powyższa linia jest *również* równoważna każdej z tych dwóch linii:\n"
"\n"
"__code4__\n"
"\n"
"ponieważ `row` jest `board[0]`, `board[1]` i `board[2]` naraz.\n"
"\n"
"Twoim zadaniem teraz jest naprawienie `make_board` aby nie miał tego problemu.\n"
"Powinien nadal zwracać listę o długości `size` gdzie każdy\n"
"element jest również listą o długości `size` gdzie każdy element jest stringiem `' '`.\n"
"Podlisty powinny być osobnymi obiektami list, a nie tą samą\n"
"listą powtórzoną."

msgid "pages.MakingTheBoard.steps.naive_make_board.text"
msgstr ""
"Do tej pory plansza była dostarczana jako zagnieżdżona lista.\n"
"Ale do pełnego programu musisz ją stworzyć sam.\n"
"To powinno być proste, prawda? Oto kod do tego:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Jest blisko, ale jest z nim subtelny problem.\n"
"Upewnij się, że rozumiesz kod,\n"
"i punkty dodatkowe, jeśli znajdziesz błąd!\n"
"Jeśli nie, nie czuj się źle ani nie trać zbytnio czasu."

msgid "pages.MakingTheBoard.title"
msgstr "Tworzenie Planszy"
