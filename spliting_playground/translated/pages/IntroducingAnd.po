#
msgid ""
msgstr ""

msgid "pages.IntroducingAnd.steps.AndExercise.hints.0.text"
msgstr ""
"Jeśli masz coś takiego jak `x < 0 and x > 100`, to jesteś na złym tropie. To"
" będzie `False` dla *każdej* wartości `x`!"

msgid "pages.IntroducingAnd.steps.AndExercise.hints.1.text"
msgstr ""
"Rozwiązanie z `and` różni się na wiele sposobów od rozwiązania z `or`."

msgid "pages.IntroducingAnd.steps.AndExercise.hints.2.text"
msgstr ""
"Nasze rozwiązanie z `or` najpierw określa, czy `x` jest nieprawidłowym "
"procentem, w przeciwnym razie zakłada ważność. Używając `and` to zrobi "
"odwrotnie."

msgid "pages.IntroducingAnd.steps.AndExercise.hints.3.text"
msgstr "Będziesz musiał odwrócić instrukcje `return` odpowiednio."

msgid "pages.IntroducingAnd.steps.AndExercise.hints.4.text"
msgstr "Będziesz musiał również zmienić operatory porównania."

msgid "pages.IntroducingAnd.steps.AndExercise.text"
msgstr ""
"Ćwiczmy teraz. Wcześniej napisaliśmy funkcję `is_valid_percentage` używając `or`. Oto przykład\n"
"rozwiązania:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Przepisz tę funkcję używając `and`."

msgid "pages.IntroducingAnd.steps.FalseAndFalse.text"
msgstr ""
"W końcu, spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.0.text"
msgstr "Lista będzie zawsze miała 3 elementy."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.1.text"
msgstr "To oznacza, że nie musisz używać pętli."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.2.text"
msgstr "Pamiętaj, że możesz uzyskać pierwszy element używając `row[0]`."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.3.text"
msgstr ""
"Pierwszy element, drugi element i trzeci element muszą być takie same."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.4.text"
msgstr ""
"To oznacza, że pierwszy element powinien być równy drugiemu elementowi oraz "
"trzeciemu elementowi."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.text"
msgstr ""
"Świetnie! Oto jedno z możliwych rozwiązań:\n"
"\n"
"__code0__\n"
"\n"
"Tak jak wcześniej, możemy to rozwiązanie uprościć:\n"
"\n"
"__code1__\n"
"\n"
"Jest inny sposób, aby to jeszcze bardziej ulepszyć, nazywa się to łączeniem porównań. Każdy warunek taki jak:\n"
"\n"
"__code2__\n"
"\n"
"może być skrócony przez usunięcie dodatkowego `and b`:\n"
"\n"
"__code3__\n"
"\n"
"To działa dla wszystkich operatorów porównania, włączając `==`, i nawet można używać różnych operatorów.\n"
"Więc rozwiązanie można uprościć do:\n"
"\n"
"__code4__\n"
"\n"
"Kolejne ćwiczenie: mając listę trzech elementów, sprawdź czy wszystkie trzy elementy są takie same.\n"
"\n"
"    __copyable__\n"
"__code5__"

msgid "pages.IntroducingAnd.steps.TrueAndFalse.text"
msgstr ""
"Dobrze, teraz spróbuj:\n"
"\n"
"__program_indented__\n"
"\n"
"Czego się spodziewasz?"

msgid "pages.IntroducingAnd.steps.TrueAndTrue.text"
msgstr ""
"Inny operatorem logicznym w Pythonie jest `and`.\n"
"Wyrażenie `A and B` jest `True` tylko jeżeli zarówno `A` i `B` są `True`. W przeciwnym przypadku jest `False`.\n"
"Spróbuj w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingAnd.steps.final_text.text"
msgstr ""
"Dobra robota. Istnieje wiele możliwych prawidłowych rozwiązań tutaj:\n"
"\n"
"__code0__\n"
"\n"
"lub używając ponownie łańcucha porównań:\n"
"\n"
"__code1__\n"
"\n"
"lub sprawdzając, czy równa się liście zawierającej trzy razy pierwszy element:\n"
"\n"
"__code2__"

msgid "pages.IntroducingAnd.title"
msgstr "Wprowadzenie `and`"
