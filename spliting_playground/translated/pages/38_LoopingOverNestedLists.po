#
msgid ""
msgstr ""

msgid "pages.LoopingOverNestedLists.steps.final_text.text"
msgstr ""
"Opanowałeś zagnieżdżone listy i jak je połączyć z zagnieżdżonymi pętlami.\n"
"Brawo! Teraz masz w swoim arsenale bardzo potężne narzędzia programistyczne."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.0.text"
msgstr "To jest bardzo podobne do poprzedniego ćwiczenia."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.1.text"
msgstr "Kiedy powinieneś wydrukować zmienną boolean?"

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.2.text"
msgstr "Pamiętaj, że chcesz wydrukować ją tylko raz."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.3.text"
msgstr ""
"Zamiast definiować zmienną boolean dla każdej podlisty, zdefiniuj tylko "
"jedną zmienną boolean dla całej listy."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.4.text"
msgstr "Kiedy i jak powinieneś modyfikować zmienną boolean?"

msgid "pages.LoopingOverNestedLists.steps.list_contains_word_exercise.text"
msgstr ""
"Dobra robota!\n"
"\n"
"Następnie, wydrukuj tylko jeden boolean, aby wskazać, czy `słowo` jest obecne w jakimkolwiek ciągu całej zagnieżdżonej listy. Na przykład, jeśli\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"twój program powinien wydrukować `False`."

msgid ""
"pages.LoopingOverNestedLists.steps.nested_list_loop_python_tutor.requirements"
msgstr ""
"Uruchom pojedynczy program składający się z dwóch powyższych części połączonych.\n"
"Są one oddzielone, aby nie musieć wpisywać części `numbers = [...]`,\n"
"ale wpisanie części z zagnieżdżoną pętlą jest najlepsze dla nauki.\n"
"Upewnij się, że wcięcia są poprawne."

msgid "pages.LoopingOverNestedLists.steps.nested_list_loop_python_tutor.text"
msgstr ""
"Teraz uruchom ten sam program ponownie w Python Tutor.\n"
"\n"
"Zbadaj, jak wygląda `numbers` i co oznaczają `numbers[0]` aż do `numbers[3]`.\n"
"Spójrz, jak zmieniają się zmienne `sublist` i `num`."

msgid ""
"pages.LoopingOverNestedLists.steps.nested_list_nested_loop_example.requirements"
msgstr ""
"Uruchom pojedynczy program składający się z dwóch powyższych części połączonych.\n"
"Są one oddzielone, aby nie musieć wpisywać części `numbers = [...]`,\n"
"ale wpisanie części z zagnieżdżoną pętlą jest najlepsze dla nauki.\n"
"Upewnij się, że wcięcia są poprawne."

msgid ""
"pages.LoopingOverNestedLists.steps.nested_list_nested_loop_example.text"
msgstr ""
"Możesz użyć zagnieżdżonej pętli do iteracji przez każdy element i pod-element zagnieżdżonej listy.\n"
"Na przykład, rozważ taką zagnieżdżoną listę.\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Kliknij przycisk, aby skopiować listę do edytora, a następnie wpisz następującą zagnieżdżoną pętlę.\n"
"\n"
"__code1__\n"
"\n"
"Przyjrzyj się uważnie kodowi. Zauważ, że zewnętrzna pętla tworzy zmienną `sublist`\n"
"i wewnętrzna pętla iteruje przez tę samą zmienną. To jest często używany wzorzec.\n"
"Teraz uruchom kod."

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.0.text"
msgstr "Jak sprawdzić, czy ciąg zawiera słowo?"

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.1.text"
msgstr ""
"Upewnij się, że sprawdzasz, czy **ciąg tekstowy** zawiera słowo, a nie "
"podlista."

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.2.text"
msgstr ""
"Jak można uzyskać dostęp do każdego ciągu w każdej podliście zagnieżdżonej "
"listy?"

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.3.text"
msgstr "Musisz użyć zagnieżdżonej pętli."

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.4.text"
msgstr ""
"Pętle powinny podążać za tym samym wzorcem co przykład na początku strony."

msgid "pages.LoopingOverNestedLists.steps.string_contains_word_exercise.text"
msgstr ""
"Teraz rozwiążmy kilka problemów, używając tego rodzaju pętli.\n"
"\n"
"Załóżmy, że mamy zagnieżdżoną listę ciągów tekstowych jak poniższa,\n"
"i chcemy szukać konkretnego `słowa` głęboko w listy.\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Możesz wyobrazić sobie, że `strings` reprezentuje książkę, gdzie każda podlista to strona i każdy ciąg znaków wewnątrz\n"
"to linia na tej stronie.\n"
"Może to również reprezentować bibliotekę, gdzie każda lista to książka, a każdy ciąg znaków to strona.\n"
"\n"
"Napisz program, który wydrukuje każdy ciąg zawierający `słowo`.\n"
"Powinno to działać dla dowolnego `słowa` i `ciągów`. Dla przykładu powyżej, powinien wydrukować\n"
"\n"
"    cześć tam\n"
"    cześć świat\n"
"\n"
"Pamiętaj, że istnieje konkretny sposób na sprawdzenie, czy ciąg zawiera inny ciąg. Jeśli nie pamiętasz jak, poszukaj w Google!"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.0.text"
msgstr "Dla każdej podlisty zdefiniuj zmienną boolean."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.1.text"
msgstr "Przechodząc przez podlistę, aktualizuj zmienną boolean odpowiednio."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.2.text"
msgstr "Wydrukuj zmienną boolean tylko raz dla każdej podlisty."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.3.text"
msgstr "Jaka powinna być początkowa wartość dla zmiennej boolean?"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.4.text"
msgstr ""
"Co jeśli jedna z podlist jest pusta? Co powinieneś wydrukować dla tej "
"podlisty?"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.5.text"
msgstr ""
"Jeśli znajdziesz słowo w ciągu, zmienna boolean powinna zostać ustawiona na "
"`True`."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.6.text"
msgstr "Co jeśli ciąg nie zawiera słowa?"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.7.text"
msgstr "Nie szkodzi! To nie zmienia faktu, że inny ciąg może zawierać słowo."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.8.text"
msgstr ""
"Innymi słowy, nie ustawiaj zmiennej boolean na `False` oprócz na początku."

msgid "pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.text"
msgstr ""
"Super!\n"
"\n"
"Teraz zmieńmy nieco ćwiczenie. Tym razem wyjście powinno powiedzieć nam, które *podlisty* zawierają `słowo`,\n"
"zamiast tego, które wewnętrzne ciągi. W szczególności chcemy wydrukować boolean dla każdej podlisty:\n"
"`True`, jeśli podlista zawiera słowo w którymkolwiek z jej ciągów, `False`, jeśli go tam wcale nie ma.\n"
"\n"
"Mając te przykładowe dane wejściowe:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"twój program powinien wydrukować\n"
"\n"
"__code1__\n"
"\n"
"Zauważ, że `słowo w podlista` nie zadziała. Na przykład, `\"cześć\" w [\"cześć tam\", \"jak się masz\"]` jest `False`\n"
"ponieważ `\"cześć\"` nie jest *równa* żadnemu z dwóch elementów tej listy, mimo że znajduje się w jednym z nich."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.0.text"
msgstr "Ponieważ ciągi mogą mieć różne długości, to jest trochę trudne."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.1.text"
msgstr "Jak długo powinna trwać twoja zewnętrzna pętla tym razem?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.2.text"
msgstr ""
"Zanim zaczniesz obsługiwać ciągi, może być dobrym pomysłem najpierw znaleźć "
"najdłuższą długość ciągu."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.3.text"
msgstr "Reszta jest bardzo podobna do poprzedniego ćwiczenia."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.4.text"
msgstr ""
"Jedyna różnica polega na tym, że teraz musisz zdecydować, czy dodać literę z"
" ciągu, czy spację."

msgid "pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.text"
msgstr ""
"Świetnie! Jeśli chcesz, możesz już teraz przejść do [następnej strony](#DefiningFunctions).\n"
"Albo możesz spróbować dodatkowego wyzwania!\n"
"\n"
"Teraz uogólnijmy poprzednie ćwiczenie do ciągów o różnej długości. Znowu masz daną listę ciągów tekstowych.\n"
"Tak jak poprzednio, napisz program, który wydrukuje pierwszą literę każdego ciągu razem w jednej linii,\n"
"następnie drugie litery razem w następnej linii i tak dalej.\n"
"Ale tym razem, jeśli ciąg nie ma wystarczającej liczby liter, powinien wydrukować spację.\n"
"\n"
"Na przykład, jeśli\n"
"\n"
"    __no_auto_translate__\n"
"    ciągi = [\"abcqwe\", \"def\", \"ghiq\"]\n"
"\n"
"twój program powinien wydrukować\n"
"\n"
"    afg\n"
"    bdh\n"
"    cei\n"
"    q q\n"
"    w\n"
"    e"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.0.text"
msgstr "To NIE jest podobne do poprzednich ćwiczeń na tej stronie."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.1.text"
msgstr ""
"Pomyśl o rozwiązaniu, gdy są tylko dwa ciągi. Jak możesz uogólnić to do "
"listy ciągów?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.2.text"
msgstr "Musisz przejść przez pierwsze litery, następnie drugie litery itd."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.3.text"
msgstr "Będziesz musiał użyć pętli, ale jak długo powinna trwać pętla?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.4.text"
msgstr "Pamiętaj, że ciągi na liście mają równe długości."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.5.text"
msgstr ""
"Dla każdej pozycji (pierwszej, drugiej itd.) zdefiniuj nowy ciąg tekstowy."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.6.text"
msgstr "Jaki powinien być początkowo ten ciąg tekstowy?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.7.text"
msgstr ""
"Dla każdej pozycji (pierwszej, drugiej itd.) będziesz musiał przejść przez "
"każdy ciąg na liście."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.8.text"
msgstr "Będziesz potrzebował kolejnej pętli wewnątrz tej, którą już masz."

msgid "pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.text"
msgstr ""
"Świetnie!\n"
"\n"
"[Wcześniej w kursie](#GettingElementsAtPositionExercises) było ćwiczenie\n"
"na wydrukowanie dwóch ciągów tekstowych pionowo, obok siebie, takie jak:\n"
"\n"
"    C Ś\n"
"    z w\n"
"    e i\n"
"    ł a\n"
"    o t\n"
"\n"
"Teraz będziemy to uogólniać do listy ciągów, a nie tylko dwóch.\n"
"\n"
"W tym ćwiczeniu otrzymujesz listę ciągów tekstowych o **równej długości**.\n"
"Napisz program, który wydrukuje pierwszą literę każdego ciągu w jednej linii,\n"
"następnie drugą literę każdego ciągu w następnej linii i tak dalej. Na przykład, jeśli\n"
"\n"
"__code0__\n"
"\n"
"twój program powinien wydrukować\n"
"\n"
"    __no_auto_translate__\n"
"    afg\n"
"    beh\n"
"    cdi\n"
"\n"
"Twój program powinien działać dla dowolnej takiej listy. Szczególnie jeśli użyjesz następującej listy,\n"
"odkryjesz ukrytą wiadomość z Zen Pythona!\n"
"\n"
"    __copyable__\n"
"    __no_auto_translate__\n"
"    ciągi = [\"  b n\", \"f ete\", \"liths\", \"astat\", \"t ene\", \"  r d\"]\n"
"\n"
"Zauważ, że tym razem nie powinieneś dodawać spacji między literami w wyjściu."

msgid "pages.LoopingOverNestedLists.title"
msgstr "Pętla po zagnieżdżonych listach"
