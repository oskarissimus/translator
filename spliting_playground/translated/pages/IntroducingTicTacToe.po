#
msgid ""
msgstr ""

msgid "pages.IntroducingTicTacToe.steps."
msgstr ""

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.0.text"
msgstr ""
"Możesz zacząć od naśladowania `row_winner` powyżej, a następnie zmodyfikować"
" to, aby działało dla kolumn."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.1.text"
msgstr ""
"Nie możesz przechodzić przez kolumny `board` tak prosto jak przez rzędy."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.10.text"
msgstr ""
"Zdefiniuj zmienną logiczną dla każdej kolumny, a następnie aktualizuj ją "
"odpowiednio wewnątrz wewnętrznej pętli."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.11.text"
msgstr "Reszta logiki jest bardzo podobna do `row_winner`."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.12.text"
msgstr "Uważaj na `' '`."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.13.text"
msgstr "Nie zapomnij zwrócić `False` na końcu, jeśli jest to potrzebne."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.2.text"
msgstr ""
"Czym *jest* kolumna zagnieżdżonej listy? Pierwsza kolumna składa się z "
"pierwszego elementu pierwszego rzędu, pierwszego elementu drugiego rzędu i "
"tak dalej."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.3.text"
msgstr ""
"Przechodzenie przez wszystkie kolumny oznacza patrzenie na pierwszy element "
"każdego rzędu, potem drugi element każdego rzędu, i tak dalej."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.4.text"
msgstr ""
"Więc musisz przechodzić przez liczby reprezentujące pozycje pierwszą, drugą,"
" itd."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.5.text"
msgstr "Jak znajdziesz liczbę kolumn w `board`?"

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.6.text"
msgstr ""
"To pokrywa zewnętrzną pętlę, która przechodzi przez każdą kolumnę. Potem "
"potrzebujesz wewnętrznej pętli, aby przejść przez każdy element w kolumnie."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.7.text"
msgstr ""
"Różne wpisy kolumny NIE znajdują się w tym samym rzędzie. Więc jak możesz je"
" uzyskać?"

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.8.text"
msgstr ""
"Możesz przechodzić przez rzędy planszy i znajdować element odpowiadający tej"
" kolumnie i rzędowi."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.9.text"
msgstr ""
"Aby uzyskać dostęp do wszystkich wpisów, powiedzmy, piątej kolumny, możesz "
"przechodzić przez wszystkie rzędy i uzyskać dostęp do piątego elementu w "
"każdym rzędzie."

msgid "pages.IntroducingTicTacToe.steps.column_winner.text"
msgstr ""
"Świetna robota!\n"
"\n"
"Teraz napisz podobną funkcję `column_winner`, która sprawdza wygrywającą *kolumnę* (linię pionową) dowolnej figury:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Tu `O` wygrało w drugiej kolumnie drugiej planszy."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.0.text"
msgstr "Ile przekątnych jest na kwadratowej planszy o dowolnym rozmiarze?"

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.1.text"
msgstr ""
"Nawet jeśli rozmiar planszy się zmienia, liczba przekątnych pozostaje taka "
"sama!"

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.10.text"
msgstr ""
"Możesz użyć jednej pętli i sprawdzić obie przekątne jednocześnie. Albo "
"możesz użyć jednej pętli dla każdej przekątnej."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.2.text"
msgstr ""
"Nie możesz zrobić czegoś takiego jak `środek == board[0][0] i środek == "
"board[2][2]` tym razem, ponieważ nie wiesz, jak długa jest przekątna."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.3.text"
msgstr ""
"Co więcej, dwie przekątne mogą nie mieć ze sobą nic wspólnego, jak `środek`."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.4.text"
msgstr ""
"Najpierw skup się na przekątnej, która biegnie od lewego górnego do prawego "
"dolnego rogu."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.5.text"
msgstr "Jak możesz uzyskać do nich dostęp z podwójnym indeksowaniem?"

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.6.text"
msgstr ""
"Czy widzisz wzór w tych podwójnych indeksach? Weź kartkę i długopis, pracuj "
"nad tym na kilku przykładach."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.7.text"
msgstr ""
"Teraz skup się na drugiej przekątnej (od prawego górnego do lewego dolnego "
"rogu). Istnieje wzór w indeksach ponownie, ale jest trochę trudniejszy."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.8.text"
msgstr "Czy pamiętasz o indeksowaniu ujemnym? Może być przydatne tutaj."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.9.text"
msgstr ""
"Gdy pojmiesz wzory, użyj tych samych pomysłów jak wcześniej, aby sprawdzić, "
"czy wszystkie wpisy są równe."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.text"
msgstr ""
"Wspaniale! To było wymagające.\n"
"\n"
"Na końcu musimy sprawdzić wygrywające przekątne. W poprzednim rozdziale napisałeś już funkcję, która to robi dla plansz 3x3.\n"
"\n"
"__code0__\n"
"\n"
"Teraz napisz `diagonal_winner`, która działa dla kwadratowych plansz dowolnego rozmiaru: 4x4, 5x5 i tak dalej...\n"
"\n"
"    __copyable__\n"
"__code1__\n"
"\n"
"W pierwszym przykładzie `X` wygrało na przekątnej od lewego dolnego do prawego górnego rogu."

msgid "pages.IntroducingTicTacToe.steps.final_text.text"
msgstr ""
"Świetna praca!\n"
"\n"
"Teraz mamy kod, który określa wygrywający stan na planszy."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.0.text"
msgstr ""
"Musisz sprawdzić każdy rząd na planszy, więc potrzebujesz pętli do tego."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.1.text"
msgstr "Jak możesz sprawdzić, czy wszystkie wpisy w rzędzie są sobie równe?"

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.10.text"
msgstr "Upewnij się, że zwracasz `False`, jeśli nie ma wygrywających rzędów."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.2.text"
msgstr ""
"To samodzielny problem sam w sobie. Możesz zacząć od zapomnienia o całej "
"planszy i po prostu sprawdzania jednego rzędu."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.3.text"
msgstr ""
"Moglibyście nawet napisać funkcję, która tylko to robi, chociaż nie musicie "
"tego robić."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.4.text"
msgstr ""
"Ponieważ rząd może mieć dowolny rozmiar, będziesz musiał przeprowadzić pętlę"
" przez cały jego obszar."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.5.text"
msgstr ""
"Dla każdego rzędu zdefiniuj zmienną logiczną (boolean). Następnie "
"przeprowadź pętlę przez ten rząd, aktualizując zmienną odpowiednio."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.6.text"
msgstr ""
"Możesz użyć pierwszego wpisu `row[0]` w rzędzie, aby porównać wszystkie "
"pozostałe wpisy do niego."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.7.text"
msgstr ""
"Zastanów się uważnie, jaką początkową wartość powinna mieć zmienna logiczna "
"i w jakich warunkach powinieneś zmienić jej wartość."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.8.text"
msgstr ""
"Po przeprowadzeniu pętli przez rząd, jeśli stwierdzisz, że wszystkie jego "
"wpisy są sobie równe, wtedy zwróć `True` (kończąc wczesniej zewnętrzną "
"pętlę)."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.9.text"
msgstr "Upewnij się, że nie zwracasz `True` dla rzędu wypełnionego spacjami."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.text"
msgstr ""
"Wykonaliście już wiele krótkich ćwiczeń rozwiązując niewielkie problemy. Teraz zajmiemy się większym, bardziej skomplikowanym\n"
"projektem, który naprawdę sprawdzi Waszą wiedzę i będzie wymagał połączenia wielu mniejszych części razem.\n"
"Będzie to bardzo zabawne!\n"
"\n"
"Stworzycie tekstową, interaktywną grę w kółko i krzyżyk, przeznaczoną dla 2 graczy ludzkich.\n"
"Oto mały podgląd tego, jak będzie wyglądała gotowa gra w trakcie rozgrywki:\n"
"\n"
"      1 2 3\n"
"    1  | |\n"
"      -+-+-\n"
"    2  | |\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"    Gracz X:\n"
"    1\n"
"    1\n"
"\n"
"      1 2 3\n"
"    1 X| |\n"
"      -+-+-\n"
"    2  | |\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"    Gracz O:\n"
"    2\n"
"    2\n"
"\n"
"      1 2 3\n"
"    1 X| |\n"
"      -+-+-\n"
"    2  |O|\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"    Gracz X:\n"
"    1\n"
"    3\n"
"\n"
"      1 2 3\n"
"    1 X| |X\n"
"      -+-+-\n"
"    2  |O|\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"Dzielimy projekt na kilka małych funkcji, które będą stanowić ćwiczenia.\n"
"\n"
"Użyjecie wielu pojęć, których się już nauczyliście: napisy (strings),\n"
"zagnieżdżone listy, zagnieżdżone pętle, `range`, wywoływanie funkcji w funkcjach, porównania i wartości logiczne (booleans).\n"
"\n"
"Po drodze dowiecie się też o kilku nowych pojęciach, w tym o znakach nowej linii, typach i `input()`.\n"
"\n"
"Oto zarys projektu:\n"
"\n"
"- trzy funkcje `row_winner`, `column_winner`,  `diagonal_winner`, które sprawdzają całą planszę pod kątem wygrywających rzędów, kolumn i przekątnych\n"
"- funkcja `winner`, która sprawdza całą planszę pod kątem zwycięzcy, łącząc powyższe funkcje\n"
"- funkcja `format_board`, która wyświetla bieżący stan gry\n"
"- funkcja `play_move`, która przyjmuje dane wejściowe od użytkownika, aby wykonać ruch,\n"
"- na końcu funkcja `play_game`, która łączy wszystko razem i uruchamia grę interaktywnie.\n"
"- Później dodamy kolejne udoskonalenia.\n"
"\n"
"Zaczynajmy!\n"
"\n"
"Tak jak w ostatnim rozdziale, będziemy reprezentować planszę do gry w kółko i krzyżyk jako zagnieżdżoną listę napisów (stringów).\n"
"Dla typowej gry będzie to lista 3x3, tj. 3 listy zawierające po 3 napisy, z graczami reprezentowanymi przez `'X'` lub `'O'`.\n"
"Puste pola będą reprezentowane przez spację, czyli `' '`. Na przykład:\n"
"\n"
"__code0__\n"
"\n"
"Jednak, aby było ciekawiej, Wasz kod będzie musiał działać dla kwadratowych plansz o dowolnym rozmiarze\n"
"(4x4, 5x5 itd.), gdzie gracze mogą być reprezentowani przez dowolne napisy, np.:\n"
"\n"
"__code1__\n"
"\n"
"Napisz funkcję `row_winner`, która zwraca `True`, jeśli `board` zawiera\n"
"wygrywający rząd, czyli poziomą linię, która ma tę samą postać we wszystkich swoich miejscach (oprócz `' '`):\n"
"\n"
"    __copyable__\n"
"__code2__\n"
"\n"
"W drugim przykładzie `O` wygrywa w dolnym rzędzie."

msgid "pages.IntroducingTicTacToe.steps.winner.hints.0.text"
msgstr ""
"Rozwiązanie jest dość krótkie! Po prostu użyj trzech funkcji poprawnie."

msgid "pages.IntroducingTicTacToe.steps.winner.hints.1.text"
msgstr ""
"Pomyśl o możliwych przypadkach. Kiedy `winner(board)` zwraca `False`? Kiedy "
"zwraca `True`?"

msgid "pages.IntroducingTicTacToe.steps.winner.text"
msgstr ""
"Brawo! To było dość trudne.\n"
"\n"
"Teraz możemy połączyć te trzy funkcje! Napisz funkcję `winner`, która przyjmuje jako argument `board` tak jak wcześniej,\n"
"i zwraca `True`, jeśli `board` zawiera wygrywający rząd, kolumnę lub przekątną, `False` w przeciwnym razie.\n"
"\n"
"Twoje rozwiązanie powinno działać przez wywołanie tych trzech funkcji. `winner` sama nie powinna wykonywać żadnej\n"
"pętli, indeksowania itp.\n"
"\n"
"Oto trochę kodu dla `row_winner`, `column_winner` i `diagonal_winner` wraz z kilkoma testami dla funkcji `winner`.\n"
"Kliknij przycisk Kopiuj i uzupełnij luki dla swojej funkcji `winner`.\n"
"\n"
"    __copyable__\n"
"__code0__"
