#
msgid ""
msgstr ""

msgid "pages.IntroducingOr.steps.InputAliceBob.text"
msgstr ""
"Poznaliśmy *wartości logiczne* (`True` i `False`), kiedy wprowadziliśmy instrukcje warunkowe If.\n"
"Dowiedzieliśmy się również o operatorach porównania `==`, `<`, `>`, `<=`, `>=`, które zwracają wartości logiczne.\n"
"Teraz chcemy połączyć wartości logiczne, aby sprawdzić bardziej złożone warunki.\n"
"\n"
"Oto prosty przykład: wyobraź sobie, że masz dwóch przyjaciół, Alicję i Boba.\n"
"Poniższa funkcja przyjmuje jeden parametr, `name`, i sprawdza, czy osoba o podanej nazwie znajduje się wśród Twoich przyjaciół.\n"
"Skopiuj i uruchom kod w edytorze:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingOr.steps.TrueOrTrue.text"
msgstr ""
"Zobaczmy czy możemy to zrobić lepiej.\n"
"Możemy połączyć instrukcje `if` i `elif` za pomocą **`or`**. `or` to *operator logiczny*,\n"
"co znaczy, że jest operatorem (tak jak `+` lub `-`), którzy łączy dwie wartości logiczne (`True` lub `False`).\n"
"\n"
"Wyrażenie `A or B` jest `True`, jeśli albo `A` albo `B` jest `True`, czyli jeśli `A` jest `True` albo `B` jest `True`, lub oba.\n"
"Jest `False` tylko wtedy, gdy ani `A` ani `B` nie jest `True`, czyli oba są `False`.\n"
"\n"
"Spróbuj wykonać następujące polecenie w konsoli.\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.TrueOrFalse.text"
msgstr ""
"Dobrze, teraz spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.FalseOrFalse.text"
msgstr ""
"Na koniec spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.ImprovingWithOr.text"
msgstr ""
"W edytorze zastąp:\n"
"\n"
"__code0__\n"
"\n"
"przez:\n"
"\n"
"__code1__\n"
"\n"
"Jak widzisz, `is_friend` zwróci `True` tylko wtedy, gdy `name` to Alicja lub Bob.\n"
"Operator `or` jest użyty pomiędzy dwoma wartościami logicznymi `name == \"Alice\"` i `name == \"Bob\"`."

msgid "pages.IntroducingOr.steps.FurtherImprovement.text"
msgstr ""
"Możemy to zrobić jeszcze lepiej. Zauważ, że:\n"
"\n"
"__code0__\n"
"\n"
"to wartość logiczna i obie instrukcje `return` zwracają wartości logiczne `True` lub `False`.\n"
"Funkcja:\n"
"\n"
" - zwraca `True`, kiedy `name == \"Alice\" or name == \"Bob\"` jest `True`, oraz\n"
" - zwraca `False`, kiedy `name == \"Alice\" or name == \"Bob\"` jest `False`.\n"
"\n"
"Więc możemy po prostu zwrócić wartość logiczną `name == \"Alice\" or name == \"Bob\"` w obu przypadkach!\n"
"\n"
"To jest częsty wzorzec do upraszczania kodu. Jeżeli kiedykolwiek znajdziesz się pisząc kod w stylu:\n"
"\n"
"__code1__\n"
"\n"
"gdzie `x` samo w sobie jest wartością logiczną, zawsze możesz uproszczyć ten blok kodu do:\n"
"\n"
"__code2__\n"
"\n"
"Zastosuj tę uproszczenie do kodu samodzielnie i uruchom go ponownie."

msgid "pages.IntroducingOr.steps.ACommonMistake.text"
msgstr ""
"Zwróć uważną uwagę, jak napisaliśmy warunek:\n"
"\n"
"__code0__\n"
"\n"
"Powszechnym błędem jest napisanie tego w następujący sposób:\n"
"\n"
"__code1__\n"
"\n"
"Ma to sens, jeśli czytasz to jak po angielsku:\n"
"\n"
"> `return` czy `name` jest równe `\"Alice\"` lub `\"Bob\"`\n"
"\n"
"Ale Python to nie angielski i tak nie działa operator `or`.\n"
"\n"
"Zamień linię z `return` w kodzie na powyższą linię i spróbuj uruchomić to ponownie."

msgid "pages.IntroducingOr.steps.InspectWithBirdseye.text"
msgstr ""
"Drugi i trzeci test nie przechodzą! Nasza funkcja wydaje się robić coś źle:\n"
"zwraca `\"Bob\"` (łańcuch znaków, a nie wartość logiczną!) gdy `name` to `\"Bob\"` lub `\"Charlie\"`. Co się dzieje?\n"
"Uruchom ten sam problematyczny kod ponownie za pomocą `birdseye`. Dokładnie zbadaj instrukcje `return` dla każdego wywołania funkcji `is_friend`.\n"
"(Użyj niebieskich przycisków strzałek)"

msgid "pages.IntroducingOr.steps.AnExercise.text"
msgstr ""
"Przy inspekcji za pomocą `birdseye` możemy zauważyć, że:\n"
"\n"
"__code0__\n"
"\n"
"nie jest tłumaczone na:\n"
"\n"
"__code1__\n"
"\n"
"w sposób, w jaki myślimy po angielsku, ale raczej:\n"
"\n"
"__code2__\n"
"\n"
"co daje jako wynik `\"Bob\"`, gdy `name == \"Alice\"` jest `False`.\n"
"\n"
"Być może teraz myślisz tak:\n"
"\n"
"[![Mam teraz dodatkowe pytania](https://i.imgur.com/jN57tGt.png)](https://imgur.com/a/icKzI)\n"
"\n"
"Jedyna rzecz, którą naprawdę musisz wiedzieć to: dopóki nie wiesz, co robisz, zawsze\n"
"upewnij się, że po obu stronach `or` są wartości logiczne, ponieważ jest to operator logiczny.\n"
"`name == \"Alice\" or \"Bob\"` łamie tę zasadę.\n"
"\n"
"Jeśli jesteś ciekawy, odpowiedzi znajdują się poniżej, ale możesz je pominąć, jeśli chcesz i przejść do ćwiczenia poniżej.\n"
"\n"
"----\n"
"\n"
"> Dlaczego `(name == \"Alice\") or (\"Bob\")` daje wynik `\"Bob\"`? Dlaczego w ogóle daje jakiś wynik? Przecież `\"Bob\"` to nie jest wartość logiczna!\n"
"\n"
"Definicja \"`A or B` jest `True`, jeśli `A` lub `B` jest `True`\" była uproszczeniem. Jest to najłatwiejszy\n"
"sposób myślenia o `or` większość czasu, zwłaszcza przy pisaniu instrukcji `if`.\n"
"Prawdziwa definicja jest taka, że jeśli `A` jest prawdą, to `A or B` to po prostu `A` (w rzeczywistości `B` nawet nie jest oceniane),\n"
"w przeciwnym razie to jest `B`.\n"
"Możesz sam sprawdzić, że jeśli `A` i `B` są wartościami logicznymi, to obie definicje są równoważne.\n"
"W tym przykładzie `A` to `name == \"Alice\"`, co jest `False`, więc `A or B` to `B`, czyli `\"Bob\"`.\n"
"\n"
"> Czy jest lepszy sposób napisania warunku bez powtarzania `name ==` za każdym razem?\n"
"\n"
"Tak! W [Funkcjach i metodach dla list](#FunctionsAndMethodsForLists) wspomnieliśmy operator `in`,\n"
"którego możesz użyć z listą w ten sposób:\n"
"\n"
"__code3__\n"
"\n"
"Ale nie zawsze możesz pozbyć się `or` w ten sposób.\n"
"\n"
"----\n"
"\n"
"Ćwiczenie: Napisz funkcję o nazwie `is_valid_percentage`, przyjmującą jeden argument numeryczny `x`.\n"
"Powinna zwrócić `True`, jeśli `x` jest między 0 a 100 (włącznie), i `False` w przeciwnym razie.\n"
"Twoja funkcja powinna używać `or`, i przejść te testy:\n"
"\n"
"    __copyable__\n"
"__code4__"

msgid "pages.IntroducingOr.steps.final_text.text"
msgstr "Dobra robota!"

msgid "pages.IntroducingOr.steps.AnExercise.hints.0.text"
msgstr ""
"Remember, you can use comparison operators `<, >, <=, >=, ==` to produce "
"booleans."

msgid "pages.IntroducingOr.steps.AnExercise.hints.1.text"
msgstr "You need to check how `x` compares to 0 and how it compares to 100."

msgid "pages.IntroducingOr.steps.AnExercise.hints.2.text"
msgstr "You need to combine the two comparisons into one boolean using `or`."

msgid "pages.IntroducingOr.steps.AnExercise.hints.3.text"
msgstr ""
"Above we used a trick so that the whole function body was just `return "
"<comparison> or <comparison>`. But that won't work here!"

msgid "pages.IntroducingOr.steps.AnExercise.hints.4.text"
msgstr "You need to use an `if` statement."

msgid "pages.IntroducingOr.steps.AnExercise.hints.5.text"
msgstr "You need to have a `return False` and a `return True`."

msgid "pages.IntroducingOr.steps.AnExercise.hints.6.text"
msgstr ""
"If you have something like `x >= 0 or x <= 100`, you're on the wrong track. "
"That's going to be true for *any* value of `x`. After all, 101 is greater "
"than 0!"

msgid "pages.IntroducingOr.title"
msgstr "Introducing `or`"

msgid "pages.IntroducingOr.steps.AnExercise.disallowed.3.label"
msgstr "comparison chaining"

msgid "pages.IntroducingOr.steps.ACommonMistake.requirements"
msgstr ""
"Run the program from the previous step, but replace:\n"
"\n"
"__code0__\n"
"\n"
"with:\n"
"\n"
"__code1__"

msgid "pages.IntroducingOr.steps.FurtherImprovement.requirements"
msgstr ""
"Run the program from the previous step, but replace:\n"
"\n"
"__code0__\n"
"\n"
"with:\n"
"\n"
"__code1__"

msgid "pages.IntroducingOr.steps.ImprovingWithOr.requirements"
msgstr ""
"Copy the program from the top of the page, then change the first four lines "
"of the function to use `or` as suggested."

msgid "pages.IntroducingOr.steps.InspectWithBirdseye.requirements"
msgstr "Run the same code as in the previous step, but with `birdseye`."
