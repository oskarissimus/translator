#
msgid ""
msgstr ""

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.text"
msgstr ""
"Wykonałeś już wiele krótkich ćwiczeń, rozwiązując małe problemy. Teraz zmierzymy się z większym, bardziej złożonym\n"
"projektem, który naprawdę przetestuje twoją wiedzę i wymaga połączenie wielu mniejszych części.\n"
"To będzie naprawdę wspaniała zabawa!\n"
"\n"
"Stworzysz tekstową interaktywną grę w kółko i krzyżyk dla 2 graczy-ludzi.\n"
"Oto mała zapowiedź tego, jak będzie wyglądać ukończona gra:\n"
"\n"
"      1 2 3\n"
"    1  | |\n"
"      -+-+-\n"
"    2  | |\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"    Gracz X:\n"
"    1\n"
"    1\n"
"\n"
"      1 2 3\n"
"    1 X| |\n"
"      -+-+-\n"
"    2  | |\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"    Gracz O:\n"
"    2\n"
"    2\n"
"\n"
"      1 2 3\n"
"    1 X| |\n"
"      -+-+-\n"
"    2  |O|\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"    Gracz X:\n"
"    1\n"
"    3\n"
"\n"
"      1 2 3\n"
"    1 X| |X\n"
"      -+-+-\n"
"    2  |O|\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"Podzielimy projekt na kilka małych funkcji, które będą ćwiczeniami.\n"
"\n"
"Wykorzystasz wiele koncepcji, które już poznałeś: łańcuchy znaków,\n"
"zagnieżdżone listy, zagnieżdżone pętle, `range`, wywoływanie funkcji w funkcjach, porównania i wartości logiczne.\n"
"\n"
"Po drodze nauczysz się również nowych koncepcji, w tym znaków nowej linii, typów i `input()`.\n"
"\n"
"Oto przybliżony zarys projektu:\n"
"\n"
"- trzy funkcje `row_winner`, `column_winner`,  `diagonal_winner` sprawdzające całą planszę pod kątem wygrywających rzędów, kolumn i przekątnych\n"
"- funkcja `winner` sprawdzająca całą planszę pod kątem zwycięzcy, łącząca powyższe funkcje\n"
"- funkcja `format_board` wyświetlająca aktualny stan gry\n"
"- funkcja `play_move` przyjmująca dane wejściowe użytkownika, aby wykonać ruch\n"
"- w końcu funkcja `play_game`, która scala wszystko razem i prowadzi grę interaktywnie.\n"
"- Później dodamy kolejne ulepszenia.\n"
"\n"
"Zaczynajmy!\n"
"\n"
"Tak jak w ostatnim rozdziale, planszę w kółko i krzyżyk będziemy reprezentować jako zagnieżdżoną listę łańcuchów znaków.\n"
"Dla typowej gry będzie to lista 3x3, czyli 3 listy zawierające po 3 łańcuchy znaków, z graczami reprezentowanymi przez `'X'` lub `'O'`.\n"
"Puste kwadraty będą reprezentowane przez spację, czyli `' '`. Na przykład:\n"
"\n"
"__code0__\n"
"\n"
"Jednak żeby było ciekawiej, twój kod będzie musiał działać dla kwadratowych plansz o dowolnym rozmiarze\n"
"(4x4, 5x5 itd.), gdzie gracze mogą być reprezentowani przez dowolne łańcuchy znaków, np.\n"
"\n"
"__code1__\n"
"\n"
"Napisz funkcję `row_winner`, która zwraca `True`, jeśli `board` zawiera\n"
"wygrywający rząd, czyli poziomą linię, która ma tę samą postać we wszystkich swoich wpisach (z wyjątkiem `' '`):\n"
"\n"
"    __copyable__\n"
"__code2__\n"
"\n"
"W drugim przykładzie `O` wygrywa w dolnym rzędzie."

msgid "pages.IntroducingTicTacToe.steps.column_winner.text"
msgstr ""
"Świetna robota!\n"
"\n"
"Teraz napisz podobną funkcję `column_winner`, która sprawdzi wygraną w *kolumnie* (pionowej linii) dla jednego z graczy:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Tutaj `O` wygrało w drugiej kolumnie na drugiej planszy."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.text"
msgstr ""
"Doskonale! To było wymagające.\n"
"\n"
"Na koniec musimy sprawdzić wygrywające przekątne. Napisałeś już funkcję, która robiła dokładnie to w poprzednim rozdziale, dla plansz 3x3:\n"
"\n"
"__code0__\n"
"\n"
"Teraz napisz funkcję `diagonal_winner`, która będzie działać dla kwadratowych plansz dowolnego rozmiaru: 4x4, 5x5 itd.\n"
"\n"
"    __copyable__\n"
"__code1__\n"
"\n"
"W pierwszym przykładzie `X` wygrało na przekątnej biegnącej od lewego dolnego rogu do prawego górnego rogu."

msgid "pages.IntroducingTicTacToe.steps.winner.text"
msgstr ""
"Brawo! To było całkiem trudne.\n"
"\n"
"Teraz możemy połączyć trzy funkcje! Napisz funkcję `winner`, która przyjmuje argument `board` tak jak wcześniej\n"
"i zwraca `True`, jeśli `board` zawiera wygrywający rząd, kolumnę lub przekątną, w przeciwnym razie `False`.\n"
"\n"
"Twoje rozwiązanie powinno działać poprzez wywołanie trzech funkcji. Sam `winner` nie powinien używać żadnych pętli, indeksowania itd.\n"
"\n"
"Oto kod dla `row_winner`, `column_winner` i `diagonal_winner`, wraz z kilkoma testami dla `winner`.\n"
"Kliknij przycisk Kopiuj i uzupełnij brakujące miejsca dla Twojej funkcji `winner`.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingTicTacToe.steps.final_text.text"
msgstr ""
"Świetna robota!\n"
"\n"
"Teraz mamy kod, który pozwala określić stan wygrywający na planszy."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.0.text"
msgstr ""
"You need to check every row in the board, so you'll need a loop for that."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.1.text"
msgstr "How can you check if all entries in a row are equal to each other?"

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.2.text"
msgstr ""
"That's a self contained problem on its own. You can start by forgetting "
"about the whole board and just checking a single row."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.3.text"
msgstr ""
"You could even write a function which just does this, although you don't "
"have to."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.4.text"
msgstr ""
"Since the row could have any size, you'll have to loop all the way through "
"it."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.5.text"
msgstr ""
"For each row, define a boolean. Then loop through that row, updating the "
"boolean accordingly."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.6.text"
msgstr ""
"You can use the first entry `row[0]` in a row to compare all the row entries"
" to it."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.7.text"
msgstr ""
"Think carefully about what the initial value of the boolean should be, and "
"under what conditions you should change its value."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.8.text"
msgstr ""
"After looping through a row, if you determined that all its entries are "
"equal, then return `True` (ending the outer loop early)."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.9.text"
msgstr "Make sure you don't return `True` for a row filled with spaces."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.10.text"
msgstr "Make sure you return `False` if there are no winning rows"

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.0.text"
msgstr ""
"You can start by imitating `row_winner` above, then change it to make it "
"work with columns."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.1.text"
msgstr "You can't loop through the columns of `board` as simply as its rows."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.2.text"
msgstr ""
"What *is* a column of a nested list? The first column consists of the first "
"element of the first row, the first element of the second row, etc."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.3.text"
msgstr ""
"Looping through all columns means looking at the first element of every row,"
" then the second element of every row, etc."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.4.text"
msgstr ""
"So you need to loop through numbers representing the positions first, "
"second, etc."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.5.text"
msgstr "How do you find the number of columns in `board`?"

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.6.text"
msgstr ""
"That covers the outer loop, which goes through each column. Then you need an"
" inner loop to go through each element in the column."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.7.text"
msgstr ""
"The different entries of a column are NOT on the same row. So how can you "
"access them?"

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.8.text"
msgstr ""
"You can loop through rows of the board and find the element corresponding to"
" that row and the current column."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.9.text"
msgstr ""
"To access all the entries of, say, the 5th column, you can loop through all "
"the rows, and access the 5th element in each row."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.10.text"
msgstr ""
"Define a boolean for each column, then update it accordingly inside the "
"inner loop."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.11.text"
msgstr "The rest of the logic is very similar to `row_winner`."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.12.text"
msgstr "Watch out for `' '`."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.13.text"
msgstr "Remember to return `False` at the end if needed."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.0.text"
msgstr "How many diagonals are there on a square board of arbitrary size?"

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.1.text"
msgstr ""
"Even if the size of the board changes, the number of diagonals remains the "
"same!"

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.2.text"
msgstr ""
"You can't do something like `middle == board[0][0] and middle == "
"board[2][2]` this time, because you don't know how long a diagonal is."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.3.text"
msgstr ""
"Moreover the two diagonals might not have anything in common like `middle`."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.4.text"
msgstr "First, focus on the diagonal that goes from top left to bottom right."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.5.text"
msgstr "How can you access those entries with double subscripting?"

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.6.text"
msgstr ""
"Do you see a pattern in those double subscripts? Get some paper and pen, "
"work it out on some examples."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.7.text"
msgstr ""
"Now focus on the other diagonal (from top right to bottom left). There is a "
"pattern in the subscripts again, but it's a little bit more difficult."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.8.text"
msgstr "Do you remember negative indexing? It might be helpful here."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.9.text"
msgstr ""
"Once you get the hang of the patterns, use the same ideas from before to "
"check if all entries are equal."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.10.text"
msgstr ""
"You can use one loop and check both diagonals at the same time. Or you can "
"use one loop for each diagonal."

msgid "pages.IntroducingTicTacToe.steps.winner.hints.0.text"
msgstr ""
"The solution is quite short! Simply use the three functions correctly."

msgid "pages.IntroducingTicTacToe.steps.winner.hints.1.text"
msgstr ""
"Think about possible cases. When does `winner(board)` return `False`? When "
"does it return `True`?"

msgid "pages.IntroducingTicTacToe.steps.winner.hints.2.text"
msgstr ""
"How can you use the three functions and a boolean operator together to get "
"the result you need?"

msgid ""
"pages.IntroducingTicTacToe.steps.intro_row_winner.messages.catch_empty_row.text"
msgstr ""
"Keep in mind that some entries might be `' '`. An empty row is not a winning"
" row."

msgid "pages.IntroducingTicTacToe.title"
msgstr "Checking the board for winners"

msgid "pages.IntroducingTicTacToe.steps.winner.disallowed.0.message"
msgstr ""
"Your solution should work by calling the three functions. `winner` itself should not do any\n"
"looping, subscripting, etc. It should be very short.\n"
"\n"
"Copy the `row_winner` and other functions and leave them as they are. Don't copy code from them\n"
"into the `winner` function, just call those functions."
