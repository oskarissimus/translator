#
msgid ""
msgstr ""

msgid ""
"pages.LoopingOverNestedLists.steps.nested_list_nested_loop_example.text"
msgstr ""
"Można użyć zagnieżdżonej pętli, by iterować po każdym elemencie i sub-elemencie zagnieżdżonej listy.\n"
"Na przykład, rozważmy taką zagnieżdżoną listę.\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Kliknij przycisk, aby skopiować listę do edytora, a następnie wpisz następującą zagnieżdżoną pętlę.\n"
"\n"
"__code1__\n"
"\n"
"Przyjrzyj się uważnie kodowi. Zauważ, że zewnętrzna pętla tworzy zmienną `sublist`\n"
"i wewnętrzna pętla iteruje po tej samej zmiennej. To jest powszechny wzorzec.\n"
"Teraz uruchom kod."

msgid "pages.LoopingOverNestedLists.steps.nested_list_loop_python_tutor.text"
msgstr ""
"Teraz uruchom ten sam program ponownie w Python Tutor.\n"
"\n"
"Zbadaj, jak wygląda `numbers`, oraz co reprezentują `numbers[0]` aż do `numbers[3]`.\n"
"Spójrz, jak zmieniają się zmienne `sublist` i `num`."

msgid "pages.LoopingOverNestedLists.steps.string_contains_word_exercise.text"
msgstr ""
"Teraz rozwiążmy kilka problemów, wykorzystując tego rodzaju pętle.\n"
"\n"
"Załóżmy, że mamy zagnieżdżoną listę łańcuchów znaków, jak poniżej,\n"
"i chcemy wyszukać konkretny `word` głęboko w liście.\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Możesz sobie wyobrazić, że `strings` reprezentuje książkę, gdzie każda podlista to strona, a każdy łańcuch znaków wewnątrz\n"
"to linijka na tej stronie.\n"
"To również może reprezentować bibliotekę, gdzie każda lista to księga, a każdy łańcuch znaków to strona.\n"
"\n"
"Napisz program, który wypisze każdy łańcuch znaków zawierający `word`.\n"
"Powinien działać dla dowolnego `word` i `strings`. Dla przykładu powyżej, powinien wypisać\n"
"\n"
"    hello there\n"
"    hello world\n"
"\n"
"Pamiętaj, że jest specyficzny sposób, aby sprawdzić, czy łańcuch znaków zawiera inny łańcuch znaków. Jeśli nie możesz sobie przypomnieć jak, wyszukaj w Google!"

msgid "pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.text"
msgstr ""
"Super!\n"
"\n"
"Teraz nieco zmienimy ćwiczenie. Tym razem wyjście powinno nam powiedzieć, które *podlisty* zawierają `word`,\n"
"a nie które wewnętrzne łańcuchy znaków. W szczególności chcemy wypisać wartość logiczną dla każdej podlisty:\n"
"`True` jeśli podlista zawiera słowo w którymkolwiek ze swoich łańcuchów znaków, `False` jeśli go tam wcale nie ma.\n"
"\n"
"Mając te przykładowe dane wejściowe:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Twój program powinien wypisać:\n"
"\n"
"__code1__\n"
"\n"
"Zwróć uwagę, że `word in sublist` nie będzie działać. Na przykład, `\"hello\" in [\"hello there\", \"how are you\"]` jest `False`\n"
"ponieważ `\"hello\"` nie jest *równoważne* żadnemu z dwóch elementów tej listy, chociaż jest w jednym z nich."

msgid "pages.LoopingOverNestedLists.steps.list_contains_word_exercise.text"
msgstr ""
"Dobra robota!\n"
"\n"
"Następnie, wypisz tylko jedną wartość logiczną, aby wskazać, czy `word` jest obecny w jakimkolwiek łańcuchu znaków w całej zagnieżdżonej liście. Na przykład, jeśli\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"twój program powinien wypisać `False`."

msgid "pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.text"
msgstr ""
"Doskonale!\n"
"\n"
"[Wcześniejszej części kursu](#GettingElementsAtPositionExercises) było ćwiczenie\n"
"polegające na wypisaniu dwóch łańcuchów znaków w pionie, obok siebie, tak jak tutaj:\n"
"\n"
"    H W\n"
"    e o\n"
"    l r\n"
"    l l\n"
"    o d\n"
"\n"
"Teraz uogólnimy to do listy łańcuchów znaków, a nie tylko dwóch.\n"
"\n"
"W tym ćwiczeniu masz daną listę łańcuchów znaków o **równej długości**.\n"
"Napisz program, który wypisze pierwszą literę każdego łańcucha znaków w jednej linii,\n"
"następnie drugą literę każdego łańcucha znaków w kolejnej linii, i tak dalej. Na przykład, jeśli\n"
"\n"
"__code0__\n"
"\n"
"to Twój program powinien wypisać\n"
"\n"
"    __no_auto_translate__\n"
"    adg\n"
"    beh\n"
"    cfi\n"
"\n"
"Twój program powinien działać dla dowolnej takiej listy. W szczególności, jeśli użyjesz następującej listy,\n"
"odkryjesz ukrytą wiadomość z Zen Pythona!\n"
"\n"
"    __copyable__\n"
"    __no_auto_translate__\n"
"    strings = [\"  b n\", \"f ete\", \"liths\", \"astat\", \"t ene\", \"  r d\"]\n"
"\n"
"Zwróć uwagę, że tym razem nie powinieneś dodawać spacji między literami na wyjściu."

msgid "pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.text"
msgstr ""
"Doskonale! Jeśli chcesz, możesz teraz przejść do [następnej strony](#DefiningFunctions).\n"
"Albo możesz podjąć dodatkowe wyzwanie!\n"
"\n"
"Teraz uogólnijmy poprzednie ćwiczenie na łańcuchy znaków o różnej długości. Znowu masz daną listę łańcuchów znaków.\n"
"Tak jak poprzednio, napisz program, który wypisze pierwszą literę każdego łańcucha znaków razem w jednej linii,\n"
"następnie drugie litery razem w kolejnej linii, i tak dalej.\n"
"Ale tym razem, jeśli łańcuch znaków nie ma wystarczającej liczby liter, powinien wypisać spację.\n"
"\n"
"Na przykład, jeśli\n"
"\n"
"    __no_auto_translate__\n"
"    strings = [\"abcqwe\", \"def\", \"ghiq\"]\n"
"\n"
"Twój program powinien wypisać\n"
"\n"
"    adg\n"
"    beh\n"
"    cfi\n"
"    q q\n"
"    w\n"
"    e"

msgid "pages.LoopingOverNestedLists.steps.final_text.text"
msgstr ""
"Opanowałeś listy zagnieżdżone oraz jak je łączyć z zagnieżdżonymi pętlami.\n"
"Świetna robota! Teraz masz w swoim arsenale programistycznym niezwykle potężne narzędzia."

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.0.text"
msgstr "How do you check if a string contains a word?"

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.1.text"
msgstr ""
"Make sure to check whether **the string** contains the word, not the "
"sublist."

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.2.text"
msgstr "How can you access each string in each sublist of a nested list?"

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.3.text"
msgstr "You need to use a nested loop."

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.4.text"
msgstr ""
"The loops should follow the same pattern as the example at the beginning of "
"the page."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.0.text"
msgstr "For each sublist, define a boolean."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.1.text"
msgstr "Go through a sublist, update the boolean accordingly."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.2.text"
msgstr "Only print the boolean once for each sublist."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.3.text"
msgstr "What should be the initial value for the boolean?"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.4.text"
msgstr ""
"What if one of the sublists is empty? What should you print for that "
"sublist?"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.5.text"
msgstr ""
"If you find the word in a string, the boolean should be set to `True`."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.6.text"
msgstr "What if a string doesn't contain the word?"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.7.text"
msgstr ""
"Doesn't matter! It doesn't change whether any other string might contain the"
" word."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.8.text"
msgstr ""
"In other words, don't set the boolean to `False` except at the beginning."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.0.text"
msgstr "This is very similar to the previous exercise."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.1.text"
msgstr "When should you print the boolean?"

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.2.text"
msgstr "Remember you want to print it only once."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.3.text"
msgstr ""
"Instead of defining a boolean for each sublist, define only one boolean for "
"the entire list."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.4.text"
msgstr "When and how should you modify the boolean?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.0.text"
msgstr "This is NOT similar to the previous exercises on this page."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.1.text"
msgstr ""
"Think about the solution when there's just two strings. How can you "
"generalize it to a list of strings?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.2.text"
msgstr ""
"You'll need to go through the first letters, then the second letters, and so"
" on."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.3.text"
msgstr "You'll have to use a loop, but how long should the loop take?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.4.text"
msgstr "Remember that strings in the list have equal lengths."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.5.text"
msgstr "For each position (first, second etc.) define a new string."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.6.text"
msgstr "What should that string be initially?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.7.text"
msgstr ""
"For each position (first, second etc.) you'll have to go through each string"
" in the list."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.8.text"
msgstr "You'll need another loop inside the one you have."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.0.text"
msgstr "Since the strings can have different lengths, this is a bit tricky."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.1.text"
msgstr "For how long should your outer loop go this time?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.2.text"
msgstr ""
"Before you start handling the strings, it might be a good idea to find the "
"longest string length first."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.3.text"
msgstr "The rest is very similar to the previous exercise."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.4.text"
msgstr ""
"The only difference is that now you have to determine whether to add a "
"letter from a string, or a space."

msgid "pages.LoopingOverNestedLists.title"
msgstr "Looping Over Nested Lists"

msgid ""
"pages.LoopingOverNestedLists.steps.nested_list_loop_python_tutor.requirements"
msgstr ""
"Run a single program consisting of the two parts above combined.\n"
"They're separated so that you don't need to type in the `numbers = [...]` part,\n"
"but typing in the nested loop part is best for learning.\n"
"Make sure the indentation is correct."

msgid ""
"pages.LoopingOverNestedLists.steps.nested_list_nested_loop_example.requirements"
msgstr ""
"Run a single program consisting of the two parts above combined.\n"
"They're separated so that you don't need to type in the `numbers = [...]` part,\n"
"but typing in the nested loop part is best for learning.\n"
"Make sure the indentation is correct."
