#
msgid ""
msgstr ""

msgid "pages.MakingTheBoard.steps.naive_make_board.text"
msgstr ""
"Do tej pory plansza była dostarczana dla Ciebie jako zagnieżdżona lista.\n"
"Ale dla pełnego programu musisz ją stworzyć sam.\n"
"To powinno być łatwe, prawda? Oto kilka linijek kodu do tego:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Jest to niemal poprawne, ale jest w tym subtelny problem.\n"
"Upewnij się, że rozumiesz kod,\n"
"i dodatkowe punkty, jeśli potrafisz zauważyć błąd!\n"
"Jeśli nie, nie martw się i nie trac za dużo czasu na to."

msgid "pages.MakingTheBoard.steps.fix_make_board.text"
msgstr ""
"Czy widzisz, co się stało?\n"
"\n"
"Każdy wiersz dostał „X” na pierwszej pozycji!\n"
"To tak, jakby kod faktycznie zrobił to:\n"
"\n"
"__code0__\n"
"\n"
"Podejmij próbę i zobacz, co jest nie tak samodzielnie.\n"
"Ale ponownie, to zawiłe, więc nie doprowadzaj się do szału przez to.\n"
"\n"
"Jeśli chcesz, oto kilka wskazówek:\n"
"\n"
" - Spróbuj uruchomić kod w kilku debuggerach.\n"
" - Eksperymentuj. Dokonuj zmian w kodzie i zobacz, co się stanie.\n"
" - Nie, kod nie wykonał 3 przypisań, jak sugerowałem wyżej. Było tylko jedno przypisanie listy.\n"
" - Nie ma żadnych ukrytych pętli czy czegoś podobnego.\n"
" - Ile list zawiera `board`? 3?\n"
" - Na poprzedniej stronie jest subtelna wskazówka na temat tego, co się stało.\n"
" - Jest strona z poprzedniego rozdziału, gdzie ten rodzaj problemu jest wyjaśniony bezpośrednio.\n"
" - W szczególności [ta strona](#EqualsVsIs).\n"
" - Spróbuj uruchomić kod przy pomocy Python Tutor.\n"
"\n"
"OK, jeśli jesteś gotowy, oto odpowiedź.\n"
"\n"
"Lista `row` została stworzona tylko raz i użyta kilka razy.\n"
"`board` zawiera tę samą listę trzy razy. Nie kopie, tylko jedną listę w trzech miejscach.\n"
"To tak, jakby zrobiło to:\n"
"\n"
"__code1__\n"
"\n"
"Co oznacza, że ten kod:\n"
"\n"
"__code2__\n"
"\n"
"jest równoznaczny z:\n"
"\n"
"__code3__\n"
"\n"
"co wpływa na 'wszystkie listy' w `board`, ponieważ wszystkie one są po prostu tą jedną listą `row`.\n"
"Innymi słowy, powyższa linijka jest *również* równoznaczna z każdą z tych dwóch linii:\n"
"\n"
"__code4__\n"
"\n"
"ponieważ `row` to `board[0]`, `board[1]` i `board[2]` naraz.\n"
"\n"
"Twoim zadaniem teraz jest naprawić `make_board`, aby nie miało tego problemu.\n"
"Nadal powinna zwracać listę o długości `size`, gdzie każdy\n"
"element to również lista o długości `size`, w której każdy element to łańcuch znaków `' '`.\n"
"Podlisty powinny być wszystkie oddzielnymi obiektami list, a nie tą samą\n"
"listą powtórzoną."

msgid "pages.MakingTheBoard.steps.final_text.text"
msgstr ""
"Świetna robota!\n"
"\n"
"To można było rozwiązać, przenosząc pierwszą pętlę do wnętrza drugiej, aby każdorazowo tworzyć nowy `row`:\n"
"\n"
"__code0__\n"
"\n"
"Innym sposobem jest skopiowanie `row` za każdym razem, na przykład zachować oryginalny kod, ale zmienić jedną linię:\n"
"\n"
"__code1__\n"
"\n"
"Możesz również skopiować `row` używając `row[:]` lub `list(row)`. Ale ważne jest, aby wiedzieć, że\n"
"wszystkie te metody tworzą *płytką kopię* listy.\n"
"Oznacza to, że kopiują całą listę na najwyższym poziomie, bez tworzenia kopii każdego elementu.\n"
"W tym przypadku, kiedy `row` zawiera tylko łańcuchy znaków, które nie mogą być zmodyfikowane\n"
"i nie potrzebują kopiowania, to wystarczy. Ale jeśli elementy to obiekty zmienne, takie jak listy,\n"
"jak w przypadku `board`, możesz napotkać ten sam problem ponownie.\n"
"Oto przykład:\n"
"\n"
"    __copyable__\n"
"__code2__\n"
"\n"
"Tutaj każdy element `cube` to oddzielna lista, kopia `board`.\n"
"I w każdej z tych kopii, każdy element to również oddzielna lista, kopia `row`.\n"
"Ale płytkie kopie `board` mają wszystkie ten sam pierwszy element (pierwsza kopia `row`),\n"
"taki sam drugi element, i tak dalej.\n"
"Zmiana `make_board` tu nic nie naprawi, rozwiązaniem jest albo:\n"
"\n"
"- wielokrotne wywoływanie `make_board`, aby za każdym razem utworzyć nowy `board`, albo\n"
"- użycie funkcji `deepcopy` zamiast `board.copy()`.\n"
"  `deepcopy` tworzy kopie na każdym poziomie zagnieżdżonych obiektów.\n"
"\n"
"Jeśli to ciągle jest dla ciebie mylące, nie martw się.\n"
"To po prostu przygotowuje cię do radzenia sobie z dziwnym zachowaniem twojego kodu w przyszłości.\n"
"Nie musisz tego rozumieć od razu, ta lekcja będzie wartościowa i tak.\n"
"\n"
"Tak czy inaczej, jesteśmy gotowi do stworzenia pełnej gry. Dasz radę!"

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.0.text"
msgstr "The existing code is almost correct."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.1.text"
msgstr "There are several ways to solve this."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.2.text"
msgstr "Some solutions involve adding something small."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.3.text"
msgstr ""
"You can also rearrange the code without adding or removing anything (except "
"spaces)."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.4.text"
msgstr "The problem is that a single list `row` is used several times."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.5.text"
msgstr ""
"So one solution is to make copies of `row` which will all be separate."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.6.text"
msgstr "Another solution is to make a new `row` from scratch each time."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.7.text"
msgstr ""
"There are a few ways to copy a list in Python with a tiny bit of code."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.8.text"
msgstr "Making a new row each time can be done by just rearranging the code."

msgid "pages.MakingTheBoard.title"
msgstr "Making the Board"

msgid ""
"pages.MakingTheBoard.steps.fix_make_board.special_messages.not_separate.text"
msgstr "However, the sublists in the result are not all separate objects."
