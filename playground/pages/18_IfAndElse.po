#
msgid ""
msgstr ""

msgid "pages.IfAndElse.steps.first_if_else.text"
msgstr ""
"Instrukcja `if` może opcjonalnie mieć część `else`. Uruchom ten przykład:\n"
"\n"
"__program_indented__"

msgid "pages.IfAndElse.steps.first_if_else_false.text"
msgstr ""
"Teraz zmień pierwszą linię na `condition = False` i uruchom to ponownie."

msgid "pages.IfAndElse.steps.if_upper_else_lower.text"
msgstr ""
"Pomyśl o `else` jako o 'w przeciwnym razie'. Oznacza to, że jeśli warunek w `if`\n"
"jest fałszywy, wówczas ciało `else` zostanie wykonane. Bez względu na to, czy warunek jest prawdziwy, czy fałszywy,\n"
"dokładnie jedno z dwóch ciał zostanie uruchomione.\n"
"\n"
"Oto bardziej interesujący przykład do uruchomienia:\n"
"\n"
"__program_indented__"

msgid "pages.IfAndElse.steps.if_upper_else_lower_false.text"
msgstr ""
"`sentence.upper()` to nowy rodzaj wyrażenia, którego jeszcze nie napotkaliśmy. Chodzi o to, że `sentence` jest łańcuchem znaków, a łańcuchy znaków mają różne *metody*, które pozwalają na wygodne obliczanie z nich nowych wartości, w tym `upper` i `lower`. Nazwy odnoszą się do wielkich liter (liter kapitałowych) i małych liter (liter małych). `'Hello World'.upper()` zwraca `'HELLO WORLD'`. To jednak nie zmienia zawartości `sentence`, więc musisz przypisać nową wartość ponownie za pomocą `sentence = sentence.upper()`.\n"
"\n"
"Teraz zmień `excited` na `False` i uruchom to ponownie."

msgid "pages.IfAndElse.steps.undefined_char.text"
msgstr ""
"Oto zepsuty program:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Dostrzegasz problem? Jeśli go uruchomisz, wszystko wydaje się być w porządku. Co mogłoby pójść nie tak?\n"
"\n"
"Spoilery poniżej! Czy udało ci się to rozgryźć?\n"
"\n"
"Co się stanie, jeśli zmienisz `excited` na `False`?"

msgid "pages.IfAndElse.steps.else_full_stop.text"
msgstr ""
"Jeśli `excited` jest prawdziwe, wówczas `char` jest zdefiniowane i wszystko działa poprawnie. Ale w przeciwnym razie\n"
"`char` nigdy nie zostaje przypisane żadnej wartości, więc próba użycia go w `sentence += char` zawodzi.\n"
"\n"
"Napraw to, dodając klauzulę `else` do `if`, tak aby jeśli `excited` jest fałszywe, do końca zdania dodawany jest kropka (`.`)\n"
"zamiast wykrzyknika (`!`)."

msgid "pages.IfAndElse.steps.capitalise.text"
msgstr ""
"Czas na wyzwanie!\n"
"\n"
"Napisz program, który dla danego łańcucha znaków `sentence`, wydrukuje zmodyfikowaną wersję\n"
"z tymi samymi literami, gdzie pierwsza litera jest wielka, a reszta małymi literami.\n"
"Na przykład, wynik powinien być `Hello world`, niezależnie od tego, czy wejściowy `sentence = 'hello world'`\n"
"czy `'HELLO WORLD'`."

msgid "pages.IfAndElse.steps.spongebob.text"
msgstr ""
"Doskonale!!!\n"
"\n"
"Jeszcze jedno ćwiczenie, a potem możesz odpocząć.\n"
"\n"
"Napisz program, który wydrukuje `sentence` w drwiący sposób, np:\n"
"\n"
"    OnE MoRe eXeRcIsE, aNd tHeN YoU CaN ReLaX.\n"
"\n"
"Każda druga litera powinna być mała, a reszta wielkie."

msgid "pages.IfAndElse.steps.final_text.text"
msgstr ""
"Doskonale! Poświęć chwilę, aby być dumny z tego, co osiągnąłeś. Czy czujesz,"
" jak rośnie twój mózg?"

msgid "pages.IfAndElse.steps.capitalise.hints.0.text"
msgstr ""
"Nauczyłeś się wszystkich narzędzi potrzebnych do tego. Wierzę w Ciebie! "
"Spójrz na poprzednie programy, aby znaleźć inspirację."

msgid "pages.IfAndElse.steps.capitalise.hints.1.text"
msgstr ""
"Będziesz potrzebować pętli, aby skonstruować nowe zdanie znak po znaku."

msgid "pages.IfAndElse.steps.capitalise.hints.2.text"
msgstr ""
"Będziesz potrzebować instrukcji `if/else`, aby wybrać, czy dodać znak "
"wielkiej czy małej litery."

msgid "pages.IfAndElse.steps.capitalise.hints.3.text"
msgstr ""
"Twoje `if/else` musi wykonywać różne bloki kodu w zależności od tego, w "
"której iteracji pętli się znajduje."

msgid "pages.IfAndElse.steps.capitalise.hints.4.text"
msgstr ""
"To oznacza, że warunek w twojej instrukcji `if` musi być zmienną, która "
"zmienia się wewnątrz pętli."

msgid "pages.IfAndElse.steps.capitalise.hints.5.text"
msgstr ""
"W pierwszej iteracji potrzebujesz wielkiej litery. W kolejnych iteracjach "
"potrzebujesz małej litery."

msgid "pages.IfAndElse.steps.spongebob.hints.0.text"
msgstr ""
"To jest podobne do poprzedniego ćwiczenia. Różnica polega na tym, kiedy i "
"gdzie ustawiasz zmienną warunkową."

msgid "pages.IfAndElse.steps.spongebob.hints.1.text"
msgstr ""
"Będziesz potrzebować zmiennej logicznej, która zmienia swoją wartość z każdą"
" iteracją."

msgid "pages.IfAndElse.steps.spongebob.hints.2.text"
msgstr ""
"```python\n"
"zmienna = __code0__  # Załóżmy, że __code0__ to albo True albo False\n"
"\n"
"if zmienna:\n"
"    zmienna = False\n"
"else:\n"
"    zmienna = True\n"
"\n"
"print(zmienna)\n"
"```"

msgid "pages.IfAndElse.steps.spongebob.hints.3.text"
msgstr ""
"```python\n"
"zmienna = __code0__  # Zakładając, że __code0__ to albo True albo False\n"
"\n"
"if zmienna:\n"
"    zmienna = False\n"
"else:\n"
"    zmienna = True\n"
"\n"
"print(zmienna)\n"
"```"

msgid "pages.IfAndElse.steps.spongebob.hints.4.text"
msgstr ""
"```python\n"
"zmienna = __code0__  # Zakładając, że __code0__ to albo True albo False\n"
"znak = __code1__  # Zakładając, że __code1__ to znak, który chcemy zmienić\n"
"\n"
"if zmienna:\n"
"    nowy_znak = znak.upper()\n"
"    zmienna = False\n"
"else:\n"
"    nowy_znak = znak.lower()\n"
"    zmienna = True\n"
"\n"
"print(nowy_znak)\n"
"```"

msgid "pages.IfAndElse.steps.undefined_char.output_prediction_choices.0"
msgstr "Hello World"

msgid "pages.IfAndElse.steps.undefined_char.output_prediction_choices.1"
msgstr "Hello World!"

msgid "pages.IfAndElse.title"
msgstr "`if` and `else`"

msgid "pages.IfAndElse.steps.else_full_stop.hints.0.text"
msgstr "Don't change anything that's already there, just add a bit more code."

msgid "pages.IfAndElse.steps.else_full_stop.hints.1.text"
msgstr ""
"`else` needs to come immediately after the `if` body, with nothing in "
"between."

msgid "pages.IfAndElse.steps.else_full_stop.hints.2.text"
msgstr ""
"`sentence += char` needs to run whether `excited` is `True` or `False`."

msgid "pages.IfAndElse.steps.else_full_stop.hints.3.text"
msgstr ""
"You *could* have a copy of `sentence += char` in both the `if` and `else` "
"blocks, but there's a better way."

msgid "pages.IfAndElse.steps.else_full_stop.hints.4.text"
msgstr "Use `else` to assign a different value to `char`."

msgid "pages.IfAndElse.steps.else_full_stop.hints.5.text"
msgstr ""
"If `excited` is `False`, then `char` should be `'.'` instead of `'!'`."

msgid "pages.IfAndElse.steps.first_if_else_false.requirements"
msgstr ""
"Run the same program from the previous step, but replace `True` with "
"`False`, so that `condition = False`."

msgid "pages.IfAndElse.steps.if_upper_else_lower_false.requirements"
msgstr ""
"Run the same program from the previous step, but replace `True` with "
"`False`, so that `excited = False`."

msgid "pages.IfAndElse.steps.undefined_char.requirements"
msgstr ""
"Copy the program above. Run it as is if you want. Then change `excited = "
"True` to `excited = False` and run it again."
