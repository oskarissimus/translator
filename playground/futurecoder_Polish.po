msgid "pages.IntroducingTheShell.steps.first_expression.text"
msgstr ""
"Po prawej stronie znajduje się *konsola*. To miejsce do uruchamiania małych fragmentów kodu Pythona. Wystarczy wpisać trochę kodu, nacisnąć enter, i już zadziała! Wypróbuj teraz:\n"
"\n"
"1. Kliknij gdziekolwiek na konsoli (czarnym obszarze).\n"
"2. Wpisz `__program__`\n"
"3. Naciśnij klawisz Enter na klawiaturze."

msgid "pages.IntroducingTheShell.steps.more_calculation.text"
msgstr ""
"Świetnie! Python obliczył `1+2` i otrzymał wynik `3`, więc konsola wyświetla ten wynik.\n"
"\n"
"Konsola to prawdopodobnie Twoje najważniejsze narzędzie do nauki Pythona i powinieneś spędzić dużo czasu na eksperymentowaniu i eksplorowaniu jej możliwości. Bądź ciekawy! Ciągle zadawaj sobie pytania \"Co by się stało, gdybym uruchomił X?\" i natychmiast odpowiadaj na to pytanie, uruchamiając to. Nigdy nie bój się czegoś wypróbować - jeśli coś pójdzie nie tak, nic złego się nie stanie.\n"
"\n"
"Spróbuj teraz wykonać więcej obliczeń. Możesz mnożyć liczby za pomocą `*`, dzielić przy użyciu `/` oraz odejmować za pomocą `-`. Możesz również używać nawiasów, czyli `(` i `)`."

msgid "pages.IntroducingTheShell.steps.final_text.text"
msgstr ""
"Doskonale! Kontynuuj eksperymentowanie. Gdy będziesz gotowy, kliknij "
"'Dalej', aby kontynuować."

msgid "pages.NavigatingShellHistory.steps.final_text.text"
msgstr ""
"Oto wskazówka: często będziesz chciał ponownie uruchomić wcześniej "
"wprowadzony fragment kodu lub jego nieco zmodyfikowaną wersję. Możesz "
"skorzystać z kopiowania i wklejania, ale jest to żmudne i utrudnia "
"eksperymentowanie. Lepszą metodą jest naciśnięcie klawisza ze strzałką w "
"górę na klawiaturze. Spowoduje to wstawienie poprzedniej linii kodu do "
"konsoli. Naciskaj go kolejno, aby cofnąć się dalej w historii i jeśli "
"przejdziesz za daleko, naciśnij klawisz ze strzałką w dół, aby przejść w "
"drugą stronę. Wypróbuj to teraz."

msgid "pages.IntroducingStrings.steps.hello_string.text"
msgstr ""
"Python pozwala na znacznie więcej niż tylko obliczenia. Tak naprawdę przez jakiś czas nie będziemy się zajmować liczbami ani matematyką. Zamiast tego przyjrzymy się *łańcuchom znaków*. Łańcuchy znaków to w zasadzie fragmenty tekstu. Na przykład, wprowadź do konsoli poniższe polecenie, razem z cudzysłowami (`'`):\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingStrings.steps.final_text.text"
msgstr ""
"Konsola po prostu zwraca to samo, ponieważ nie ma nic więcej do obliczenia. `'hello'` jest po prostu równe `'hello'`.\n"
"\n"
"Łańcuch znaków to ciąg znaków. Znak to pojedynczy symbol, taki jak litera, cyfra, znak interpunkcyjny, spacja itp. W tym przypadku łańcuch zawiera 5 znaków `hello`. Cudzysłowy nie są częścią łańcucha - są one umieszczone, aby zarówno ludzie, jak i komputery wiedziały, że jest to łańcuch składający się z jakichkolwiek znaków znajdujących się między cudzysłowami."

msgid "pages.AddingStrings.steps.hello_world_concat.text"
msgstr ""
"Łańcuchy znaków mogą być łączone razem za pomocą `+`, chociaż ma to bardzo odmienne znaczenie niż dodawanie liczb. Na przykład spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.AddingStrings.steps.hello_world_space.text"
msgstr ""
"Możesz zauważyć, że `+` łączy dwa łańcuchy znaków ze sobą jeden za drugim. Technicznie nazywa się to konkatenacją.\n"
"\n"
"Oto ćwiczenie: zmodyfikuj nieco poprzedni kod, tak aby wynikiem było łańcuch znaków `'hello world'`, czyli z odstępem między słowami.\n"
"\n"
"A tak przy okazji, jeśli utkniesz, możesz kliknąć ikonę żarówki w prawym dolnym rogu, aby uzyskać wskazówkę."

msgid "pages.AddingStrings.steps.final_text.text"
msgstr ""
"Brawo! Wszystkie z poniższych są prawidłowymi rozwiązaniami:\n"
"\n"
"__code0__"

msgid "pages.IntroducingVariables.steps.word_assign.text"
msgstr ""
"Aby tworzyć interesujące programy, nie możemy zawsze manipulować tymi samymi wartościami. Potrzebujemy sposobu, aby odnosić się do wartości, które nie są znane z góry i mogą się zmieniać - wartości, które mogą być zmienne. Nazywane są one *zmiennymi*.\n"
"\n"
"Uruchom ten kod:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingVariables.steps.word_check.text"
msgstr ""
"To tworzy zmienną o nazwie `word`, która odnosi się do łańcucha znaków `'Hello'`.\n"
"\n"
"Sprawdź teraz, co się stanie, gdy uruchomisz `__program__` w konsoli samodzielnie."

msgid "pages.IntroducingVariables.steps.word_string_check.text"
msgstr ""
"Dobrze. Dla porównania, uruchom `__program__` w konsoli samodzielnie, z "
"cudzysłowami."

msgid "pages.IntroducingVariables.steps.sunshine_undefined_check.text"
msgstr ""
"Jak widzisz, cudzysłowy robią całą różnicę. `'word'` to dosłownie tylko `'word'`, stąd technicznie nazywa się to *dosłownym łańcuchem znaków (string literal)*. Z drugiej strony, `word` to zmienna, której wartość może być dowolna.\n"
"\n"
"Podobnie, `'sunshine'` to `'sunshine'`, ale co jest `__program__` bez cudzysłowów?"

msgid "pages.IntroducingVariables.steps.final_text.text"
msgstr ""
"Odpowiedź brzmi, że `sunshine` wygląda na zmienną, więc Python próbuje "
"odszukać jej wartość, ale ponieważ nigdy nie zdefiniowaliśmy zmiennej o tej "
"nazwie, otrzymujemy błąd."

msgid "pages.UsingVariables.steps.name_assign.text"
msgstr ""
"Wcześniej stworzyliśmy zmienną o nazwie `word` z wartością `'Hello'` za pomocą tego kodu:\n"
"\n"
"__code0__\n"
"\n"
"Teraz stwórz zmienną o nazwie `your_name`, której wartością będzie inny łańcuch znaków.\n"
"\n"
"(Znak `_` w `your_name` nazywany jest *podkreśleniem (underscore)*. Używaj go do oddzielania słów, kiedy chcesz stworzyć nazwę zmiennej składającą się z wielu słów. Można go wpisać na większości klawiatur, naciskając jednocześnie klawisz Shift i myślnik/kreskę/minus (`-`).)"

msgid "pages.UsingVariables.steps.hello_plus_name.text"
msgstr ""
"Możesz używać zmiennych w obliczeniach tak samo, jak używałbyś dosłownych wartości. Na przykład, spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.UsingVariables.steps.word_plus_name.text"
msgstr ""
"Albo po prostu możesz dodawać do siebie zmienne. Spróbuj:\n"
"\n"
"__code0__"

msgid "pages.UsingVariables.steps.word_plus_name_with_space.text"
msgstr ""
"Ups... to nie wygląda ładnie. Czy możesz zmodyfikować powyższy kod, tak aby "
"między słowem a twoim imieniem była spacja?"

msgid "pages.UsingVariables.steps.word_assign_goodbye.text"
msgstr ""
"Doskonale!\n"
"\n"
"Zmienne mogą również zmieniać swoje wartości z czasem. Obecnie `word` ma wartość `'Hello'`. Możesz zmienić jej wartość w ten sam sposób, w jaki ustawiałeś ją po raz pierwszy. Uruchom to:\n"
"\n"
"__code0__"

msgid "pages.UsingVariables.steps.goodbye_plus_name.text"
msgstr ""
"Teraz zaobserwuj efekt tej zmiany, uruchamiając ponownie `__program__`."

msgid "pages.UsingVariables.steps.first_print.text"
msgstr ""
"Te cudzysłowy wokół łańcuchów znaków zaczynają być irytujące. Spróbuj uruchomić to:\n"
"\n"
"__code0__"

msgid "pages.UsingVariables.steps.final_text.text"
msgstr ""
"Hura! Już więcej bez cudzysłowów! Wyjaśnimy, co dzieje się w tym kodzie "
"później. Na razie wystarczy wiedzieć, że `print(<coś>)` wyświetla `<coś>` w "
"konsoli. W szczególności pokazuje faktyczną zawartość łańcuchów znaków, na "
"której zazwyczaj nam zależy, zamiast reprezentacji łańcuchów znaków "
"odpowiednich dla kodu, gdzie występują takie rzeczy jak cudzysłowy. Słowo "
"`print` tutaj nie ma nic wspólnego z drukowaniem tuszem na papierze."

msgid "pages.WritingPrograms.steps.editor_hello_world.text"
msgstr ""
"Nadszedł czas, aby przestać robić wszystko w konsoli. W prawym górnym rogu widzisz *edytor*. To miejsce, gdzie możesz pisać i uruchamiać dłuższe programy. Konsola jest świetna i powinieneś nadal jej używać do eksploracji, ale to w edytorze mieszkają prawdziwe programy.\n"
"\n"
"Wpisz poniższy program do edytora, a następnie kliknij przycisk 'Uruchom':\n"
"\n"
"__code0__"

msgid "pages.WritingPrograms.steps.final_text.text"
msgstr ""
"Gratulacje, uruchomiłeś swój pierwszy prawdziwy program!\n"
"\n"
"Poświęć trochę czasu, aby zrozumieć ten program. Python wykonuje każdą linię po kolei, od góry do dołu. Powinieneś spróbować symulować ten proces w swojej głowie - zastanów się, co robi każda linia. Zobacz, jak zmieniła się wartość `word` i jaki miało to wpływ. Zauważ, że kiedy używane jest kilka razy `print`, każda rzecz (w tym przypadku `Hello World` i `Goodbye World`) jest drukowana w osobnej linii.\n"
"\n"
"Kilka rzeczy, które warto zauważyć o programach w edytorze:\n"
"\n"
"1. Program wykonuje się w konsoli, co oznacza, że zmienne zdefiniowane w programie istnieją teraz w konsoli z ostatnimi wartościami, które miały w programie. Pozwala ci to na eksplorację w konsoli po zakończeniu programu. Na przykład `name` ma teraz wartość `'World'` w konsoli.\n"
"2. Programy działają w izolacji – nie zależą od wcześniej zdefiniowanych zmiennych. Konsola jest resetowana i wszystkie poprzednie zmienne są usuwane. Więc chociaż `word` obecnie istnieje w konsoli, jeśli usuniesz pierwszą linię programu i uruchomisz go ponownie, otrzymasz błąd o niezdefiniowanym `word`.\n"
"3. Jeśli wprowadzasz kod w konsoli i ma on wartość, ta wartość zostanie automatycznie wyświetlona. Dla programów w edytorze to się nie dzieje - musisz wydrukować wartości. Jeśli usuniesz `print()` z programu, zmieniając dwie linie na tylko `word + ' ' + name`, nic nie zostanie wyświetlone.\n"
"\n"
"Polecam sprawdzić to wszystko samodzielnie."

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.text"
msgstr ""
"Często będziesz używać zmiennych do przechowywania wyników obliczeń. To pomoże budować bardziej złożone programy. Na przykład, wypróbuj ten program:\n"
"\n"
"__code0__"

msgid "pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.text"
msgstr ""
"Teraz `sentence` ma wartość `'Hello World'`, która może być używana wielokrotnie. Zwróć uwagę, że będzie ona miała tę wartość tak długo, aż nie zostanie jej bezpośrednio przypisana na nowo, np. za pomocą innego polecenia, takiego jak `sentence = <coś>`. Na przykład, dodaj te dwie linie na końcu programu:\n"
"\n"
"__code0__"

msgid "pages.StoringCalculationsInVariables.steps.final_text.text"
msgstr ""
"W przeciwieństwie do arkusza kalkulacyjnego, gdzie formuły aktualizują się "
"automatycznie, zmienna taka jak `sentence` nie pamięta, jak została "
"obliczona i nie zmieni się, jeżeli wartości bazowe `word` lub `name` zostaną"
" zmienione."

msgid "pages.IntroducingForLoops.steps.first_for_loop.text"
msgstr ""
"Dobre wiadomości! Przekroczyłeś już nudne podstawy. Możemy zacząć pisać ciekawe programy i trochę się zabawić. Jednym z najpotężniejszych pojęć w programowaniu jest *pętla*, która pozwala powtarzać ten sam kod wielokrotnie. Python posiada dwa rodzaje pętli: pętlę `for` i pętlę `while`. Oto przykład pętli for, spróbuj uruchomić ten program:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingForLoops.steps.final_text.text"
msgstr ""
"Możesz odczytać kod prawie jak zwykły angielski:\n"
"\n"
"> Dla każdego znaku w łańcuchu znaków `name`, wydrukuj ten znak.\n"
"\n"
"Każdy znak to po prostu normalny łańcuch znaków. `character` to normalna zmienna, której przed wykonaniem kodu za `:` przypisywana jest nowa wartość. Więc powyższy kod jest równoważny z:\n"
"\n"
"    __no_auto_translate__\n"
"    name = 'World'\n"
"\n"
"    character = 'W'\n"
"    print(character)\n"
"\n"
"    character = 'o'\n"
"    print(character)\n"
"\n"
"    character = 'r'\n"
"    print(character)\n"
"\n"
"    character = 'l'\n"
"    print(character)\n"
"\n"
"    character = 'd'\n"
"    print(character)\n"
"\n"
"Zauważ, że moglibyśmy użyć innej nazwy zmiennej, `character` po prostu czyni to jaśniejszym.\n"
"\n"
"Pętla for zazwyczaj podąża za tą strukturą:\n"
"\n"
"    for <zmienna> in <kolekcja>: <kod do powtórzenia>\n"
"\n"
"`for`, `in` i `:` są wszystkie niezbędne."

msgid "pages.Indentation.steps.missing_indentation.text"
msgstr ""
"Ta przykładowa pętla:\n"
"\n"
"__code0__\n"
"\n"
"działa, ale zazwyczaj (i powinno) być napisana tak:\n"
"\n"
"__code1__\n"
"\n"
"Konkretnie, kod do powtórzenia (znany jako *ciało*) zaczyna się w nowym wierszu po dwukropku (`:`), i musi być *wcięty*, to znaczy mieć pewną ilość spacji przed sobą. Kod poniżej bez wcięcia jest nieprawidłowy, uruchom go żeby przekonać się sam:\n"
"\n"
"__program_indented__"

msgid "pages.Indentation.steps.two_indented_lines.text"
msgstr ""
"Spacje są wymagane, aby powiedzieć Pythonowi, które linie kodu należą do ciała pętli for. To jest kluczowe, gdy pętla zawiera kilka linii, co często ma miejsce. Na przykład, uruchom ten kod:\n"
"\n"
"__code0__"

msgid "pages.Indentation.steps.one_indented_line.text"
msgstr ""
"Są dwie linie z wcięciem, więc obie są częścią ciała, więc `---` zostanie wydrukowane po każdym znaku. Teraz spróbuj uruchomić ten sam kod bez wcięcia w ostatniej linii:\n"
"\n"
"__code0__"

msgid "pages.Indentation.steps.mismatched_indentations.text"
msgstr ""
"Ponieważ `print('---')` nie jest wcięte, nie jest częścią ciała pętli. To oznacza, że jest wykonywane tylko raz, po zakończeniu całej pętli. Oba programy są prawidłowe, po prostu robią różne rzeczy.\n"
"\n"
"Program poniżej jest nieprawidłowy. Obie linie w ciele pętli mają wcięcia, ale w różnych ilościach. Pierwsza linia zaczyna się od 4 spacji, druga linia zaczyna się od 2. Spróbuj go uruchomić.\n"
"\n"
"__program_indented__"

msgid "pages.Indentation.steps.final_text.text"
msgstr ""
"Gdy stosujesz wcięcia, powinieneś zawsze wciąć o 4 spacje. W rzeczywistości "
"akceptowalne jest każde spójne wcięcie, ale 4 spacje to konwencja, której "
"przestrzega prawie każdy. Zauważ, że edytor zazwyczaj ułatwia to dla ciebie."
" Na przykład, jeśli naciśniesz klawisz 'Tab' na swojej klawiaturze w "
"edytorze, wstawi on dla ciebie 4 spacje."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_1.text"
msgstr ""
"Czas na ćwiczenia! Zmodyfikuj ten program:\n"
"\n"
"__code0__\n"
"\n"
"aby zamiast tego wyjście wyglądało:\n"
"\n"
"    __no_auto_translate__\n"
"    ---W\n"
"    ---o\n"
"    ---r\n"
"    ---l\n"
"    ---d"

msgid "pages.BasicForLoopExercises.steps.loop_exercise_2.text"
msgstr ""
"Wspaniale! Teraz napisz program, który wydrukuje `name` raz dla każdej litery w `name`. Na przykład, dla `name = 'Amy'`, powinien wyjść wynik:\n"
"\n"
"    __no_auto_translate__\n"
"    Amy\n"
"    Amy\n"
"    Amy\n"
"\n"
"Dla `name = 'World'`, powinno to wyglądać:\n"
"\n"
"    __no_auto_translate__\n"
"    World\n"
"    World\n"
"    World\n"
"    World\n"
"    World\n"
"\n"
"Przy okazji, możesz ustawić `name` na cokolwiek w pierwszej linii. Tylko reszta programu po tym będzie sprawdzana."

msgid "pages.BasicForLoopExercises.steps.final_text.text"
msgstr ""
"Robimy naprawdę duże postępy! Rozwiązujesz problemy i piszesz nowe kody!\n"
"Zachowajmy zainteresowanie i róbmy rzeczy coraz bardziej interesujące."

msgid "pages.BuildingUpStrings.steps.hello_plus_equals.text"
msgstr ""
"Zanim przyjrzymy się kolejnym pętlom, musimy szybko poznać kolejne pojęcie. Spójrz na ten program:\n"
"\n"
"__program_indented__\n"
"\n"
"Co myślisz, co robi linia `hello = hello + '!'`? Uruchom program, aby się dowiedzieć."

msgid "pages.BuildingUpStrings.steps.name_triangle.text"
msgstr ""
"Pythonowi nie przeszkadza, że `hello` jest zarówno po lewej, jak i po prawej stronie znaku `=`, po prostu robi to, co zawsze robiłby, gdyby zmienne były różne: oblicza `hello + '!'`, co w tym momencie jest `'Hello' + '!'`, co jest równe `'Hello!'`, i to staje się nową wartością `hello`. Jeśli to pomoże, możesz myśleć o tej linii jako podzielonej na dwa kroki:\n"
"\n"
"__code0__\n"
"\n"
"albo:\n"
"\n"
"__code1__\n"
"\n"
"To jest bardzo użyteczne w pętli. Wypróbuj ten program:\n"
"\n"
"__program_indented__"

msgid "pages.BuildingUpStrings.steps.name_triangle_missing_last_line.text"
msgstr ""
"Poświęć czas, aby całkowicie zrozumieć ten program. Robi on coś w tym stylu:\n"
"\n"
"    line = '-'\n"
"\n"
"    char = 'W'\n"
"    line = line + char\n"
"         = '-'  + 'W'\n"
"         = '-W'\n"
"    print('-W')\n"
"\n"
"    char = 'o'\n"
"    line = line  + char\n"
"         = '-W'  + 'o'\n"
"         = '-Wo'\n"
"    print('-Wo')\n"
"\n"
"    char = 'r'\n"
"    line = line  + char\n"
"         = '-Wo' + 'r'\n"
"         = '-Wor'\n"
"    print('-Wor')\n"
"\n"
"    ...\n"
"\n"
"Szczegóły są ważne. Co się stanie, jeśli zamienisz miejscami ostatnie dwie linie i uruchomisz ten program zamiast tego?\n"
"\n"
"__program_indented__"

msgid "pages.BuildingUpStrings.steps.final_text.text"
msgstr ""
"Czyż to nie jest piękne?\n"
"\n"
"Wzorzec rozpoczynania od pustego elementu i budowania go poprzez pętlę `for` jest *bardzo* powszechny\n"
"i będziesz mieć dużo praktyki w tym zakresie. Niektóre z początkowych pustych wartości to\n"
"`''`, `0` oraz `[]` - pusta lista, którą wkrótce zobaczysz."

msgid "pages.BuildingUpStringsExercises.steps.name_triangle_spaced.text"
msgstr ""
"Zmodyfikuj ten program:\n"
"\n"
"__code0__\n"
"\n"
"tak, aby dodać spację po każdym znaku w trójkącie, aby wynik wyglądał tak:\n"
"\n"
"    W\n"
"    W o\n"
"    W o r\n"
"    W o r l\n"
"    W o r l d"

msgid "pages.BuildingUpStringsExercises.steps.name_triangle_backwards.text"
msgstr ""
"Fantastycznie! Teraz zmodyfikuj program tak, aby każda linia była odwrócona, jak tutaj:\n"
"\n"
"    __no_auto_translate__\n"
"    W\n"
"    oW\n"
"    roW\n"
"    lroW\n"
"    dlroW"

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.text"
msgstr ""
"Świetnie!\n"
"\n"
"Kod taki jak:\n"
"\n"
"__code0__\n"
"\n"
"jest tak powszechny, że Python pozwala na jego skrócenie. To oznacza to samo:\n"
"\n"
"__code1__\n"
"\n"
"Zauważ, że nie ma skrótu dla `line = char + line`.\n"
"\n"
"Teraz użyj `+=` oraz pętli for do napisania własnego programu, który wydrukuje `name` 'podkreślone', jak tutaj:\n"
"\n"
"    World\n"
"    ----- \n"
"\n"
"Powinien być jeden `-` dla każdego znaku w `name`."

msgid "pages.BuildingUpStringsExercises.steps.name_box.text"
msgstr ""
"Fantastycznie!\n"
"\n"
"Przy okazji, kiedy nie musisz używać zmiennej, często przyjętym zwyczajem jest nazwanie tej zmiennej `_` (podkreślenie), np. `for _ in name:`. Nie zmienia to działania programu, ale jest pomocne dla czytelników.\n"
"\n"
"Spróbujmy coś bardziej wyszukanego. Rozszerz swój program, aby narysować ramkę wokół nazwy, tak jak tutaj:\n"
"\n"
"    +-----+\n"
"    |World|\n"
"    +-----+"

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.text"
msgstr ""
"Świetnie Ci to idzie! Wygląda na to, że potrzebujesz większego wyzwania... może zamiast umieszczać nazwę w pudełku, nazwa powinna być pudełkiem? Napisz program, który wygeneruje takie wyjście:\n"
"\n"
"    +World+\n"
"    W     W\n"
"    o     o\n"
"    r     r\n"
"    l     l\n"
"    d     d\n"
"    +World+"

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.text"
msgstr ""
"Super! Naprawdę łapiesz to w lot!\n"
"\n"
"Jeśli chcesz, możesz spróbować jeszcze jednego dodatkowego, opcjonalnego wyzwania poniżej.\n"
"Jeśli nie, możesz już przejść do [następnej strony](#BasicTerminology).\n"
"Możesz wrócić i zrobić to później, jeśli chcesz.\n"
"\n"
"Spróbuj napisać program, który wyświetli podaną `name` na ukos, np.:\n"
"\n"
"    W\n"
"     o\n"
"      r\n"
"       l\n"
"        d"

msgid "pages.BuildingUpStringsExercises.steps.final_text.text"
msgstr "Wow, nic Cię nie powstrzyma!"

msgid "pages.BasicTerminology.steps.final_text.text"
msgstr ""
"Oto kilka pojęć, które powinieneś znać:\n"
"\n"
"***Wyrażenie*** to fragment kodu, który ma jakąś wartość. Na przykład w tej linii kodu:\n"
"\n"
"    __no_auto_translate__\n"
"    sentence = 'Hello ' + name\n"
"\n"
"są trzy wyrażenia:\n"
"\n"
"1. `'Hello '`\n"
"2. `name`\n"
"3. `'Hello ' + name`\n"
"\n"
"Natomiast cała linia `sentence = ...` to ***instrukcja***. To polecenie, które każe komputerowi wykonać jakąś akcję. Samo w sobie nie ma wartości. Oznacza to na przykład, że nie można dodawać do siebie instrukcji. Ten kod jest nieprawidłowy:\n"
"\n"
"    (word = 'Hello') + (name = 'Bob')\n"
"\n"
"Konkretnie, instrukcja taka jak `sentence = ...`, gdzie zmiennej przypisywana jest wartość, nazywana jest ***przypisaniem*** - wartość jest *przypisywana do* zmiennej.\n"
"\n"
"Program to lista instrukcji, które są wykonywane w kolejności. Pętla `for` to *złożona instrukcja*, co oznacza, że ma własne ciało, które zawiera inne instrukcje. Większość instrukcji będzie również zawierać wyrażenia, a wyrażenia mogą zawierać mniejsze wyrażenia, ale wyrażenia nie mogą zawierać instrukcji.\n"
"\n"
"Proces obliczania wartości wyrażenia nazywa się ***ewaluacją*** - zauważ, jak prawie zawiera słowo 'wartość'. Komputer *ewaluuje* `1 + 2` aby otrzymać wartość `3`.\n"
"\n"
"Proces wykonywania pętli nazywa się ***iteracją***. Kod taki jak `for char in 'Hello':` to *iterowanie przez* łańcuch znaków `'Hello'`. Fakt, że jest to możliwe, oznacza, że łańcuchy znaków są *iterowalne*. W przeciwieństwie do nich, liczby nie są iterowalne, co dokładnie powie Ci Python, jeśli spróbujesz `for char in 3:`. Każde przejście przez pętlę to *jedna iteracja*, więc w tym przykładzie będzie ich 5."

msgid "pages.IntroducingIfStatements.steps.introducing_booleans.text"
msgstr ""
"Teraz nauczymy się, jak nakazać komputerowi podejmowanie decyzji i wykonywanie kodu\n"
"tylko w określonych warunkach. Do tego będziemy potrzebowali nowego rodzaju wartości. Widziałeś już\n"
"liczby i łańcuchy znaków, teraz poznaj *wartości logiczne*. Istnieją tylko dwie wartości logiczne:\n"
"`True` (Prawda) i `False` (Fałsz). Wypróbuj ten program:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingIfStatements.steps.first_if_statements.text"
msgstr ""
"Wartości logiczne są przeznaczone do użycia wewnątrz *instrukcji warunkowych* (często nazywanych również *kondycjami*).\n"
"\n"
"Oto prosty przykład, który możesz uruchomić:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingIfStatements.steps.excited_example.text"
msgstr ""
"Zwróć uwagę, jak kod w pierwszej instrukcji `if` został wykonany, ale w drugiej już nie.\n"
"\n"
"Ogólnie rzecz biorąc, instrukcja warunkowa `if` wygląda następująco:\n"
"\n"
"    if <warunek>:\n"
"        <ciało>\n"
"\n"
"gdzie `<warunek>` to dowolne wyrażenie, które daje wartość logiczną, a `<ciało>` to **wcięta** lista\n"
"jednego lub więcej poleceń. Struktura jest dość podobna do pętli `for`. Zwróć uwagę na dwukropek (`:`), który\n"
"jest niezbędny.\n"
"\n"
"Kiedy komputer widzi `if <warunek>:`, sprawdza, czy `<warunek>` jest `True`. Jeśli tak jest, wykonuje ciało.\n"
"Jeśli nie, pomija je i kontynuuje resztę programu.\n"
"\n"
"Oto bardziej interesujący przykład, który możesz uruchomić:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingIfStatements.steps.excited_false_example.text"
msgstr ""
"(Pamiętaj, że `sentence += '!'` oznacza `sentence = sentence + '!'`)\n"
"\n"
"Zmień `excited = True` na `excited = False` i uruchom program ponownie, aby zobaczyć, jaka jest różnica."

msgid "pages.IntroducingIfStatements.steps.excited_confused_exercise.text"
msgstr ""
"Czas na ćwiczenie. Zmodyfikuj program powyżej, aby zawierał dodatkowy\n"
"parametr logiczny `confused`, a program powinien się zaczynać tak:\n"
"\n"
"__code0__\n"
"\n"
"(`sentence` może być dowolnym łańcuchem znaków, a obie wartości logiczne mogą być `True` lub `False`)\n"
"\n"
"Gdy `confused` ma wartość true, wydrukowane zdanie powinno mieć na końcu dodany znak zapytania.\n"
"Jeśli zarówno `confused`, jak i `excited` są prawdziwe, zdanie powinno się kończyć na `!?`."

msgid "pages.IntroducingIfStatements.steps.final_text.text"
msgstr ""
"Dobra robota! Ten program może robić 4 różne rzeczy w zależności od tego, jak połączysz `excited`\n"
"i `confused`. Wypróbuj je, jeśli chcesz."

msgid "pages.CombiningCompoundStatements.steps.for_inside_if.text"
msgstr ""
"Złożone instrukcje takie jak pętle `for` i instrukcje `if` mają ciała, które są listą\n"
"wewnętrznych instrukcji. Te wewnętrzne instrukcje mogą być czymkolwiek, w tym innymi złożonymi instrukcjami.\n"
"Wypróbuj ten przykład pętli `for` wewnątrz instrukcji `if`, kiedy chcesz pokazać,\n"
"że jesteś *naprawdę* podekscytowany:\n"
"\n"
"__program_indented__"

msgid "pages.CombiningCompoundStatements.steps.final_text.text"
msgstr ""
"Zauważ, jak ciało instrukcji `if` (4 linie) jest zazwyczaj wcięte, podczas gdy ciało\n"
"pętli `for` (1 linia) jest dodatkowo wcięte o 4 spacje w każdej linii, aby pokazać, że\n"
"te linie znajdują się w pętli `for`. Możesz zobaczyć ogólną strukturę programu\n"
"tylko poprzez spojrzenie na wcięcia.\n"
"\n"
"Alternatywnie, możesz umieścić instrukcję `if` wewnątrz pętli `for`:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Te dwa programy dają dokładnie ten sam rezultat. Jednak pierwszy jest bardziej wydajny, ponieważ\n"
"iteruje nad łańcuchem znaków tylko wtedy, kiedy jest to konieczne, ponieważ kiedy `excited = False` nic się nie zmienia."

msgid "pages.UnderstandingProgramsWithSnoop.steps.print_tail.text"
msgstr ""
"Uruchom ten program:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.UnderstandingProgramsWithSnoop.steps.print_tail_snoop.text"
msgstr ""
"Programy zaczynają być skomplikowane!\n"
"Nadszedł czas, aby przedstawić nowe narzędzie, które pomoże Ci zrozumieć programy. Kliknij przycisk `snoop`, aby uruchomić ten sam program, jednocześnie wyświetlając, co się dzieje."

msgid "pages.UnderstandingProgramsWithSnoop.steps.print_first_character.text"
msgstr ""
"Tada! Przewiń na górę konsoli i przeanalizujmy, co `snoop` pokazuje.\n"
"Zaczyna się bardzo prosto:\n"
"\n"
"        1 | sentence = 'Hello World'\n"
"        3 | include = False\n"
"        4 | new_sentence = ''\n"
"        5 | for char in sentence:\n"
"     ...... char = 'H'\n"
"\n"
"Pierwsze linie po prostu pokazują ci linie programu, które komputer wykonał.\n"
"Po lewej stronie jest numer linii, jak w edytorze.\n"
"\n"
"Uruchomienie `for char in sentence:` przypisuje wartość do zmiennej `char`, więc `snoop` pokazuje tę wartość.\n"
"Linie zaczynające się od `......` wskazują na nową zmienną lub zmianę wartości istniejącej zmiennej.\n"
"Takie linie nie będą pokazywane, kiedy są zbędne, dlatego wyjście `snoop` nie zaczyna się tak:\n"
"\n"
"        1 | sentence = 'Hello World'\n"
"     ...... sentence = 'Hello World'\n"
"        3 | include = False\n"
"     ...... include = False\n"
"        4 | new_sentence = ''\n"
"     ...... new_sentence = ''\n"
"        5 | for char in sentence:\n"
"     ...... char = 'H'\n"
"\n"
"Następne dwie linie to:\n"
"\n"
"        6 |     if include:\n"
"        8 |     include = True\n"
"\n"
"Co ważne, to czego nie widać: ponieważ `include` ma wartość `False`, linia 7 (`new_sentence += char`) zostaje pominięta. Ale potem `include` jest ustawione na `True`, więc następna iteracja pętli jest inna:\n"
"\n"
"        5 | for char in sentence:\n"
"     ...... char = 'e'\n"
"        6 |     if include:\n"
"        7 |         new_sentence += char\n"
"     .............. new_sentence = 'e'\n"
"\n"
"`new_sentence += char` uruchamia się po raz pierwszy i zmienna `new_sentence` otrzymuje nową wartość.\n"
"\n"
"Teraz zmodyfikuj program, aby zrobić odwrotnie: wydrukować tylko pierwszy znak, pomijając resztę."

msgid "pages.UnderstandingProgramsWithSnoop.steps.final_text.text"
msgstr "Świetna robota! Pracujesz z coraz bardziej złożonymi programami."

msgid "pages.IfAndElse.steps.first_if_else.text"
msgstr ""
"Instrukcja `if` może opcjonalnie mieć część `else`. Uruchom ten przykład:\n"
"\n"
"__program_indented__"

msgid "pages.IfAndElse.steps.first_if_else_false.text"
msgstr ""
"Teraz zmień pierwszą linię na `condition = False` i uruchom to ponownie."

msgid "pages.IfAndElse.steps.if_upper_else_lower.text"
msgstr ""
"Pomyśl o `else` jako o 'w przeciwnym razie'. Oznacza to, że jeśli warunek w `if`\n"
"jest fałszywy, wówczas ciało `else` zostanie wykonane. Bez względu na to, czy warunek jest prawdziwy, czy fałszywy,\n"
"dokładnie jedno z dwóch ciał zostanie uruchomione.\n"
"\n"
"Oto bardziej interesujący przykład do uruchomienia:\n"
"\n"
"__program_indented__"

msgid "pages.IfAndElse.steps.if_upper_else_lower_false.text"
msgstr ""
"`sentence.upper()` to nowy rodzaj wyrażenia, którego jeszcze nie napotkaliśmy. Chodzi o to, że `sentence` jest łańcuchem znaków, a łańcuchy znaków mają różne *metody*, które pozwalają na wygodne obliczanie z nich nowych wartości, w tym `upper` i `lower`. Nazwy odnoszą się do wielkich liter (liter kapitałowych) i małych liter (liter małych). `'Hello World'.upper()` zwraca `'HELLO WORLD'`. To jednak nie zmienia zawartości `sentence`, więc musisz przypisać nową wartość ponownie za pomocą `sentence = sentence.upper()`.\n"
"\n"
"Teraz zmień `excited` na `False` i uruchom to ponownie."

msgid "pages.IfAndElse.steps.undefined_char.text"
msgstr ""
"Oto zepsuty program:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Dostrzegasz problem? Jeśli go uruchomisz, wszystko wydaje się być w porządku. Co mogłoby pójść nie tak?\n"
"\n"
"Spoilery poniżej! Czy udało ci się to rozgryźć?\n"
"\n"
"Co się stanie, jeśli zmienisz `excited` na `False`?"

msgid "pages.IfAndElse.steps.else_full_stop.text"
msgstr ""
"Jeśli `excited` jest prawdziwe, wówczas `char` jest zdefiniowane i wszystko działa poprawnie. Ale w przeciwnym razie\n"
"`char` nigdy nie zostaje przypisane żadnej wartości, więc próba użycia go w `sentence += char` zawodzi.\n"
"\n"
"Napraw to, dodając klauzulę `else` do `if`, tak aby jeśli `excited` jest fałszywe, do końca zdania dodawany jest kropka (`.`)\n"
"zamiast wykrzyknika (`!`)."

msgid "pages.IfAndElse.steps.capitalise.text"
msgstr ""
"Czas na wyzwanie!\n"
"\n"
"Napisz program, który dla danego łańcucha znaków `sentence`, wydrukuje zmodyfikowaną wersję\n"
"z tymi samymi literami, gdzie pierwsza litera jest wielka, a reszta małymi literami.\n"
"Na przykład, wynik powinien być `Hello world`, niezależnie od tego, czy wejściowy `sentence = 'hello world'`\n"
"czy `'HELLO WORLD'`."

msgid "pages.IfAndElse.steps.spongebob.text"
msgstr ""
"Doskonale!!!\n"
"\n"
"Jeszcze jedno ćwiczenie, a potem możesz odpocząć.\n"
"\n"
"Napisz program, który wydrukuje `sentence` w drwiący sposób, np:\n"
"\n"
"    OnE MoRe eXeRcIsE, aNd tHeN YoU CaN ReLaX.\n"
"\n"
"Każda druga litera powinna być mała, a reszta wielkie."

msgid "pages.IfAndElse.steps.final_text.text"
msgstr ""
"Doskonale! Poświęć chwilę, aby być dumny z tego, co osiągnąłeś. Czy czujesz,"
" jak rośnie twój mózg?"

msgid "pages.TheEqualityOperator.steps.introducing_equality.text"
msgstr ""
"Istnieje wiele sposobów uzyskiwania wartości logicznych bez ich bezpośredniego przypisywania,\n"
"co pozwala konstruować bardzo użyteczne instrukcje `if`. W szczególności istnieje wiele *operatorów porównania*,\n"
"które porównują wartości dwóch wyrażeń.\n"
"Najbardziej powszechnym jest operator równości, który sprawdza czy dwie wartości są równe.\n"
"Oznaczany jest dwoma znakami równości: `==`. Spróbuj uruchomić to:\n"
"\n"
"__program_indented__"

msgid "pages.TheEqualityOperator.steps.equality_vs_assignment.text"
msgstr ""
"Jak widzisz, jeśli wartości są równe, wyrażenie równości zostaje ocenione jako `True`,\n"
"w przeciwnym razie jako `False`.\n"
"\n"
"Zwróć uwagę na różnicę między operatorem równości `==` a pojedynczym `=` który ma inne znaczenie,\n"
"szczególnie w instrukcjach przypisania, jakie do tej pory widziałeś. Co się stanie, jeśli spróbujesz\n"
"usunąć pojedynczy `=` z poprzedniego programu?"

msgid "pages.TheEqualityOperator.steps.if_equals_replacing_characters.text"
msgstr ""
"Użyjmy `==` w instrukcji `if`. W tym programie ciało `if` zostanie wykonane tylko wtedy, gdy `c` to znak `'s'`. Przekonaj się sam.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.TheEqualityOperator.steps.if_equals_replacing_characters_exercise.text"
msgstr ""
"Teraz rozszerz program, aby również zamieniał literę `e` na `3` oraz `a` na "
"`@`."

msgid "pages.TheEqualityOperator.steps.final_text.text"
msgstr "Dobra robota!"

msgid "pages.IntroducingElif.steps.dna_example.text"
msgstr ""
"Krótka lekcja biologii! Większość komórek w twoim ciele zawiera pełny kod genetyczny w postaci DNA.\n"
"Składa się on z nici złożonych z jednostek molekularnych zwanych nukleobazami, które występują w czterech odmianach:\n"
"Adenina, Cytosyna, Guanina i Tymina, krótko ACGT.\n"
"Część pojedynczej nici może wyglądać na przykład tak:\n"
"\n"
"    AGTAGCGTCCTTAGTTACAGGATGGCTTAT...\n"
"\n"
"Nici ta będzie sparowana z inną nicią, w której A jest zastąpione przez T i odwrotnie,\n"
"oraz C jest zastąpione przez G i odwrotnie, np:\n"
"\n"
"    TCATCGCAGGAATCAATGTCCTACCGAATA...\n"
"\n"
"Obie nici są \"zapięte\" razem w słynną strukturę podwójnej helisy,\n"
"połączone przez pasujące do siebie pary A-T i C-G. Te parowania są niezbędne przy kopiowaniu DNA,\n"
"gdy komórki się dzielą i rozmnażają. Podwójna helisa jest rozpinana, a kod jest transkrybowany\n"
"na swoją przeciwną wersję, aby dokonać kopii.\n"
"\n"
"Powtórzymy ten proces. Spróbujmy napisać podobny program, jak ten, który właśnie napisaliśmy:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingElif.steps.dna_example_with_else.text"
msgstr ""
"Ojej, to nie do końca działa. `T` jest zmieniane na `A`, ale `A` nie jest zmieniane na nic.\n"
"Czy widzisz, dlaczego?\n"
"\n"
"Kiedy `char == 'A'`, to wówczas ciało `char = 'T'` rzeczywiście się wykonuje. Ale to oznacza, że kolejny\n"
"warunek `char == 'T'` również jest spełniony i wtedy `char = 'A'` i wracamy do punktu wyjścia.\n"
"Musimy zmieniać `char` z `T` na `A` tylko jeśli `char` początkowo nie było `A`. Oznacza to, że `char == 'A'` było `False`. Możemy to osiągnąć za pomocą `else`, tak jak tutaj:\n"
"\n"
"__code0__\n"
"\n"
"Teraz napraw program, aby poprawnie zamieniał wszystkie znaki."

msgid "pages.IntroducingElif.steps.dna_example_with_elif.text"
msgstr ""
"Fantastycznie! Udało ci się naśladować to, co twoje własne komórki ciągle wykonują.\n"
"\n"
"`If` umieszczony wewnątrz `else` można zastąpić pojedynczym słowem kluczowym `elif`. Na przykład,\n"
"poprzedni kod można zmienić na to:\n"
"\n"
"__code0__"

msgid "pages.IntroducingElif.steps.final_text.text"
msgstr ""
"Często spotyka się łańcuch klauzul `elif`, gdy chcemy, aby jedno z wielu ciał zostało wykonane, tak jak w tym przypadku. Ogólnie rzecz biorąc, kod tego typu:\n"
"\n"
"__code0__\n"
"\n"
"może być przepisany jako:\n"
"\n"
"__code1__\n"
"\n"
"co jest krótsze i oszczędza problem z nieprzyjemnym zagnieżdżonym wcięciem.\n"
"Różnica jest tylko kosmetyczna: gdy komputer wykonuje ten kod, nie może\n"
"rozróżnić między tymi dwiema wersjami.\n"
"\n"
"Należy zauważyć, że `elif` może opcjonalnie być poprzedzony jednym finalnym `else`. Nie włączyliśmy go\n"
"w naszym przykładzie DNA, ale moglibyśmy dodać, aby ostrzec nas o jakichkolwiek niespodziewanych znakach\n"
"w danych wejściowych, lub zmienić `elif char == 'C':` na `else:`, jeśli bylibyśmy pewni\n"
"że dane wejściowe są prawidłowe."

msgid "pages.OtherComparisonOperators.steps.try_not_equals.text"
msgstr ""
"Przeciwieństwem operatora równości `==` jest operator *nierówności* `!=`. "
"Jeśli się przyjrzeć, to trochę przypomina ≠. Zwraca `True`, gdy dwie "
"wartości są... nierówne. Wypróbuj `__program__` samodzielnie w konsoli."

msgid "pages.OtherComparisonOperators.steps.brokn_kyboard.text"
msgstr ""
"Oto sympatyczny mały program używający `!=`:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.OtherComparisonOperators.steps.introducing_less_than.text"
msgstr ""
"Inne przydatne operatory to `<` (mniejsze niż) i `>` (większe niż). Na "
"przykład `a < b` oznacza \"`a` jest mniejsze od `b`\". Spróbuj użyć jednego "
"z tych operatorów w konsoli, aby porównać dwie liczby."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.text"
msgstr ""
"Możesz również użyć tych operatorów do porównania łańcuchów znaków. Jeśli "
"uszeregujesz dwa łańcuchy znaków w porządku alfabetycznym, pierwszy jest "
"'mniejszy' od drugiego. Przekonaj się sam."

msgid "pages.OtherComparisonOperators.steps.grades_example.text"
msgstr ""
"Oto praktyczny przykład zastosowania `<` do wypróbowania:\n"
"\n"
"__program_indented__\n"
"\n"
"Przypomnijmy, że `elif percentage < 60` po `if percentage < 40` oznacza \"jeśli procent nie był mniejszy niż 40 i równocześnie jest mniejszy niż 60\", więc przejdzie dla wszystkich liczb od 40 do 59 włącznie. Podobnie ocena 'B' jest przyznawana dla procentów od 60 do 79, a 'A' dla każdej liczby 80 i wyższej."

msgid "pages.OtherComparisonOperators.steps.min_three_exercise.text"
msgstr ""
"Teraz czas na ćwiczenie: napisz program, który przyjmuje trzy zmienne `x1`, `x2` i `x3`, i wypisuje wartość najmniejszej z nich. Więc dla:\n"
"\n"
"__code0__\n"
"\n"
"powinien wydrukować `10`."

msgid "pages.OtherComparisonOperators.steps.final_text.text"
msgstr ""
"Cudownie!\n"
"\n"
"Istnieje wiele sposobów, aby rozwiązać to zadanie. Oto jedno z rozwiązań:\n"
"\n"
"__code0__\n"
"\n"
"A oto inne:\n"
"\n"
"__code1__\n"
"\n"
"Te programy (również Twój) działają równie dobrze zarówno z liczbami, jak i łańcuchami znaków. Więc dla:\n"
"\n"
"__code2__\n"
"\n"
"wydrukują `Alice`, ponieważ to jest pierwszy łańcuch znaków w porządku alfabetycznym.\n"
"\n"
"`<` i `>` zwracają wartość False, jeśli porównywane wartości są równe. Na przykład,\n"
"3 nie jest mniejsze niż 3, więc `3 < 3` oraz `3 > 3` są obie False.\n"
"Aby uwzględnić równe wartości, użyj `<=` i `>=`.\n"
"Znowu, jeśli się przyjrzeć, wyglądają one trochę jak ≤ i ≥.\n"
"Zwróć uwagę, że `=` występuje na drugim miejscu – nie istnieją takie operatory jak `=<` czy `=>`.\n"
"Aby to zapamiętać, czytaj je na głos jako \"mniejsze lub równe\"\n"
"i \"większe lub równe\".\n"
"\n"
"Podsumowując, główne operatory porównania to `==`, `!=`, `<`, `>`, `<=` i `>=`.\n"
"Jeśli kiedykolwiek masz wątpliwości, co do ich działania, pobaw się nimi w konsoli!"

msgid "pages.IntroducingLists.steps.first_list.text"
msgstr ""
"Nadeszła pora, aby dowiedzieć się o potężnym nowym rodzaju wartości, zwanym *listami*. Oto przykład:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingLists.steps.can_contain_anything.text"
msgstr ""
"Lista jest *sekwencją* (uporządkowaną kolekcją/kontenerem) dowolnej liczby wartości.\n"
"Wartości te często określane są jako *elementy*.\n"
"Mogą być czymkolwiek: liczbami, łańcuchami znaków, wartościami logicznymi, a nawet listami! Mogą również być mieszaniną typów.\n"
"\n"
"Aby bezpośrednio utworzyć listę, jak powyżej:\n"
"\n"
"1. Napisz nawiasy kwadratowe: `[]`\n"
"2. Jeśli nie chcesz pustej listy, wpisz w środku pewne wyrażenia, które będą elementami.\n"
"3. Użyj przecinków (`,`), aby oddzielić elementy.\n"
"\n"
"Oto kolejny przykład tworzenia listy:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingLists.steps.numbers_sum.text"
msgstr ""
"Jak widziałeś powyżej, listy są *iterowalne*, co oznacza, że możesz iterować po nich używając `pętli for`.\n"
"Oto program, który sumuje wszystkie liczby na liście:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingLists.steps.strings_sum.text"
msgstr ""
"Teraz zmodyfikuj program, aby mógł on sumować listę łańcuchów znaków zamiast liczb.\n"
"Na przykład, mając:\n"
"\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"\n"
"powinien on wypisać:\n"
"\n"
"    __no_auto_translate__\n"
"    Thisisalist"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.text"
msgstr ""
"Fantastycznie!\n"
"\n"
"Jeśli chcesz, możesz już teraz przejść do [następnej strony](#BuildingNewLists).\n"
"\n"
"Dla chętnych na dodatkowe wyzwanie: rozszerz program tak, aby wprowadzić ciąg separatorów *pomiędzy* każdym słowem.\n"
"Na przykład, mając:\n"
"\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"    separator = ' - '\n"
"\n"
"to powinno wyświetlić:\n"
"\n"
"    __no_auto_translate__\n"
"    This - is - a - list"

msgid "pages.IntroducingLists.steps.final_text.text"
msgstr ""
"Gratulacje! To było naprawdę trudne! Jedno z rozwiązań wygląda tak:\n"
"\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"    separator = ' - '\n"
"    total = ''\n"
"    not_first = False\n"
"\n"
"    for word in words:\n"
"        if not_first:\n"
"            total += separator\n"
"        total += word\n"
"        not_first = True\n"
"\n"
"    print(total)"

msgid "pages.BuildingNewLists.steps.double_numbers.text"
msgstr ""
"Listy i łańcuchy znaków mają wiele wspólnego.\n"
"Na przykład, możesz dodać dwie listy, aby połączyć je razem w nową listę.\n"
"Możesz także stworzyć pustą listę, która nie ma żadnych elementów.\n"
"Sprawdź to sam:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Mając tę wiedzę, napisz program, który bierze listę liczb\n"
"i wypisuje listę, na której każda liczba została podwojona. Na przykład, mając:\n"
"\n"
"__code1__\n"
"\n"
"to powinno wydrukować:\n"
"\n"
"__code2__"

msgid "pages.BuildingNewLists.steps.filter_numbers.text"
msgstr ""
"Świetnie!\n"
"\n"
"Gdy chcesz dodać pojedynczy element na koniec listy, zamiast:\n"
"\n"
"__code0__\n"
"\n"
"częściej używa się:\n"
"\n"
"__code1__\n"
"\n"
"Nie ma między nimi dużych różnic, ale `.append`\n"
"będzie bardziej zrozumiałe i czytelne dla większości ludzi.\n"
"\n"
"Teraz użyj `.append`, aby napisać program, który bierze listę liczb i\n"
"wypisuje nową listę zawierającą tylko te liczby, które są większe niż 5.\n"
"\n"
"Na przykład, mając:\n"
"\n"
"__code2__\n"
"\n"
"to powinno wydrukować:\n"
"\n"
"__code3__"

msgid "pages.BuildingNewLists.steps.final_text.text"
msgstr "Fantastycznie! Robimy świetne postępy."

msgid "pages.UsingBreak.steps.list_contains_exercise.text"
msgstr ""
"Ćwiczenie: napisz program, który bierze listę i wartość i sprawdza,\n"
"czy lista zawiera tę wartość. Na przykład, mając:\n"
"\n"
"    __no_auto_translate__\n"
"    things = ['This', 'is', 'a', 'list']\n"
"    thing_to_find = 'is'\n"
"\n"
"powinien wydrukować `True`, ale dla\n"
"\n"
"    __no_auto_translate__\n"
"    thing_to_find = 'other'\n"
"\n"
"powinien wydrukować `False`."

msgid "pages.UsingBreak.steps.final_text.text"
msgstr ""
"Miło słyszeć!\n"
"\n"
"Typowe rozwiązanie wygląda mniej więcej tak:\n"
"\n"
"__code0__\n"
"\n"
"Twoje rozwiązanie jest prawdopodobnie podobne. Jest w porządku, ale troszeczkę nieefektywne.\n"
"Dzieje się tak, ponieważ pętla będzie przeszukiwać całą listę, nawet jeśli znajdzie element na początku.\n"
"Możesz przerwać dowolną pętlę używając instrukcji `break`, tak jak tutaj:\n"
"\n"
"__code1__\n"
"\n"
"To rozwiązanie jest równie poprawne, ale omija zbędne iteracje i sprawdzenia, kiedy już znajdzie element.\n"
"Możesz użyć `snoop`, aby zobaczyć różnicę."

msgid "pages.GettingElementsAtPosition.steps.introducing_subscripting.text"
msgstr ""
"Pętle są świetne, ale często chcesz po prostu pobrać pojedynczy element z listy znanego położenia.\n"
"Oto jak to zrobić:\n"
"\n"
"__program_indented__"

msgid "pages.GettingElementsAtPosition.steps.index_error.text"
msgstr ""
"Ogólnie rzecz biorąc, możesz uzyskać element na pozycji `i` za pomocą `words[i]`. Operacja ta nazywana jest *indeksowaniem* i pozycja, na której się znajduje, to *indeks*.\n"
"\n"
"Prawdopodobnie zauważyłeś, że pierwszy indeks to 0, a nie 1. W programowaniu liczenie zaczyna się od 0. Wydaje się to dziwne, ale tak właśnie robi większość języków programowania i ogólnie uważa się to za lepsze rozwiązanie.\n"
"\n"
"Oznacza to również, że ostatni indeks na tej liście czterech elementów to 3. Co się stanie, jeśli spróbujesz uzyskać indeks większy niż ten?"

msgid "pages.GettingElementsAtPosition.steps.introducing_len_and_range.text"
msgstr ""
"Dokładnie tak. `words[4]` i dalsze nie istnieją, więc próba ich użycia skończy się błędem.\n"
"Ten pierwszy program jest nieco powtarzalny. Ulepszymy go, używając listy i pętli!\n"
"\n"
"__program_indented__"

msgid "pages.GettingElementsAtPosition.steps.range_len.text"
msgstr ""
"To już lepiej, ale wypisywanie \"[0, 1, 2, ...]\" nie jest najlepszym rozwiązaniem, szczególnie gdy lista staje się długa.\n"
"Istnieje przydatna funkcja `range`, która wykonuje tę czynność za ciebie. Zamień \"[0, 1, 2, 3]\" na `range(4)`,\n"
"czyli `indices = range(4)`."

msgid "pages.GettingElementsAtPosition.steps.final_text.text"
msgstr ""
"Jeśli nadal nie czujesz się do końca komfortowo z `range` lub `len`, poćwicz i eksperymentuj z nimi przez chwilę.\n"
"Oto kilka prostych ćwiczeń, które możesz wypróbować samodzielnie, jeśli chcesz.\n"
"\n"
"- Wydrukuj liczby od `1` do `100` włącznie.\n"
"- Wydrukuj swoje imię 100 razy.\n"
"- Wydrukuj każde słowo z listy `words` prócz ostatniego.\n"
"- Wydrukuj każde słowo z `words` w odwrotnej kolejności, tzn. wydrukuj ostatnie słowo, potem przedostatnie słowo itd.\n"
"- Powróć do dodatkowego zadania na końcu strony [Wprowadzenie do List](#IntroducingLists),\n"
"niezależnie od tego, czy udało ci się je zakończyć. Teraz jest to dużo łatwiejsze z `range` i `len`!\n"
"\n"
"Kiedy będziesz gotowy, kontynuuj na następnej stronie dla czegoś nieco bardziej wymagającego."

msgid "pages.CallingFunctionsTerminology.steps.print_functions.text"
msgstr ""
"Nadszedł czas, aby jeszcze bardziej poszerzyć Twoje słownictwo.\n"
"\n"
"`print` i `len` to ***funkcje***. Przekonaj się sam:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.introducing_callable.text"
msgstr ""
"Wyrażenie takie jak `len(things)` czy `print(things)` to ***wywołanie*** funkcji - kiedy to piszesz, ***wywołujesz*** funkcję `len` lub `print`. Fakt, że jest to możliwe, oznacza, że funkcje są ***wywoływalne***:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.not_callable.text"
msgstr ""
"Większość rzeczy nie jest wywoływalna, więc próba wywołania ich skończy się błędem:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.print_returns_none.text"
msgstr ""
"W wywołaniu `len(things)`, `things` jest ***argumentem***. Czasami możesz także spotkać słowo ***parametr***, które oznacza mniej więcej to samo co argument. To trochę jakbyś podawał argument funkcji - konkretnie mówimy, że argument `things` jest *przekazywany* do `len`, a `len` *akceptuje* lub *odbiera* argument.\n"
"\n"
"`len(things)` zostanie obliczone do liczby, takiej jak 3, w tym przypadku mówimy, że `len` ***zwróciła*** 3.\n"
"\n"
"Wszystkie wywołania muszą coś zwrócić... nawet jeśli jest to nic. Na przykład zadaniem `print` jest wyświetlenie czegoś na ekranie, a nie zwrócenie użytecznej wartości. Dlatego zamiast tego zwraca coś bezużytecznego:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.len_of_none.text"
msgstr ""
"`None` to specjalna wartość 'null', która nie posiada żadnych interesujących właściwości. Jest to powszechny symbol zastępczy, który reprezentuje brak prawdziwej, użytecznej wartości. Funkcje, które nie chcą niczego zwracać, domyślnie zwracają `None`. Jeśli zobaczysz komunikat o błędzie dotyczący `None` lub `NoneType`, często oznacza to, że przypisałeś złą rzecz do zmiennej:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.methods_of_str.text"
msgstr ""
"***Metoda*** to funkcja, która należy do jakiegoś typu i może być wywołana na wszystkich wartościach danego typu przy użyciu `.`. Na przykład, `upper` i `lower` są metodami łańcuchów znaków, które wywołuje się używając na przykład `word.upper()`:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.no_append_for_str.text"
msgstr ""
"Innym przykładem jest to, że `append` jest metodą list. Ale nie możesz użyć `.upper` na liście ani `.append` na łańcuchu znaków:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsTerminology.steps.final_text.text"
msgstr ""
"Słowo 'atrybut' w komunikacie o błędzie odnosi się do użycia `.` - błąd "
"pojawia się właściwie już przy `word.append`, nawet bez wywołania metody."

msgid "pages.FunctionsAndMethodsForLists.steps.append_vs_concatenate.text"
msgstr ""
"Przyjrzyjmy się, jak pracować z listami. Załóżmy, że mamy listę `nums = [1, 2, 3]`. Możesz użyć:\n"
"\n"
"- **`append`**: Dodaje element na końcu listy. `nums.append(4)` zmienia listę na `[1, 2, 3, 4]`.\n"
"- **`len`**: Zwraca liczbę elementów. `len(nums)` wynosi `3`.\n"
"- **`range`**: `range(n)` to obiekt podobny do listy numerów od `0` do `n - 1`. Oznacza to, że zawiera `n` liczb. W szczególności, `range(len(nums))` jest jak `[0, 1, 2]`, które są indeksami każdego elementu w `nums`.\n"
"- **`[]` (subskrypcja/indeksowanie)**: Pobiera wartość przy danym indeksie. `nums[0]` to `1`, `nums[1]` to `2`, `nums[2]` to `3`.\n"
"- **`+`**: Łączy listy. `nums + [4, 5]` to `[1, 2, 3, 4, 5]`.\n"
"\n"
"Zauważ, że `nums.append(4)` modyfikuje istniejącą listę `nums`, podczas gdy `nums + [4, 5]` tego nie robi.\n"
"Jednym ze sposobów na zachowanie wartości `nums + [4, 5]` jest przypisanie jej do *nowej zmiennej*.\n"
"Uruchom następujący kod:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_predict.text"
msgstr ""
"Jak widzisz, `+` nie modyfikuje `nums`, ale `append` tak.\n"
"\n"
"Oto kilka nowych rzeczy.\n"
"\n"
"**`przypisanie subskrypcji`**: Ustawia wartość przy danym indeksie (zastępując wartość, która była tam wcześniej) używając składni\n"
"\n"
"__code0__\n"
"\n"
"Zgłasza błąd, jeśli `index` nie jest poprawnym indeksem `some_list`. Na przykład uruchom ten program:\n"
"\n"
"__program_indented__"

msgid "pages.FunctionsAndMethodsForLists.steps.index_predict_exercise.text"
msgstr ""
"**`index`**: Zwraca pierwszy indeks wartości na liście, używając składni\n"
"\n"
"__code0__\n"
"\n"
"Zgłasza błąd, jeśli wartości nie ma na liście. Na przykład uruchom tę linię w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.FunctionsAndMethodsForLists.steps.pop_predict_exercise.text"
msgstr ""
"**`pop`**: Usuwa i zwraca element o danym *indeksie* używając składni\n"
"\n"
"__code0__\n"
"\n"
"Bez argumentu, tj. po prostu `some_list.pop()`, zostanie usunięty i zwrócony ostatni element.\n"
"Zgłasza błąd, jeśli `index` nie jest poprawnym indeksem `some_list`. Na przykład uruchom ten program:\n"
"\n"
"__program_indented__"

msgid "pages.FunctionsAndMethodsForLists.steps.remove_predict_exercise.text"
msgstr ""
"**`remove`**: Usuwa pierwsze wystąpienie danego *wartości* używając składnii\n"
"\n"
"__code0__\n"
"\n"
"Zgłasza błąd, jeśli wartości nie ma na liście. Na przykład uruchom ten program:\n"
"\n"
"__program_indented__"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.text"
msgstr ""
"Teraz rozwiążesz cztery krótkie ćwiczenia dotyczące tych pojęć.\n"
"Poniżej znajduje się lista poprawnych i błędnych linii kodu wymieszanych razem.\n"
"Każde nadchodzące ćwiczenie ma rozwiązanie, które zawiera dokładnie jedną z poniższych linii,\n"
"i musisz znaleźć poprawną linię z tej listy.\n"
"\n"
"__code0__\n"
"\n"
"Oto niekompletny program:\n"
"\n"
"    __copyable__\n"
"__code1__\n"
"\n"
"Zamień środkową linię jedną linią z listy powyżej. Końcowy program powinien zmodyfikować `x`, przenosząc pierwszy element na koniec, tak aby wydrukował `['b', 'c', 'a']`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.text"
msgstr ""
"Dobra robota. W następnym ćwiczeniu zacznij od tego samego niekompletnego programu:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Wybierz linię kodu z listy, która nadpisze ostatni element `x` pierwszym elementem,\n"
"tak aby teraz wydrukowało `['a', 'b', 'a']`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.text"
msgstr ""
"Świetnie!\n"
"\n"
"Możesz zauważyć, że praca z ostatnim elementem za pomocą `x[len(x) - 1]` jest nieco uciążliwa.\n"
"To samo można osiągnąć za pomocą `x[-1]`.\n"
"Podobnie, przedostatni element `x[len(x) - 2]` można zapisać jako `x[-2]` i tak dalej.\n"
"Python pozwala nam także liczyć indeksy wstecz, zaczynając od ostatniego elementu jako `-1`:\n"
"\n"
"| Indeks     | Pierwszy el. | Drugi el. | Trzeci el.  | ... | Przedostatni el. | Ostatni el.  |\n"
"|------------|---------------|------------|-------------|-----|-----------------|--------------|\n"
"| Do przodu  | `0`          | `1`        | `2`         | ... | `len(x) - 2`    | `len(x) - 1` |\n"
"| Do tyłu    | `-len(x)`    |`-len(x) + 1`|`-len(x) + 2`| ... | `-2`            | `-1`         |\n"
"\n"
"Następne ćwiczenie:\n"
"\n"
"Tym razem, zamiast modyfikować listę `x`, utworzysz nową listę `y`:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"`y` powinna być taka sama jak `x`, ale powinna także zawierać powtórzony na końcu pierwszy element.\n"
"Dlatego program wydrukuje `['a', 'b', 'c', 'a']`."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.text"
msgstr ""
"Dobra robota. Teraz ostatnie ćwiczenie:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Zastąp środkową linię `x.remove(0)` linią z listy, która robi to samo."

msgid "pages.FunctionsAndMethodsForLists.steps.final_text.text"
msgstr "Dziękuję!"

msgid "pages.MoreListFunctionsAndMethods.steps.sorted_predict_exercise.text"
msgstr ""
"Oto kilka przydatnych funkcji/metod.\n"
"\n"
"**`sorted`**: Przyjmuje obiekt iterowalny i zwraca listę elementów posortowanych od najmniejszego do największego, używając składni\n"
"\n"
"__code0__\n"
"\n"
"Na przykład uruchom tę linię w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.MoreListFunctionsAndMethods.steps.in_predict_exercise.text"
msgstr ""
"**`in`**: Operator porównania, który sprawdza, czy wartość znajduje się na liście, używając składni\n"
"\n"
"__code0__\n"
"\n"
"Na przykład uruchom ten program:\n"
"\n"
"__program_indented__"

msgid "pages.MoreListFunctionsAndMethods.steps.sum_predict_exercise.text"
msgstr ""
"**`sum`**: Sumuje elementy obiektu iterowalnego zawierającego liczby, używając składni\n"
"\n"
"__code0__\n"
"\n"
"Na przykład uruchom tę linię w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.MoreListFunctionsAndMethods.steps.count_predict_exercise.text"
msgstr ""
"**`count`**: Zwraca liczbę wystąpień podanego argumentu na liście używając składni\n"
"\n"
"__code0__\n"
"\n"
"Na przykład uruchom tę linię w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.text"
msgstr ""
"Możliwe, że rozpoznałeś niektóre z tych elementów z Twoich ćwiczeń. Zapewniam Cię, że te ćwiczenia nie były bezcelowe,\n"
"ponieważ teraz nauczyłeś się cennych podstawowych umiejętności. Na przykład, możesz użyć `in`, żeby sprawdzić, czy lista zawiera 5,\n"
"ale nie ma równie łatwego sposobu, żeby sprawdzić, czy zawiera liczbę większą niż 5.\n"
"\n"
"Teraz rozwiążesz kolejny zestaw czterech ćwiczeń zawierających te nowe pojęcia.\n"
"Ponownie, prawidłowe i nieprawidłowe linie kodu są ze sobą wymieszane,\n"
"i musisz wybrać z listy tę prawidłową linię.\n"
"\n"
"__code0__\n"
"\n"
"Oto program:\n"
"\n"
"    __copyable__\n"
"__code1__\n"
"\n"
"Zastąp część `1 in x` (zostaw `y = `) jedną linią z powyższej listy, która robi to samo."

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.text"
msgstr ""
"Świetna robota! W następnym ćwiczeniu zacznij od tego niekompletnego programu:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Zastąp część po `y = ` jedną linią z powyższej listy.\n"
"Finalny program powinien wydrukować średnią (technicznie rzecz biorąc *średnią arytmetyczną*) liczb w `x`."

msgid "pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.text"
msgstr ""
"Dobra robota! W następnym ćwiczeniu zacznij od tego niekompletnego programu:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Zastąp część po `y = ` jedną linią z powyższej listy.\n"
"Finalny program powinien wydrukować wynik sumowania wszystkich liczb od `1` do `x` włącznie, czyli `1 + 2 + 3 + ... + x`."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.text"
msgstr ""
"Doskonale. I ostatnie:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Zastąp część po `y = ` jedną linią z powyższej listy.\n"
"Finalny program powinien wydrukować *drugą najmniejszą wartość* w `x`."

msgid "pages.MoreListFunctionsAndMethods.steps.final_text.text"
msgstr "Gratulacje! Jesteś teraz mistrzem metod i funkcji list!"

msgid "pages.StringMethodsUnderstandingMutation.steps.string_in_step.text"
msgstr ""
"Już widziałeś, że `len` i indeksowanie działają na łańcuchach znaków, trochę jakby łańcuchy znaków były listami znaków.\n"
"Łańcuchy znaków obsługują również niektóre z nowo poznanych metod, nie tylko dla pojedynczych znaków, ale dla dowolnych podłańcuchów.\n"
"Na przykład wypróbuj to:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.StringMethodsUnderstandingMutation.steps.string_count_index.text"
msgstr ""
"`in` działa na łańcuchach znaków tak jak na listach! Komenda zwróciła `True`, ponieważ `the` występuje w `feed the dog and the cat` jako *podłańcuch*.\n"
"A co z `count` i `index`?\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.StringMethodsUnderstandingMutation.steps.mutation_string_append.text"
msgstr ""
"Te dwie metody również działają na łańcuchach znaków podobnie do tego, jak działają na listach.\n"
"`index` zwraca *indeks początkowy* szukanego słowa `'the'` w dłuższym łańcuchu `'feed the dog and the cat'`, którym jest `5`.\n"
"\n"
"|  0   |  1   |  2   |  3   |  4   | **5** |  6   |  7   |  8   | ...  |\n"
"| :--: | :--: | :--: | :--: | :--: | :---: | :--: | :--: | :--: | :--: |\n"
"|  f   |  e   |  e   |  d   |      | **t** |  h   |  e   |      | ...  |\n"
"\n"
"Zauważ, że w większości przypadków metody, które *modyfikują listę w miejscu* (`append`, `insert`, `remove`), po prostu zwracają `None`,\n"
"podczas gdy pozostałe funkcje/metody zwracają nową przydatną wartość bez zmiany oryginalnego argumentu.\n"
"Jedynym wyjątkiem jest metoda `pop`.\n"
"\n"
"Modyfikowanie wartości bezpośrednio nazywane jest *mutacją* - typy wartości, które mogą być mutowane, są *mutowalne*,\n"
"podczas gdy te, które nie mogą, są *niemutowalne*. Listy są mutowalne.\n"
"Łańcuchy znaków są niemutowalne - nie mają żadnych metod takich jak `append` czy nawet przypisania dla indeksów.\n"
"Zobacz sam:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.StringMethodsUnderstandingMutation.steps.string_lower_upper.text"
msgstr ""
"Po prostu nie możesz zmienić łańcucha znaków - możesz jedynie stworzyć nowe łańcuchy i użyć ich zamiast starych.\n"
"To oznacza, że poniższe stwierdzenie jest samo w sobie bezużyteczne:\n"
"\n"
"__code0__\n"
"\n"
"Łańcuch znaków, do którego odwołuje się `word`, nie jest modyfikowany, zamiast tego `word.lower()` zwrócił nowy łańcuch, który natychmiast został odrzucony.\n"
"Jeśli chcesz zmienić wartość, do której odwołuje się `word`, musisz przypisać nową wartość do zmiennej:\n"
"\n"
"    __copyable__\n"
"__code1__"

msgid "pages.StringMethodsUnderstandingMutation.steps.final_text.text"
msgstr ""
"Zauważ, że `sentence.upper()` nie zmienia oryginalnego `sentence`.\n"
"\n"
"Możesz również natychmiast użyć `word.lower()` w większym wyrażeniu, np.\n"
"\n"
"__code0__"

msgid "pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.text"
msgstr "max([21, 55, 4, 91, 62, 49])"

msgid "pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.text"
msgstr "nums.insert(2, 9)"

msgid "pages.HowToFindInformationWithGoogleAndMore.steps.dir_list.text"
msgstr "help(list)"

msgid "pages.HowToFindInformationWithGoogleAndMore.steps.final_text.text"
msgstr ""
"dir() zwraca listę atrybutów argumentu, które w większości są metodami. "
"Wiele z nich będzie zaczynać się od `__`, które na razie możesz zignorować -"
" przewiń do końca listy, a zobaczysz kilka znajomych metod."

msgid ""
"pages.UnderstandingProgramsWithPythonTutor.steps.run_with_python_tutor.text"
msgstr ""
"Czas poznać kolejne narzędzie do eksploracji programów.\n"
"Skopiuj poniższy kod do edytora, a następnie kliknij nowy przycisk \"Python Tutor\".\n"
"Przycisk otworzy nową zakładkę z wizualizacją z [pythontutor.com](http://pythontutor.com).\n"
"Tam możesz przechodzić przez program krok po kroku za pomocą przycisków \"Prev\" i \"Next\", lub przeciągając\n"
"suwak w lewo lub w prawo. Możesz również zobaczyć wartości zmiennych po prawej stronie.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.UnderstandingProgramsWithPythonTutor.steps.final_text.text"
msgstr ""
"Zwróć uwagę, że kod zostaje wykonany dwa razy oddzielnie: raz tutaj, raz na stronie pythontutor.com.\n"
"W zależności od twojego programu, oba wykonywania mogą dać różne wyniki."

msgid "pages.EqualsVsIs.steps.two_separate_lists.text"
msgstr ""
"Czas poznać kilka technicznych szczegółów, które często są źle rozumiane i prowadzą do błędów.\n"
"Uruchom ten program:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.EqualsVsIs.steps.same_list.text"
msgstr ""
"Ten program jest dość prosty i składa się głównie z rzeczy, które już znasz.\n"
"Tworzymy dwie zmienne, które odnoszą się do list.\n"
"Listy mają takie same elementy, więc są równe: `list1 == list2` jest `True`.\n"
"\n"
"Ale potem pojawia się nowy operator porównania: `is`. Tutaj `list1 is list2` jest `False`.\n"
"Oznacza to, że niezależnie od tego, że dwie listy są równe,\n"
"są nadal dwiema odrębnymi, różnymi, indywidualnymi listami.\n"
"W rezultacie, kiedy do `list1` dodasz 4, zmienia się tylko `list1`.\n"
"\n"
"Teraz zmień `list2 = [1, 2, 3]` na `list2 = list1` i zobacz, jaką różnicę to sprawi."

msgid "pages.EqualsVsIs.steps.final_text.text"
msgstr ""
"Teraz `list1 is list2` jest `True`, ponieważ *jest tylko jedna lista*, i obie zmienne\n"
"`list1` i `list2` odnoszą się do tej samej listy. `list1.append(4)` dodaje do jednej listy\n"
"i wynik można zobaczyć zarówno w `print(list1)`, jak i `print(list2)`, ponieważ obie linie\n"
"teraz są tylko różnymi sposobami drukowania tej samej listy.\n"
"\n"
"Polecam uruchomić obie wersje w Python Tutor, aby zobaczyć, jak wizualizuje on różnicę.\n"
"W drugim przypadku obie zmienne mają strzałki wskazujące na pojedynczy obiekt listy.\n"
"\n"
"`list2 = list1` nie tworzy wiecznego połączenia między zmiennymi. Jeśli przypiszesz nową wartość\n"
"do *którejkolwiek* z zmiennych, np. `list1 = [7, 8, 9]`, druga zmienna nie będzie miała na to wpływu\n"
"i nadal będzie wskazywać na oryginalną listę.\n"
"\n"
"W podstawowy sposób, przypisanie takie jak:\n"
"\n"
"    list2 = <wyrażenie>\n"
"\n"
"oznacza 'zrób, aby zmienna `list2` odnosiła się do tego, na co `<wyrażenie>` się oblicza'.\n"
"To nie robi kopii tej wartości, co sprawia, że obie zmienne mogą wskazywać na tę samą listę.\n"
"Ale jak już wcześniej się nauczyliśmy, `list2` nie pamięta `<wyrażenia>`, tylko wartość.\n"
"Nie wie o innych zmiennych.\n"
"\n"
"Można skopiować listę za pomocą metody `copy`:\n"
"\n"
"__code0__\n"
"\n"
"To sprawi, że program będzie zachowywał się jak pierwsza wersja.\n"
"\n"
"Jeśli napotkasz taki problem i nadal masz trudności z zrozumieniem tych zagadnień, przeczytaj esej [Fakty i mity o nazwach i wartościach w Pythonie](https://nedbatchelder.com/text/names.html)."

msgid "pages.ModifyingWhileIterating.steps.run_broken_with_python_tutor.text"
msgstr ""
"Rozważ ten program. Przechodzi przez listę liczb i usuwa te mniejsze niż 10. Przynajmniej próbuje.\n"
"Uruchom go w Python Tutor.\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"(pamiętaj, że `numbers.pop(i)` usuwa element z `numbers` o indeksie `i`)"

msgid "pages.ModifyingWhileIterating.steps.remove_instead_of_pop.text"
msgstr ""
"Podczas wykonywania, program wyraźnie pomija 7 lub 3 i nie usuwa ich, a na końcu kończy się niepowodzeniem, gdy próbuje uzyskać dostęp do indeksu, który jest zbyt wysoki. Czy widzisz, dlaczego się tak dzieje?\n"
"\n"
"Zmienna indeksu `i` przechodzi przez typowe wartości 0, 1, 2, ... tak jak powinna, ale kiedy lista się zmienia, nie są to już pozycje, które chcemy. Na przykład w pierwszej iteracji `i` to 0 i `number` to 10, który zostaje usunięty. Przesuwa to resztę liczb o jedną pozycję w lewo, więc teraz 7 znajduje się na pozycji 0. Ale potem w następnej iteracji `i` to 1, a `numbers[i]` to 8. 7 zostało pominięte.\n"
"\n"
"Możemy spróbować napisać program tak, aby używał `remove` zamiast `pop`, więc nie będziemy musieli używać indeksów. Nawet wygląda to ładniej w ten sposób.\n"
"\n"
"__program_indented__"

msgid "pages.ModifyingWhileIterating.steps.make_copy.text"
msgstr ""
"Okazuje się jednak, że robi to prawie to samo - nie kończy się błędem, ale nadal nie usuwa 7 ani 3.\n"
"Dzieje się tak z tego samego powodu - iteracja przez listę nadal odbywa się przez indeksy \"pod spodem\".\n"
"\n"
"Lekcja tutaj jest taka, ***nigdy nie modyfikuj czegoś podczas iteracji przez to***. Trzymaj modyfikację i pętle osobno.\n"
"\n"
"Dobra wiadomość jest taka, że istnieje wiele sposobów na rozwiązanie tego problemu. Możesz zamiast tego po prostu przejść przez kopię, jak w:\n"
"\n"
"__code0__"

msgid "pages.ModifyingWhileIterating.steps.make_copy2.text"
msgstr ""
"Teraz modyfikowana lista i lista, po której iterujemy, są oddzielnymi obiektami, nawet jeśli początkowo ich zawartość jest taka sama.\n"
"\n"
"Podobnie, możesz iterować po oryginale i modyfikować kopię:\n"
"\n"
"__program_indented__"

msgid "pages.ModifyingWhileIterating.steps.make_new_list.text"
msgstr ""
"Albo możesz zbudować nową listę od zera. W tym przypadku, wykonaliśmy już coś podobnego w ćwiczeniu:\n"
"\n"
"__program_indented__"

msgid "pages.ModifyingWhileIterating.steps.final_text.text"
msgstr ""
"Aby powtórzyć, ***nigdy nie modyfikuj czegoś, podczas gdy przez to iterujesz***. Twoje opcje to:\n"
"\n"
"- Modyfikuj kopię\n"
"- Iteruj po kopii\n"
"- Nie modyfikuj niczego, zamiast tego stwórz nową wersję."

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quotes_apostrophe.text"
msgstr ""
"Do tej pory definiowaliśmy łańcuchy znaków używając pojedynczych cudzysłowów, jak:\n"
"\n"
"__code0__\n"
"\n"
"Co się stanie, jeśli chcemy zdefiniować łańcuch znaków, który zawiera apostrof? Spróbuj tego:\n"
"\n"
"__program_indented__"

msgid "pages.SingleAndDoubleQuotesInStrings.steps.double_quotes.text"
msgstr ""
"Więc nie możemy używać apostrofu jak chcemy w łańcuchu znaków z pojedynczymi cudzysłowami.\n"
"Apostrof jest traktowany jak pojedynczy cudzysłów i dlatego działa jako *zamykający cudzysłów* definicji ciągu `'Alice'`.\n"
"Następnie pozostały tekst `s Diner'` jest niepoprawną składnią i Python nie rozumie tego.\n"
"\n"
"Na szczęście Python pozwala nam definiować łańcuchy znaków w inny sposób, używając podwójnych cudzysłowów `\"`:\n"
"\n"
"__program_indented__"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_double_quotes_equal.text"
msgstr ""
"Pamiętaj, że cudzysłowy są tylko częścią ludzkiej notacji dla łańcuchów znaków.\n"
"Nie są przechowywane jako rzeczywista część łańcucha znaków.\n"
"Spróbuj tego w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.text"
msgstr ""
"Jak widzisz, Python traktuje łańcuch znaków definiowany przy użyciu pojedynczych lub podwójnych cudzysłowów jako taki sam.\n"
"\n"
"Teraz napisz program, który wyświetla następujący tekst z Zen Pythona:\n"
"\n"
"    __copyable__\n"
"    Special cases aren't special enough to break the rules.\n"
"\n"
"Program powinien składać się z jednej linii używającej `print()`, bez zmiennych."

msgid "pages.SingleAndDoubleQuotesInStrings.steps.single_quote_exercise.text"
msgstr ""
"Doskonale!\n"
"\n"
"Teraz wydrukuj dokładnie następujący cytat (włącznie z podwójnymi cudzysłowami):\n"
"\n"
"    __copyable__\n"
"    \"Talk is cheap. Show me the code.\" - Linus Torvalds\n"
"\n"
"Program powinien składać się z jednej linii używającej `print()`, bez zmiennych."

msgid "pages.SingleAndDoubleQuotesInStrings.steps.final_text.text"
msgstr ""
"Dobra robota!\n"
"\n"
"W większości przypadków możesz użyć albo pojedynczych, albo podwójnych cudzysłowów do definiowania swoich łańcuchów znaków, w zależności od twoich preferencji.\n"
"Ale jeśli twój łańcuch znaków zawiera `'`, wtedy użyj `\"`, aby go zdefiniować i odwrotnie."

msgid "pages.IntroducingFstrings.steps.introduce_f_strings.text"
msgstr ""
"Do tej pory łączyliśmy łańcuchy znaków poprzez ich konkatenację za pomocą `+`, jak:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Jednakże ta metoda może być trochę uciążliwa. Możemy napisać to samo bardziej elegancko, używając *łańcucha znaków f*.\n"
"Zastąp ostatnią linię programu powyżej poniższą linią i uruchom ją.\n"
"Upewnij się, że zawarłeś `f` przed łańcuchem znaków.\n"
"\n"
"__code1__"

msgid "pages.IntroducingFstrings.steps.concatenate_string_number.text"
msgstr ""
"Składnia łańcucha znaków f zaczyna się od `f`, po którym następuje łańcuch znaków.\n"
"Łańcuch f-string może zawierać nazwy zmiennych w środku nawiasów klamrowych `{}`.\n"
"Zostaną one zastąpione wartościami tych zmiennych przekształconymi na łańcuchy znaków.\n"
"Zmienne mogą być czymkolwiek: łańcuchami znaków, liczbami, listami itd.\n"
"\n"
"Dlatego łańcuchy znaków f pozwalają łatwo kombinować łańcuchy znaków i liczby, które\n"
"nie mogą być po prostu dodane do siebie. Na przykład uruchom następujący program:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingFstrings.steps.basic_f_string_exercise.text"
msgstr ""
"To nie działa, ponieważ nie możemy użyć `+` między łańcuchem znaków `\"Hello Alice. You are \"` a liczbą `age`.\n"
"\n"
"Napraw to, zastępując wszystkie konkatenacje łańcuchów znaków (+) pojedynczym łańcuchem znaków f."

msgid "pages.IntroducingFstrings.steps.eval_expr_inside_f_string.text"
msgstr ""
"Oprócz zmiennych, łańcuch znaków f może faktycznie zawierać dowolne wyrażenie Pythona wewnątrz nawiasów klamrowych.\n"
"Wypróbuj to w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingFstrings.steps.fix_broken_program.text"
msgstr ""
"Jak widzisz, możemy zdefiniować łańcuch znaków f również używając podwójnych cytatów, tak jak w przypadku normalnego łańcucha.\n"
"I tak jak cytaty, łańcuchy znaków f są tylko notacją. Gdy są wyliczone, komputer zapomina, że użyto łańcucha znaków f, przechowuje tylko końcowy wynik jako normalny łańcuch znaków.\n"
"\n"
"Oto bardzo zepsuty program:\n"
"\n"
"    __copyable__\n"
"    people = [\"Alice\", \"Bob\", \"Charlie\"]\n"
"    print('There are' + people.length() + 'people waiting, the first one's name is' + people.1 + '.')\n"
"\n"
"Napraw go!\n"
"Twoje rozwiązanie powinno działać dla dowolnej listy łańcuchów znaków o nazwie `people`.\n"
"Na przykład, w powyższym przypadku powinno wydrukować:\n"
"\n"
"    There are 3 people waiting, the first one's name is Alice."

msgid "pages.IntroducingFstrings.steps.final_text.text"
msgstr ""
"Świetnie!\n"
"\n"
"Od teraz zachęcamy do używania łańcuchów znaków f zamiast `+` do budowania twoich łańcuchów znaków, tam gdzie to możliwe."

msgid "pages.IntroducingNestedLoops.steps.first_nested_loop.text"
msgstr ""
"Widziałeś, że zagnieżdżone treści instrukcji `if` lub pętli mogą zawierać dowolny rodzaj instrukcji, w tym więcej instrukcji `if` i pętli. W szczególności pętla może zawierać inną pętlę. Oto przykład:\n"
"\n"
"__program_indented__\n"
"\n"
"To nazywa się *pętlą zagnieżdżoną*. Nie ma w tym nic naprawdę nowego, ale warto to dokładnie zrozumieć, ponieważ może to być bardzo przydatne do pisania interesujących programów."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.text"
msgstr ""
"Upewnij się, że w pełni rozumiesz, co się dzieje. `print(letter)` i `print('---')` są wywoływane po 3 razy, ponieważ ich wcięcie umieszcza je w *pętli zewnętrznej*. `print(f'{letter} {number}')` jest wywoływane 3 × 4 = 12 razy, ponieważ znajduje się w *pętli wewnętrznej* `for number in range(4):`, która ma 4 iteracje, ale sama jest w pętli zewnętrznej, więc wykonuje się 3 razy.\n"
"\n"
"Wykorzystajmy to! Załóżmy, że jesteś nauczycielem i musisz wydrukować wszystkie tabliczki mnożenia od 1 do 12 dla swoich uczniów. Nie chcesz tego robić ręcznie, ale możesz napisać program, który zrobi to za Ciebie! Wydruk programu powinien wyglądać tak, łącznie z liniami myślników:\n"
"\n"
"    1 x 1 = 1\n"
"    1 x 2 = 2\n"
"    1 x 3 = 3\n"
"    1 x 4 = 4\n"
"    1 x 5 = 5\n"
"    1 x 6 = 6\n"
"    1 x 7 = 7\n"
"    1 x 8 = 8\n"
"    1 x 9 = 9\n"
"    1 x 10 = 10\n"
"    1 x 11 = 11\n"
"    1 x 12 = 12\n"
"    ---\n"
"    2 x 1 = 2\n"
"    2 x 2 = 4\n"
"    2 x 3 = 6\n"
"    2 x 4 = 8\n"
"    2 x 5 = 10\n"
"    2 x 6 = 12\n"
"    2 x 7 = 14\n"
"    2 x 8 = 16\n"
"    2 x 9 = 18\n"
"    2 x 10 = 20\n"
"    2 x 11 = 22\n"
"    2 x 12 = 24\n"
"    ---\n"
"    3 x 1 = 3\n"
"    3 x 2 = 6\n"
"    3 x 3 = 9\n"
"    (rozumiesz już ideę...)\n"
"    11 x 10 = 110\n"
"    11 x 11 = 121\n"
"    11 x 12 = 132\n"
"    ---\n"
"    12 x 1 = 12\n"
"    12 x 2 = 24\n"
"    12 x 3 = 36\n"
"    12 x 4 = 48\n"
"    12 x 5 = 60\n"
"    12 x 6 = 72\n"
"    12 x 7 = 84\n"
"    12 x 8 = 96\n"
"    12 x 9 = 108\n"
"    12 x 10 = 120\n"
"    12 x 11 = 132\n"
"    12 x 12 = 144\n"
"    ---"

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_exercise.text"
msgstr ""
"W porządku!\n"
"\n"
"Następne ćwiczenie: organizujesz turniej w grę, taką jak szachy lub tenis. Masz listę nazwisk graczy:\n"
"\n"
"__code0__\n"
"\n"
"Każdy gracz zmierzy się z każdym pozostałym graczem dwa razy: raz kiedy uzyskuje przewagę (np. zaczyna ruch lub serwuje pierwszy) i raz bez. Wypisz wszystkie kombinacje meczów tak:\n"
"\n"
"    Alicja vs Bob\n"
"    Alicja vs Charlie\n"
"    Bob vs Alicja\n"
"    Bob vs Charlie\n"
"    Charlie vs Alicja\n"
"    Charlie vs Bob\n"
"\n"
"Zauważ, że \"Alicja vs Bob\" i \"Bob vs Alicja\" są oba na liście, ale nie ma \"Alicja vs Alicja\" - nie chcemy, aby ktoś grał sam ze sobą."

msgid "pages.IntroducingNestedLoops.steps.crack_password_exercise.text"
msgstr ""
"W twoim kolejnym ćwiczeniu musisz złamać hasło. Wiesz, że składa się ono dokładnie z czterech liter i że możliwe są tylko pewne litery, które zanotowałeś:\n"
"\n"
"__code0__\n"
"\n"
"Musisz wypisać wszystkie możliwe hasła:\n"
"\n"
"    AAAA\n"
"    AAAB\n"
"    AAAC\n"
"    AAAD\n"
"    AABA\n"
"    AABB\n"
"    ...pomijając kilka...\n"
"    DDDA\n"
"    DDDB\n"
"    DDDC\n"
"    DDDD"

msgid "pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.text"
msgstr ""
"Niesamowite, jesteś teraz praktycznie hakerem!\n"
"\n"
"Jeszcze jedno ćwiczenie. Dla danego rozmiaru:\n"
"\n"
"__code0__\n"
"\n"
"Wypisz 'do góry nogami' trójkąt stworzony ze znaku plus `+`, którego boki są tak długie jak dany rozmiar, np.:\n"
"\n"
"    +++++\n"
"    ++++\n"
"    +++\n"
"    ++\n"
"    +"

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.text"
msgstr ""
"Niesamowite, jesteś również artystą!\n"
"\n"
"Jeśli chcesz, możesz teraz przejść do [następnej strony](#IntroducingBirdseye). Albo możesz zrobić dodatkowe wyzwanie!\n"
"\n"
"Podobnie jak w poprzednim ćwiczeniu, organizujesz turniej gry. Masz listę nazwisk graczy:\n"
"\n"
"__code0__\n"
"\n"
"Tym razem każda para graczy powinna pojawić się tylko raz. Konkretnie, wypisz tylko te pary, które są w\n"
"takiej samej kolejności od lewej do prawej, jak są w `players`, zaczynając od par zawierających osobę najbardziej na lewo\n"
"w `players` i przemieszczając się w prawo. Na przykład, dla powyższego, twój program powinien wypisać\n"
"\n"
"    Charlie vs Alicja\n"
"    Charlie vs Dylan\n"
"    Charlie vs Bob\n"
"    Alicja vs Dylan\n"
"    Alicja vs Bob\n"
"    Dylan vs Bob"

msgid "pages.IntroducingNestedLoops.steps.final_text.text"
msgstr ""
"Doskonale! Rozwiązanie wygląda następująco:\n"
"\n"
"__code0__"

msgid "pages.IntroducingBirdseye.steps.first_birdseye_example.text"
msgstr ""
"Widziałeś `snoop` i Python Tutor. futurecoder oferuje jeszcze jedno narzędzie do analizowania programów w trakcie ich działania, nazywa się `birdseye`.\n"
"\n"
"Oto przykładowy program do uruchomienia. Skopiuj go do edytora i kliknij przycisk `birdseye`. Otworzy się nowa karta przeglądarki z wizualizacją.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingBirdseye.steps.birdseye_loop_example.text"
msgstr ""
"Podczas gdy inne narzędzia pokazują, jak kod działa linia po linii i jakie są wartości zmiennych, `birdseye` pokazuje wartość każdego wyrażenia w programie. Pozwala to zobaczyć, jak skomplikowane wyrażenie jest rozbijane na mniejsze podwyrażenia\n"
"i jaka jest wartość każdego z nich.\n"
"\n"
"Najedź kursorem na różne wyrażenia w ramkach w ostatniej linii programu.\n"
"W miarę jak każde pole zostanie wyróżnione, jego wartość jest wyświetlana na dole ekranu. Kliknięcie na pole przyklei je do panelu, dzięki czemu możesz zobaczyć wartości kilku wyrażeń na raz i swobodnie przemieszczać mysz.\n"
"\n"
"W tym przypadku `birdseye` pokazuje, że wyrażenie:\n"
"\n"
"__code0__\n"
"\n"
"zostaje rozbite na\n"
"\n"
"__code1__\n"
"\n"
"a nie\n"
"\n"
"__code2__\n"
"\n"
"Innymi słowy, Python przestrzega zwykłego porządku działań matematycznych, a nie tylko oceniania od lewej do prawej.\n"
"\n"
"Zauważ, że są pewne wyrażenia, na które `birdseye` nie nakłada ramki. W tym przypadku `2`, `3`, `4`, `5` oraz `print` są również wyrażeniami, ale ich wartości są oczywiste i ramkowanie ich byłoby tylko zbędnym bałaganem.\n"
"\n"
"Oto bardziej skomplikowany przykład do wypróbowania:\n"
"\n"
"    __copyable__\n"
"__code3__"

msgid "pages.IntroducingBirdseye.steps.final_text.text"
msgstr ""
"Zwróć uwagę, że:\n"
"\n"
"1. Obok pętli for znajduje się para strzałek. Kliknij je, aby nawigować w czasie przez pętlę i zobaczyć, co działo się w różnych iteracjach.\n"
"2. Kod, który nie był wykonywany w iteracji z powodu `if`, jest wyszarzony. Wyrażenia wewnątrz nie mają wartości, ponieważ nie były oceniane.\n"
"3. Zapisane wartości dla wyrażeń `vowels` i `consonants` zależą od tego, na które pole patrzysz. W linijkach po pętli zawierają one wszystkie litery, ale wewnątrz pętli mają tylko niektóre, i dokładna ich liczba zależy od tego, która iteracja jest aktualnie rozpatrywana.\n"
"4. W `vowels.append(letter)`, widać jakie wartości miały te zmienne *w tamtym momencie*. Oznacza to, że `letter` jest na punkcie dołączenia do `vowels`, ale to jeszcze się nie stało, więc `vowels` nie zawiera jeszcze `letter`."

msgid "pages.IntroducingNestedLists.steps.string_list_exercise.text"
msgstr ""
"Ćwiczenie: mając daną listę łańcuchów znaków, wypisz pierwszą literę drugiego łańcucha z listy. Na przykład, mając:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"powinieneś/powinnaś wypisać `d`."

msgid "pages.IntroducingNestedLists.steps.double_subscripting.text"
msgstr ""
"Możesz to rozwiązać tak:\n"
"\n"
"__code0__\n"
"\n"
"Istnieje jednak krótszy sposób. `strings[1]` jest wyrażeniem tak samo jak każde inne i indeksowanie jak `[0]` może być użyte na dowolnym wyrażeniu, nie tylko na zmiennych.\n"
"Więc możesz pominąć zmienną pośrednią i zrobić to jedną linią:\n"
"\n"
"__code1__\n"
"\n"
"Przyjrzyj się dobrze tej składni. Jeśli wydaje się nowa i wyszukana, nie jest.\n"
"To po prostu zwykła składnia indeksowania, zastosowana dwukrotnie.\n"
"Wypróbuj to w `birdseye`, aby zobaczyć, jak Python dzieli to na mniejsze części."

msgid "pages.IntroducingNestedLists.steps.double_subscripting_exercise.text"
msgstr ""
"Używając tej składni, zmodyfikuj program, aby wypisać ostatnią literę przedostatniego łańcucha znaków w liście `strings`.\n"
"Musisz użyć pojedynczego wyrażenia podobnego do powyższego, i nie wolno Ci używać `len`.\n"
"Twoje rozwiązanie powinno działać dla dowolnej niepustej listy łańcuchów znaków.\n"
"Dla wcześniej podanego przykładu wejściowego powinno wypisać `f`."

msgid "pages.IntroducingNestedLists.steps.first_nested_list_example.text"
msgstr ""
"Dobra robota!\n"
"\n"
"Podwójne stosowanie indeksowania może być jeszcze bardziej potężne.\n"
"Można je zastosować nie tylko do listy łańcuchów znaków, ale również do *listy list*.\n"
"Na przykład, co wypisze poniższy program?\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.text"
msgstr ""
"Jak widzisz, Python pozwala na posiadanie *zagnieżdżonych list*: list, gdzie każdy element jest inną listą (nazywamy je *podlistami*).\n"
"\n"
"Możemy stosować indeksowanie nawet więcej niż dwa razy.\n"
"Napisz program, który bierze zagnieżdżoną listę `strings` jak powyżej,\n"
"i wypisuje **pierwszą literę trzeciego łańcucha znaków w drugiej podliście**.\n"
"Użyj tylko pojedynczego wyrażenia, podobnie jak w poprzednim ćwiczeniu.\n"
"Na przykład, dla listy powyżej, powinien wypisać `y`."

msgid "pages.IntroducingNestedLists.steps.final_text.text"
msgstr ""
"Świetnie! Teraz bardzo dobrze rozumiesz zagnieżdżone indeksowanie.\n"
"\n"
"Wciąż możemy używać wszystkich metod list i funkcji, których się wcześniej nauczyliśmy.\n"
"Na przykład możemy dodać nowe słowo do ostatniej podlisty `strings` za pomocą `append`,\n"
"żeby znalazło się po `'you'`:\n"
"\n"
"__code0__\n"
"\n"
"Przecież podlista `strings[1]` jest nadal listą jak każda inna!\n"
"\n"
"Na następnej stronie nauczymy się jak iterować po zagnieżdżonych listach."

msgid ""
"pages.LoopingOverNestedLists.steps.nested_list_nested_loop_example.text"
msgstr ""
"Można użyć zagnieżdżonej pętli, by iterować po każdym elemencie i sub-elemencie zagnieżdżonej listy.\n"
"Na przykład, rozważmy taką zagnieżdżoną listę.\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Kliknij przycisk, aby skopiować listę do edytora, a następnie wpisz następującą zagnieżdżoną pętlę.\n"
"\n"
"__code1__\n"
"\n"
"Przyjrzyj się uważnie kodowi. Zauważ, że zewnętrzna pętla tworzy zmienną `sublist`\n"
"i wewnętrzna pętla iteruje po tej samej zmiennej. To jest powszechny wzorzec.\n"
"Teraz uruchom kod."

msgid "pages.LoopingOverNestedLists.steps.nested_list_loop_python_tutor.text"
msgstr ""
"Teraz uruchom ten sam program ponownie w Python Tutor.\n"
"\n"
"Zbadaj, jak wygląda `numbers`, oraz co reprezentują `numbers[0]` aż do `numbers[3]`.\n"
"Spójrz, jak zmieniają się zmienne `sublist` i `num`."

msgid "pages.LoopingOverNestedLists.steps.string_contains_word_exercise.text"
msgstr ""
"Teraz rozwiążmy kilka problemów, wykorzystując tego rodzaju pętle.\n"
"\n"
"Załóżmy, że mamy zagnieżdżoną listę łańcuchów znaków, jak poniżej,\n"
"i chcemy wyszukać konkretny `word` głęboko w liście.\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Możesz sobie wyobrazić, że `strings` reprezentuje książkę, gdzie każda podlista to strona, a każdy łańcuch znaków wewnątrz\n"
"to linijka na tej stronie.\n"
"To również może reprezentować bibliotekę, gdzie każda lista to księga, a każdy łańcuch znaków to strona.\n"
"\n"
"Napisz program, który wypisze każdy łańcuch znaków zawierający `word`.\n"
"Powinien działać dla dowolnego `word` i `strings`. Dla przykładu powyżej, powinien wypisać\n"
"\n"
"    hello there\n"
"    hello world\n"
"\n"
"Pamiętaj, że jest specyficzny sposób, aby sprawdzić, czy łańcuch znaków zawiera inny łańcuch znaków. Jeśli nie możesz sobie przypomnieć jak, wyszukaj w Google!"

msgid "pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.text"
msgstr ""
"Super!\n"
"\n"
"Teraz nieco zmienimy ćwiczenie. Tym razem wyjście powinno nam powiedzieć, które *podlisty* zawierają `word`,\n"
"a nie które wewnętrzne łańcuchy znaków. W szczególności chcemy wypisać wartość logiczną dla każdej podlisty:\n"
"`True` jeśli podlista zawiera słowo w którymkolwiek ze swoich łańcuchów znaków, `False` jeśli go tam wcale nie ma.\n"
"\n"
"Mając te przykładowe dane wejściowe:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Twój program powinien wypisać:\n"
"\n"
"__code1__\n"
"\n"
"Zwróć uwagę, że `word in sublist` nie będzie działać. Na przykład, `\"hello\" in [\"hello there\", \"how are you\"]` jest `False`\n"
"ponieważ `\"hello\"` nie jest *równoważne* żadnemu z dwóch elementów tej listy, chociaż jest w jednym z nich."

msgid "pages.LoopingOverNestedLists.steps.list_contains_word_exercise.text"
msgstr ""
"Dobra robota!\n"
"\n"
"Następnie, wypisz tylko jedną wartość logiczną, aby wskazać, czy `word` jest obecny w jakimkolwiek łańcuchu znaków w całej zagnieżdżonej liście. Na przykład, jeśli\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"twój program powinien wypisać `False`."

msgid "pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.text"
msgstr ""
"Doskonale!\n"
"\n"
"[Wcześniejszej części kursu](#GettingElementsAtPositionExercises) było ćwiczenie\n"
"polegające na wypisaniu dwóch łańcuchów znaków w pionie, obok siebie, tak jak tutaj:\n"
"\n"
"    H W\n"
"    e o\n"
"    l r\n"
"    l l\n"
"    o d\n"
"\n"
"Teraz uogólnimy to do listy łańcuchów znaków, a nie tylko dwóch.\n"
"\n"
"W tym ćwiczeniu masz daną listę łańcuchów znaków o **równej długości**.\n"
"Napisz program, który wypisze pierwszą literę każdego łańcucha znaków w jednej linii,\n"
"następnie drugą literę każdego łańcucha znaków w kolejnej linii, i tak dalej. Na przykład, jeśli\n"
"\n"
"__code0__\n"
"\n"
"to Twój program powinien wypisać\n"
"\n"
"    __no_auto_translate__\n"
"    adg\n"
"    beh\n"
"    cfi\n"
"\n"
"Twój program powinien działać dla dowolnej takiej listy. W szczególności, jeśli użyjesz następującej listy,\n"
"odkryjesz ukrytą wiadomość z Zen Pythona!\n"
"\n"
"    __copyable__\n"
"    __no_auto_translate__\n"
"    strings = [\"  b n\", \"f ete\", \"liths\", \"astat\", \"t ene\", \"  r d\"]\n"
"\n"
"Zwróć uwagę, że tym razem nie powinieneś dodawać spacji między literami na wyjściu."

msgid "pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.text"
msgstr ""
"Doskonale! Jeśli chcesz, możesz teraz przejść do [następnej strony](#DefiningFunctions).\n"
"Albo możesz podjąć dodatkowe wyzwanie!\n"
"\n"
"Teraz uogólnijmy poprzednie ćwiczenie na łańcuchy znaków o różnej długości. Znowu masz daną listę łańcuchów znaków.\n"
"Tak jak poprzednio, napisz program, który wypisze pierwszą literę każdego łańcucha znaków razem w jednej linii,\n"
"następnie drugie litery razem w kolejnej linii, i tak dalej.\n"
"Ale tym razem, jeśli łańcuch znaków nie ma wystarczającej liczby liter, powinien wypisać spację.\n"
"\n"
"Na przykład, jeśli\n"
"\n"
"    __no_auto_translate__\n"
"    strings = [\"abcqwe\", \"def\", \"ghiq\"]\n"
"\n"
"Twój program powinien wypisać\n"
"\n"
"    adg\n"
"    beh\n"
"    cfi\n"
"    q q\n"
"    w\n"
"    e"

msgid "pages.LoopingOverNestedLists.steps.final_text.text"
msgstr ""
"Opanowałeś listy zagnieżdżone oraz jak je łączyć z zagnieżdżonymi pętlami.\n"
"Świetna robota! Teraz masz w swoim arsenale programistycznym niezwykle potężne narzędzia."

msgid "pages.DefiningFunctions.steps.define_greet.text"
msgstr ""
"Widziałeś już, jak wywoływać funkcje takie jak `print()` i `len()`. Teraz nauczysz się, jak pisać własne funkcje, których ty lub inni ludzie można używać. To bardzo ważne, gdy programy stają się większe i bardziej skomplikowane.\n"
"\n"
"Oto prosty przykład:\n"
"\n"
"__program_indented__\n"
"\n"
"To definiuje funkcję o nazwie `greet`, która akceptuje jeden parametr. Poniżej definicji wywołujemy funkcję dwa razy.\n"
"Uruchom kod, aby zobaczyć, co się stanie."

msgid "pages.DefiningFunctions.steps.how_are_you.text"
msgstr ""
"Definicja funkcji to złożone wyrażenie. Tak jak `if` i `for`, posiada linię nagłówkową po której następuje wcięte ciało, które może zawierać jedno lub więcej wyrażeń.\n"
"\n"
"Dodaj kolejne wyrażenie do funkcji tak, aby wyglądała ona w następujący sposób:\n"
"\n"
"__code0__\n"
"\n"
"Następnie uruchom program ponownie."

msgid "pages.DefiningFunctions.steps.change_function_name.text"
msgstr ""
"Zauważ, jak zmieniło się wyjście programu. `How are you?` zostało wydrukowane dwa razy. Możesz myśleć o całym programie jako równoważnym z tym:\n"
"\n"
"__code0__\n"
"\n"
"Pokazuje to jedną z najbardziej użytecznych rzeczy dotyczących funkcji. Pozwalają one na wielokrotne używanie tego samego kodu bez konieczności jego powtarzania. To jakby pisanie programu w programie.\n"
"\n"
"Nagłówek definicji funkcji zawsze zawiera te części:\n"
"\n"
"1. Specjalne słowo kluczowe `def`, po którym następuje spacja.\n"
"2. Nazwę funkcji. Jest to jak nazwa zmiennej - możesz wybrać nazwę, którą chcesz, ale istnieją pewne ograniczenia, np. nie może zawierać spacji.\n"
"3. Parę nawiasów `(` i `)`\n"
"4. Zero lub więcej nazw parametrów pomiędzy nawiasami, oddzielone przecinkami, jeśli jest ich więcej niż jeden. Tutaj mamy jeden parametr o nazwie `name`.\n"
"5. Dwukropek `:`\n"
"\n"
"Wykonajmy proste ćwiczenia. Zmień nazwę funkcji z `greet` na `say_hello`.\n"
"Upewnij się, że cały program działa nadal jak wcześniej, ale nie zmieniaj niczego innego."

msgid "pages.DefiningFunctions.steps.change_parameter_name.text"
msgstr ""
"Dobrze! Teraz wykonaj podobne ćwiczenie: zmień nazwę parametru z `name` na "
"`person_name`."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.text"
msgstr ""
"Dobrze wykonane!\n"
"\n"
"Teraz napisz własną funkcję o nazwie `print_twice`, która przyjmuje jeden argument `x` i drukuje ten argument dwa razy\n"
"na dwóch liniach.\n"
"\n"
"Na przykład, `print_twice(\"Hello\")` powinno dać wynik:\n"
"\n"
"__code0__\n"
"\n"
"Możesz przetestować swoją funkcję, wywołując ją po definicji funkcji, ale nie jest to wymagane."

msgid "pages.DefiningFunctions.steps.print_many.text"
msgstr ""
"Funkcje mogą mieć wiele parametrów. Oto przykład:\n"
"\n"
"__program_indented__"

msgid "pages.DefiningFunctions.steps.swap_parameters.text"
msgstr ""
"Zwróć uwagę na przecinki używane do oddzielania parametrów w definicji funkcji i argumenty w wywołaniu funkcji,\n"
"oraz na zgodność pomiędzy definicją a wywołaniem:\n"
"\n"
"    def print_many(thing, n):\n"
"                     ^    ^\n"
"                     |    |\n"
"      print_many(\"Hello\", 3)\n"
"\n"
"Więc wywołanie `print_many(\"Hello\", 3)` jest jak uruchomienie:\n"
"\n"
"__code0__\n"
"\n"
"Teraz kolejne proste ćwiczenie. Zamień miejscami parametry w nagłówku definicji funkcji tak, aby powstało:\n"
"\n"
"__code1__\n"
"\n"
"Jeśli to zrobisz i nic więcej, otrzymasz błąd. Popraw resztę programu, aby działała jak wcześniej.\n"
"*Nie zmieniaj ciała funkcji*."

msgid "pages.DefiningFunctions.steps.final_text.text"
msgstr ""
"Doskonale! Teraz masz solidne podstawy w zakresie definiowania funkcji."

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.print_twice_call_print_many.text"
msgstr ""
"Ciało funkcji może zawierać cokolwiek, w tym wywołania innych funkcji. Tak naprawdę już to zrobiliśmy, wywołując\n"
"print. Ale wywołanie jednej z naszych własnych funkcji nie różni się niczym, więc nasze funkcje mogą wywoływać siebie nawzajem!\n"
"\n"
"Na przykład, możemy zaimplementować `print_twice` korzystając z `print_many`:\n"
"\n"
"__program_indented__"

msgid "pages.CallingFunctionsWithinFunctions.steps.see_stack_in_snoop.text"
msgstr ""
"Ważne jest, aby dobrze zrozumieć, co się tutaj dzieje i wiedzieć, jak\n"
"badać wywołania funkcji, więc wypróbujemy to w każdym debuggerze.\n"
"\n"
"Najpierw uruchom program ponownie z `snoop`."

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.see_stack_in_pythontutor.text"
msgstr ""
"`snoop` rozpoczyna każde wywołanie funkcji od:\n"
"\n"
"1. Nowego poziomu wcięcia w dziennikach.\n"
"2. `>>> Wywołanie funkcji <nazwa funkcji>`\n"
"3. Wartości argumentów.\n"
"4. Linii nagłówkowej funkcji.\n"
"\n"
"Kończy wywołanie za pomocą `<<< Zwrócona wartość z <nazwa funkcji>`. Niedługo dowiemy się więcej o wartościach zwracanych.\n"
"\n"
"Teraz uruchom program ponownie za pomocą Python Tutor."

msgid "pages.CallingFunctionsWithinFunctions.steps.see_stack_in_birdseye.text"
msgstr ""
"Za każdym razem, gdy funkcja jest wywoływana, tworzona jest nowa *ramka* (ang. frame), która zawiera wartości lokalnych zmiennych\n"
"w danym wywołaniu oraz inne informacje o tym, co aktualnie się dzieje.\n"
"Gdy wywołanie funkcji się kończy, ramka jest usuwana.\n"
"\n"
"Można to zobaczyć w Python Tutor po prawej stronie pod \"Ramki\" (ang. \"Frames\"). Na górze znajduje się ramka globalna (Global frame),\n"
"ramka najwyższego poziomu, gdzie działa cały program. Kiedy klikniesz Dalej (Next), pojawiają się nowe ramki,\n"
"a następnie znikają. W każdej z nich możesz zobaczyć wartości zmiennych.\n"
"\n"
"Na koniec uruchom program z `birdseye`."

msgid "pages.CallingFunctionsWithinFunctions.steps.final_text.text"
msgstr ""
"`birdseye` pokazuje tylko jedną ramkę (wywołanie funkcji) na raz. Na początku widzimy ramkę globalną.\n"
"Na dole jest wywołanie `print_twice`. Kliknij na małą niebieską strzałkę, żeby wejść do tej ramki,\n"
"a następnie kliknij na kolejną, aby wejść do `print_many`."

msgid "pages.ReturningValuesFromFunctions.steps.first_return.text"
msgstr ""
"Funkcje mogą być szczególnie przydatne, gdy *zwracają* wartości, zamiast je tylko wyświetlać. Wypróbuj ten przykład:\n"
"\n"
"__program_indented__"

msgid "pages.ReturningValuesFromFunctions.steps.losing_return_value.text"
msgstr ""
"Tutaj przekazaliśmy `number` (która ma wartość `5`) jako argument `x` do funkcji `double`, a `double` *zwróciła*\n"
"`x * 2`, czyli `5 * 2`, czyli `10`, co stało się wartością zmiennej `twice`. Specjalne słowo kluczowe `return` wewnątrz \n"
"`double` sprawia, że `double(number)` staje się wyrażeniem z wartością - konkretnie z wartością, która została zwrócona.\n"
"To trochę jak `twice = double(number)` jest równoważne `twice = number * 2`, chociaż to nie\n"
"dokładnie to, co się dzieje.\n"
"\n"
"Zauważ, że `double(number)` *nie zmieniła `number`*. Na końcu `number` wciąż jest `5`. Raczej `double(number)`\n"
"zwróciła nową wartość. Kluczowe jest, aby program wykorzystał tę zwróconą wartość, w tym przypadku przechowując\n"
"ją w zmiennej. Natychmiastowe wydrukowanie jej za pomocą `print(double(number))` również działa. Z drugiej strony,\n"
"spróbuj tego:\n"
"\n"
"__program_indented__"

msgid "pages.ReturningValuesFromFunctions.steps.quadruple_exercise.text"
msgstr ""
"Tutaj `double(number)` nadal zwróciła `10`, ale nie wykorzystaliśmy tego, więc zostało to utracone. `number` wciąż jest `5`.\n"
"\n"
"Napisz funkcję `quadruple`, która przyjmuje jeden argument `x` i zwraca ten argument pomnożony przez 4.\n"
"Musisz użyć wyłącznie funkcji `double` - bezpośrednio w ciele funkcji `quadruple` nie wolno używać liczb ani mnożenia."

msgid "pages.ReturningValuesFromFunctions.steps.final_text.text"
msgstr ""
"Dobrze zrobione! Oto dwie możliwe rozwiązania:\n"
"\n"
"__code0__"

msgid "pages.TestingFunctions.steps.introducing_assert_equal.text"
msgstr ""
"Ważną częścią pisania programów jest sprawdzenie, czy działają poprawnie. Możesz to robić ręcznie, np. sprawdzając, czy\n"
"`print(double(5))` wydrukuje `10`, ale tego rodzaju ręczne testy mogą szybko stać się nużące.\n"
"Pomocne jest faktyczne pisanie programów, które testują twoje programy. To nazywa się *automatycznym testowaniem*,\n"
"a programy te nazywane są *testami*.\n"
"\n"
"Oto prosta funkcja `assert_equal`, która pomoże nam pisać testy:\n"
"\n"
"__code0__\n"
"\n"
"\n"
"(Co to za funkcja `repr`? Spróbuj `print(f\"{'abc'} {repr('abc')}\")`, aby zobaczyć jedną różnicę, ale nie przejmuj się tym zbytnio.)\n"
"\n"
"To nie jest standardowa część Pythona (chociaż podobne funkcje istnieją), ale dodaliśmy ją do twojego środowiska kodowania,\n"
"abyś mógł z niej zawsze korzystać. Oto przykład jej użycia, który możesz wypróbować:\n"
"\n"
"__program_indented__"

msgid "pages.TestingFunctions.steps.make_tests_fail.text"
msgstr ""
"Te komunikaty \"OK\" informują nas, że testy przeszły pomyślnie. Nasza funkcja `double` wydaje się działać poprawnie. Zmień ją tak, aby zwracała\n"
"`x * 3` i zobacz, co się stanie."

msgid "pages.TestingFunctions.steps.complete_quadruple_tests.text"
msgstr ""
"Świetnie! Nasze testy nie przeszły! Oczywiście zazwyczaj nie jest to dobra wiadomość, ale mówi nam, że testy\n"
"wykonują swoją pracę. Upewnią się one, że nasza implementacja funkcji `double` jest poprawna.\n"
"\n"
"Przećwiczmy tę nową koncepcję. Poniżej znajduje się funkcja `quadruple` z poprzedniej części wraz z niektórymi niekompletnymi testami.\n"
"Napraw program, dodając brakujące argumenty do `assert_equal`.\n"
"\n"
"__code0__"

msgid "pages.TestingFunctions.steps.surround_exercise.text"
msgstr ""
"Kolejnym użytecznym aspektem testów jest to, że każdy może je przeczytać i zobaczyć jasne, jednoznaczne przykłady\n"
"tego, co funkcja robi. Jest to pomocne, gdy funkcja jest skomplikowana i trudna do opisania w języku angielskim.\n"
"\n"
"Na przykład, oto kilka testów:\n"
"\n"
"__code0__\n"
"\n"
"Nie muszę tłumaczyć, co robi funkcja `surround`, możesz zobaczyć sam.\n"
"\n"
"Napisz funkcję `surround`, która przejdzie te testy i zacznij od:\n"
"\n"
"__code1__"

msgid "pages.TestingFunctions.steps.alert_exercise.text"
msgstr ""
"Doskonale! Teraz napisz funkcję `alert`, która przejdzie te testy:\n"
"\n"
"__code0__\n"
"\n"
"Ciało funkcji `alert` nie może zawierać `+`. Zamiast tego użyj funkcji `surround`. Twoja funkcja powinna zaczynać się tak:\n"
"\n"
"__code1__"

msgid "pages.TestingFunctions.steps.final_text.text"
msgstr ""
"Świetna robota! Te narzędzia będą bardzo pomocne w kolejnych rozdziałach."

msgid "pages.MoreOnReturn.steps.double_return_in_one_function.text"
msgstr ""
"Czasami `return` może być źródłem zamieszania i błędów dla początkujących uczniów.\n"
"Dowiedzmy się więcej o tym, jak ona działa.\n"
"\n"
"Uruchom ten kod:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.MoreOnReturn.steps.cannot_return_multiple_values.text"
msgstr ""
"Gdy instrukcja `return` zostanie wykonana, funkcja się zakończy, a reszta kodu zostanie zignorowana.\n"
"Oznacza to, że każdy kod bezpośrednio po instrukcji `return` w tym samym bloku jest *nieosiągalny*:\n"
"`return 2` *nigdy* nie zostanie wykonany, bez względu na to, ile razy uruchomimy tę funkcję!\n"
"\n"
"***Tylko jeden `return` może być wykonany przy każdym wywołaniu funkcji, a następnie wykonanie się zatrzymuje.***\n"
"\n"
"Wiele instrukcji `return` może być nadal użyteczne, gdy są poprawnie używane, np. w bloku `if-else`:\n"
"\n"
"__code0__\n"
"\n"
"Powszechnym błędem jest niezrozumienie działania `return` w pętlach `for`. Spróbuj następującego kodu:\n"
"\n"
"    __copyable__\n"
"__code1__"

msgid "pages.MoreOnReturn.steps.return_ends_whole_function.text"
msgstr ""
"Na pierwszy rzut oka może się wydawać intuicyjne, aby `return` zwracał jedną wartość dla każdej iteracji w pętli `for`.\n"
"Ale to nie działa w taki sposób!\n"
"Jeśli przyjrzysz się kodowi za pomocą `snoop` lub Python tutor, zobaczysz, że funkcja zwraca 2 podczas pierwszej\n"
"iteracji pętli, a następnie natychmiast się kończy.\n"
"\n"
"Nawet jeśli istnieje tylko jedna instrukcja `return`, zostanie ona wykonana tylko raz i zwróci jedną wartość.\n"
"Jeśli chcesz zwrócić kilka wartości, zwróć listę:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Co się stanie, jeśli mamy do czynienia z zagnieżdżonymi pętlami? Wypróbuj następującą funkcję:\n"
"\n"
"    __copyable__\n"
"__code1__"

msgid "pages.MoreOnReturn.steps.break_vs_return.text"
msgstr ""
"Tak jak wcześniej, `return` ***kończy działanie całej funkcji***, łącznie ze wszystkimi pętlami.\n"
"\n"
"Wcześniej pokazaliśmy [jak zatrzymać pętlę za pomocą `break`](#UsingBreak).\n"
"Zmień `return letter` na `break` i zobacz, jaka jest różnica."

msgid "pages.MoreOnReturn.steps.final_text.text"
msgstr ""
"W przeciwieństwie do `return`, `break` zatrzymuje tylko najbardziej wewnętrzną pętlę, w której jest używany, w tym przypadku `for number in range(3):`.\n"
"Oto dokładnie co się dzieje:\n"
"\n"
"- Dla `letter = b`, linia `print(f\"{letter} {number}\")` jest wykonana tylko dla `number = 0`,\n"
"- potem wewnętrzna pętla jest zatrzymywana przez `break`, ale\n"
"- zewnętrzna pętla kontynuuje swoje wykonanie, przechodząc do następnej litery `c`\n"
"- która jest wykonana w całości, ponieważ nie powoduje ona wyzwolenia instrukcji `break`."

msgid "pages.IntroducingOr.steps.InputAliceBob.text"
msgstr ""
"Poznaliśmy *wartości logiczne* (`True` i `False`), kiedy wprowadziliśmy instrukcje warunkowe If.\n"
"Dowiedzieliśmy się również o operatorach porównania `==`, `<`, `>`, `<=`, `>=`, które zwracają wartości logiczne.\n"
"Teraz chcemy połączyć wartości logiczne, aby sprawdzić bardziej złożone warunki.\n"
"\n"
"Oto prosty przykład: wyobraź sobie, że masz dwóch przyjaciół, Alicję i Boba.\n"
"Poniższa funkcja przyjmuje jeden parametr, `name`, i sprawdza, czy osoba o podanej nazwie znajduje się wśród Twoich przyjaciół.\n"
"Skopiuj i uruchom kod w edytorze:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingOr.steps.TrueOrTrue.text"
msgstr ""
"Zobaczmy czy możemy to zrobić lepiej.\n"
"Możemy połączyć instrukcje `if` i `elif` za pomocą **`or`**. `or` to *operator logiczny*,\n"
"co znaczy, że jest operatorem (tak jak `+` lub `-`), którzy łączy dwie wartości logiczne (`True` lub `False`).\n"
"\n"
"Wyrażenie `A or B` jest `True`, jeśli albo `A` albo `B` jest `True`, czyli jeśli `A` jest `True` albo `B` jest `True`, lub oba.\n"
"Jest `False` tylko wtedy, gdy ani `A` ani `B` nie jest `True`, czyli oba są `False`.\n"
"\n"
"Spróbuj wykonać następujące polecenie w konsoli.\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.TrueOrFalse.text"
msgstr ""
"Dobrze, teraz spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.FalseOrFalse.text"
msgstr ""
"Na koniec spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingOr.steps.ImprovingWithOr.text"
msgstr ""
"W edytorze zastąp:\n"
"\n"
"__code0__\n"
"\n"
"przez:\n"
"\n"
"__code1__\n"
"\n"
"Jak widzisz, `is_friend` zwróci `True` tylko wtedy, gdy `name` to Alicja lub Bob.\n"
"Operator `or` jest użyty pomiędzy dwoma wartościami logicznymi `name == \"Alice\"` i `name == \"Bob\"`."

msgid "pages.IntroducingOr.steps.FurtherImprovement.text"
msgstr ""
"Możemy to zrobić jeszcze lepiej. Zauważ, że:\n"
"\n"
"__code0__\n"
"\n"
"to wartość logiczna i obie instrukcje `return` zwracają wartości logiczne `True` lub `False`.\n"
"Funkcja:\n"
"\n"
" - zwraca `True`, kiedy `name == \"Alice\" or name == \"Bob\"` jest `True`, oraz\n"
" - zwraca `False`, kiedy `name == \"Alice\" or name == \"Bob\"` jest `False`.\n"
"\n"
"Więc możemy po prostu zwrócić wartość logiczną `name == \"Alice\" or name == \"Bob\"` w obu przypadkach!\n"
"\n"
"To jest częsty wzorzec do upraszczania kodu. Jeżeli kiedykolwiek znajdziesz się pisząc kod w stylu:\n"
"\n"
"__code1__\n"
"\n"
"gdzie `x` samo w sobie jest wartością logiczną, zawsze możesz uproszczyć ten blok kodu do:\n"
"\n"
"__code2__\n"
"\n"
"Zastosuj tę uproszczenie do kodu samodzielnie i uruchom go ponownie."

msgid "pages.IntroducingOr.steps.ACommonMistake.text"
msgstr ""
"Zwróć uważną uwagę, jak napisaliśmy warunek:\n"
"\n"
"__code0__\n"
"\n"
"Powszechnym błędem jest napisanie tego w następujący sposób:\n"
"\n"
"__code1__\n"
"\n"
"Ma to sens, jeśli czytasz to jak po angielsku:\n"
"\n"
"> `return` czy `name` jest równe `\"Alice\"` lub `\"Bob\"`\n"
"\n"
"Ale Python to nie angielski i tak nie działa operator `or`.\n"
"\n"
"Zamień linię z `return` w kodzie na powyższą linię i spróbuj uruchomić to ponownie."

msgid "pages.IntroducingOr.steps.InspectWithBirdseye.text"
msgstr ""
"Drugi i trzeci test nie przechodzą! Nasza funkcja wydaje się robić coś źle:\n"
"zwraca `\"Bob\"` (łańcuch znaków, a nie wartość logiczną!) gdy `name` to `\"Bob\"` lub `\"Charlie\"`. Co się dzieje?\n"
"Uruchom ten sam problematyczny kod ponownie za pomocą `birdseye`. Dokładnie zbadaj instrukcje `return` dla każdego wywołania funkcji `is_friend`.\n"
"(Użyj niebieskich przycisków strzałek)"

msgid "pages.IntroducingOr.steps.AnExercise.text"
msgstr ""
"Przy inspekcji za pomocą `birdseye` możemy zauważyć, że:\n"
"\n"
"__code0__\n"
"\n"
"nie jest tłumaczone na:\n"
"\n"
"__code1__\n"
"\n"
"w sposób, w jaki myślimy po angielsku, ale raczej:\n"
"\n"
"__code2__\n"
"\n"
"co daje jako wynik `\"Bob\"`, gdy `name == \"Alice\"` jest `False`.\n"
"\n"
"Być może teraz myślisz tak:\n"
"\n"
"[![Mam teraz dodatkowe pytania](https://i.imgur.com/jN57tGt.png)](https://imgur.com/a/icKzI)\n"
"\n"
"Jedyna rzecz, którą naprawdę musisz wiedzieć to: dopóki nie wiesz, co robisz, zawsze\n"
"upewnij się, że po obu stronach `or` są wartości logiczne, ponieważ jest to operator logiczny.\n"
"`name == \"Alice\" or \"Bob\"` łamie tę zasadę.\n"
"\n"
"Jeśli jesteś ciekawy, odpowiedzi znajdują się poniżej, ale możesz je pominąć, jeśli chcesz i przejść do ćwiczenia poniżej.\n"
"\n"
"----\n"
"\n"
"> Dlaczego `(name == \"Alice\") or (\"Bob\")` daje wynik `\"Bob\"`? Dlaczego w ogóle daje jakiś wynik? Przecież `\"Bob\"` to nie jest wartość logiczna!\n"
"\n"
"Definicja \"`A or B` jest `True`, jeśli `A` lub `B` jest `True`\" była uproszczeniem. Jest to najłatwiejszy\n"
"sposób myślenia o `or` większość czasu, zwłaszcza przy pisaniu instrukcji `if`.\n"
"Prawdziwa definicja jest taka, że jeśli `A` jest prawdą, to `A or B` to po prostu `A` (w rzeczywistości `B` nawet nie jest oceniane),\n"
"w przeciwnym razie to jest `B`.\n"
"Możesz sam sprawdzić, że jeśli `A` i `B` są wartościami logicznymi, to obie definicje są równoważne.\n"
"W tym przykładzie `A` to `name == \"Alice\"`, co jest `False`, więc `A or B` to `B`, czyli `\"Bob\"`.\n"
"\n"
"> Czy jest lepszy sposób napisania warunku bez powtarzania `name ==` za każdym razem?\n"
"\n"
"Tak! W [Funkcjach i metodach dla list](#FunctionsAndMethodsForLists) wspomnieliśmy operator `in`,\n"
"którego możesz użyć z listą w ten sposób:\n"
"\n"
"__code3__\n"
"\n"
"Ale nie zawsze możesz pozbyć się `or` w ten sposób.\n"
"\n"
"----\n"
"\n"
"Ćwiczenie: Napisz funkcję o nazwie `is_valid_percentage`, przyjmującą jeden argument numeryczny `x`.\n"
"Powinna zwrócić `True`, jeśli `x` jest między 0 a 100 (włącznie), i `False` w przeciwnym razie.\n"
"Twoja funkcja powinna używać `or`, i przejść te testy:\n"
"\n"
"    __copyable__\n"
"__code4__"

msgid "pages.IntroducingOr.steps.final_text.text"
msgstr "Dobra robota!"

msgid "pages.IntroducingAnd.steps.TrueAndTrue.text"
msgstr ""
"Inny operatorem logicznym w Pythonie jest `and`.\n"
"Wyrażenie `A and B` jest `True` tylko wtedy, gdy ZARÓWNO `A`, jak i `B` są `True`. W przeciwnym razie jest `False`.\n"
"Wypróbuj to w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingAnd.steps.TrueAndFalse.text"
msgstr ""
"Dobrze, teraz spróbuj:\n"
"\n"
"__program_indented__\n"
"\n"
"Czego się spodziewasz?"

msgid "pages.IntroducingAnd.steps.FalseAndFalse.text"
msgstr ""
"Na koniec spróbuj:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingAnd.steps.AndExercise.text"
msgstr ""
"Ćwiczmy teraz. Wcześniej napisaliśmy funkcję `is_valid_percentage` używając `or`. Oto przykładowe\n"
"rozwiązanie:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Przepisz tę funkcję używając zamiast tego `and`."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.text"
msgstr ""
"Świetnie! Oto jedno z możliwych rozwiązań:\n"
"\n"
"__code0__\n"
"\n"
"Jak poprzednio, możemy uprościć to rozwiązanie do:\n"
"\n"
"__code1__\n"
"\n"
"Jest jeszcze inny sposób, aby to jeszcze bardziej ulepszyć, zwany łączeniem porównań. Każdy warunek tego typu:\n"
"\n"
"__code2__\n"
"\n"
"można skrócić poprzez usunięcie dodatkowego `and b` do:\n"
"\n"
"__code3__\n"
"\n"
"To działa dla wszystkich operatorów porównania, włączając `==`, a nawet dwa operatory mogą być różne.\n"
"Więc rozwiązanie można uprościć do:\n"
"\n"
"__code4__\n"
"\n"
"Następne ćwiczenie: mając listę trzech elementów, sprawdź, czy wszystkie trzy elementy są sobie równe.\n"
"\n"
"    __copyable__\n"
"__code5__"

msgid "pages.IntroducingAnd.steps.final_text.text"
msgstr ""
"Dobra robota. Istnieje wiele możliwych poprawnych rozwiązań:\n"
"\n"
"__code0__\n"
"\n"
"lub używając ponownie łączenia porównań:\n"
"\n"
"__code1__\n"
"\n"
"lub sprawdzając, czy jest równa liście zawierającej trzy razy pierwszy element:\n"
"\n"
"__code2__"

msgid "pages.MultiLineExpressions.steps.invalid_multiline.text"
msgstr ""
"Nasze linie kodu zaczynają być dość długie.\n"
"Na szczęście Python oferuje kilka sposobów na rozłożenie jednego polecenia na wiele linii,\n"
"ale nie dzieje się to automatycznie. Musisz się upewnić, że Python rozumie, że właśnie to robisz.\n"
"Na przykład ten kod to niepoprawna składnia i spowoduje błąd:\n"
"\n"
"__program_indented__"

msgid "pages.MultiLineExpressions.steps.valid_multiline.text"
msgstr ""
"Python próbuje zinterpretować to jako dwie osobne linie kodu i się gubi. Musisz mu powiedzieć,\n"
"że pierwsza linia jest kontynuowana na drugiej linii.\n"
"\n"
"Jednym ze sposobów, aby to osiągnąć, jest dodanie `\\` na końcu linii, aby 'uciec' przed przerwą w linii.\n"
"\n"
"Innym sposobem jest upewnienie się, że przerwa w linii znajduje się w jakimś rodzaju nawiasów. Wtedy\n"
"kontynuacja linii jest sugerowana, ponieważ Python będzie czekał aż wszystkie nawiasy zostaną zamknięte przed\n"
"uznaniem linii za kompletne. Jeśli już masz nawiasy, na przykład dlatego, że wywołujesz funkcję\n"
"lub tworzysz listę, możesz nie musieć nic robić! W przeciwnym razie możesz dodać nawiasy do dowolnego wyrażenia,\n"
"aby zasugerować kontynuację linii.\n"
"\n"
"Oto kilka przykładów. Zachowaj szczególną uwagę na detale.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.MultiLineExpressions.steps.final_text.text"
msgstr ""
"Więc jeśli otrzymasz tajemniczy `SyntaxError`, upewnij się, że nie "
"rozdzieliłeś niepoprawnie żadnych linii!"

msgid "pages.CombiningAndAndOr.steps.CombiningAndOr.text"
msgstr ""
"Jeśli użyjesz zarówno `and`, jak i `or` w jednym wyrażeniu, jest to bardzo podobne do łączenia `*` i `+`.\n"
"Operatory są ewaluowane w określonej kolejności.\n"
"\n"
"Na przykład, spróbuj następujący kod w konsoli.\n"
"Czego się spodziewasz?\n"
"\n"
"__program_indented__"

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.text"
msgstr ""
"Jeśli przeczytasz to nieuwaznie od lewej do prawej, możesz pomyśleć, że:\n"
"\n"
"__code0__\n"
"\n"
"jest równoważne z\n"
"\n"
"__code1__\n"
"\n"
"ale tak naprawdę jest równoważne z\n"
"\n"
"__code2__\n"
"\n"
"Dzieje się tak, ponieważ `and` ma wyższy priorytet niż `or`.\n"
"Jest to ważne, ponieważ pierwsza interpretacja redukuje się do `True and False`, co daje `False`, podczas gdy druga\n"
"interpretacja redukuje się do `True or False`, co daje `True`!\n"
"Możesz spróbować obie opcje z nawiasami w konsoli, aby to potwierdzić.\n"
"\n"
"**Nauczka stąd jest taka, aby być szczególnie ostrożnym podczas łączenia operatorów.** Albo dodaj nawiasy dla pewności albo\n"
"rozdziel swoje wyrażenie na mniejsze części i każdą część przypisz do zmiennej.\n"
"To sprawi, że twój kod będzie jasny, czytelny i jednoznaczny oraz uchroni cię przed bolesnymi błędami.\n"
"\n"
"Czas na ćwiczenie. Załóżmy, że piszesz program do gry w kółko i krzyżyk,\n"
"znane również jako gra w \"O i X\". Jeśli nigdy nie słyszałeś o kółko i krzyżyk, możesz przeczytać zasady\n"
"i zagrać kilka gier [tutaj](https://gametable.org/games/tic-tac-toe/).\n"
"\n"
"Musimy sprawdzić, czy ktoś wygrał grę. Nasza funkcja `all_equal` jest już przydatna do sprawdzania rzędów.\n"
"\n"
"Napisz funkcję do sprawdzania, czy ktoś wygrał grę poprzez umieszczenie 3 tych samych elementów na jednej z linii przekątnych.\n"
"Plansza jest podana jako zagnieżdżona lista `board` z 3 podlistami, każda podlista zawiera 3 ciągi znaków, reprezentujące rząd. Na przykład:\n"
"\n"
"__code3__\n"
"\n"
"Funkcja powinna zwracać wartość logiczną: `True`, jeśli na jednej z przekątnych są 3 takie same elementy, `False` w przeciwnym przypadku.\n"
"Kliknij przycisk Kopiuj, aby rozpocząć od poniższego kodu.\n"
"Przygotowaliśmy dla Ciebie kilka testów, twoim zadaniem jest zastąpić `...` twoim kodem.\n"
"\n"
"    __copyable__\n"
"__code4__"

msgid "pages.CombiningAndAndOr.steps.final_text.text"
msgstr ""
"Dobra robota! To było trudne. Oto kilka możliwych rozwiązań:\n"
"\n"
"__code0__\n"
"\n"
"albo:\n"
"\n"
"__code1__"

msgid "pages.IntroducingNotPage.steps.IntroducingNot.text"
msgstr ""
"W przeciwieństwie do pozostałych dwóch operatorów logicznych `and` i `or`,\n"
"które są używane między dwoma wartościami logicznymi (nazywane operatorami *binarnymi*),\n"
"`not` jest używany przed tylko jedną wartością logiczną (nazywany operatorem *unarnym*).\n"
"Neguje on wyrażenie, do którego jest stosowany, trochę jak znak minus. Spróbuj w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingNotPage.steps.NotFalse.text"
msgstr ""
"Teraz spróbuj następującego:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingNotPage.steps.NotTrueOrTrue.text"
msgstr ""
"Jaki jest priorytet `not` w porównaniu z `and` i `or`? Spróbuj następującego w `birdseye`:\n"
"\n"
"__code0__"

msgid "pages.IntroducingNotPage.steps.NotPriority.text"
msgstr ""
"Możesz zobaczyć w `birdseye`, że\n"
"\n"
"__code0__\n"
"\n"
"jest interpretowany przez Pythona jako\n"
"\n"
"__code1__\n"
"\n"
"a nie:\n"
"\n"
"__code2__\n"
"\n"
"Więc `not` ma wyższy priorytet niż `or`, jeżeli nie używamy nawiasów. To tak samo, jak\n"
"\n"
"__code3__\n"
"\n"
"oznacza:\n"
"\n"
"__code4__\n"
"\n"
"a nie\n"
"\n"
"__code5__\n"
"\n"
"`not` ma również wyższy priorytet niż `and`.\n"
"\n"
"Ponownie, najważniejsze jest, aby używać nawiasów lub dodatkowych zmiennych, gdy masz wątpliwości.\n"
"\n"
"Ćwiczenie: Załóżmy, że piszesz program do przetwarzania obrazów. Tylko niektóre rodzaje plików mogą być przetwarzane.\n"
"Jeśli użytkownik dostarczy plik, który nie może być przetworzony, chcesz wyświetlić błąd:\n"
"\n"
"__code6__\n"
"\n"
"Załóżmy, że pliki .png i .jpg mogą być przetwarzane, ale inne typy plików nie mogą.\n"
"Oto przykładowa funkcja do tego:\n"
"\n"
"    __copyable__\n"
"__code7__\n"
"\n"
"Jest ona dłuższa niż musi. Przepisz funkcję `invalid_image` tak, aby ciało funkcji składało się z jednej linii `return <expression>`,\n"
"czyli bez instrukcji `if`. Powinna przejść te same testy."

msgid "pages.IntroducingNotPage.steps.final_text.text"
msgstr ""
"Dobrze zrobione! Oto dwie poprawne rozwiązania:\n"
"\n"
"__code0__\n"
"\n"
"(jeśli jesteś ciekawy, są one równoważne ze względu na coś, co nazywa się prawem De Morgana)\n"
"\n"
"Zwróć również uwagę, że jest to kolejny ogólny wzorzec, który można uprościć: jeśli twój kod ma formę:\n"
"\n"
"__code1__\n"
"\n"
"gdzie `x` sam w sobie jest wartością logiczną, to można to uprościć do:\n"
"\n"
"__code2__"

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.text"
msgstr ""
"Wykonałeś już wiele krótkich ćwiczeń, rozwiązując małe problemy. Teraz zmierzymy się z większym, bardziej złożonym\n"
"projektem, który naprawdę przetestuje twoją wiedzę i wymaga połączenie wielu mniejszych części.\n"
"To będzie naprawdę wspaniała zabawa!\n"
"\n"
"Stworzysz tekstową interaktywną grę w kółko i krzyżyk dla 2 graczy-ludzi.\n"
"Oto mała zapowiedź tego, jak będzie wyglądać ukończona gra:\n"
"\n"
"      1 2 3\n"
"    1  | |\n"
"      -+-+-\n"
"    2  | |\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"    Gracz X:\n"
"    1\n"
"    1\n"
"\n"
"      1 2 3\n"
"    1 X| |\n"
"      -+-+-\n"
"    2  | |\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"    Gracz O:\n"
"    2\n"
"    2\n"
"\n"
"      1 2 3\n"
"    1 X| |\n"
"      -+-+-\n"
"    2  |O|\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"    Gracz X:\n"
"    1\n"
"    3\n"
"\n"
"      1 2 3\n"
"    1 X| |X\n"
"      -+-+-\n"
"    2  |O|\n"
"      -+-+-\n"
"    3  | |\n"
"\n"
"Podzielimy projekt na kilka małych funkcji, które będą ćwiczeniami.\n"
"\n"
"Wykorzystasz wiele koncepcji, które już poznałeś: łańcuchy znaków,\n"
"zagnieżdżone listy, zagnieżdżone pętle, `range`, wywoływanie funkcji w funkcjach, porównania i wartości logiczne.\n"
"\n"
"Po drodze nauczysz się również nowych koncepcji, w tym znaków nowej linii, typów i `input()`.\n"
"\n"
"Oto przybliżony zarys projektu:\n"
"\n"
"- trzy funkcje `row_winner`, `column_winner`,  `diagonal_winner` sprawdzające całą planszę pod kątem wygrywających rzędów, kolumn i przekątnych\n"
"- funkcja `winner` sprawdzająca całą planszę pod kątem zwycięzcy, łącząca powyższe funkcje\n"
"- funkcja `format_board` wyświetlająca aktualny stan gry\n"
"- funkcja `play_move` przyjmująca dane wejściowe użytkownika, aby wykonać ruch\n"
"- w końcu funkcja `play_game`, która scala wszystko razem i prowadzi grę interaktywnie.\n"
"- Później dodamy kolejne ulepszenia.\n"
"\n"
"Zaczynajmy!\n"
"\n"
"Tak jak w ostatnim rozdziale, planszę w kółko i krzyżyk będziemy reprezentować jako zagnieżdżoną listę łańcuchów znaków.\n"
"Dla typowej gry będzie to lista 3x3, czyli 3 listy zawierające po 3 łańcuchy znaków, z graczami reprezentowanymi przez `'X'` lub `'O'`.\n"
"Puste kwadraty będą reprezentowane przez spację, czyli `' '`. Na przykład:\n"
"\n"
"__code0__\n"
"\n"
"Jednak żeby było ciekawiej, twój kod będzie musiał działać dla kwadratowych plansz o dowolnym rozmiarze\n"
"(4x4, 5x5 itd.), gdzie gracze mogą być reprezentowani przez dowolne łańcuchy znaków, np.\n"
"\n"
"__code1__\n"
"\n"
"Napisz funkcję `row_winner`, która zwraca `True`, jeśli `board` zawiera\n"
"wygrywający rząd, czyli poziomą linię, która ma tę samą postać we wszystkich swoich wpisach (z wyjątkiem `' '`):\n"
"\n"
"    __copyable__\n"
"__code2__\n"
"\n"
"W drugim przykładzie `O` wygrywa w dolnym rzędzie."

msgid "pages.IntroducingTicTacToe.steps.column_winner.text"
msgstr ""
"Świetna robota!\n"
"\n"
"Teraz napisz podobną funkcję `column_winner`, która sprawdzi wygraną w *kolumnie* (pionowej linii) dla jednego z graczy:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Tutaj `O` wygrało w drugiej kolumnie na drugiej planszy."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.text"
msgstr ""
"Doskonale! To było wymagające.\n"
"\n"
"Na koniec musimy sprawdzić wygrywające przekątne. Napisałeś już funkcję, która robiła dokładnie to w poprzednim rozdziale, dla plansz 3x3:\n"
"\n"
"__code0__\n"
"\n"
"Teraz napisz funkcję `diagonal_winner`, która będzie działać dla kwadratowych plansz dowolnego rozmiaru: 4x4, 5x5 itd.\n"
"\n"
"    __copyable__\n"
"__code1__\n"
"\n"
"W pierwszym przykładzie `X` wygrało na przekątnej biegnącej od lewego dolnego rogu do prawego górnego rogu."

msgid "pages.IntroducingTicTacToe.steps.winner.text"
msgstr ""
"Brawo! To było całkiem trudne.\n"
"\n"
"Teraz możemy połączyć trzy funkcje! Napisz funkcję `winner`, która przyjmuje argument `board` tak jak wcześniej\n"
"i zwraca `True`, jeśli `board` zawiera wygrywający rząd, kolumnę lub przekątną, w przeciwnym razie `False`.\n"
"\n"
"Twoje rozwiązanie powinno działać poprzez wywołanie trzech funkcji. Sam `winner` nie powinien używać żadnych pętli, indeksowania itd.\n"
"\n"
"Oto kod dla `row_winner`, `column_winner` i `diagonal_winner`, wraz z kilkoma testami dla `winner`.\n"
"Kliknij przycisk Kopiuj i uzupełnij brakujące miejsca dla Twojej funkcji `winner`.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.IntroducingTicTacToe.steps.final_text.text"
msgstr ""
"Świetna robota!\n"
"\n"
"Teraz mamy kod, który pozwala określić stan wygrywający na planszy."

msgid "pages.NewlinesAndFormatBoard.steps.one_way_to_print_board.text"
msgstr ""
"Następnie chcielibyśmy rozwiązać problem wyświetlania planszy do gry w kółko i krzyżyk. Oto jeden ze sposobów na to:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"(Co to jest `\"\".join`? Wyszukaj to!)"

msgid "pages.NewlinesAndFormatBoard.steps.invalid_multi_line_string.text"
msgstr ""
"To dobry początek, ale idealnie byśmy chcieli funkcję, która *zwraca* łańcuch znaków zamiast go drukować.\n"
"W ten sposób inny kod może w łatwy sposób używać tego łańcucha znaków na różne sposoby. Możemy chcieć manipulować łańcuchem\n"
"(na przykład otoczyć go ramką lub wyekstrahować tylko kilka pierwszych linii), możemy chcieć wysłać go gdzieś innym niż na ekran\n"
"(np. do pliku) i w tym konkretnym przypadku chcemy mieć możliwość testowania go przy użyciu `assert_equal`. To nie działa:\n"
"\n"
"__code0__\n"
"\n"
"ponieważ `print_board` nie używa `return`, więc domyślnie zwraca `None`.\n"
"Zamiast tego chcielibyśmy mieć kod w stylu:\n"
"\n"
"__code1__\n"
"\n"
"Wtedy `print(format_board(board))` powinien wydrukować coś podobnego do tego, co widzieliśmy na początku.\n"
"Ale jak zwrócić łańcuch znaków z wieloma liniami? I jak to przetestować? Chcielibyśmy zrobić coś takiego:\n"
"\n"
"    __copyable__\n"
"__code2__\n"
"\n"
"Zobacz sam, jak to nie działa."

msgid ""
"pages.NewlinesAndFormatBoard.steps.multi_line_strings_triple_quotes.text"
msgstr ""
"Zwykle łańcuch znaków musi znajdować się w jednej linii, więc taki zapis jest nieprawidłowy:\n"
"\n"
"    string = \"Pierwsza linia\n"
"    Druga linia\"\n"
"    print(string)\n"
"\n"
"Ale Python dostarcza rozwiązanie! Jest nim użycie *potrójnych cudzysłowów*, czyli trzech znaków cudzysłowia pod rząd\n"
"(albo `'''` albo `\"\"\"`) wokół zawartości łańcucha znaków. Uruchom następujący kod:\n"
"\n"
"__program_indented__"

msgid "pages.NewlinesAndFormatBoard.steps.discovering_newline.text"
msgstr ""
"Hurra! *Łańcuch znaków pomiędzy potrójnymi cudzysłowami* może rozciągać się na wiele linii i będą one wyświetlane na wyjściu.\n"
"\n"
"Podobnie jak pojedyncze i podwójne cudzysłowy, potrójne cudzysłowy są tylko innym rodzajem notacji, a nie nowym rodzajem łańcucha znaków.\n"
"`\"\"\"abc\"\"\"` to to samo co `\"abc\"`.\n"
"\n"
"Jednakże łańcuch `string` zawiera coś nowego. Uruchom `__program__` w konsoli, żeby zobaczyć."

msgid "pages.NewlinesAndFormatBoard.steps.introducing_newline.text"
msgstr ""
"Oto sekret!\n"
"\n"
"`\\n` reprezentuje ***znak nowej linii***. To jest po prostu inny znak, podobnie jak litera czy spacja (`' '`).\n"
"To znak, który występuje między dwoma oddzielnymi liniami, który wpisujesz, naciskając Enter na klawiaturze.\n"
"\n"
"Ponownie, `\\n` *reprezentuje* znak nowej linii w literalach łańcuchowych w Pythonie.\n"
"Łańcuch znaków tak naprawdę nie zawiera `\\` i `n`, zawiera tylko jeden znak. Sprawdź to w konsoli:\n"
"\n"
"__code0__"

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.text"
msgstr ""
"Teraz użyj znaku nowej linii, aby napisać funkcję `format_board` (twoje rozwiązanie powinno działać dla kwadratowej `board` dowolnego rozmiaru):\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.text"
msgstr ""
"Świetnie! Typowe rozwiązanie wygląda tak:\n"
"\n"
"__code0__\n"
"\n"
"Jeśli sprawdziłeś, jak działa `join` i użyłeś go w swoim rozwiązaniu, to bardzo dobrze!\n"
"Możesz to również było rozwiązane w taki sposób:\n"
"\n"
"__code1__\n"
"\n"
"Jeśli chcesz, możesz teraz przejść do [następnej strony](#Types). Lub możesz podjąć dodatkowe wyzwanie!\n"
"\n"
"Napisz ulepszoną wersję funkcji `format_board`, która wyświetla separatory rzędów i kolumn. Na przykład, jeśli\n"
"\n"
"__code2__\n"
"\n"
"to `print(format_board(board))` powinno wydrukować\n"
"\n"
"    X|O|X\n"
"    -+-+-\n"
"     |O|O\n"
"    -+-+-\n"
"     |X|\n"
"\n"
"Ponownie powinno to działać dla kwadratowej `board` *dowolnego rozmiaru*.\n"
"\n"
"Zachęcamy do użycia `join` w tym ćwiczeniu. Podajemy jeden test jak poprzednio, możesz napisać dodatkowe testy:\n"
"\n"
"    __copyable__\n"
"__code3__"

msgid "pages.NewlinesAndFormatBoard.steps.final_text.text"
msgstr ""
"Świetna robota! To było całkiem wymagające.\n"
"\n"
"Teraz opanowałeś umiejętność tworzenia łańcucha znaków z wielu linii tekstu oraz rozwiązałeś problem wyświetlania planszy graczom.\n"
"\n"
"Następnie dowiesz się więcej o typach w Pythonie, o tym, jak je konwertować, oraz o tym, jak uzyskiwać dane wejściowe od graczy.\n"
"Jesteś już w połowie drogi do ukończenia projektu. Tak trzymaj!"

msgid "pages.Types.steps.five_different_types.text"
msgstr ""
"Do tej pory zobaczyliśmy różne rodzaje danych: łańcuchy znaków, listy, liczby i wartości logiczne.\n"
"Nazywane są one *typami*. Każda wartość ma swój typ, który wpływa na jej zachowanie\n"
"i może być ujawniony za pomocą funkcji `type`:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.Types.steps.check_type_manually.text"
msgstr ""
"Python zgłasza najpierw, że `type('Hello World')` to `<class 'str'>`. Na razie nie przejmuj się słowem `class`.\n"
"`str` to skrót od *string*.\n"
"\n"
"Następnie `True` to `bool` (skrót od *boolean*) i `[1, 2, 3]` ma typ `list`.\n"
"\n"
"Zauważ, że istnieją dwa typy dla liczb:\n"
"\n"
"- `int`, skrót od 'integer', oznacza liczby całkowite, czyli bez ułamków lub przecinków.\n"
"- `float`, skrót od 'floating point number', jest dla liczb z przecinkiem i ewentualnie częścią ułamkową.\n"
"\n"
"W większości przypadków nie musisz martwić się o różne typy numerów, ponieważ można je mieszać podczas wykonywania operacji matematycznych.\n"
"\n"
"Typy to wartości, które mogą być używane na różne sposoby, podobnie jak inne wartości.\n"
"Na przykład, wypróbuj to w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.Types.steps.different_types_look_same.text"
msgstr ""
"Wartości różnych typów są zazwyczaj dość różne od siebie, ale mogą wyglądać podobnie, gdy są wydrukowane,\n"
"co może być mylące. Spróbuj tego:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"(Możesz użyć `print(repr(123))` i `print(repr('123'))`, aby zauważyć różnicę. Co to jest `repr`? Wyszukaj to w Google!)"

msgid "pages.Types.steps.plus_has_two_meanings.text"
msgstr ""
"Różne typy mają różne metody i obsługują różne operatory.\n"
"Ten sam metod lub operator może również oznaczać inne rzeczy.\n"
"Na przykład, zobacz, jak `+` ma różne znaczenia dla `str` i `int`:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.Types.steps.less_than_has_two_meanings.text"
msgstr ""
"W przypadku dwóch liczb całkowitych `+` działa jako dodawanie, natomiast dla dwóch łańcuchów znaków działanie to oznacza konkatenację.\n"
"Python automatycznie rozpoznaje znaczenie `+` na podstawie typów danych wejściowych.\n"
"Podobnie `<` działa inaczej na dwóch łańcuchach znaków i dwóch liczbach całkowitych:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.Types.steps.less_than_sorting_strings.text"
msgstr ""
"Więc `<` działa jako zwykłe 'mniejsze niż' między dwiema liczbami całkowitymi, ponieważ `13` jest mniejsze niż `120`,\n"
"ale działa jako porządkowanie słownikowe między dwoma łańcuchami znaków: `13` jest 'alfabetycznie' po `120`\n"
"ponieważ `3` występuje po `2`.\n"
"\n"
"Zobacz jakie to robi różnice, kiedy sortujesz listę:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.Types.steps.common_type_errors.text"
msgstr ""
"Co się stanie, jeśli użyjesz operatora między `str` a `int`? Spróbuj w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.Types.steps.fixing_type_errors_with_conversion.text"
msgstr ""
"Użycie łańcucha znaków zamiast liczby całkowitej w `range` jak w `range('5')`,\n"
"lub w indeksowaniu listy jak w `list['3']` również spowoduje błąd.\n"
"\n"
"Większość tych problemów można rozwiązać, konwertując łańcuch znaków na liczbę całkowitą poprzez użycie `int` jako funkcji:\n"
"`int('5')` zwróci liczbę całkowitą `5`.\n"
"Podobnie, liczbę całkowitą można przekonwertować na łańcuch znaków za pomocą funkcji `str`:\n"
"`str(5)` zwróci łańcuch znaków `'5'`.\n"
"\n"
"Wykorzystując tę nową wiedzę, napraw ten uszkodzony program:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Poprawny program powinien wypisać:\n"
"\n"
"    Starting... 1\n"
"    Starting... 2\n"
"    Starting... 3\n"
"    Go!\n"
"\n"
"Twoje rozwiązanie powinno działać dla dowolnej wartości zmiennej `number`."

msgid "pages.Types.steps.format_board_with_numbers.text"
msgstr ""
"Napisz ulepszoną wersję `format_board`, która zawiera numery wierszy i kolumn, takie jak:\n"
"\n"
"     123\n"
"    1XOX\n"
"    2 OO\n"
"    3 X\n"
"\n"
"Powinna działać dla plansz o dowolnym, jednocyfrowym rozmiarze. Oto przypadek testowy:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.Types.steps.final_text.text"
msgstr ""
"Świetnie!\n"
"\n"
"Przy okazji, kiedy musisz połączyć łańcuchy znaków i liczby, pamiętaj, że możesz również\n"
"używać f-stringów. Często wyglądają one lepiej.\n"
"\n"
"Nauczyłeś się o typach w Pythonie i jak unikać wspólnych błędów poprzez konwersję typów.\n"
"Kontynuuj prace nad resztą projektu!"

msgid "pages.InteractiveProgramsWithInput.steps.first_input.text"
msgstr ""
"Programy, które do tej pory napisaliśmy, nie są interaktywne.\n"
"Aby nasza interaktywna gra w kółko i krzyżyk była możliwa, będziemy potrzebować metody odbierania wprowadzeń od graczy.\n"
"Python pozwala nam na to za pomocą wbudowanej funkcji `input`. Uruchom ten program:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Gdy `name = input()` zostanie wykonane, program faktycznie zatrzymuje się i czeka, aż coś wpiszesz w konsoli i naciśniesz Enter,\n"
"więc musisz to zrobić, aby program został zakończony."

msgid "pages.InteractiveProgramsWithInput.steps.convert_input_to_int.text"
msgstr ""
"To, co wpisałeś (nie uwzględniając naciśnięcia Enter na końcu), jest zwracane przez funkcję `input()` jako łańcuch znaków.\n"
"\n"
"Istotne jest, aby zrozumieć, że `input()` ***zawsze zwraca łańcuch znaków***, bez względu na to, co użytkownik wpisał.\n"
"To Ty decydujesz o konwersji tego łańcucha na typ danych, który jest potrzebny.\n"
"Zapominanie o tym szczególe jest częstym źródłem mylących błędów.\n"
"\n"
"Na przykład, ten program na pierwszy rzut oka wygląda dobrze, ale jeśli go wypróbujesz, zobaczysz, że tak naprawdę nie działa:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Napraw program, aby kiedy użytkownik wpisze wartość `super_secret_number` (`7` w tym przykładzie),\n"
"program wyświetlił `Amazing! Are you psychic?` jak oczekiwano.\n"
"Powinno to działać, kiedy `super_secret_number` jest dowolną liczbą całkowitą (`int`)."

msgid "pages.InteractiveProgramsWithInput.steps.final_text.text"
msgstr ""
"Doskonale!\n"
"\n"
"Istnieją dwa główne sposoby naprawienia tego problemu. Możesz konwertować wprowadzone dane na liczbę:\n"
"\n"
"__code0__\n"
"\n"
"albo przekonwertować poprawną odpowiedź na łańcuch znaków:\n"
"\n"
"__code1__\n"
"\n"
"Ważną różnicą między tymi dwiema metodami jest to, że pierwsze podejście spowoduje wystąpienie błędu,\n"
"jeśli użytkownik wpisze coś, co nie jest liczbą, co może być albo nie być tym, czego chcesz."

msgid "pages.NestedListAssignment.steps.modify_list_in_function.text"
msgstr ""
"Widzieliśmy, jak uzyskać dane wejściowe od użytkownika, teraz użyjmy tego, aby faktycznie umieścić pionki\n"
"na planszy i zagrać w grę. Na początek wypróbuj ten kod:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.NestedListAssignment.steps.nested_assignment_two_lines.text"
msgstr ""
"Zauważ, jak wywołanie `play_move(game_board, 'X')` faktycznie *modyfikuje* `game_board` bezpośrednio.\n"
"Zmienna `board` wewnątrz wywołania `play_move` i zmienna `game_board` wewnątrz wywołania `play_game` wskazują na ten sam obiekt listy.\n"
"Nie ma kopiowania. Python Tutor jest dobry w pokazywaniu tego za pomocą strzałek.\n"
"\n"
"To również oznacza, że w tym przypadku nie ma potrzeby, aby `play_move` coś zwracało,\n"
"może po prostu zmodyfikować `board`, a wywołujący (w tym przypadku `play_game`) zobaczy efekt.\n"
"\n"
"Jednak nasza plansza jest dwuwymiarowa, reprezentowana przez zagnieżdżoną listę.\n"
"Więc musimy przypisać `player` do elementu listy wewnętrznej, coś na zasadzie:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.NestedListAssignment.steps.nested_assignment_input.text"
msgstr ""
"Te dwie linie:\n"
"\n"
"__code0__\n"
"\n"
"mogą zostać połączone w jedną:\n"
"\n"
"__code1__\n"
"\n"
"Te dwa fragmenty kodu są niemal dokładnie równoważne. Python najpierw ocenia `board[1]`, aby *uzyskać* listę wewnętrzną, podczas gdy `[0] = ...` ustawia element `board[1]`.\n"
"Możesz zobaczyć wartość `board[1]` w `birdseye`, ponieważ jest to wyrażenie, i właściwie możesz zastąpić je dowolnym innym wyrażeniem.\n"
"\n"
"Teraz, gdy wiesz, jak ustawić elementy w zagnieżdżonych listach, czas to uczynić interaktywnym!\n"
"Napisz własną wersję funkcji `play_move`, która pobiera dane wejściowe od użytkownika, aby ustalić, gdzie zagrać, zamiast grać zawsze na `board[1][0]`.\n"
"Powinna ona wywołać funkcję `input()` dwukrotnie, aby użytkownik mógł podać wiersz i kolumnę jako dwa oddzielne liczby. Ponadto, nasi użytkownicy nie są programistami, więc zaczynają liczyć od 1, a nie 0.\n"
"\n"
"Na przykład, jeśli użytkownik wpisze te dane wejściowe:\n"
"\n"
"__code2__\n"
"\n"
"to znaczy, że chcą wykonać ruch w drugim wierszu i pierwszej kolumnie, co jest takie samo jak w naszym pierwotnym przykładzie.\n"
"\n"
"Oto jakiś początkowy kod:\n"
"\n"
"    __copyable__\n"
"__code3__\n"
"\n"
"To wywołuje funkcję `play_move` dwa razy, więc użytkownik będzie musiał podać dwie pary liczb.\n"
"Oto przykład tego, jak powinna wyglądać 'gra':\n"
"\n"
"     123\n"
"    1\n"
"    2\n"
"    3\n"
"\n"
"    X na ruch:\n"
"\n"
"__code2__\n"
"     123\n"
"    1\n"
"    2X\n"
"    3\n"
"\n"
"    O na ruch:\n"
"\n"
"    1\n"
"    3\n"
"     123\n"
"    1  O\n"
"    2X\n"
"    3\n"
"\n"
"Nie musisz używać dostarczonego kodu dokładnie, to tylko, aby dać ci poczucie tego, co się dzieje.\n"
"Ważne jest, aby twoja funkcja `play_move` poprawnie modyfikowała argument `board`.\n"
"Nie musi niczego zwracać ani wyświetlać, to nie będzie sprawdzane.\n"
"\n"
"Możesz zakładać, że użytkownik zawsze poda prawidłowe liczby. Później dowiemy się, jak radzić sobie z nieprawidłowymi danymi wejściowymi, takimi jak liczby spoza zakresu lub dane wejściowe, które w ogóle nie są liczbami."

msgid "pages.NestedListAssignment.steps.final_text.text"
msgstr ""
"Świetnie! Jesteś już prawie gotowy, żeby złożyć to wszystko w całość, "
"kontynuuj!"

msgid "pages.MakingTheBoard.steps.naive_make_board.text"
msgstr ""
"Do tej pory plansza była dostarczana dla Ciebie jako zagnieżdżona lista.\n"
"Ale dla pełnego programu musisz ją stworzyć sam.\n"
"To powinno być łatwe, prawda? Oto kilka linijek kodu do tego:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Jest to niemal poprawne, ale jest w tym subtelny problem.\n"
"Upewnij się, że rozumiesz kod,\n"
"i dodatkowe punkty, jeśli potrafisz zauważyć błąd!\n"
"Jeśli nie, nie martw się i nie trac za dużo czasu na to."

msgid "pages.MakingTheBoard.steps.fix_make_board.text"
msgstr ""
"Czy widzisz, co się stało?\n"
"\n"
"Każdy wiersz dostał „X” na pierwszej pozycji!\n"
"To tak, jakby kod faktycznie zrobił to:\n"
"\n"
"__code0__\n"
"\n"
"Podejmij próbę i zobacz, co jest nie tak samodzielnie.\n"
"Ale ponownie, to zawiłe, więc nie doprowadzaj się do szału przez to.\n"
"\n"
"Jeśli chcesz, oto kilka wskazówek:\n"
"\n"
" - Spróbuj uruchomić kod w kilku debuggerach.\n"
" - Eksperymentuj. Dokonuj zmian w kodzie i zobacz, co się stanie.\n"
" - Nie, kod nie wykonał 3 przypisań, jak sugerowałem wyżej. Było tylko jedno przypisanie listy.\n"
" - Nie ma żadnych ukrytych pętli czy czegoś podobnego.\n"
" - Ile list zawiera `board`? 3?\n"
" - Na poprzedniej stronie jest subtelna wskazówka na temat tego, co się stało.\n"
" - Jest strona z poprzedniego rozdziału, gdzie ten rodzaj problemu jest wyjaśniony bezpośrednio.\n"
" - W szczególności [ta strona](#EqualsVsIs).\n"
" - Spróbuj uruchomić kod przy pomocy Python Tutor.\n"
"\n"
"OK, jeśli jesteś gotowy, oto odpowiedź.\n"
"\n"
"Lista `row` została stworzona tylko raz i użyta kilka razy.\n"
"`board` zawiera tę samą listę trzy razy. Nie kopie, tylko jedną listę w trzech miejscach.\n"
"To tak, jakby zrobiło to:\n"
"\n"
"__code1__\n"
"\n"
"Co oznacza, że ten kod:\n"
"\n"
"__code2__\n"
"\n"
"jest równoznaczny z:\n"
"\n"
"__code3__\n"
"\n"
"co wpływa na 'wszystkie listy' w `board`, ponieważ wszystkie one są po prostu tą jedną listą `row`.\n"
"Innymi słowy, powyższa linijka jest *również* równoznaczna z każdą z tych dwóch linii:\n"
"\n"
"__code4__\n"
"\n"
"ponieważ `row` to `board[0]`, `board[1]` i `board[2]` naraz.\n"
"\n"
"Twoim zadaniem teraz jest naprawić `make_board`, aby nie miało tego problemu.\n"
"Nadal powinna zwracać listę o długości `size`, gdzie każdy\n"
"element to również lista o długości `size`, w której każdy element to łańcuch znaków `' '`.\n"
"Podlisty powinny być wszystkie oddzielnymi obiektami list, a nie tą samą\n"
"listą powtórzoną."

msgid "pages.MakingTheBoard.steps.final_text.text"
msgstr ""
"Świetna robota!\n"
"\n"
"To można było rozwiązać, przenosząc pierwszą pętlę do wnętrza drugiej, aby każdorazowo tworzyć nowy `row`:\n"
"\n"
"__code0__\n"
"\n"
"Innym sposobem jest skopiowanie `row` za każdym razem, na przykład zachować oryginalny kod, ale zmienić jedną linię:\n"
"\n"
"__code1__\n"
"\n"
"Możesz również skopiować `row` używając `row[:]` lub `list(row)`. Ale ważne jest, aby wiedzieć, że\n"
"wszystkie te metody tworzą *płytką kopię* listy.\n"
"Oznacza to, że kopiują całą listę na najwyższym poziomie, bez tworzenia kopii każdego elementu.\n"
"W tym przypadku, kiedy `row` zawiera tylko łańcuchy znaków, które nie mogą być zmodyfikowane\n"
"i nie potrzebują kopiowania, to wystarczy. Ale jeśli elementy to obiekty zmienne, takie jak listy,\n"
"jak w przypadku `board`, możesz napotkać ten sam problem ponownie.\n"
"Oto przykład:\n"
"\n"
"    __copyable__\n"
"__code2__\n"
"\n"
"Tutaj każdy element `cube` to oddzielna lista, kopia `board`.\n"
"I w każdej z tych kopii, każdy element to również oddzielna lista, kopia `row`.\n"
"Ale płytkie kopie `board` mają wszystkie ten sam pierwszy element (pierwsza kopia `row`),\n"
"taki sam drugi element, i tak dalej.\n"
"Zmiana `make_board` tu nic nie naprawi, rozwiązaniem jest albo:\n"
"\n"
"- wielokrotne wywoływanie `make_board`, aby za każdym razem utworzyć nowy `board`, albo\n"
"- użycie funkcji `deepcopy` zamiast `board.copy()`.\n"
"  `deepcopy` tworzy kopie na każdym poziomie zagnieżdżonych obiektów.\n"
"\n"
"Jeśli to ciągle jest dla ciebie mylące, nie martw się.\n"
"To po prostu przygotowuje cię do radzenia sobie z dziwnym zachowaniem twojego kodu w przyszłości.\n"
"Nie musisz tego rozumieć od razu, ta lekcja będzie wartościowa i tak.\n"
"\n"
"Tak czy inaczej, jesteśmy gotowi do stworzenia pełnej gry. Dasz radę!"

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.text"
msgstr ""
"Nadszedł czas, aby zebrać to wszystko razem! Poniżej znajduje się kod, którym możesz się rozpocząć.\n"
"\n"
"Zawiera implementacje różnych funkcji, które zdefiniowaliśmy na poprzednich stronach do rozwiązywania części\n"
"problemu, używając niektórych sztuczek, których jeszcze się nie nauczyłeś, aby je skrócić. Nie zmieniaj ich.\n"
"\n"
"Twoim zadaniem jest prawidłowa implementacja funkcji `play_game`. Obecna implementacja pokazuje, co\n"
"powinno się wydarzyć na początku gry, ale to oczywiście niekompletne.\n"
"Rozwiązanie powinno działać dla dowolnej wielkości planszy i kontynuować grę aż do jej zakończenia.\n"
"Ostatnią rzeczą, którą `play_game` powinna zrobić, to wywołanie `print_winner(player)`\n"
"jeśli `winner(board)` jest prawdziwe, lub wywołanie `print_draw()` jeśli plansza jest wypełniona bez zwycięzcy.\n"
"\n"
"Możesz założyć, że użytkownik wprowadzi tylko prawidłowe dane,\n"
"to znaczy numery od 1 do `board_size` aby wybrać komórkę na planszy, która nie jest już zajęta.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.TheFullTicTacToeGame.steps.final_text.text"
msgstr ""
"### ***GRATULACJE!!!***\n"
"\n"
"Udało Ci się!"

msgid "code_bits.'hello '"
msgstr "'cześć '"

msgid "code_bits.'world'"
msgstr "'świat'"

msgid "code_bits.'hello'"
msgstr "'cześć'"

msgid "code_bits.' world'"
msgstr "' świat'"

msgid "code_bits.word"
msgstr "słowo"

msgid "code_bits.'Hello'"
msgstr "'Witaj'"

msgid "code_bits.__program_indented__"
msgstr "__program_indented__"

msgid "code_bits.'Goodbye'"
msgstr "'Żegnaj'"

msgid "code_bits.sentence"
msgstr "zdanie"

msgid "code_bits.character"
msgstr "znak"

msgid "code_bits.name"
msgstr "imię"

msgid "code_bits.'World'"
msgstr "'Świat'"

msgid "code_bits.temp"
msgstr "temp"

msgid "code_bits.hello"
msgstr "cześć"

msgid "code_bits.line"
msgstr "linia"

msgid "code_bits.char"
msgstr "char"

msgid "code_bits.'Hello World'"
msgstr "'Witaj Świat'"

msgid "code_bits.excited"
msgstr "podekscytowany"

msgid "code_bits.confused"
msgstr "zdezorientowany"

msgid "code_bits.new_sentence"
msgstr "nowe_zdanie"

msgid "code_bits.x1"
msgstr "x1"

msgid "code_bits.'Charlie'"
msgstr "'Charlie'"

msgid "code_bits.x2"
msgstr "x2"

msgid "code_bits.'Alice'"
msgstr "'Alicja'"

msgid "code_bits.x3"
msgstr "x3"

msgid "code_bits.'Bob'"
msgstr "'Bob'"

msgid "code_bits.first"
msgstr "pierwszy"

msgid "code_bits.numbers"
msgstr "liczby"

msgid "code_bits.new_numbers"
msgstr "nowe_liczby"

msgid "code_bits.element"
msgstr "element"

msgid "code_bits.some_list"
msgstr "jakaś_lista"

msgid "code_bits.found"
msgstr "znaleziono"

msgid "code_bits.thing"
msgstr "rzecz"

msgid "code_bits.things"
msgstr "rzeczy"

msgid "code_bits.thing_to_find"
msgstr "rzecz_do_znalezienia"

msgid "code_bits.words"
msgstr "słowa"

msgid "code_bits.char1"
msgstr "char1"

msgid "code_bits.char2"
msgstr "char2"

msgid "code_bits.string1"
msgstr "łańcuch1"

msgid "code_bits.string2"
msgstr "łańcuch2"

msgid "code_bits.new_value"
msgstr "nowa_wartość"

msgid "code_bits.index"
msgstr "indeks"

msgid "code_bits.value"
msgstr "wartość"

msgid "code_bits.insert_one_line_from_above"
msgstr "wstaw_jedną_linię_z_góry"

msgid "code_bits.'yes'"
msgstr "'tak'"

msgid "code_bits.nums"
msgstr "liczby"

msgid "code_bits.list2"
msgstr "lista2"

msgid "code_bits.list1"
msgstr "lista1"

msgid "code_bits.number"
msgstr "numer"

msgid "code_bits.\"Alice\""
msgstr "\"Alicja\""

msgid "code_bits.friend"
msgstr "przyjaciel"

msgid "code_bits.meal"
msgstr "posiłek"

msgid "code_bits.\"lunch\""
msgstr "\"lunch\""

msgid "code_bits.\" with \""
msgstr "\" z \""

msgid "code_bits.\" went to \""
msgstr "\" poszedł do \""

msgid "code_bits.f\"{name} went to {meal} with {friend}.\""
msgstr "\"{name} poszedł na {meal} z {friend}.\""

msgid "code_bits.players"
msgstr "gracze"

msgid "code_bits.\"Bob\""
msgstr "\"Bob\""

msgid "code_bits.\"Charlie\""
msgstr "\"Charlie\""

msgid "code_bits.letters"
msgstr "litery"

msgid "code_bits.\"ABCD\""
msgstr "\"ABCD\""

msgid "code_bits.size"
msgstr "rozmiar"

msgid "code_bits.'Dylan'"
msgstr "'Dylan'"

msgid "code_bits.f'{players[i]} vs {players[j]}'"
msgstr "'{players[i]} kontra {players[j]}'"

msgid "code_bits.strings"
msgstr "łańcuchy znaków"

msgid "code_bits.\"abc\""
msgstr "\"abc\""

msgid "code_bits.\"def\""
msgstr "\"def\""

msgid "code_bits.\"ghi\""
msgstr "\"ghi\""

msgid "code_bits.string"
msgstr "łańcuch znaków"

msgid "code_bits.\"today?\""
msgstr "\"dziś?\""

msgid "code_bits.sublist"
msgstr "podlista"

msgid "code_bits.num"
msgstr "num"

msgid "code_bits.\"hello\""
msgstr "\"cześć\""

msgid "code_bits.\"hello there\""
msgstr "\"cześć tam\""

msgid "code_bits.\"how are you\""
msgstr "\"jak się masz\""

msgid "code_bits.\"goodbye world\""
msgstr "\"do widzenia świat\""

msgid "code_bits.\"hello world\""
msgstr "\"cześć świat\""

msgid "code_bits.\"goodbye\""
msgstr "\"do widzenia\""

msgid "code_bits.\"Python\""
msgstr "\"Python\""

msgid "code_bits.greet"
msgstr "powitać"

msgid "code_bits.f\"Hello {name}!\""
msgstr "\"Witaj {name}!\""

msgid "code_bits.\"How are you?\""
msgstr "\"Jak się masz?\""

msgid "code_bits.Hello"
msgstr "Cześć"

msgid "code_bits.\"Hello\""
msgstr "\"Cześć\""

msgid "code_bits.print_many"
msgstr "wydrukuj_wiele"

msgid "code_bits.quadruple"
msgstr "poczwórny"

msgid "code_bits.double"
msgstr "podwójny"

msgid "code_bits.assert_equal"
msgstr "zakładaj_równe"

msgid "code_bits.actual"
msgstr "rzeczywisty"

msgid "code_bits.expected"
msgstr "oczekiwany"

msgid "code_bits.\"OK\""
msgstr "\"OK\""

msgid "code_bits.f\"Error! {repr(actual)} != {repr(expected)}\""
msgstr "\"Błąd! {repr(actual)} != {repr(expected)}\""

msgid "code_bits.\"++more++\""
msgstr "\"++więcej++\""

msgid "code_bits.\"=the same=\""
msgstr "\"=takie samo=\""

msgid "code_bits.surround"
msgstr "otoczyć"

msgid "code_bits.\"more\""
msgstr "\"więcej\""

msgid "code_bits.\"the same\""
msgstr "\"takie samo\""

msgid "code_bits.\"!! Warning !!\""
msgstr "\"!! Ostrzeżenie !!\""

msgid "code_bits.\"!!!! DANGER !!!!\""
msgstr "\"!!!! NIEBEZPIECZEŃSTWO !!!!\""

msgid "code_bits.alert"
msgstr "alarm"

msgid "code_bits.\"Warning\""
msgstr "\"Ostrzeżenie\""

msgid "code_bits.\"DANGER\""
msgstr "\"NIEBEZPIECZEŃSTWO\""

msgid "code_bits.condition"
msgstr "warunek"

msgid "code_bits.value1"
msgstr "wartość1"

msgid "code_bits.value2"
msgstr "wartość2"

msgid "code_bits.double_numbers"
msgstr "podwaja_liczby"

msgid "code_bits.doubles"
msgstr "podwojenia"

msgid "code_bits.is_valid_percentage"
msgstr "czy_poprawny_procent"

msgid "code_bits.all_equal"
msgstr "wszystkie_równe"

msgid "code_bits.row"
msgstr "wiersz"

msgid "code_bits.diagonal_winner"
msgstr "zwycięzca_na_przekątnej"

msgid "code_bits.board"
msgstr "plansza"

msgid "code_bits.middle"
msgstr "środek"

msgid "code_bits.diagonal1"
msgstr "przekątna1"

msgid "code_bits.diagonal2"
msgstr "przekątna2"

msgid "code_bits.invalid_image"
msgstr "niepoprawny_obraz"

msgid "code_bits.\"dog.png\""
msgstr "\"pies.png\""

msgid "code_bits.\"cat.jpg\""
msgstr "\"kot.jpg\""

msgid "code_bits.\"invoice.pdf\""
msgstr "\"faktura.pdf\""

msgid "code_bits.\".png\""
msgstr "\".png\""

msgid "code_bits.\".jpg\""
msgstr "\".jpg\""

msgid "code_bits.filename"
msgstr "nazwa_pliku"

msgid "code_bits.\"I can't process \""
msgstr "\"Nie mogę przetworzyć \""

msgid "code_bits.row_winner"
msgstr "zwycięzca_w_rzędzie"

msgid "code_bits.column_winner"
msgstr "zwycięzca_w_kolumnie"

msgid "code_bits.winner"
msgstr "zwycięzca"

msgid "code_bits.winning_line"
msgstr "linia_zwycięska"

msgid "code_bits.piece"
msgstr "figura"

msgid "code_bits.entry"
msgstr "wpis"

msgid "code_bits.col"
msgstr "kolumna"

msgid "code_bits.column"
msgstr "kolumna"

msgid "code_bits.format_board"
msgstr "formatuj_planszę"

msgid "code_bits.print_board"
msgstr "wydrukuj_planszę"

msgid "code_bits.'XOX\\nO  \\n XO'"
msgstr "'XOX\\nO  \\n XO'"

msgid "code_bits.result"
msgstr "rezultat"

msgid "code_bits.'\\n'"
msgstr "'\\n'"

msgid "code_bits.'X|O|X\\n-+-+-\\nO| | \\n-+-+-\\n |X|O'"
msgstr "'X|O|X\\n-+-+-\\nO| | \\n-+-+-\\n |X|O'"

msgid "code_bits.joined_rows"
msgstr "połączone_wiersze"

msgid "code_bits.\"\\n\""
msgstr "\"\\n\""

msgid "code_bits.'Go!'"
msgstr "'Ruszaj!'"

msgid "code_bits.'Starting... '"
msgstr "'Rozpoczynanie... '"

msgid "code_bits.' 123\\n1XOX\\n2O  \\n3 XO'"
msgstr "' 123\\n1XOX\\n2O  \\n3 XO'"

msgid "code_bits.super_secret_number"
msgstr "super_tajna_liczba"

msgid "code_bits.guess"
msgstr "zgadnij"

msgid "code_bits.\"What number am I thinking of?\""
msgstr "\"O jakiej liczbie myślę?\""

msgid "code_bits.\"Amazing! Are you psychic?\""
msgstr "\"Niesamowite! Jesteś jasnowidzem?\""

msgid "code_bits.\"Nope!\""
msgstr "\"Nie!\""

msgid "code_bits.play_game"
msgstr "zagraj_w_grę"

msgid "code_bits.play_move"
msgstr "wykonaj_ruch"

msgid "code_bits.first_row"
msgstr "pierwszy_wiersz"

msgid "code_bits.joined_row"
msgstr "połączony_wiersz"

msgid "code_bits.'\\nX to play:\\n'"
msgstr "'\\nX do gry:\\n'"

msgid "code_bits.'\\nO to play:\\n'"
msgstr "'\\nO do gry:\\n'"

msgid "code_bits.player"
msgstr "gracz"

msgid "code_bits.make_board"
msgstr "stworz_plansze"

msgid "code_bits.make_cube"
msgstr "stworz_sześcian"

msgid "code_bits.test"
msgstr "test"

msgid "code_bits.cube"
msgstr "sześcian"

msgid "code_bits.main_diagonal_winner"
msgstr "zwycięzca_na_głównej_przekątnej"

msgid "code_bits.print_winner"
msgstr "wydrukuj_zwycięzcę"

msgid "code_bits.print_draw"
msgstr "wydrukuj_remis"

msgid "code_bits.f'\\n  {\"+\".join(\"-\" * size)}\\n'"
msgstr "f'\\n  {\"+\".join(\"-\" * size)}\\n'"

msgid "code_bits.rows"
msgstr "wiersze"

msgid ""
"code_bits.f'  {\" \".join(str(i + 1) for i in "
"range(size))}\\n{line.join(rows)}'"
msgstr "f'  {\" \".join(str(i + 1) for i in range(size))}\\n{line.join(wiersze)}'"

msgid "code_bits.f'{i + 1} {\"|\".join(row)}'"
msgstr "f'{i + 1} {\"|\".join(wiersz)}'"

msgid "code_bits.f'{player} to play:'"
msgstr "f'{gracz} do gry:'"

msgid "code_bits.f'{player} wins!'"
msgstr "f'{gracz} wygrywa!'"

msgid "code_bits.\"It's a draw!\""
msgstr "\"To remis!\""

msgid "code_bits.board_size"
msgstr "wielkość_planszy"

msgid "code_bits.player1"
msgstr "gracz1"

msgid "code_bits.player2"
msgstr "gracz2"

msgid "pages.BuildingUpStrings.steps.empty_string.text"
msgstr ""
"Ostatni znak w `name` zostaje dodany do `line` dopiero na końcu pętli, po tym jak `print(line)` zostało już wykonane po raz ostatni. Dlatego ten znak oraz pełna `name` nigdy nie są wyświetlane na dole trójkąta. Jeśli jesteś zdezorientowany, spróbuj umieścić `print(line)` zarówno przed, jak i po `line = line + char`.\n"
"\n"
"Pozbądźmy się tych znaków `-` w wyniku. Możesz już być w stanie się domyślić jak.\n"
"\n"
"*Pusty ciąg* to ciąg znaków nie zawierający w ogóle żadnych znaków.\n"
"Jest napisany jako para cudzysłowów otaczających nic: `''`.\n"
"Jest jak zero ciągów znaków.\n"
"Dodanie go do innego ciągu po prostu daje ci ten sam niezmieniony ciąg,\n"
"w taki sam sposób, jak `0 + 5` jest po prostu `5`.\n"
"\n"
"Wypróbuj to w konsoli:\n"
"\n"
"__program_indented__"

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.text"
msgstr ""
"Nie myl pustego ciągu znaków z `' '`, który jest niepustym ciągiem znaków zawierającym jeden znak: spację.\n"
"\n"
"Teraz popraw oryginalny program, aby pozbyć się tych linii w wyjściu, tak aby\n"
"dla `name = 'World'` wydrukowało:\n"
"\n"
"    __no_auto_translate__\n"
"    W\n"
"    Wo\n"
"    Wor\n"
"    Worl\n"
"    World"

msgid "pages.AddingStrings.steps.hello_world_space.hints.0.text"
msgstr "Spacja jest znakiem tak jak każdy inny, jak `o` lub `w`."

msgid "pages.AddingStrings.steps.hello_world_space.hints.1.text"
msgstr "Znak spacji musi być umieszczony wewnątrz cudzysłowów."

msgid "pages.UsingVariables.steps.word_plus_name_with_space.hints.0.text"
msgstr "Będziesz musiał użyć `+` dwa razy, tak jak w 1+2+3."

msgid "pages.UsingVariables.steps.word_plus_name_with_space.hints.1.text"
msgstr ""
"Twoja odpowiedź powinna zawierać mieszaninę zmiennych (bez cudzysłowów) i "
"literałów napisowych (w cudzysłowach)."

msgid "pages.UsingVariables.steps.word_plus_name_with_space.hints.2.text"
msgstr "Będziesz musiał mieć znak spacji wewnątrz cudzysłowów."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_1.hints.0.text"
msgstr ""
"Powinieneś użyć tylko jednego `print`, ponieważ każde wywołanie print "
"wypisuje tekst w nowej linii."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_1.hints.1.text"
msgstr "Będziesz musiał użyć `+`."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_2.hints.0.text"
msgstr ""
"Aby napisać program, który wydrukuje zmienną `name` 3 razy, można zrobić to w następujący sposób:\n"
"\n"
"```python\n"
"name = 'World'\n"
"print(name + name + name)\n"
"```"

msgid "pages.BasicForLoopExercises.steps.loop_exercise_2.hints.1.text"
msgstr ""
"Rozwiązanie będzie wyglądać bardzo podobnie do innych programów, które "
"widzieliśmy w tej sekcji."

msgid "pages.BasicForLoopExercises.steps.loop_exercise_2.hints.2.text"
msgstr ""
"Pętla for utworzy zmienną taką jak `character`, ale program nie musi jej "
"wykorzystywać."

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.0.text"
msgstr ""
"Najpierw upewnij się, że nie pracujesz na uszkodzonej wersji poprzedniego "
"programu na tej stronie."

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.1.text"
msgstr ""
"To znaczy, `line = line + char` powinno znajdować się przed `print(line)`."

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.2.text"
msgstr "Poza tym, musisz dokonać tylko jednej ***drobnej*** zmiany."

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.3.text"
msgstr "Chcemy pozbyć się '-'. Więc po prostu to zrób. Dosłownie."

msgid "pages.BuildingUpStrings.steps.name_triangle_empty_string.hints.4.text"
msgstr "Użyj pustego łańcucha znaków!"

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_spaced.hints.0.text"
msgstr "Będziesz musiał użyć jeszcze jednego `+`."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_spaced.hints.1.text"
msgstr ""
"Będziesz musiał użyć łańcucha znaków składającego się z jednej spacji: `' "
"'`."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.0.text"
msgstr ""
"Rozwiązanie jest bardzo podobne do oryginalnego programu trójkąta, wystarczy"
" wprowadzić jedną małą zmianę."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.1.text"
msgstr ""
"Nadal chcesz dodawać po jednym znaku do zmiennej `line` za każdym razem, "
"tylko kwestia jest, gdzie go dodajesz."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.2.text"
msgstr ""
"Chcesz, aby linie były odwrócone, więc musisz odwrócić/coś przewrócić."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.3.text"
msgstr "Musisz dodać znak przed łańcuchem znaków, zamiast po nim."

msgid ""
"pages.BuildingUpStringsExercises.steps.name_triangle_backwards.hints.4.text"
msgstr ""
"3 + 7 jest równe 7 + 3. To samo dotyczy wszystkich liczb. Czy to również "
"prawda dla łańcuchów znaków?"

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.hints.0.text"
msgstr "Spójrz na program trójkąta w poszukiwaniu inspiracji."

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.hints.1.text"
msgstr ""
"Spójrz na program, w którym drukowałeś `name` raz dla każdego znaku, w "
"poszukiwaniu inspiracji."

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.hints.2.text"
msgstr ""
"Będziesz musiał zbudować łańcuch znaków z kresek (`-`), dodając po jednym "
"znaku za każdym razem."

msgid "pages.BuildingUpStringsExercises.steps.name_underlined.hints.3.text"
msgstr ""
"Pętla for utworzy zmienną taką jak `char`, ale program nie musi jej "
"wykorzystywać."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.0.text"
msgstr ""
"Wykonałeś już całą trudną pracę w poprzednim ćwiczeniu. Teraz to tylko "
"proste dodawanie łańcuchów znaków."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.1.text"
msgstr ""
"Potrzebujesz tylko jednej pętli for - tej, która została użyta do stworzenia"
" linii kresek z poprzedniego ćwiczenia."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.2.text"
msgstr ""
"Nie próbuj robić wszystkiego naraz. Podziel problem na mniejsze, łatwiejsze "
"podproblemy."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.3.text"
msgstr ""
"Spróbuj napisać program, który wyświetli:\n"
"\n"
"    -----\n"
"    Świat\n"
"    -----"

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.4.text"
msgstr ""
"Ponieważ musisz wyświetlić trzy oddzielne linie tekstu, będziesz musiał "
"wywołać `print()` trzy razy."

msgid "pages.BuildingUpStringsExercises.steps.name_box.hints.5.text"
msgstr ""
"Spróbuj napisać program, który wyświetli:\n"
"\n"
"    |Świat|"

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.hints.0.text"
msgstr "Będziesz potrzebował dwóch oddzielnych pętli for dla `name`."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.hints.1.text"
msgstr ""
"Każda linia oprócz pierwszej i ostatniej ma te same znaki w środku. To "
"oznacza, że możesz coś ponownie wykorzystać."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.hints.2.text"
msgstr "Stwórz zmienną zawierającą spacje w środku i użyj jej wielokrotnie."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.hints.3.text"
msgstr ""
"Użyj jednej pętli do stworzenia sporej liczby spacji, a drugiej pętli do "
"wydrukowania wielu linii, wykorzystując wcześniej utworzone spacje."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.0.text"
msgstr ""
"Pierwsza litera powinna mieć 0 spacji przed nią, druga litera powinna mieć 1"
" spację przed nią, trzecia powinna mieć 2 spacje, itd."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.1.text"
msgstr ""
"Powinieneś przechowywać spacje w zmiennej i budować je w pętli, tak jak "
"wcześniej."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.2.text"
msgstr ""
"Różnica polega na tym, że musisz drukować litery jednocześnie z budowaniem "
"spacji."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.3.text"
msgstr ""
"Innymi słowy, potrzebujesz jednej pętli, która wykonuje obie te czynności."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.4.text"
msgstr "Ciało pętli musi wydrukować spacje i literę, a także dodać spację."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.hints.5.text"
msgstr ""
"Ponieważ przed pierwszą literą nie powinno być spacji, musisz dodać spację "
"po wydrukowaniu litery."

msgid ""
"pages.IntroducingIfStatements.steps.excited_confused_exercise.hints.0.text"
msgstr ""
"Musisz dodać tylko kilka linii do istniejącego programu. Wszystkie "
"istniejące kody powinny pozostać bez zmian."

msgid ""
"pages.IntroducingIfStatements.steps.excited_confused_exercise.hints.1.text"
msgstr "Kod, który dodasz, powinien być bardzo podobny do istniejącego kodu."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.0.text"
msgstr ""
"Kod powinien być prawie dokładnie taki sam, wystarczy wprowadzić kilka "
"niewielkich zmian."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.1.text"
msgstr ""
"Upewnij się, że kod wewnątrz `if include:` wykonuje się na początku pętli, w"
" pierwszej iteracji."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.2.text"
msgstr "To oznacza, że `include` powinien mieć wartość `True` w tym momencie."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.3.text"
msgstr ""
"Upewnij się, że kod wewnątrz `if include:` *nie* wykonuje się po pierwszej "
"iteracji."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_first_character.hints.4.text"
msgstr "To oznacza, że `include` powinien być `False` po pierwszej iteracji."

msgid "pages.IfAndElse.steps.capitalise.hints.0.text"
msgstr ""
"Nauczyłeś się wszystkich narzędzi potrzebnych do tego. Wierzę w Ciebie! "
"Spójrz na poprzednie programy, aby znaleźć inspirację."

msgid "pages.IfAndElse.steps.capitalise.hints.1.text"
msgstr ""
"Będziesz potrzebować pętli, aby skonstruować nowe zdanie znak po znaku."

msgid "pages.IfAndElse.steps.capitalise.hints.2.text"
msgstr ""
"Będziesz potrzebować instrukcji `if/else`, aby wybrać, czy dodać znak "
"wielkiej czy małej litery."

msgid "pages.IfAndElse.steps.capitalise.hints.3.text"
msgstr ""
"Twoje `if/else` musi wykonywać różne bloki kodu w zależności od tego, w "
"której iteracji pętli się znajduje."

msgid "pages.IfAndElse.steps.capitalise.hints.4.text"
msgstr ""
"To oznacza, że warunek w twojej instrukcji `if` musi być zmienną, która "
"zmienia się wewnątrz pętli."

msgid "pages.IfAndElse.steps.capitalise.hints.5.text"
msgstr ""
"W pierwszej iteracji potrzebujesz wielkiej litery. W kolejnych iteracjach "
"potrzebujesz małej litery."

msgid "pages.IfAndElse.steps.spongebob.hints.0.text"
msgstr ""
"To jest podobne do poprzedniego ćwiczenia. Różnica polega na tym, kiedy i "
"gdzie ustawiasz zmienną warunkową."

msgid "pages.IfAndElse.steps.spongebob.hints.1.text"
msgstr ""
"Będziesz potrzebować zmiennej logicznej, która zmienia swoją wartość z każdą"
" iteracją."

msgid "pages.IfAndElse.steps.spongebob.hints.2.text"
msgstr ""
"```python\n"
"zmienna = __code0__  # Załóżmy, że __code0__ to albo True albo False\n"
"\n"
"if zmienna:\n"
"    zmienna = False\n"
"else:\n"
"    zmienna = True\n"
"\n"
"print(zmienna)\n"
"```"

msgid "pages.IfAndElse.steps.spongebob.hints.3.text"
msgstr ""
"```python\n"
"zmienna = __code0__  # Zakładając, że __code0__ to albo True albo False\n"
"\n"
"if zmienna:\n"
"    zmienna = False\n"
"else:\n"
"    zmienna = True\n"
"\n"
"print(zmienna)\n"
"```"

msgid "pages.IfAndElse.steps.spongebob.hints.4.text"
msgstr ""
"```python\n"
"zmienna = __code0__  # Zakładając, że __code0__ to albo True albo False\n"
"znak = __code1__  # Zakładając, że __code1__ to znak, który chcemy zmienić\n"
"\n"
"if zmienna:\n"
"    nowy_znak = znak.upper()\n"
"    zmienna = False\n"
"else:\n"
"    nowy_znak = znak.lower()\n"
"    zmienna = True\n"
"\n"
"print(nowy_znak)\n"
"```"

msgid ""
"pages.TheEqualityOperator.steps.if_equals_replacing_characters_exercise.hints.0.text"
msgstr ""
"```python\n"
"zmienna = __code0__  # Zakładając, że __code0__ to albo True albo False\n"
"znak = __code1__  # Zakładając, że __code1__ to znak, który chcemy zmienić\n"
"\n"
"if zmienna:\n"
"    nowy_znak = znak.upper()\n"
"else:\n"
"    nowy_znak = znak.lower()\n"
"\n"
"zmienna = not zmienna\n"
"\n"
"print(nowy_znak)\n"
"```"

msgid "pages.IntroducingElif.steps.dna_example_with_else.hints.0.text"
msgstr ""
"```python\n"
"zmienna = not __code0__\n"
"```"

msgid "pages.IntroducingElif.steps.dna_example_with_else.hints.1.text"
msgstr ""
"```python\n"
"zmienna = __code0__  # Zakładając, że __code0__ to albo True albo False\n"
"znak = __code1__  # Zakładając, że __code1__ to znak 'G' lub 'C'\n"
"\n"
"if znak == 'G':\n"
"    nowy_znak = 'C'\n"
"else:\n"
"    nowy_znak = 'G'\n"
"\n"
"zmienna = not zmienna\n"
"\n"
"print(nowy_znak)\n"
"```"

msgid "pages.OtherComparisonOperators.steps.min_three_exercise.hints.0.text"
msgstr ""
"```python\n"
"x1 = __code0__\n"
"x2 = __code1__\n"
"\n"
"if x1 < x2:\n"
"    najmniejsza = x1\n"
"else:\n"
"    najmniejsza = x2\n"
"\n"
"print(najmniejsza)\n"
"```"

msgid "pages.OtherComparisonOperators.steps.min_three_exercise.hints.1.text"
msgstr ""
"```python\n"
"x1 = __code0__\n"
"x2 = __code1__\n"
"\n"
"if x1 < x2:\n"
"    print(x1)\n"
"else:\n"
"    print(x2)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum.hints.0.text"
msgstr ""
"```python\n"
"x1 = __code0__\n"
"x2 = __code1__\n"
"\n"
"najmniejsza = ''\n"
"if x1 < x2:\n"
"    najmniejsza += x1\n"
"else:\n"
"    najmniejsza += x2\n"
"\n"
"print(najmniejsza)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum.hints.1.text"
msgstr ""
"```python\n"
"x1 = __code0__\n"
"x2 = __code1__\n"
"\n"
"if x1 < x2:\n"
"    mniejsza = x1\n"
"else:\n"
"    mniejsza = x2\n"
"\n"
"print(mniejsza)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum.hints.2.text"
msgstr ""
"```python\n"
"x1 = __code0__\n"
"x2 = __code1__\n"
"\n"
"if x1 < x2:\n"
"    mniejsza = x1\n"
"else:\n"
"    mniejsza = x2\n"
"\n"
"print(mniejsza)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum.hints.3.text"
msgstr ""
"```python\n"
"x1 = __code0__\n"
"x2 = __code1__\n"
"\n"
"if x1 < x2:\n"
"    print(x1)\n"
"else:\n"
"    print(x2)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum.hints.4.text"
msgstr ""
"Tak, istnieje podobne pojęcie wśród łańcuchów znaków do liczby 0, jest to "
"pusty łańcuch znaków, reprezentowany przez '' (dwa pojedyncze cudzysłowy bez"
" żadnych znaków pomiędzy nimi) lub \"\" (dwa podwójne cudzysłowy bez żadnych"
" znaków pomiędzy nimi)."

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.0.text"
msgstr ""
"```python\n"
"x1 = __code0__\n"
"x2 = __code1__\n"
"\n"
"if x1 < x2:\n"
"    result = x1\n"
"else:\n"
"    result = x2\n"
"\n"
"print(result)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.1.text"
msgstr ""
"```python\n"
"x1 = __code0__\n"
"x2 = __code1__\n"
"\n"
"if x1 < x2:\n"
"    print(x1)\n"
"else:\n"
"    print(x2)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.2.text"
msgstr ""
"```python\n"
"# Zakładamy, że 'words' to lista słów, a 'separator' to łańcuch znaków używany jako separator\n"
"words = __code0__  # np. ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # np. ', '\n"
"\n"
"result = ''\n"
"for word in words:\n"
"    result += word + separator\n"
"\n"
"# Usuwamy ostatni separator z końca wynikowego łańcucha znaków\n"
"result = result[:-len(separator)]\n"
"\n"
"print(result)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.3.text"
msgstr ""
"```python\n"
"words = __code0__  # np. ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # np. ', '\n"
"\n"
"result = ''\n"
"for i, word in enumerate(words):\n"
"    if i > 0:\n"
"        result += separator\n"
"    result += word\n"
"\n"
"print(result)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.4.text"
msgstr ""
"```python\n"
"words = __code0__  # np. ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # np. ', '\n"
"\n"
"result = ''\n"
"for word in words:\n"
"    if result:  # Jeżeli 'result' nie jest pustym łańcuchem znaków, dodajemy separator przed słowem\n"
"        result += separator\n"
"    result += word\n"
"\n"
"print(result)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.5.text"
msgstr ""
"```python\n"
"words = __code0__  # np. ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # np. ', '\n"
"\n"
"result = separator.join(words)  # Łączenie słów w liście za pomocą separatora\n"
"\n"
"print(result)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.6.text"
msgstr ""
"```python\n"
"words = __code0__  # na przykład ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # na przykład ', '\n"
"\n"
"# Rozpoczęcie wyniku od pierwszego słowa w liście, aby ominąć dodawanie separatora w pierwszej iteracji\n"
"result = words[0]\n"
"\n"
"# Iterowanie przez pozostałe słowa w liście i dodawanie ich z separatorem\n"
"for word in words[1:]:\n"
"    result += separator + word\n"
"\n"
"print(result)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.7.text"
msgstr ""
"```python\n"
"words = __code0__  # na przykład ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # na przykład ', '\n"
"\n"
"result = \"\"\n"
"for i, word in enumerate(words):\n"
"    if i == len(words) - 1:  # Jeśli to jest ostatnie słowo w liście, nie dodawaj separatora\n"
"        result += word\n"
"    else:\n"
"        result += word + separator  # Dodanie słowa i separatora\n"
"\n"
"print(result)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.8.text"
msgstr ""
"```python\n"
"words = __code0__  # na przykład ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # na przykład ', '\n"
"\n"
"result = ''\n"
"for i, word in enumerate(words):\n"
"    result += word\n"
"    if i < len(words) - 1:  # Jeżeli to nie jest ostatnia iteracja, dodaj separator\n"
"        result += separator\n"
"\n"
"print(result)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.9.text"
msgstr ""
"```python\n"
"words = __code0__  # na przykład ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # na przykład ', '\n"
"\n"
"result = ''\n"
"for i, word in enumerate(words):\n"
"    result += word\n"
"    if i != len(words) - 1:  # Dodaj separator tylko jeśli to nie jest ostatnia iteracja\n"
"        result += separator\n"
"\n"
"print(result)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.10.text"
msgstr ""
"```python\n"
"words = __code0__  # na przykład ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # na przykład ', '\n"
"\n"
"result = ''\n"
"for i, word in enumerate(words):\n"
"    if i == 0:  # Jeśli to jest pierwsza iteracja, nie dodawaj separatora\n"
"        result += word\n"
"    else:\n"
"        result += separator + word  # W każdej kolejnej iteracji dodaj separator przed słowem\n"
"\n"
"print(result)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.11.text"
msgstr ""
"```python\n"
"words = __code0__  # na przykład ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # na przykład ', '\n"
"\n"
"result = ''\n"
"first_iteration = True  # Zmienna śledząca, czy jesteśmy w pierwszej iteracji\n"
"\n"
"for word in words:\n"
"    if not first_iteration:  # Jeśli to nie jest pierwsza iteracja, dodaj separator przed słowem\n"
"        result += separator\n"
"    result += word\n"
"    first_iteration = False  # Po pierwszej iteracji ustawiamy zmienną na False\n"
"\n"
"print(result)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.12.text"
msgstr ""
"```python\n"
"words = __code0__  # na przykład ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # na przykład ', '\n"
"\n"
"result = ''\n"
"pierwsza_iteracja = True  # Zmienna śledząca, czy jesteśmy w pierwszej iteracji\n"
"\n"
"for word in words:\n"
"    if not pierwsza_iteracja:  # Jeśli to nie jest pierwsza iteracja, dodaj separator przed słowem\n"
"        result += separator\n"
"    result += word\n"
"    pierwsza_iteracja = False  # Po pierwszej iteracji ustawiamy zmienną na False\n"
"\n"
"print(result)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.13.text"
msgstr ""
"```python\n"
"words = __code0__  # na przykład ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # na przykład ', '\n"
"\n"
"result = ''\n"
"pierwsza_iteracja = True  # Zmienna śledząca, czy jesteśmy w pierwszej iteracji\n"
"\n"
"for word in words:\n"
"    if pierwsza_iteracja:\n"
"        result += word\n"
"        pierwsza_iteracja = False  # Ustawienie zmiennej na False po pierwszej iteracji\n"
"    else:\n"
"        result += separator + word  # Dodawanie separatora przed słowem w pozostałych iteracjach\n"
"\n"
"print(result)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.14.text"
msgstr ""
"```python\n"
"words = __code0__  # na przykład ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # na przykład ', '\n"
"\n"
"result = ''\n"
"for word in words:\n"
"    if result:  # Jeśli w zmiennej result jest już jakiś tekst, dodaj separator\n"
"        result += separator\n"
"    result += word  # Dodaj kolejne słowo do wyniku\n"
"\n"
"print(result)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.15.text"
msgstr ""
"```python\n"
"words = __code0__  # na przykład ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # na przykład ', '\n"
"\n"
"result = words[0]  # Rozpocznij wynik od pierwszego słowa\n"
"for word in words[1:]:  # Iteruj przez listę pomijając pierwsze słowo\n"
"    result += separator + word  # Dodaj separator, a następnie słowo\n"
"\n"
"print(result)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.16.text"
msgstr ""
"```python\n"
"words = __code0__  # przykładowo ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # przykładowo ', '\n"
"\n"
"result = ''  # Rozpoczęcie pustego łańcucha znaków do akumulacji wyniku\n"
"\n"
"for word in words:\n"
"    if result:  # Jeżeli w zmiennej result jest już jakiś tekst (nie jest pusty)\n"
"        result += separator  # Najpierw dodaj separator\n"
"    result += word  # Następnie dodaj słowo\n"
"\n"
"print(result)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.17.text"
msgstr ""
"```python\n"
"words = __code0__  # na przykład ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # na przykład ', '\n"
"\n"
"result = ''\n"
"pierwsza_iteracja = True  # Zmienna śledząca, czy jesteśmy w pierwszej iteracji\n"
"\n"
"for word in words:\n"
"    if pierwsza_iteracja:\n"
"        result += word\n"
"        pierwsza_iteracja = False  # Zmień zmienną na False po dodaniu pierwszego słowa\n"
"    else:\n"
"        result += separator + word  # W pozostałych iteracjach dodaj najpierw separator, potem słowo\n"
"\n"
"print(result)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.18.text"
msgstr ""
"```python\n"
"words = __code0__  # na przykład ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # na przykład ', '\n"
"\n"
"result = ''\n"
"pierwsze_słowo = True  # Zmienna śledząca, czy jesteśmy przy pierwszym słowie listy\n"
"\n"
"for word in words:\n"
"    if pierwsze_słowo:\n"
"        result += word\n"
"        pierwsze_słowo = False  # Zmiana zmiennej na False po dodaniu pierwszego słowa\n"
"    else:\n"
"        result += separator + word  # W każdej następnej iteracji dodajemy najpierw separator, potem słowo\n"
"\n"
"print(result)\n"
"```"

msgid "pages.IntroducingLists.steps.strings_sum_bonus.hints.19.text"
msgstr ""
"```python\n"
"words = __code0__  # przykładowo ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # przykładowo ', '\n"
"\n"
"result = ''\n"
"to_pierwsza_iteracja = True  # Zmienna śledząca, czy jest to pierwsza iteracja\n"
"\n"
"for word in words:\n"
"    if to_pierwsza_iteracja:  # Sprawdź, czy to jest pierwsza iteracja\n"
"        result += word  # Jeśli tak, dodaj tylko słowo\n"
"        to_pierwsza_iteracja = False  # Zmień wartość zmiennej, aby oznaczyć koniec pierwszej iteracji\n"
"    else:\n"
"        result += separator + word  # W kolejnych iteracjach dodaj separator przed słowem\n"
"\n"
"print(result)\n"
"```"

msgid "pages.BuildingNewLists.steps.double_numbers.hints.0.text"
msgstr ""
"```python\n"
"words = __code0__  # na przykład ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # na przykład ', '\n"
"\n"
"result = separator.join(words)  # Połącz słowa z listy używając separatora\n"
"\n"
"# Poniższy kod pokazuje, jak można pomnożyć liczby używając `*`\n"
"liczba1 = 3\n"
"liczba2 = 4\n"
"wynik_mnozenia = liczba1 * liczba2\n"
"print(f\"Wynik mnożenia: {wynik_mnozenia}\")\n"
"```"

msgid "pages.BuildingNewLists.steps.double_numbers.hints.1.text"
msgstr ""
"```python\n"
"words = __code0__  # na przykład ['jabłko', 'banan', 'wiśnia']\n"
"separator = __code1__  # na przykład ', '\n"
"\n"
"result = ''  # Zacznij od pustego łańcucha znaków\n"
"first_iteration = True  # Zmienna do sprawdzenia, czy to pierwsza iteracja\n"
"\n"
"# Ten program jest bardzo podobny do programów, które napisałeś do budowania łańcuchów znaków znak po znaku.\n"
"for word in words:\n"
"    if first_iteration:\n"
"        result += word  # Dodaj słowo bez separatora\n"
"        first_iteration = False  # Ustaw wartość na False, ponieważ to już nie będzie pierwsza iteracja\n"
"    else:\n"
"        result += separator + word  # W następnych iteracjach dodaj separator przed słowem\n"
"\n"
"print(result)\n"
"```"

msgid "pages.BuildingNewLists.steps.double_numbers.hints.2.text"
msgstr ""
"```python\n"
"nowa_lista = []  # Utwórz nową pustą listę\n"
"\n"
"# Następnie zbuduj ją element po elemencie w pętli for.\n"
"for i in range(__code0__):  # Na przykład range(5) dla i od 0 do 4\n"
"    nowa_lista.append(__code1__)  # Dodaj element do listy, na przykład element może być 'element' + str(i)\n"
"\n"
"print(nowa_lista)\n"
"```"

msgid "pages.BuildingNewLists.steps.double_numbers.hints.3.text"
msgstr ""
"```python\n"
"# Zacznij od pustej listy.\n"
"lista = []\n"
"\n"
"# Tutaj możesz dodawać elementy do listy w pętli for lub w inny sposób zależnie od potrzeb programu.\n"
"for element in __code0__:  # Przykładowe źródło elementów do dodania\n"
"    lista.append(element)  # Dodaj element do listy\n"
"\n"
"print(lista)\n"
"```"

msgid "pages.BuildingNewLists.steps.double_numbers.hints.4.text"
msgstr ""
"```python\n"
"# Możesz utworzyć listę z jednym elementem `x`, po prostu pisząc `[x]`.\n"
"element_x = __code0__  # Na przykład 'wartość'\n"
"lista_z_jednym_elementem = [element_x]\n"
"\n"
"print(lista_z_jednym_elementem)\n"
"```"

msgid "pages.BuildingNewLists.steps.double_numbers.hints.5.text"
msgstr ""
"```python\n"
"# Możesz dodać element do listy, dodając listę zawierającą jeden element.\n"
"lista = __code0__  # Na przykład ['jabłko', 'banan']\n"
"element_do_dodania = __code1__  # Na przykład 'wiśnia'\n"
"\n"
"lista += [element_do_dodania]  # Dodanie elementu do istniejącej listy poprzez dodanie listy z tym elementem\n"
"\n"
"print(lista)\n"
"```"

msgid "pages.BuildingNewLists.steps.filter_numbers.hints.0.text"
msgstr ""
"```python\n"
"# To jest bardzo podobne do poprzedniego ćwiczenia.\n"
"lista = __code0__  # Na przykład ['a', 'b', 'c']\n"
"element_do_dodania = __code1__  # Na przykład 'd'\n"
"\n"
"lista.append(element_do_dodania)  # Dodaj element do listy przy użyciu metody append\n"
"\n"
"print(lista)\n"
"```"

msgid "pages.BuildingNewLists.steps.filter_numbers.hints.1.text"
msgstr ""
"```python\n"
"lista = __code0__  # Na przykład lista z elementami do sprawdzenia\n"
"nowa_lista = []\n"
"\n"
"# Różnica polega na tym, że czasami powinieneś pominąć dodawanie elementu do nowej listy.\n"
"for element in lista:\n"
"    if __code1__:  # Warunek decydujący czy dodać element do nowej listy, na przykład 'if element % 2 == 0' dla elementów parzystych\n"
"        nowa_lista.append(element)  # Dodaj element do nowej listy jeśli warunek jest spełniony\n"
"\n"
"print(nowa_lista)\n"
"```"

msgid "pages.BuildingNewLists.steps.filter_numbers.hints.2.text"
msgstr ""
"```python\n"
"# Użyj instrukcji warunkowej `if`.\n"
"lista = __code0__  # Przykładowa lista, z której będziemy wybierać elementy\n"
"nowa_lista = []\n"
"\n"
"for element in lista:\n"
"    if __code1__:  # Warunek, który musi być spełniony, np. 'element > 10'\n"
"        nowa_lista.append(element)  # Dodaj element do nowej listy, jeżeli warunek jest prawdziwy\n"
"\n"
"print(nowa_lista)\n"
"```"

msgid "pages.BuildingNewLists.steps.filter_numbers.hints.3.text"
msgstr ""
"```python\n"
"# Użyj operatora porównania, aby przetestować, czy liczba jest wystarczająco duża, aby ją dodać.\n"
"lista = __code0__  # Lista liczb do przetestowania\n"
"nowa_lista = []\n"
"\n"
"for liczba in lista:\n"
"    if liczba __code1__:  # Operator porównania, na przykład '>', i wartość do porównania, np. '> 10'\n"
"        nowa_lista.append(liczba)  # Dodaj liczbę do nowej listy, jeśli spełnia warunek\n"
"\n"
"print(nowa_lista)\n"
"```"

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.0.text"
msgstr ""
"```python\n"
"# Potrzebujesz pętli.\n"
"lista = __code0__  # Lista liczb do przeanalizowania\n"
"nowa_lista = []\n"
"\n"
"for liczba in lista:\n"
"    if liczba __code1__:  # Użyj operatora porównania, aby sprawdzić, czy liczba jest wystarczająco duża\n"
"        nowa_lista.append(liczba)  # Dodaj liczbę do nowej listy, jeśli spełnia warunek\n"
"\n"
"print(nowa_lista)\n"
"```"

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.1.text"
msgstr "You will need an `if` statement."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.2.text"
msgstr "You will need a comparison operator."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.3.text"
msgstr "Specifically `==`."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.4.text"
msgstr "You need a boolean variable that you print at the end."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.5.text"
msgstr ""
"If you find the element in the list you should set that variable to `True`."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.6.text"
msgstr "Once you've found the element, you can't unfind it."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.7.text"
msgstr ""
"That means that once you set the variable to `True`, it should never be set "
"to anything else after that."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.8.text"
msgstr "Don't use an `else`."

msgid "pages.UsingBreak.steps.list_contains_exercise.hints.9.text"
msgstr ""
"There is no reason to ever set the variable to `False` inside the loop."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.0.text"
msgstr ""
"Your solution should have exactly three statements: `x = ['a', 'b', 'c']`, "
"then one line copied exactly from the list (no additions), and `print(x)`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.1.text"
msgstr "Moving the first element to the end requires two things."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.2.text"
msgstr "Removing the first element..."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.3.text"
msgstr "and adding it to the end."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.4.text"
msgstr "Which functions/methods can you use for this?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.hints.5.text"
msgstr "Remember that the first index is 0."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.0.text"
msgstr ""
"Your solution should have exactly three statements: `x = ['a', 'b', 'c']`, "
"then one line copied exactly from the list (no additions), and `print(x)`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.1.text"
msgstr "You need to get the value of the first element in `x`..."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.2.text"
msgstr "and assign that value to the last position in `x`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.3.text"
msgstr "How do you assign a value at a specific index in the list?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.hints.4.text"
msgstr "What are the indices of the first and last last elements in `x`?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.0.text"
msgstr ""
"Your solution should have exactly three statements: `x = ['a', 'b', 'c']`, "
"`y = ` followed by one line copied exactly from the list, and `print(y)`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.1.text"
msgstr "Which lines of code create a new list rather than modifying?"

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.2.text"
msgstr "`x` is a list. Each element of `x` is a string."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.3.text"
msgstr ""
"You can add lists together, you can add strings together, but you can't add "
"a string and a list."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.hints.4.text"
msgstr "How do you make a list containing one element?"

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.0.text"
msgstr ""
"Your solution should have exactly three statements: `x = [1, 2, 0, 3]`, one "
"line copied exactly from the list (no additions), and `print(x)`."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.1.text"
msgstr "What does `x.remove(0)` do?"

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.2.text"
msgstr "It removes an element!"

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.3.text"
msgstr "Which function/method can also remove an element?"

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.4.text"
msgstr ""
"The other function/method can't simply be told 'remove 0', it needs a "
"different kind of information."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.5.text"
msgstr "Specifically, it needs to be told where 0 is."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.hints.6.text"
msgstr "Which function/method provides that kind of information?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.0.text"
msgstr ""
"Your solution should have exactly three statements: `x = ['a', 'b', 'c']`, "
"`y = ` followed by one line copied exactly from the list, and `print(y)`."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.1.text"
msgstr "When is `1 in x` True?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.2.text"
msgstr "When `1` is in `x`!"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.3.text"
msgstr "Could be that `1` is in `x` once, or twice, or three times..."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.hints.4.text"
msgstr "...but not zero times!"

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.0.text"
msgstr ""
"Your solution should have exactly three statements: `x = [15, 12, -6, 3]`, "
"`y = ` followed by one line copied exactly from the list, and `print(y)`."

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.1.text"
msgstr "If you're not sure, look up how to calculate the average/mean."

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.2.text"
msgstr "To calculate the average of numbers in `x` we need two things."

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.3.text"
msgstr "Which two functions/methods give you those two things?"

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.hints.4.text"
msgstr "How do you combine those two things to calculate the average?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.hints.0.text"
msgstr ""
"Your solution should have exactly three statements: `x = 100`, `y = ` "
"followed by one line copied exactly from the list, and `print(y)`."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.hints.1.text"
msgstr "What function/method can be used to add up things?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.hints.2.text"
msgstr "Which function/method gives us the numbers `1, 2, 3, ..., x`?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.hints.3.text"
msgstr ""
"You have to make a small tweak, otherwise that last number `x` will be left "
"out."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.0.text"
msgstr ""
"Your solution should have exactly three statements: `x = [12, -6, 2, -1, "
"3]`, `y = ` followed by one line copied exactly from the list, and "
"`print(y)`."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.1.text"
msgstr ""
"The numbers in `x` seem to be all out of order. Can you do something about "
"that?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.2.text"
msgstr ""
"If you figured that part out, try using that function in the shell to play "
"around with it."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.3.text"
msgstr ""
"How would you use that function to get the smallest value in a list? What "
"about the biggest?"

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.hints.4.text"
msgstr "After that, how can you get the *second* smallest value?"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.hints.0.text"
msgstr "Use the words 'python' and 'list' in your search query."

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.hints.1.text"
msgstr ""
"In one word, what's special about `91` in the list `[21, 55, 4, 91, 62, "
"49]`?"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.hints.2.text"
msgstr "'biggest' or 'largest'"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.hints.3.text"
msgstr "'python biggest value in list'"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.hints.0.text"
msgstr "Use the words 'python' and 'list' in your search query."

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.hints.1.text"
msgstr ""
"Instead of putting the value at the beginning or end, we want to put it "
"____________?"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.hints.2.text"
msgstr "'in the middle' or 'at an index' or 'at a particular position'"

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.hints.3.text"
msgstr "'python add value at index'"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.hints.0.text"
msgstr "How should you define the string?"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.hints.1.text"
msgstr "With single quotes, or with double quotes?"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.hints.2.text"
msgstr "You only need one string."

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.double_quote_exercise.hints.3.text"
msgstr "No need to add strings together."

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quote_exercise.hints.0.text"
msgstr "Think simple! How would you normally do this?"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quote_exercise.hints.1.text"
msgstr ""
"If a string contains a single quote, we must use double quotes to define it."

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quote_exercise.hints.2.text"
msgstr "What if the string contains double quotes?"

msgid "pages.IntroducingFstrings.steps.basic_f_string_exercise.hints.0.text"
msgstr "This is just like the given f-string example."

msgid "pages.IntroducingFstrings.steps.basic_f_string_exercise.hints.1.text"
msgstr "Did you forget the `f`?"

msgid "pages.IntroducingFstrings.steps.basic_f_string_exercise.hints.2.text"
msgstr "How many pairs of curly brackets do you need?"

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.0.text"
msgstr "There are four problems with the expression inside `print`."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.1.text"
msgstr "There is a problem with the syntax that finds the number of people."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.2.text"
msgstr "Then one of the strings has a problem with the quotes."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.3.text"
msgstr ""
"Also there is a problem with the syntax that finds the first person's name."

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.4.text"
msgstr "And you can't add strings and numbers together!"

msgid "pages.IntroducingFstrings.steps.fix_broken_program.hints.5.text"
msgstr "Did you properly use curly brackets in your f-string?"

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.0.text"
msgstr "You need to use a for loop inside a for loop."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.1.text"
msgstr "You need the numbers from 1 to 12."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.2.text"
msgstr "Whenever you need a sequence of consecutive numbers, use `range`."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.3.text"
msgstr "You want something like `for x in range(n):`."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.4.text"
msgstr ""
"This will start with `x = 0`, but there's an easy workaround for that."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.5.text"
msgstr "You can just add 1 to `x`."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.6.text"
msgstr "Use `*` to multiply numbers."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.7.text"
msgstr "Use an f-string with several variables."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.8.text"
msgstr ""
"Remember to print a line with the correct number of dashes after each "
"section."

msgid "pages.IntroducingNestedLoops.steps.times_table_exercise.hints.9.text"
msgstr ""
"Make sure each line is in the correct loop and has the right amount of "
"indentation."

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_exercise.hints.0.text"
msgstr ""
"Think about how you would do this manually and systematically, with a pencil"
" and paper."

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_exercise.hints.1.text"
msgstr "You need to use a for loop inside a for loop."

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_exercise.hints.2.text"
msgstr ""
"You need an `if` statement to check that the two players aren't the same "
"person."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.0.text"
msgstr ""
"Think about how you would do this manually and systematically, with a pencil"
" and paper."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.1.text"
msgstr ""
"The fact that the password must be four letters long is very important. This"
" would be a lot harder to solve if the password could be any given length."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.2.text"
msgstr "But the string `letters` might have any number of characters."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.3.text"
msgstr ""
"If there are `n` different letters, then the number of possible passwords is"
" `n^4 == n*n*n*n` because there are `n` possible letters for each position "
"and they're all independent."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.4.text"
msgstr ""
"Suppose again that `letters = \"ABCD\"`. Imagine you have all possible "
"three-letter passwords. Now for each one, add an A at the end, or add a B, "
"or a C, or a D. That's how you would get all possible four-letter passwords."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.5.text"
msgstr ""
"Remember, a for loop can contain any statement, including another for loop."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.6.text"
msgstr "That applies to all for loops."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.7.text"
msgstr "One for loop inside another for loop is no longer enough."

msgid ""
"pages.IntroducingNestedLoops.steps.crack_password_exercise.hints.8.text"
msgstr "You have to go deeper."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.0.text"
msgstr ""
"How would you describe instructions to type in this triangle manually?"

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.1.text"
msgstr ""
"Print a line of `size` plus signs, then `size - 1` plus signs, etc. down to "
"1 plus sign. For example print 5 `+`s, then 4 `+`s, then 3, 2, and 1."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.2.text"
msgstr "Break this down into subproblems."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.3.text"
msgstr ""
"How do you print one line of `+`s of a given length, and how do you go "
"through all the lengths?"

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.4.text"
msgstr ""
"Building up a line of characters should be very familiar from previous "
"exercises, the only difference is that you have to make it a given length "
"instead of just the same length as another string."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.5.text"
msgstr "An easy way to do something `n` times is to loop over `range(n)`."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.6.text"
msgstr "You need to use a for loop inside a for loop."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.7.text"
msgstr ""
"You need numbers that count down, like 5, 4, 3, 2, 1. There is a way to do "
"this with `range`, and you can easily look it up, but it's also easy to use "
"a normal range and do some very simple maths to convert numbers counting up "
"into numbers counting down."

msgid ""
"pages.IntroducingNestedLoops.steps.upside_down_triangle_exercise.hints.8.text"
msgstr "What formula converts 0 into 5, 1 into 4, 2 into 3, etc?"

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.0.text"
msgstr "You'll need a for loop inside a for loop like before."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.1.text"
msgstr "This time something like `for player1 in players:` won't be enough."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.2.text"
msgstr "Your program needs to use the *positions* of the players in the list."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.3.text"
msgstr ""
"That means you need to loop over the positions and use indexing "
"(subscripting) to access the list entries."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.4.text"
msgstr "To loop over the positions, use `range`..."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.5.text"
msgstr "...and `len`."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.6.text"
msgstr ""
"Look at the desired output: `Charlie vs Alice`: `Charlie` comes before "
"`Alice` in the `players` list."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.7.text"
msgstr ""
"We don't want to print `Alice vs Charlie` because `Alice` comes AFTER "
"`Charlie` in `players`."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.8.text"
msgstr ""
"The only pairs we want to print are those where the left player comes before"
" the right player in the list."

msgid "pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.9.text"
msgstr ""
"How can we express this relation in terms of the list indices of the two "
"for-loops?"

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.10.text"
msgstr "You need to use a comparison operator."

msgid ""
"pages.IntroducingNestedLoops.steps.player_vs_player_bonus.hints.11.text"
msgstr ""
"Once you figure out the relation, you can express it with an `if` statement."

msgid "pages.IntroducingNestedLists.steps.string_list_exercise.hints.0.text"
msgstr "How can you access the second string in the list?"

msgid "pages.IntroducingNestedLists.steps.string_list_exercise.hints.1.text"
msgstr "Then how do you access a particular letter in a string?"

msgid "pages.IntroducingNestedLists.steps.string_list_exercise.hints.2.text"
msgstr "Remember that the indexing of lists and strings are very similar."

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.0.text"
msgstr "This is very similar to the previous exercise."

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.1.text"
msgstr ""
"Do you remember how to access the last position of a list (without using "
"`len`)?"

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.2.text"
msgstr "Similarly how do you access the second-to-last position in a list?"

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.3.text"
msgstr "If you can't remember, you can Google it!"

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.4.text"
msgstr "Indexing works similarly on lists and strings."

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.5.text"
msgstr ""
"Do you get an `index out of range` error? Is it for a string, or a list? "
"Why?"

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.6.text"
msgstr ""
"Make sure you are not confusing the order of the list index and the string "
"index."

msgid ""
"pages.IntroducingNestedLists.steps.double_subscripting_exercise.hints.7.text"
msgstr "Use `birdseye` if you're having trouble."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.0.text"
msgstr "This is very similar to the previous exercises."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.1.text"
msgstr "How many times do you need to use subscripting?"

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.2.text"
msgstr "First you need to access a sublist."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.3.text"
msgstr "Then a string in that sublist."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.4.text"
msgstr "Then a letter in that string."

msgid "pages.IntroducingNestedLists.steps.triple_subscripting.hints.5.text"
msgstr "Use `birdseye` if you're having trouble."

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.0.text"
msgstr "How do you check if a string contains a word?"

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.1.text"
msgstr ""
"Make sure to check whether **the string** contains the word, not the "
"sublist."

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.2.text"
msgstr "How can you access each string in each sublist of a nested list?"

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.3.text"
msgstr "You need to use a nested loop."

msgid ""
"pages.LoopingOverNestedLists.steps.string_contains_word_exercise.hints.4.text"
msgstr ""
"The loops should follow the same pattern as the example at the beginning of "
"the page."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.0.text"
msgstr "For each sublist, define a boolean."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.1.text"
msgstr "Go through a sublist, update the boolean accordingly."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.2.text"
msgstr "Only print the boolean once for each sublist."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.3.text"
msgstr "What should be the initial value for the boolean?"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.4.text"
msgstr ""
"What if one of the sublists is empty? What should you print for that "
"sublist?"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.5.text"
msgstr ""
"If you find the word in a string, the boolean should be set to `True`."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.6.text"
msgstr "What if a string doesn't contain the word?"

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.7.text"
msgstr ""
"Doesn't matter! It doesn't change whether any other string might contain the"
" word."

msgid ""
"pages.LoopingOverNestedLists.steps.sublist_contains_word_exercise.hints.8.text"
msgstr ""
"In other words, don't set the boolean to `False` except at the beginning."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.0.text"
msgstr "This is very similar to the previous exercise."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.1.text"
msgstr "When should you print the boolean?"

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.2.text"
msgstr "Remember you want to print it only once."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.3.text"
msgstr ""
"Instead of defining a boolean for each sublist, define only one boolean for "
"the entire list."

msgid ""
"pages.LoopingOverNestedLists.steps.list_contains_word_exercise.hints.4.text"
msgstr "When and how should you modify the boolean?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.0.text"
msgstr "This is NOT similar to the previous exercises on this page."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.1.text"
msgstr ""
"Think about the solution when there's just two strings. How can you "
"generalize it to a list of strings?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.2.text"
msgstr ""
"You'll need to go through the first letters, then the second letters, and so"
" on."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.3.text"
msgstr "You'll have to use a loop, but how long should the loop take?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.4.text"
msgstr "Remember that strings in the list have equal lengths."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.5.text"
msgstr "For each position (first, second etc.) define a new string."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.6.text"
msgstr "What should that string be initially?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.7.text"
msgstr ""
"For each position (first, second etc.) you'll have to go through each string"
" in the list."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_strings_list_exercise.hints.8.text"
msgstr "You'll need another loop inside the one you have."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.0.text"
msgstr "Since the strings can have different lengths, this is a bit tricky."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.1.text"
msgstr "For how long should your outer loop go this time?"

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.2.text"
msgstr ""
"Before you start handling the strings, it might be a good idea to find the "
"longest string length first."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.3.text"
msgstr "The rest is very similar to the previous exercise."

msgid ""
"pages.LoopingOverNestedLists.steps.zip_longest_strings_exercise.hints.4.text"
msgstr ""
"The only difference is that now you have to determine whether to add a "
"letter from a string, or a space."

msgid "pages.DefiningFunctions.steps.change_function_name.hints.0.text"
msgstr ""
"You have to change the name in the function definition header, but that's "
"not all."

msgid "pages.DefiningFunctions.steps.change_function_name.hints.1.text"
msgstr ""
"If you just change the name in the function definition header, what happens?"

msgid "pages.DefiningFunctions.steps.change_function_name.hints.2.text"
msgstr ""
"You get an error. Look at the message. What is it telling you? Where does "
"the error come from?"

msgid "pages.DefiningFunctions.steps.change_function_name.hints.3.text"
msgstr ""
"If your function is called `say_hello`, what does `greet(\"Alice\")` mean?"

msgid "pages.DefiningFunctions.steps.change_function_name.hints.4.text"
msgstr "You need to change exactly 3 lines of the program."

msgid "pages.DefiningFunctions.steps.change_function_name.hints.5.text"
msgstr "In each line you change, change exactly one word."

msgid "pages.DefiningFunctions.steps.change_function_name.hints.6.text"
msgstr ""
"Don't touch the body of the function. It should still have `print(\"How are "
"you?\")`."

msgid "pages.DefiningFunctions.steps.change_function_name.hints.7.text"
msgstr ""
"You should still call the function twice after defining it, with arguments "
"`\"Alice\"` and `\"Bob\"`."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.0.text"
msgstr ""
"You have to change the parameter name in the function definition header, but"
" that's not all."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.1.text"
msgstr ""
"If you just change the parameter name in the function definition header, "
"what happens?"

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.2.text"
msgstr ""
"You get an error. Look at the message. What is it telling you? Where does "
"the error come from?"

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.3.text"
msgstr ""
"If the parameter is called `person_name`, what does `print(f\"Hello "
"{name}!\")` mean?"

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.4.text"
msgstr "You need to change exactly 2 lines of the program."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.5.text"
msgstr "In each line you change, change exactly one word."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.6.text"
msgstr ""
"Don't touch the part after the function definition, i.e. "
"`say_hello(\"Alice\")` and `say_hello(\"Bob\")`."

msgid "pages.DefiningFunctions.steps.change_parameter_name.hints.7.text"
msgstr ""
"You should still have two statements in the function body, including "
"`print(\"How are you?\")`."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.0.text"
msgstr ""
"There's no clever problem solving here, this is just about following the "
"recipe for defining a function."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.1.text"
msgstr "Make sure you have all the parts of a function listed above."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.2.text"
msgstr "That includes `def`, `()`, and `:`."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.3.text"
msgstr "Make sure your function is named `print_twice`."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.4.text"
msgstr ""
"Make sure it accepts one parameter called `x` in between the parentheses "
"`()`."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.5.text"
msgstr "Look at the other functions defined above for help."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.6.text"
msgstr "Use the parameter inside the function body."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.7.text"
msgstr "Make sure the body is indented."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.8.text"
msgstr "The body needs two statements or a very simple loop."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.hints.9.text"
msgstr ""
"Make sure that you don't call `print_twice` inside the function body of "
"`print_twice`. Check your indentation."

msgid "pages.DefiningFunctions.steps.swap_parameters.hints.0.text"
msgstr ""
"The only change to the function definition should be the swapping of "
"parameters as instructed, nothing else."

msgid "pages.DefiningFunctions.steps.swap_parameters.hints.1.text"
msgstr "You need to fix the call to `print_many`."

msgid "pages.DefiningFunctions.steps.swap_parameters.hints.2.text"
msgstr ""
"If the function is defined as `def print_many(n, thing)`, what does "
"`print_many(\"Hello\", 3)` mean?"

msgid "pages.DefiningFunctions.steps.swap_parameters.hints.3.text"
msgstr "We still want `thing = \"Hello\"` and `n = 3`."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.0.text"
msgstr "To multiply by 4, multiply by 2 twice."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.1.text"
msgstr "That means you need to call `double` twice."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.2.text"
msgstr "Make sure you use the returned value from `double` each time."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.3.text"
msgstr "Make sure you have all the parts of a function definition."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.4.text"
msgstr "That includes `def`, `()`, and `:`."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.5.text"
msgstr "Make sure your function is named `quadruple`."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.6.text"
msgstr ""
"Make sure it accepts one parameter called `x` in between the parentheses "
"`()`."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.7.text"
msgstr "Use the parameter inside the function body."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.8.text"
msgstr "Make sure the body is indented."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.9.text"
msgstr "Make sure you `return` something at the end."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.10.text"
msgstr "Look at the definition of `double` for an example."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.hints.11.text"
msgstr ""
"Make sure that you don't call `quadruple` inside the function body of "
"`quadruple`. Check your indentation."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.0.text"
msgstr "The argument `sides` should be added before and after `string`."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.1.text"
msgstr "Use string concatenation to do this."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.2.text"
msgstr "Make sure the body is indented."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.3.text"
msgstr "Make sure you `return` something at the end."

msgid "pages.TestingFunctions.steps.surround_exercise.hints.4.text"
msgstr ""
"Make sure that you don't call `surround` inside the function body of "
"`surround`. Check your indentation."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.0.text"
msgstr ""
"`string` should be surrounded by one space and `level` exclamation marks "
"(`!`) on each side."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.1.text"
msgstr ""
"Include the definition of `surround` from before in your program and call it"
" in `alert`."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.2.text"
msgstr "Use `surround` for the spaces."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.3.text"
msgstr "Use `surround` for the exclamation marks."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.4.text"
msgstr ""
"You're not allowed to combine several exclamation marks into one string, so "
"call `surround` several times."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.5.text"
msgstr "That is, call `surround` once for each pair of exclamation marks."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.6.text"
msgstr "So call `surround(..., '!')` several times."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.7.text"
msgstr "Use a loop to call it several times."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.8.text"
msgstr "Use `range(n)` to make your loop have `n` iterations."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.9.text"
msgstr "Make sure you use the return value from `surround`."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.10.text"
msgstr ""
"Think of how you would build up strings with `+=`. Repeatedly update the "
"same variable, building up your result."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.11.text"
msgstr "That is, write `something = surround(something, '!')` in your loop."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.12.text"
msgstr "Make sure you `return` something at the end of `alert`."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.13.text"
msgstr ""
"Make sure you don't `return` inside the loop, but after it. Check your "
"indentation."

msgid "pages.TestingFunctions.steps.alert_exercise.hints.14.text"
msgstr ""
"Make sure that you don't call `alert` inside the function body of `alert`. "
"Check your indentation."

msgid "pages.IntroducingOr.steps.AnExercise.hints.0.text"
msgstr ""
"Remember, you can use comparison operators `<, >, <=, >=, ==` to produce "
"booleans."

msgid "pages.IntroducingOr.steps.AnExercise.hints.1.text"
msgstr "You need to check how `x` compares to 0 and how it compares to 100."

msgid "pages.IntroducingOr.steps.AnExercise.hints.2.text"
msgstr "You need to combine the two comparisons into one boolean using `or`."

msgid "pages.IntroducingOr.steps.AnExercise.hints.3.text"
msgstr ""
"Above we used a trick so that the whole function body was just `return "
"<comparison> or <comparison>`. But that won't work here!"

msgid "pages.IntroducingOr.steps.AnExercise.hints.4.text"
msgstr "You need to use an `if` statement."

msgid "pages.IntroducingOr.steps.AnExercise.hints.5.text"
msgstr "You need to have a `return False` and a `return True`."

msgid "pages.IntroducingOr.steps.AnExercise.hints.6.text"
msgstr ""
"If you have something like `x >= 0 or x <= 100`, you're on the wrong track. "
"That's going to be true for *any* value of `x`. After all, 101 is greater "
"than 0!"

msgid "pages.IntroducingAnd.steps.AndExercise.hints.0.text"
msgstr ""
"If you have something like `x < 0 and x > 100`, you're on the wrong track. "
"That's going to be `False` for *any* value of `x`!"

msgid "pages.IntroducingAnd.steps.AndExercise.hints.1.text"
msgstr ""
"The solution with `and` is different in several ways from the solution with "
"`or`."

msgid "pages.IntroducingAnd.steps.AndExercise.hints.2.text"
msgstr ""
"Our solution with `or` first determines if `x` is an invalid percentage, "
"else concludes validity. Using `and` will do this in reverse."

msgid "pages.IntroducingAnd.steps.AndExercise.hints.3.text"
msgstr "You will have to reverse the `return` statements accordingly."

msgid "pages.IntroducingAnd.steps.AndExercise.hints.4.text"
msgstr "You will have to change the comparison operators too."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.0.text"
msgstr "The list will always have 3 elements."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.1.text"
msgstr "That means you don't need to use a loop."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.2.text"
msgstr "Remember that you can get the first element using `row[0]`."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.3.text"
msgstr ""
"The first element, second element, and third element all need to be equal."

msgid "pages.IntroducingAnd.steps.TicTacToeWinningRow.hints.4.text"
msgstr ""
"That means the first element should be equal to the second element and also "
"the third element."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.0.text"
msgstr "How many diagonals are there on the board?"

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.1.text"
msgstr ""
"Which entries of the three sublists make up each diagonal? How can you "
"access these entries?"

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.2.text"
msgstr "Every list always has 3 entries, so no need for a loop."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.3.text"
msgstr ""
"There are two problems to solve here: checking for a win in a specific "
"diagonal, and combining the checks for each diagonal."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.4.text"
msgstr "One problem can be solved using `and`, the other using `or`."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.5.text"
msgstr ""
"There's a lot of similarity with the `all_equal` function. You can even call"
" that function to help! But then you have to include its definition."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.6.text"
msgstr ""
"Similar to `all_equal`, check that the 3 entries on a diagonal are equal to "
"each other, e.g. by using `and`."

msgid "pages.CombiningAndAndOr.steps.AndHasHigherPriority.hints.7.text"
msgstr "Check the two diagonals together, using `or`."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.0.text"
msgstr ""
"What if you were instead asked to simplify this related but opposite function?\n"
"\n"
"__code0__"

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.1.text"
msgstr ""
"In that case there is a standard simplification trick you can apply that we "
"discussed a few pages ago."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.2.text"
msgstr ""
"In particular the `returns` are redundant because "
"`filename.endswith(\".png\") or filename.endswith(\".jpg\")` is already the "
"desired boolean."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.3.text"
msgstr ""
"So you can just write:\n"
"\n"
"__code0__"

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.4.text"
msgstr "For the real exercise, you can do something similar."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.5.text"
msgstr "The difference in the real exercise is that the result is reversed."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.6.text"
msgstr ""
"That is, `invalid_image` returns `True` when `valid_image` returns `False` "
"and vice versa."

msgid "pages.IntroducingNotPage.steps.NotPriority.hints.7.text"
msgstr "Remember what `not` does?"

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.0.text"
msgstr ""
"You need to check every row in the board, so you'll need a loop for that."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.1.text"
msgstr "How can you check if all entries in a row are equal to each other?"

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.2.text"
msgstr ""
"That's a self contained problem on its own. You can start by forgetting "
"about the whole board and just checking a single row."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.3.text"
msgstr ""
"You could even write a function which just does this, although you don't "
"have to."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.4.text"
msgstr ""
"Since the row could have any size, you'll have to loop all the way through "
"it."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.5.text"
msgstr ""
"For each row, define a boolean. Then loop through that row, updating the "
"boolean accordingly."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.6.text"
msgstr ""
"You can use the first entry `row[0]` in a row to compare all the row entries"
" to it."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.7.text"
msgstr ""
"Think carefully about what the initial value of the boolean should be, and "
"under what conditions you should change its value."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.8.text"
msgstr ""
"After looping through a row, if you determined that all its entries are "
"equal, then return `True` (ending the outer loop early)."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.9.text"
msgstr "Make sure you don't return `True` for a row filled with spaces."

msgid "pages.IntroducingTicTacToe.steps.intro_row_winner.hints.10.text"
msgstr "Make sure you return `False` if there are no winning rows"

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.0.text"
msgstr ""
"You can start by imitating `row_winner` above, then change it to make it "
"work with columns."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.1.text"
msgstr "You can't loop through the columns of `board` as simply as its rows."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.2.text"
msgstr ""
"What *is* a column of a nested list? The first column consists of the first "
"element of the first row, the first element of the second row, etc."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.3.text"
msgstr ""
"Looping through all columns means looking at the first element of every row,"
" then the second element of every row, etc."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.4.text"
msgstr ""
"So you need to loop through numbers representing the positions first, "
"second, etc."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.5.text"
msgstr "How do you find the number of columns in `board`?"

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.6.text"
msgstr ""
"That covers the outer loop, which goes through each column. Then you need an"
" inner loop to go through each element in the column."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.7.text"
msgstr ""
"The different entries of a column are NOT on the same row. So how can you "
"access them?"

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.8.text"
msgstr ""
"You can loop through rows of the board and find the element corresponding to"
" that row and the current column."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.9.text"
msgstr ""
"To access all the entries of, say, the 5th column, you can loop through all "
"the rows, and access the 5th element in each row."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.10.text"
msgstr ""
"Define a boolean for each column, then update it accordingly inside the "
"inner loop."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.11.text"
msgstr "The rest of the logic is very similar to `row_winner`."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.12.text"
msgstr "Watch out for `' '`."

msgid "pages.IntroducingTicTacToe.steps.column_winner.hints.13.text"
msgstr "Remember to return `False` at the end if needed."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.0.text"
msgstr "How many diagonals are there on a square board of arbitrary size?"

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.1.text"
msgstr ""
"Even if the size of the board changes, the number of diagonals remains the "
"same!"

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.2.text"
msgstr ""
"You can't do something like `middle == board[0][0] and middle == "
"board[2][2]` this time, because you don't know how long a diagonal is."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.3.text"
msgstr ""
"Moreover the two diagonals might not have anything in common like `middle`."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.4.text"
msgstr "First, focus on the diagonal that goes from top left to bottom right."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.5.text"
msgstr "How can you access those entries with double subscripting?"

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.6.text"
msgstr ""
"Do you see a pattern in those double subscripts? Get some paper and pen, "
"work it out on some examples."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.7.text"
msgstr ""
"Now focus on the other diagonal (from top right to bottom left). There is a "
"pattern in the subscripts again, but it's a little bit more difficult."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.8.text"
msgstr "Do you remember negative indexing? It might be helpful here."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.9.text"
msgstr ""
"Once you get the hang of the patterns, use the same ideas from before to "
"check if all entries are equal."

msgid "pages.IntroducingTicTacToe.steps.diagonal_winner.hints.10.text"
msgstr ""
"You can use one loop and check both diagonals at the same time. Or you can "
"use one loop for each diagonal."

msgid "pages.IntroducingTicTacToe.steps.winner.hints.0.text"
msgstr ""
"The solution is quite short! Simply use the three functions correctly."

msgid "pages.IntroducingTicTacToe.steps.winner.hints.1.text"
msgstr ""
"Think about possible cases. When does `winner(board)` return `False`? When "
"does it return `True`?"

msgid "pages.IntroducingTicTacToe.steps.winner.hints.2.text"
msgstr ""
"How can you use the three functions and a boolean operator together to get "
"the result you need?"

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.0.text"
msgstr ""
"Look carefully at the test case we provided. It shows you all you need!"

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.1.text"
msgstr ""
"You need to build up a string for the whole board. Start with an empty "
"string."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.2.text"
msgstr "For each row, add the characters from that row to the string."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.3.text"
msgstr "You'll need a nested loop."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.4.text"
msgstr ""
"When you reach the end of a row, you need to add a newline before the next "
"row."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.5.text"
msgstr ""
"`'\\n'` is just like any other character! You can add it as usual with `+`."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.6.text"
msgstr "Notice that the end of the last row is different than the others."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.7.text"
msgstr ""
"Before you add a newline, you'll need to check if it's the last row or not."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.8.text"
msgstr "Your outer loop should loop over the length of the board."

msgid "pages.NewlinesAndFormatBoard.steps.format_board_simple.hints.9.text"
msgstr "Then check if you are at the last index or not."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.0.text"
msgstr ""
"There are two types of lines to be displayed: one type has the pieces joined"
" by `|`s in between them, the other type has `-`s joined by `+`s in between "
"them."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.1.text"
msgstr ""
"Both of these types of lines can be built up by using `join` appropriately."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.2.text"
msgstr ""
"For example, how can you convert a row `['X', 'O', 'X']` into `'X|O|X'` "
"using `join`?"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.3.text"
msgstr ""
"Similarly, how can you obtain `'-+-+-'` using `join`? To what list should "
"you apply `join`?"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.4.text"
msgstr ""
"Once you figured out how to build up both types of lines, how can you "
"combine them to obtain the final result?"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.5.text"
msgstr "Notice that the lines with the `+-`  signs are always the same."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.6.text"
msgstr ""
"And there is one line with `+-` separating every consecutive pair of lines "
"with pieces."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.7.text"
msgstr "You can use `join` on the lines themselves!"

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.8.text"
msgstr ""
"The lines with the pieces can be joined together with the `+-` line in "
"between them (with newlines added in appropriate places)."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.9.text"
msgstr ""
"To do that, first you need to keep the lines with the pieces stored in a "
"list as you are building them."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.10.text"
msgstr "Then apply `join` to that list, with the `+-` line as separator."

msgid ""
"pages.NewlinesAndFormatBoard.steps.format_board_bonus_challenge.hints.11.text"
msgstr ""
"To add the newlines to the `+-` line correctly, take a look at the test case"
" we provided."

msgid "pages.Types.steps.fixing_type_errors_with_conversion.hints.0.text"
msgstr "At what points is this code broken?"

msgid "pages.Types.steps.fixing_type_errors_with_conversion.hints.1.text"
msgstr "There are values that need to be converted to a different type."

msgid "pages.Types.steps.fixing_type_errors_with_conversion.hints.2.text"
msgstr "Specifically there's a `str` that needs to be converted to an `int`."

msgid "pages.Types.steps.fixing_type_errors_with_conversion.hints.3.text"
msgstr "And an `int` that needs to be converted to a `str`."

msgid "pages.Types.steps.format_board_with_numbers.hints.0.text"
msgstr ""
"You can start by using the ideas from your previous solution to "
"`format_board`. Using `join` is highly recommended!"

msgid "pages.Types.steps.format_board_with_numbers.hints.1.text"
msgstr "The first line has to be treated separately from the rest."

msgid "pages.Types.steps.format_board_with_numbers.hints.2.text"
msgstr "Remember that `range` yields numbers in the way: 0, 1, 2, ..."

msgid "pages.Types.steps.format_board_with_numbers.hints.3.text"
msgstr "We want numbers on the first line like this: 1, 2, 3..."

msgid "pages.Types.steps.format_board_with_numbers.hints.4.text"
msgstr ""
"Each number has to be converted to a string before being added to the first "
"row!"

msgid "pages.Types.steps.format_board_with_numbers.hints.5.text"
msgstr "For the rows of the board itself, do something similar."

msgid "pages.Types.steps.format_board_with_numbers.hints.6.text"
msgstr ""
"Start with a list consisting only of the first line that you built above."

msgid "pages.Types.steps.format_board_with_numbers.hints.7.text"
msgstr ""
"Add each row's string to the list, then join the list with a newline "
"character."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.0.text"
msgstr "`input()` always returns a string."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.1.text"
msgstr "A string that looks like a number is still a string, not a number."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.2.text"
msgstr "In `super_secret_number = 7`, `7` is a number, not a string."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.3.text"
msgstr "That makes `super_secret_number` also a number."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.4.text"
msgstr "A string cannot equal a number."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.5.text"
msgstr ""
"To check that two values are equal, make sure they're the same type first."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.6.text"
msgstr ""
"So to compare a number and a string, first convert the number to a string or"
" convert the string to a number."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.7.text"
msgstr ""
"You learned how to convert between strings and numbers in the previous page."

msgid ""
"pages.InteractiveProgramsWithInput.steps.convert_input_to_int.hints.8.text"
msgstr ""
"Use `int()` to convert to an integer (whole number) or `str()` to convert to"
" a string."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.0.text"
msgstr ""
"Your function needs to call `input()` twice. Input isn't passed to "
"`play_move` as an argument."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.1.text"
msgstr "`input()` always returns a string."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.2.text"
msgstr "A string that looks like a number is still a string, not a number."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.3.text"
msgstr "List indices have to be numbers, not strings."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.4.text"
msgstr ""
"If the board is 3x3, the user might input 1, 2, or 3 for each coordinate."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.5.text"
msgstr "What are the valid indices of a list of length 3?"

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.6.text"
msgstr "You need to take the input of 1, 2, or 3 and turn it into 0, 1, or 2."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.7.text"
msgstr "You also need to be able to handle bigger boards, like 9x9 or beyond."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.8.text"
msgstr "You can't do maths with strings, only numbers."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.9.text"
msgstr "How can you convert a string to a number?"

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.10.text"
msgstr ""
"Once you've got two numbers, you need to modify the nested list `board` with"
" them."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.11.text"
msgstr "The code for this has been shown to you above."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.12.text"
msgstr ""
"You just need to use the numbers from user input instead of the hardcoded 1 "
"and 0."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.hints.13.text"
msgstr "You can use nested subscripting in one line, or do it in two steps."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.0.text"
msgstr "The existing code is almost correct."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.1.text"
msgstr "There are several ways to solve this."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.2.text"
msgstr "Some solutions involve adding something small."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.3.text"
msgstr ""
"You can also rearrange the code without adding or removing anything (except "
"spaces)."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.4.text"
msgstr "The problem is that a single list `row` is used several times."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.5.text"
msgstr ""
"So one solution is to make copies of `row` which will all be separate."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.6.text"
msgstr "Another solution is to make a new `row` from scratch each time."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.7.text"
msgstr ""
"There are a few ways to copy a list in Python with a tiny bit of code."

msgid "pages.MakingTheBoard.steps.fix_make_board.hints.8.text"
msgstr "Making a new row each time can be done by just rearranging the code."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.0.text"
msgstr ""
"You should use all of the functions `winner`, `format_board` (not counting "
"its use in `play_move`), `play_move`, `make_board`, `print_winner`, and "
"`print_draw` somewhere."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.1.text"
msgstr ""
"You only need to mention each of those functions once in your code, although"
" some of them will be called several times as the program runs."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.2.text"
msgstr "You will need a for loop to repeatedly play moves."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.3.text"
msgstr ""
"You don't need to check if the board has been filled up, because you can "
"always calculate how many moves it takes to fill up the board."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.4.text"
msgstr ""
"So you can just use a loop that will run a fixed number of iterations, and "
"inside the loop check if the loop needs to be ended early."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.5.text"
msgstr ""
"What's the maximum number of moves that can be played in a 3x3 board? 4x4?"

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.6.text"
msgstr ""
"A loop over a `range` is an easy way to iterate a fixed number of times."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.7.text"
msgstr "So you can use `for _ in range(N):` to play at most `N` moves."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.8.text"
msgstr "Once there's a winner, you need to end the loop and the game."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.9.text"
msgstr "Either `print_winner` or `print_draw` should be called, not both."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.10.text"
msgstr "Whichever function is called, it must be called exactly once."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.11.text"
msgstr ""
"One easy way to make sure you don't call a function multiple times is to "
"call it outside of any loop."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.12.text"
msgstr "We've learned about two ways to make a loop stop."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.13.text"
msgstr "One way is `break`, which specifically ends one loop and no more."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.14.text"
msgstr "The second way ends not just the loop but the whole function call."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.15.text"
msgstr "The second way is `return`."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.16.text"
msgstr ""
"Don't play moves in pairs like `play_move(board, player1)` and "
"`play_move(board, player2)` in the sample code."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.17.text"
msgstr "Instead, each loop iteration should play one move."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.18.text"
msgstr "You need a variable to keep track of which player's turn it is."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.19.text"
msgstr "The player should be switched in each loop iteration."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.20.text"
msgstr "An `if` statement is a good way to do this."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.21.text"
msgstr "Especially combined with an `else`."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.22.text"
msgstr "Make sure `player1` plays the first move."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.23.text"
msgstr ""
"Only call `print_winner` after checking `winner` with an `if` statement."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.24.text"
msgstr ""
"You need to check for the winner inside the loop since you don't know when a"
" player might win."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.25.text"
msgstr ""
"Once you call `print_winner`, you can use `return` to end the function."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.26.text"
msgstr ""
"Just `return` by itself is fine, `play_game` isn't meant to return a value."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.27.text"
msgstr ""
"Don't use `else` after checking for a winner to call `print_draw` if there "
"isn't a winner. Just because no one has won yet doesn't mean it's a draw "
"already."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.28.text"
msgstr ""
"`print_draw` should only be called after all moves have been played and "
"there's still no winner."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.29.text"
msgstr "So it should be called after the loop, outside of it."

msgid "pages.TheFullTicTacToeGame.steps.the_full_game.hints.30.text"
msgstr ""
"Check the indentation to make sure `print_draw` isn't in the body of the for"
" loop."

msgid "code_bits.valid_image"
msgstr "valid_image"

msgid ""
"pages.IntroducingTheShell.steps.first_expression.messages.anything_else.text"
msgstr ""
"Awesome, you're trying out your own experiments!\n"
"That's a great sign. Keep it up.\n"
"Just letting you know that you do need to eventually type `1+2` for the book to move forward."

msgid ""
"pages.AddingStrings.steps.hello_world_space.messages.literal_answer.text"
msgstr "You must still add two or more strings together."

msgid ""
"pages.UsingVariables.steps.name_assign.messages.assigned_something_else.text"
msgstr ""
"Put `your_name` before the `=` to create a variable called `your_name`."

msgid "pages.UsingVariables.steps.name_assign.messages.empty_string.text"
msgstr "For this exercise, choose a non-empty string"

msgid ""
"pages.UsingVariables.steps.name_assign.messages.name_equals_something_else.text"
msgstr ""
"You've got the `your_name = ` part right, now put a string (use quotes) on "
"the right of the `=`."

msgid "pages.UsingVariables.steps.name_assign.messages.starts_with_space.text"
msgstr "For this exercise, choose a name that doesn't start with a space."

msgid ""
"pages.BuildingUpStringsExercises.steps.diagonal_name_bonus_challenge.messages.add_space_first.text"
msgstr ""
"Almost there! You have one space too many before each letter.\n"
"Make sure that the first time your loop calls `print`\n"
"your variable which will contain the spaces is an empty string.\n"
"Check the order of your code."

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.messages.added_str_and_int.text"
msgstr "You can't add together strings and numbers. Use an f-string."

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.messages.adding_one_in_wrong_loop.text"
msgstr ""
"You added 1 to your outer loop variable at the wrong place!\n"
"Where should you do that instead to fix it?"

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.messages.too_long.text"
msgstr ""
"Your solution is too long. You only need a few lines of code for this problem.\n"
"Use a nested loop so that you don't need to repeat yourself.\n"
"The computer will do the repetition for you!"

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.messages.used_times_instead_of_x.text"
msgstr ""
"That's almost correct! Make sure to display the right character `x` in your table.\n"
"For example, your solution should display `3 x 4 = 12` and not `3 * 4 = 12`."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.messages.used_multiply.text"
msgstr ""
"You cannot use `*`, `+`, or even any numbers inside `quadruple`.\n"
"You must call `double` to solve the problem."

msgid ""
"pages.TestingFunctions.steps.alert_exercise.messages.catch_return_inside_loop.text"
msgstr ""
"In the `alert` function, you placed your `return` statement at the wrong place!\n"
"Pay attention to your indentations in `alert`. You might be ending a loop too early with `return`."

msgid "pages.TestingFunctions.steps.alert_exercise.messages.used_format.text"
msgstr ""
"You cannot use string concatenation/formatting/interpolation/multiplication or f-strings in `alert`.\n"
"You must call `surround` to solve the problem."

msgid ""
"pages.IntroducingTicTacToe.steps.intro_row_winner.messages.catch_empty_row.text"
msgstr ""
"Keep in mind that some entries might be `' '`. An empty row is not a winning"
" row."

msgid "code_bits.\" years old.\""
msgstr "\" years old.\""

msgid "code_bits.\". You are \""
msgstr "\". You are \""

msgid "code_bits.\"ABC\""
msgstr "\"ABC\""

msgid "code_bits.\"Alice's Diner\""
msgstr "\"Alice's Diner\""

msgid "code_bits.\"Hello \""
msgstr "\"Hello \""

msgid "code_bits.\"Python rocks!\""
msgstr "\"Python rocks!\""

msgid "code_bits.\"Special cases aren't special enough to break the rules.\""
msgstr "\"Special cases aren't special enough to break the rules.\""

msgid "code_bits.' is cool!'"
msgstr "' is cool!'"

msgid "code_bits.'\"Talk is cheap. Show me the code.\" - Linus Torvalds'"
msgstr "'\"Talk is cheap. Show me the code.\" - Linus Torvalds'"

msgid "code_bits.'AB'"
msgstr "'AB'"

msgid "code_bits.'AGTAGCGTC'"
msgstr "'AGTAGCGTC'"

msgid "code_bits.'AGTAGCGTCCTTAGTTACAGGATGGCTTAT'"
msgstr "'AGTAGCGTCCTTAGTTACAGGATGGCTTAT'"

msgid "code_bits.'Alex'"
msgstr "'Alex'"

msgid "code_bits.'Amazing'"
msgstr "'Amazing'"

msgid "code_bits.'HELLO THERE'"
msgstr "'HELLO THERE'"

msgid "code_bits.'Hello '"
msgstr "'Hello '"

msgid "code_bits.'Hello there'"
msgstr "'Hello there'"

msgid "code_bits.'No'"
msgstr "'No'"

msgid "code_bits.'One more exercise, and then you can relax.'"
msgstr "'One more exercise, and then you can relax.'"

msgid "code_bits.'Python'"
msgstr "'Python'"

msgid "code_bits.'The e key on my keyboard is broken'"
msgstr "'The e key on my keyboard is broken'"

msgid "code_bits.'This does not'"
msgstr "'This does not'"

msgid "code_bits.'This gets printed'"
msgstr "'This gets printed'"

msgid "code_bits.'This'"
msgstr "'This'"

msgid "code_bits.'Type your name, then press Enter:'"
msgstr "'Type your name, then press Enter:'"

msgid "code_bits.'Yes'"
msgstr "'Yes'"

msgid "code_bits.'a string'"
msgstr "'a string'"

msgid "code_bits.'ab'"
msgstr "'ab'"

msgid "code_bits.'abc'"
msgstr "'abc'"

msgid "code_bits.'abcqwe'"
msgstr "'abcqwe'"

msgid "code_bits.'aeiou'"
msgstr "'aeiou'"

msgid "code_bits.'are'"
msgstr "'are'"

msgid "code_bits.'bc'"
msgstr "'bc'"

msgid "code_bits.'de'"
msgstr "'de'"

msgid "code_bits.'def'"
msgstr "'def'"

msgid "code_bits.'fghi'"
msgstr "'fghi'"

msgid "code_bits.'ghi'"
msgstr "'ghi'"

msgid "code_bits.'ghiq'"
msgstr "'ghiq'"

msgid "code_bits.'goodbye world'"
msgstr "'goodbye world'"

msgid "code_bits.'goodbye'"
msgstr "'goodbye'"

msgid "code_bits.'hello there'"
msgstr "'hello there'"

msgid "code_bits.'hello world'"
msgstr "'hello world'"

msgid "code_bits.'how are you'"
msgstr "'how are you'"

msgid "code_bits.'how'"
msgstr "'how'"

msgid "code_bits.'is'"
msgstr "'is'"

msgid "code_bits.'jklmn'"
msgstr "'jklmn'"

msgid "code_bits.'kesha'"
msgstr "'kesha'"

msgid "code_bits.'list'"
msgstr "'list'"

msgid "code_bits.'on'"
msgstr "'on'"

msgid "code_bits.'store'"
msgstr "'store'"

msgid "code_bits.'the'"
msgstr "'the'"

msgid "code_bits.'there'"
msgstr "'there'"

msgid "code_bits.'to'"
msgstr "'to'"

msgid "code_bits.'way'"
msgstr "'way'"

msgid "code_bits.'word'"
msgstr "'word'"

msgid "code_bits.'you'"
msgstr "'you'"

msgid "code_bits.age"
msgstr "age"

msgid "code_bits.all_equal1"
msgstr "all_equal1"

msgid "code_bits.all_equal2"
msgstr "all_equal2"

msgid "code_bits.all_numbers"
msgstr "all_numbers"

msgid "code_bits.big_numbers"
msgstr "big_numbers"

msgid "code_bits.c1"
msgstr "c1"

msgid "code_bits.c2"
msgstr "c2"

msgid "code_bits.c3"
msgstr "c3"

msgid "code_bits.c4"
msgstr "c4"

msgid "code_bits.consonants"
msgstr "consonants"

msgid "code_bits.dna"
msgstr "dna"

msgid "code_bits.f\"2 * 3 + 4 is equal to {2 * 3 + 4}\""
msgstr "f\"2 * 3 + 4 is equal to {2 * 3 + 4}\""

msgid "code_bits.f\"Hello {person_name}!\""
msgstr "f\"Hello {person_name}!\""

msgid ""
"code_bits.f\"There are {len(people)} people waiting, the first one's name is"
" {people[0]}.\""
msgstr ""
"f\"There are {len(people)} people waiting, the first one's name is "
"{people[0]}.\""

msgid "code_bits.f\"{letter} {number}\""
msgstr "f\"{letter} {number}\""

msgid "code_bits.f'Hello {name}!'"
msgstr "f'Hello {name}!'"

msgid "code_bits.f'Hello {name}. You are {age} years old.'"
msgstr "f'Hello {name}. You are {age} years old.'"

msgid "code_bits.f'\\n{\"+\".join(lines)}\\n'"
msgstr "f'\\n{\"+\".join(lines)}\\n'"

msgid "code_bits.f'{left} x {right} = {left * right}'"
msgstr "f'{left} x {right} = {left * right}'"

msgid "code_bits.f'{letter} {number}'"
msgstr "f'{letter} {number}'"

msgid "code_bits.f'{player1} vs {player2}'"
msgstr "f'{player1} vs {player2}'"

msgid "code_bits.foo"
msgstr "foo"

msgid "code_bits.game_board"
msgstr "game_board"

msgid "code_bits.grade"
msgstr "grade"

msgid "code_bits.include"
msgstr "include"

msgid "code_bits.is_friend"
msgstr "is_friend"

msgid "code_bits.left"
msgstr "left"

msgid "code_bits.length"
msgstr "length"

msgid "code_bits.length1"
msgstr "length1"

msgid "code_bits.length2"
msgstr "length2"

msgid "code_bits.lengths"
msgstr "lengths"

msgid "code_bits.letter"
msgstr "letter"

msgid "code_bits.level"
msgstr "level"

msgid "code_bits.lines"
msgstr "lines"

msgid "code_bits.new_name"
msgstr "new_name"

msgid "code_bits.new_nums"
msgstr "new_nums"

msgid "code_bits.not_first"
msgstr "not_first"

msgid "code_bits.opposite_dna"
msgstr "opposite_dna"

msgid "code_bits.people"
msgstr "people"

msgid "code_bits.percentage"
msgstr "percentage"

msgid "code_bits.person_name"
msgstr "person_name"

msgid "code_bits.present"
msgstr "present"

msgid "code_bits.print_twice"
msgstr "print_twice"

msgid "code_bits.printed"
msgstr "printed"

msgid "code_bits.right"
msgstr "right"

msgid "code_bits.say_hello"
msgstr "say_hello"

msgid "code_bits.separator"
msgstr "separator"

msgid "code_bits.sides"
msgstr "sides"

msgid "code_bits.small_numbers"
msgstr "small_numbers"

msgid "code_bits.spaces"
msgstr "spaces"

msgid "code_bits.sunshine"
msgstr "sunshine"

msgid "code_bits.to_find"
msgstr "to_find"

msgid "code_bits.topleft"
msgstr "topleft"

msgid "code_bits.topright"
msgstr "topright"

msgid "code_bits.total"
msgstr "total"

msgid "code_bits.twice"
msgstr "twice"

msgid "code_bits.upper"
msgstr "upper"

msgid "code_bits.vowels"
msgstr "vowels"

msgid "code_bits.your_name"
msgstr "your_name"

msgid "linting_messages.pyflakes.ImportShadowedByLoopVar.message_format"
msgstr ""
"**Import `{0}` shadowed by loop variable**\n"
"\n"
"The name of the loop variable `{0}` should be changed as it redefines the `{0}` module imported earlier.\n"
"Choose a different loop variable to avoid this error."

msgid "linting_messages.pyflakes.ImportStarNotPermitted.message_format"
msgstr ""
"**Import made using `*` **\n"
"\n"
"`from {0} import *` imports everything from the module `{0}` into the current namespace.\n"
"This creates a bunch of invisible unknown variables.\n"
"It makes it hard to read and understand code and see where things come from.\n"
"\n"
"Avoid this kind of import and instead explicitly import exactly the names you need."

msgid "linting_messages.pyflakes.IsLiteral.message_format"
msgstr ""
"**`is` comparison with literal**\n"
"\n"
"You used the `is`/`is not` operator to compare with a literal (e.g. a string or number).\n"
"You should have rather used the `==` / `!=` operator.\n"
"\n"
"The `is` operator checks if two expressions refer to the exact same object.\n"
"You rarely want to use them, certainly not for basic data types like strings and numbers.\n"
"In those cases they will seem to work sometimes (e.g. for small numbers) and mysteriously\n"
"fail on other occasions."

msgid "linting_messages.pyflakes.MultiValueRepeatedKeyLiteral.message_format"
msgstr ""
"**Dictionary key `{0}` repeated with different values**\n"
"\n"
"A dictionary cannot have multiple entries for the same key.\n"
"Check your code again and change the repeated key to something unique."

msgid "linting_messages.pyflakes.RedefinedWhileUnused.message_format"
msgstr ""
"**Redefined `{0}` without using it**\n"
"\n"
"You defined `{0}` on line `{1}`, but before ever using it you redefined it,\n"
"overwriting the original definition.\n"
"\n"
"In general your functions and classes should have different names.\n"
"Check that you use everything you define, e.g. that you called your functions."

msgid "linting_messages.pyflakes.UnusedImport.message_format"
msgstr ""
"**Unused import `{0}`**\n"
"\n"
"You imported `{0}` but never used it. Did you forget to use it?\n"
"Maybe you used the wrong variable in its place? If you don't need the import, just remove it entirely."

msgid "linting_messages.pyflakes.UnusedVariable.message_format"
msgstr ""
"**Unused variable `{0}`**\n"
"\n"
"You defined a variable `{0}` but never used it. Did you forget to use it?\n"
"Maybe you used the wrong variable in its place? If you don't need it, just remove it entirely."

msgid "output_predictions.Error"
msgstr "Error"

msgid "pages.AddingStrings.title"
msgstr "Adding Strings"

msgid "pages.BasicForLoopExercises.title"
msgstr "Basic For Loop Exercises"

msgid "pages.BasicTerminology.title"
msgstr "Basic Terminology"

msgid "pages.BuildingNewLists.title"
msgstr "Building New Lists"

msgid ""
"pages.BuildingUpStrings.steps.hello_plus_equals.output_prediction_choices.0"
msgstr ""
"Hello\n"
"Hello"

msgid ""
"pages.BuildingUpStrings.steps.hello_plus_equals.output_prediction_choices.1"
msgstr ""
"Hello\n"
"Hello!"

msgid ""
"pages.BuildingUpStrings.steps.hello_plus_equals.output_prediction_choices.2"
msgstr ""
"Hello!\n"
"Hello!"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.0"
msgstr ""
"-\n"
"W\n"
"-\n"
"o\n"
"-\n"
"r\n"
"-\n"
"l\n"
"-\n"
"d"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.1"
msgstr ""
"-W\n"
"-o\n"
"-r\n"
"-l\n"
"-d"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.2"
msgstr "-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.3"
msgstr "-W-o-r-l-d"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.4"
msgstr ""
"-W\n"
"-Wo\n"
"-Wor\n"
"-Worl\n"
"-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.5"
msgstr ""
"-World\n"
"-Worl\n"
"-Wor\n"
"-Wo\n"
"-W"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.6"
msgstr ""
"-World\n"
"-World\n"
"-World\n"
"-World\n"
"-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle.output_prediction_choices.7"
msgstr ""
"-World\n"
"--World\n"
"---World\n"
"----World\n"
"-----World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle_missing_last_line.output_prediction_choices.0"
msgstr ""
"-W\n"
"-Wo\n"
"-Wor\n"
"-Worl\n"
"-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle_missing_last_line.output_prediction_choices.1"
msgstr ""
"-Wo\n"
"-Wor\n"
"-Worl\n"
"-World"

msgid ""
"pages.BuildingUpStrings.steps.name_triangle_missing_last_line.output_prediction_choices.2"
msgstr ""
"-\n"
"-W\n"
"-Wo\n"
"-Wor\n"
"-Worl"

msgid "pages.BuildingUpStrings.title"
msgstr "Building Up Strings"

msgid "pages.BuildingUpStringsExercises.title"
msgstr "Building Up Strings Exercises"

msgid "pages.CallingFunctionsTerminology.title"
msgstr "Terminology: Calling functions and methods"

msgid "pages.CallingFunctionsWithinFunctions.title"
msgstr "Calling Functions Within Functions"

msgid "pages.CombiningAndAndOr.title"
msgstr "Combining `and` and `or`"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.0"
msgstr "Hello World"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.2"
msgstr "Hello World!!!!!!!!!!!"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.3"
msgstr "!!!!!!!!!!!Hello World"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.4"
msgstr "Hello World!"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.5"
msgstr "!Hello World"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.6"
msgstr "!Hello World!"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.7"
msgstr "H!e!l!l!o! !W!o!r!l!d!"

msgid ""
"pages.CombiningCompoundStatements.steps.for_inside_if.output_prediction_choices.8"
msgstr "!H!e!l!l!o! !W!o!r!l!d"

msgid "pages.CombiningCompoundStatements.title"
msgstr "Combining Compound Statements"

msgid "pages.DefiningFunctions.steps.how_are_you.output_prediction_choices.0"
msgstr ""
"Hello Alice!\n"
"How are you?\n"
"Hello Bob!\n"
"How are you?"

msgid "pages.DefiningFunctions.steps.how_are_you.output_prediction_choices.1"
msgstr ""
"Hello Alice!\n"
"Hello Bob!\n"
"How are you?"

msgid "pages.DefiningFunctions.steps.how_are_you.output_prediction_choices.2"
msgstr ""
"Hello Alice!\n"
"How are you?\n"
"Hello Bob!"

msgid "pages.DefiningFunctions.steps.print_many.output_prediction_choices.2"
msgstr ""
"Hello\n"
"Hello\n"
"Hello"

msgid "pages.DefiningFunctions.steps.print_many.output_prediction_choices.3"
msgstr "Hello"

msgid "pages.DefiningFunctions.steps.print_many.output_prediction_choices.4"
msgstr ""
"H\n"
"e\n"
"l\n"
"l\n"
"o"

msgid "pages.DefiningFunctions.title"
msgstr "Defining Functions"

msgid "pages.EqualsVsIs.title"
msgstr "`==` vs `is`, and Having Multiple Names for One Value"

msgid "pages.FunctionsAndMethodsForLists.title"
msgstr "Functions and Methods for Lists"

msgid "pages.GettingElementsAtPosition.steps.index_error.program"
msgstr "words[4]"

msgid "pages.GettingElementsAtPosition.steps.introducing_subscripting.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"\n"
"print(words[0])\n"
"print(words[1])\n"
"print(words[2])\n"
"print(words[3])"

msgid "pages.GettingElementsAtPosition.steps.range_len.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"indices = range(4)\n"
"\n"
"for index in indices:\n"
"    print(index)\n"
"    print(words[index])"

msgid "pages.GettingElementsAtPosition.title"
msgstr "Getting elements at a position, `range()`, and `len()`"

msgid "pages.HowToFindInformationWithGoogleAndMore.title"
msgstr "How to Find Information with Google, and more"

msgid "pages.IfAndElse.steps.undefined_char.output_prediction_choices.0"
msgstr "Hello World"

msgid "pages.IfAndElse.steps.undefined_char.output_prediction_choices.1"
msgstr "Hello World!"

msgid "pages.IfAndElse.title"
msgstr "`if` and `else`"

msgid "pages.Indentation.steps.mismatched_indentations.program"
msgstr ""
"for character in name:\n"
"    print(character)\n"
"  print('---')"

msgid "pages.Indentation.steps.missing_indentation.program"
msgstr ""
"for character in name:\n"
"print(character)"

msgid "pages.Indentation.title"
msgstr "Indentation"

msgid "pages.InteractiveProgramsWithInput.title"
msgstr "Interactive Programs with `input()`"

msgid "pages.IntroducingAnd.title"
msgstr "Introducing `and`"

msgid "pages.IntroducingBirdseye.title"
msgstr "Understanding Programs with `birdseye`"

msgid "pages.IntroducingElif.title"
msgstr "Introducing `elif`"

msgid "pages.IntroducingForLoops.title"
msgstr "Introducing For Loops"

msgid ""
"pages.IntroducingFstrings.steps.concatenate_string_number.output_prediction_choices.0"
msgstr "\"Hello \" + name + \". You are \" + age + \" years old.\""

msgid ""
"pages.IntroducingFstrings.steps.concatenate_string_number.output_prediction_choices.1"
msgstr "Hello name. You are age years old."

msgid ""
"pages.IntroducingFstrings.steps.concatenate_string_number.output_prediction_choices.2"
msgstr "Hello Alice. You are 20 years old."

msgid ""
"pages.IntroducingFstrings.steps.concatenate_string_number.output_prediction_choices.3"
msgstr "Hello 'Alice'. You are 20 years old."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.0"
msgstr "f\"{name} went to {meal} with {friend}.\""

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.1"
msgstr "\"{name} went to {meal} with {friend}.\""

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.2"
msgstr "{name} went to {meal} with {friend}."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.3"
msgstr "'name' went to 'meal' with 'friend'."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.4"
msgstr "name went to meal with friend."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.5"
msgstr "\"Alice\" went to \"lunch\" with 'Bob'."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.6"
msgstr "'Alice' went to 'lunch' with 'Bob'."

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.7"
msgstr "\"Alice went to lunch with Bob.\""

msgid ""
"pages.IntroducingFstrings.steps.introduce_f_strings.output_prediction_choices.8"
msgstr "Alice went to lunch with Bob."

msgid "pages.IntroducingFstrings.title"
msgstr "f-strings"

msgid ""
"pages.IntroducingIfStatements.steps.excited_example.output_prediction_choices.0"
msgstr "Hello World"

msgid ""
"pages.IntroducingIfStatements.steps.excited_example.output_prediction_choices.1"
msgstr "Hello World!"

msgid ""
"pages.IntroducingIfStatements.steps.excited_false_example.output_prediction_choices.0"
msgstr "Hello World"

msgid ""
"pages.IntroducingIfStatements.steps.excited_false_example.output_prediction_choices.1"
msgstr "Hello World!"

msgid "pages.IntroducingIfStatements.title"
msgstr "Introducing If Statements"

msgid "pages.IntroducingLists.steps.first_list.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"\n"
"for word in words:\n"
"    print(word)"

msgid "pages.IntroducingLists.title"
msgstr "Introducing Lists"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.0"
msgstr "hello"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.1"
msgstr "there"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.10"
msgstr "a"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.2"
msgstr "how"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.3"
msgstr "are"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.4"
msgstr "you"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.5"
msgstr "['hello', 'there']"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.6"
msgstr "['how', 'are', 'you']"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.7"
msgstr "h"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.8"
msgstr "t"

msgid ""
"pages.IntroducingNestedLists.steps.first_nested_list_example.output_prediction_choices.9"
msgstr "e"

msgid "pages.IntroducingNestedLists.steps.first_nested_list_example.program"
msgstr ""
"strings = [['hello', 'there'], ['how', 'are', 'you']]\n"
"print(strings[1][0])"

msgid "pages.IntroducingNestedLists.title"
msgstr "Introducing Nested Lists"

msgid "pages.IntroducingNestedLoops.title"
msgstr "Introducing Nested Loops"

msgid "pages.IntroducingNotPage.title"
msgstr "Introducing `not`"

msgid "pages.IntroducingOr.title"
msgstr "Introducing `or`"

msgid "pages.IntroducingStrings.title"
msgstr "Introducing Strings"

msgid "pages.IntroducingTheShell.title"
msgstr "Introducing The Shell"

msgid "pages.IntroducingTicTacToe.title"
msgstr "Checking the board for winners"

msgid ""
"pages.IntroducingVariables.steps.sunshine_undefined_check.output_prediction_choices.0"
msgstr "sunshine"

msgid ""
"pages.IntroducingVariables.steps.sunshine_undefined_check.output_prediction_choices.1"
msgstr "'sunshine'"

msgid ""
"pages.IntroducingVariables.steps.sunshine_undefined_check.output_prediction_choices.2"
msgstr "Hello"

msgid ""
"pages.IntroducingVariables.steps.sunshine_undefined_check.output_prediction_choices.3"
msgstr "'Hello'"

msgid ""
"pages.IntroducingVariables.steps.word_string_check.output_prediction_choices.0"
msgstr "word"

msgid ""
"pages.IntroducingVariables.steps.word_string_check.output_prediction_choices.1"
msgstr "'word'"

msgid ""
"pages.IntroducingVariables.steps.word_string_check.output_prediction_choices.2"
msgstr "Hello"

msgid ""
"pages.IntroducingVariables.steps.word_string_check.output_prediction_choices.3"
msgstr "'Hello'"

msgid "pages.IntroducingVariables.title"
msgstr "Introducing Variables"

msgid "pages.LoopingOverNestedLists.title"
msgstr "Looping Over Nested Lists"

msgid "pages.MakingTheBoard.title"
msgstr "Making the Board"

msgid "pages.ModifyingWhileIterating.title"
msgstr "Modifying While Iterating"

msgid "pages.MoreListFunctionsAndMethods.title"
msgstr "More List Functions and Methods"

msgid "pages.MoreOnReturn.title"
msgstr "`return` ends the function call"

msgid "pages.MultiLineExpressions.steps.invalid_multiline.program"
msgstr ""
"is_friend = name == \"Alice\" or\n"
"            name == \"Bob\""

msgid "pages.MultiLineExpressions.title"
msgstr "Multi-line statements"

msgid "pages.NavigatingShellHistory.title"
msgstr "Navigating Shell History"

msgid "pages.NestedListAssignment.title"
msgstr "Nested List Assignment: Playing Moves on the Board"

msgid "pages.NewlinesAndFormatBoard.steps.invalid_multi_line_string.program"
msgstr ""
"assert_equal(\n"
"    format_board([\n"
"        ['X', 'O', 'X'],\n"
"        [' ', 'O', 'O'],\n"
"        [' ', 'X', ' ']\n"
"    ]),\n"
"    \"XOX\n"
"      OO\n"
"      X \"\n"
")"

msgid "pages.NewlinesAndFormatBoard.title"
msgstr "The newline character, `format_board`"

msgid "pages.OtherComparisonOperators.title"
msgstr "Other Comparison Operators"

msgid "pages.ReturningValuesFromFunctions.title"
msgstr "Returning Values From Functions"

msgid ""
"pages.SingleAndDoubleQuotesInStrings.steps.single_quotes_apostrophe.program"
msgstr "print('Alice's Diner')"

msgid "pages.SingleAndDoubleQuotesInStrings.title"
msgstr "Single and Double Quotes in Strings"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.output_prediction_choices.0"
msgstr ""
"Hello World\n"
"Hello World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.output_prediction_choices.1"
msgstr ""
"Hello World\n"
"Goodbye World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.output_prediction_choices.2"
msgstr ""
"Goodbye World\n"
"Goodbye World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.0"
msgstr "sentence"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.1"
msgstr "word + ' ' + name"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.2"
msgstr "Hello + ' ' + World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.3"
msgstr "'Hello' + ' ' + 'World'"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.4"
msgstr "Hello World"

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_equals_word_plus_name.output_prediction_choices.5"
msgstr "'Hello World'"

msgid "pages.StoringCalculationsInVariables.title"
msgstr "Storing Calculations In Variables"

msgid ""
"pages.StringMethodsUnderstandingMutation.steps.string_count_index.program"
msgstr ""
"string = 'feed the dog and the cat'\n"
"print(string.count('the'))\n"
"print(string.index('the'))"

msgid "pages.StringMethodsUnderstandingMutation.steps.string_in_step.program"
msgstr "print('the' in 'feed the dog and the cat')"

msgid "pages.StringMethodsUnderstandingMutation.title"
msgstr "String Methods and Immutability"

msgid "pages.TestingFunctions.title"
msgstr "Testing Functions"

msgid "pages.TheEqualityOperator.steps.equality_vs_assignment.program"
msgstr "print(1 + 2 = 3)"

msgid "pages.TheEqualityOperator.title"
msgstr "The Equality Operator"

msgid "pages.TheFullTicTacToeGame.title"
msgstr "The Full Tic-Tac-Toe Game"

msgid "pages.Types.title"
msgstr "Types"

msgid "pages.UnderstandingProgramsWithPythonTutor.title"
msgstr "Understanding Programs With Python Tutor"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.0"
msgstr "Hello World"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.1"
msgstr "ello World"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.2"
msgstr "Hello Worl"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.3"
msgstr "H"

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail.output_prediction_choices.4"
msgstr "d"

msgid "pages.UnderstandingProgramsWithSnoop.title"
msgstr "Understanding Programs With `snoop`"

msgid "pages.UsingBreak.title"
msgstr "Using `break` to end a loop early"

msgid "pages.UsingVariables.title"
msgstr "Using Variables and `print()`"

msgid "pages.WritingPrograms.title"
msgstr "Writing Programs"

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.0.text"
msgstr ""
"This is almost exactly the same as the previous step, just use strings "
"instead of numbers."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.1.text"
msgstr "You only need to run one very small, simple line in the shell."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.2.text"
msgstr ""
"You can also do this by running multiple lines in the shell, first defining "
"variables and then comparing them, but you don't need to, this can be done "
"without variables."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.3.text"
msgstr ""
"Remember adding two strings in the shell at the beginning of the course?"

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.4.text"
msgstr "For example, we did `'hello' + 'world'`"

msgid "pages.OtherComparisonOperators.steps.comparing_strings.hints.5.text"
msgstr ""
"For this exercise you have to do basically that, but compare them instead."

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.hints.0.text"
msgstr "You only need to run one very small, simple line in the shell."

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.hints.1.text"
msgstr "How would you add two numbers in the shell?"

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.hints.2.text"
msgstr "For example, try `123 + 456`"

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.hints.3.text"
msgstr ""
"For this exercise you have to do basically that, but compare them instead."

msgid "chapters.a_bit_more_about_strings.title"
msgstr "A Bit More About Strings"

msgid "chapters.boolean operators.title"
msgstr "Boolean Operators"

msgid "chapters.for_loops.title"
msgstr "For Loops"

msgid "chapters.functions.title"
msgstr "Functions"

msgid "chapters.if_statements.title"
msgstr "If Statements"

msgid "chapters.lists.title"
msgstr "Lists"

msgid "chapters.nested_loops.title"
msgstr "Nested Loops"

msgid "chapters.string_basics.title"
msgstr "String Basics"

msgid "chapters.the_shell.title"
msgstr "The Shell"

msgid "chapters.tic_tac_toe_project.title"
msgstr "Tic Tac Toe Project"

msgid "chapters.variables.title"
msgstr "Variables"

msgid ""
"pages.IntroducingNestedLoops.steps.times_table_exercise.special_messages.multiply_with_x.text"
msgstr "To multiply numbers, use `*`"

msgid ""
"pages.IntroducingTheShell.steps.more_calculation.special_messages.multiply_with_x.text"
msgstr ""
"I see an 'x'. If you're trying to multiply, use an asterisk, e.g:\n"
"\n"
"__code0__"

msgid ""
"pages.IntroducingVariables.steps.word_check.special_messages.bad_word.text"
msgstr "Oops, you need to set `word = 'Hello'` before we can continue."

msgid ""
"pages.NewlinesAndFormatBoard.steps.discovering_newline.special_messages.bad_string.text"
msgstr ""
"Oops, `string` doesn't have the right value. Run the program from the "
"previous step again."

msgid ""
"pages.UsingVariables.steps.word_plus_name.special_messages.bad_word.text"
msgstr "Oops, you need to set `word = 'Hello'` before we can continue."

msgid ""
"pages.UsingVariables.steps.word_plus_name_with_space.special_messages.bad_word.text"
msgstr "Oops, you need to set `word = 'Hello'` before we can continue."

msgid "misc_terms.blank_result"
msgstr "<nothing>"

msgid "misc_terms.case_sensitive"
msgstr ""
"Python is case sensitive! That means that small and capital letters matter "
"and changing them changes the meaning of the program. The strings `'hello'` "
"and `'Hello'` are different, as are the variable names `word` and `Word`."

msgid "misc_terms.code_should_start_like"
msgstr ""
"Your code should start like this:\n"
"\n"
"{expected_start}\n"

msgid "misc_terms.copy_button"
msgstr "Copy"

msgid "misc_terms.disallowed_default_label"
msgstr "more than {max_count} {label}"

msgid "misc_terms.disallowed_default_message"
msgstr ""
"Well done, you have found a solution! However, for this exercise and your "
"learning, you're not allowed to use {label}."

msgid "misc_terms.expected_mode_birdseye"
msgstr "With your code in the editor, click the `birdseye` button."

msgid "misc_terms.expected_mode_pythontutor"
msgstr "With your code in the editor, click the Python Tutor button."

msgid "misc_terms.expected_mode_shell"
msgstr "Type your code directly in the shell after `>>>` and press Enter."

msgid "misc_terms.expected_mode_snoop"
msgstr "With your code in the editor, click the `snoop` button."

msgid "misc_terms.incorrect_mode"
msgstr "The code is correct, but you didn't run it as instructed."

msgid "misc_terms.invalid_inputs"
msgstr ""
"The values of your input variables are invalid, try using values like the "
"example."

msgid "misc_terms.must_define_function"
msgstr "You must define a function `{function_name}`"

msgid "misc_terms.no_more_test_inputs"
msgstr "No more test inputs - solution should have finished by now"

msgid "misc_terms.not_a_function"
msgstr "`{function_name}` is not a function."

msgid "misc_terms.q_wiz_debugger"
msgstr ""
"It's great that you're using a debugger! Solving the problem on your own is "
"ideal. If you can't, use the 'Run' button to generate the question."

msgid "misc_terms.q_wiz_final_message"
msgstr ""
"\n"
"Great! Here's some final tips:\n"
"\n"
"- Make sure the output is showing the problem you have and not something else.\n"
"- Reduce your code to a **minimal** example. Remove any code that isn't directly related to the problem.\n"
"- Run your code through the `snoop`, `birdseye`, and Python Tutor debuggers to understand what it's doing.\n"
"- Search for your problem online.\n"
"- Read [How do I ask a good question?](https://stackoverflow.com/help/how-to-ask)\n"
"\n"
"If you're really ready, copy and paste the below into the question website,\n"
"and replace the first line with a description of your problem.\n"
"\n"
"You can still change your code or expected output and click Run again to regenerate the question.\n"
"\n"
"    __copyable__\n"
"    *Explain what you're trying to do and why*\n"
"\n"
"    Here's my code:\n"
"\n"
"{}\n"
"\n"
"    This is the result:\n"
"\n"
"{}\n"
"\n"
"    The expected output is:\n"
"\n"
"{}\n"

msgid "misc_terms.q_wiz_input_and_add"
msgstr ""
"and add\n"
"\n"
"    {list_line}\n"
"\n"
"to the top of your code."

msgid "misc_terms.q_wiz_input_message_start"
msgstr ""
"`input()` makes it harder to ask and answer questions about code. Replace "
"calls to input with strings so that everyone can run the code instantly and "
"get the same results."

msgid "misc_terms.q_wiz_input_replace_with"
msgstr ""
"Replace:\n"
"\n"
"{original_lines}\n"
"\n"
"with\n"
"\n"
"{replaced_lines}"

msgid "misc_terms.q_wiz_no_output"
msgstr ""
"Your code didn't output anything. Add some `print()` calls so that at least "
"it outputs *something*. Use code to show readers exactly where the problem "
"is."

msgid "misc_terms.q_wiz_same_as_expected_output"
msgstr ""
"Your output is the same as your expected output! If your problem is still "
"there, adjust your code and/or your expected output so that the two outputs "
"don't match. Make it clear what would be different if the code worked the "
"way you want it to."

msgid "misc_terms.signature_should_be"
msgstr ""
"The signature should be:\n"
"\n"
"    def {function_name}{needed_signature}:\n"
"\n"
"not:\n"
"\n"
"    def {function_name}{actual_signature}:"

msgid "misc_terms.syntax_error_at_line"
msgstr "at line"

msgid "misc_terms.when_it_should_output"
msgstr "when it should output:"

msgid "misc_terms.your_code_outputs"
msgstr "Your code outputs:"

msgid "misc_terms.your_code_outputs_given_values"
msgstr ""
"Given these values:\n"
"\n"
"{given_values}\n"
"\n"
"your code outputs:"

msgid "pages.BuildingNewLists.steps.filter_numbers.disallowed.0.message"
msgstr ""
"Well done, that's correct! However, you should use `.append()` instead of "
"`+=`."

msgid "pages.BuildingUpStringsExercises.steps.name_box.disallowed.0.message"
msgstr ""
"Well done, this solution is correct! However, it can be improved.\n"
"You only need to use one loop - using more is inefficient.\n"
"You can reuse the variable containing the line of `-` and `+`."

msgid "pages.BuildingUpStringsExercises.steps.name_box_2.disallowed.0.message"
msgstr ""
"Well done, this solution is correct!\n"
"And you used a nested loop (a loop inside a loop) which we haven't even covered yet!\n"
"However, in this case a nested loop is inefficient.\n"
"You can make a variable containing spaces and reuse that in each line."

msgid "pages.IntroducingOr.steps.AnExercise.disallowed.3.label"
msgstr "comparison chaining"

msgid "pages.IntroducingTicTacToe.steps.winner.disallowed.0.message"
msgstr ""
"Your solution should work by calling the three functions. `winner` itself should not do any\n"
"looping, subscripting, etc. It should be very short.\n"
"\n"
"Copy the `row_winner` and other functions and leave them as they are. Don't copy code from them\n"
"into the `winner` function, just call those functions."

msgid ""
"pages.Types.steps.fixing_type_errors_with_conversion.disallowed.0.label"
msgstr "f-strings"

msgid ""
"pages.MakingTheBoard.steps.fix_make_board.special_messages.not_separate.text"
msgstr "However, the sublists in the result are not all separate objects."

msgid "code_bits.indices"
msgstr "indices"

msgid "pages.GettingElementsAtPosition.steps.indices_out_of_bounds.text"
msgstr "Now try `__program__` in the shell."

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.0"
msgstr ""
"This\n"
"is\n"
"a\n"
"list"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.2"
msgstr ""
"0\n"
"This\n"
"1\n"
"is\n"
"2\n"
"a\n"
"3\n"
"list"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.3"
msgstr ""
"This\n"
"0\n"
"is\n"
"1\n"
"a\n"
"2\n"
"list\n"
"3"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.4"
msgstr ""
"0\n"
"1\n"
"2\n"
"3\n"
"This\n"
"is\n"
"a\n"
"list"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.output_prediction_choices.5"
msgstr ""
"This\n"
"is\n"
"a\n"
"list\n"
"0\n"
"1\n"
"2\n"
"3"

msgid ""
"pages.GettingElementsAtPosition.steps.introducing_len_and_range.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"indices = [0, 1, 2, 3]\n"
"\n"
"for index in indices:\n"
"    print(index)\n"
"    print(words[index])"

msgid ""
"pages.GettingElementsAtPosition.steps.print_indices_and_words.hints.0.text"
msgstr "Remember that earlier we used `range(4)`."

msgid ""
"pages.GettingElementsAtPosition.steps.print_indices_and_words.hints.1.text"
msgstr ""
"This time, it should work for any list. What if the list has 5 elements, or "
"10?"

msgid ""
"pages.GettingElementsAtPosition.steps.print_indices_and_words.hints.2.text"
msgstr "Combine the two functions you learned!"

msgid "pages.GettingElementsAtPosition.steps.print_indices_and_words.text"
msgstr ""
"So in general, the valid indices are:\n"
"\n"
"__code0__\n"
"\n"
"Now we can fix the program from earlier to work with any list. Fill in the `...`:\n"
"\n"
"    __copyable__\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"\n"
"    for index in ...:\n"
"        print(index)\n"
"        print(words[index])\n"
"\n"
"For the given example value of `words` it should print:\n"
"\n"
"    0\n"
"    This\n"
"    1\n"
"    is\n"
"    2\n"
"    a\n"
"    3\n"
"    list"

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.0.text"
msgstr ""
"To access the last element of the list, you'll need the index of the last "
"position."

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.1.text"
msgstr ""
"If the list has 2 elements, the first element is at index 0, so the last "
"element is at index 1."

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.2.text"
msgstr ""
"Likewise, if the list had 3 elements, the last element would be at index 2."

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.3.text"
msgstr "Do you see a pattern between those numbers? How can you express it?"

msgid "pages.GettingElementsAtPosition.steps.print_last_element.hints.4.text"
msgstr "Can you come up with a general solution that works for any length?"

msgid "pages.GettingElementsAtPosition.steps.print_last_element.text"
msgstr ""
"Exercise: for any non-empty list `words`, print the last element. For example, if\n"
"\n"
"    __no_auto_translate__\n"
"    words = ['This', 'is', 'a', 'list']\n"
"\n"
"your program should print `list`."

msgid ""
"pages.GettingElementsAtPosition.steps.printing_the_range.output_prediction_choices.4"
msgstr ""
"This\n"
"is\n"
"a\n"
"list"

msgid "pages.GettingElementsAtPosition.steps.printing_the_range.text"
msgstr ""
"As you can see, the result is the same. Try this:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid ""
"pages.GettingElementsAtPosition.steps.range_almost_the_same_as_list.text"
msgstr ""
"`range(4)` is the same thing as `[0, 1, 2, 3]` ... almost. Try `__program__`"
" in the shell."

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.0"
msgstr "range(4)"

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.1"
msgstr "range(0, 4)"

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.2"
msgstr "list(range(4))"

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.3"
msgstr "list(range(0, 4))"

msgid ""
"pages.GettingElementsAtPosition.steps.range_versus_list.output_prediction_choices.4"
msgstr "range(0, 1, 2, 3)"

msgid "pages.GettingElementsAtPosition.steps.range_versus_list.text"
msgstr ""
"That's probably a bit surprising. If you're curious, the `0` represents the start of the range.\n"
"`0` is the default start, so `range(4)` is equal to `range(0, 4)`.\n"
"`4` is the end of the range, but the end is always excluded, so the last value is `3`.\n"
"If you're confused now, don't worry about it.\n"
"\n"
"There's a good reason for why `range(4)` is not actually a list - it makes programs faster and more efficient.\n"
"It's not worth explaining that more right now.\n"
"\n"
"But you can easily convert it to a list: try `__program__` in the shell."

msgid "pages.GettingElementsAtPosition.steps.using_len_first_time.program"
msgstr ""
"words = ['This', 'is', 'a', 'list']\n"
"print(len(words))"

msgid "pages.GettingElementsAtPosition.steps.using_len_first_time.text"
msgstr ""
"That's just a demonstration to let you see a range in a more familiar form.\n"
"You should almost never actually do that.\n"
"\n"
"If you're feeling overwhelmed, don't worry! All you need to know is that `range(n)`\n"
"is very similar to the list:\n"
"\n"
"__code0__\n"
"\n"
"By the way, you can get the number of elements in a list (commonly called the *length*) using the `len` function.\n"
"Try it by running this code:\n"
"\n"
"    __copyable__\n"
"__code1__"

msgid "pages.GettingElementsAtPositionExercises.steps.final_text.text"
msgstr "Magnificent! Take a break, you've earned it!"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.0.text"
msgstr ""
"You will need to look at all the possible indices of `things` and check "
"which one is the answer."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.1.text"
msgstr ""
"To look at all possible indices, you will need a loop over "
"`range(len(things))`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.2.text"
msgstr "To check if an index is the answer, you will need to use:"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.3.text"
msgstr "- `if`"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.4.text"
msgstr "- the index in a subscript"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.5.text"
msgstr "- `==`"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.6.text"
msgstr ""
"Since you're looking for the first index, you need to stop the loop once you"
" find one."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.7.text"
msgstr "You learned how to stop a loop in the middle recently."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.hints.8.text"
msgstr "You need to use `break`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.messages.all_indices.text"
msgstr ""
"You're almost there! However, this prints all the indices,\n"
"not just the first one."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.index_exercise.messages.last_index.text"
msgstr ""
"You're almost there! However, this prints the *last* index,\n"
"not the first one."

msgid "pages.GettingElementsAtPositionExercises.steps.index_exercise.text"
msgstr ""
"Given a list `things` and a value `to_find`,\n"
"print the first index of `to_find` in the list, i.e. the lowest number `i` such that\n"
"`things[i]` is `to_find`. For example, for\n"
"\n"
"    __no_auto_translate__\n"
"    things = ['on', 'the', 'way', 'to', 'the', 'store']\n"
"    to_find = 'the'\n"
"\n"
"your program should print `1`.\n"
"\n"
"You can assume that `to_find` appears at least once."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.0.text"
msgstr ""
"Did you experiment with indexing and `len()` with strings in the shell?"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.1.text"
msgstr ""
"Forget loops for a moment. How would you print just the first line, which "
"has the first character of each of the two strings?"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.2.text"
msgstr ""
"In the second line you want to print the second character of each string, "
"and so on."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.3.text"
msgstr "You will need a `for` loop."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.4.text"
msgstr "You will need indexing (subscripting)."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.5.text"
msgstr "You will need `range`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.6.text"
msgstr "You will need `len`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.7.text"
msgstr "You will need `+`."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.8.text"
msgstr "You will need to index both strings."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_exercise.hints.9.text"
msgstr ""
"You will need to pass the same index to both strings each time to retrieve "
"matching characters."

msgid "pages.GettingElementsAtPositionExercises.steps.zip_exercise.text"
msgstr ""
"Nice!\n"
"\n"
"By the way, indexing and `len()` also work on strings. Try them out in the shell.\n"
"\n"
"Here's another exercise. Given two strings of equal length, e.g:\n"
"\n"
"    __no_auto_translate__\n"
"    string1 = 'Hello'\n"
"    string2 = 'World'\n"
"\n"
"print them vertically side by side, with a space between each character:\n"
"\n"
"    H W\n"
"    e o\n"
"    l r\n"
"    l l\n"
"    o d"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.0.text"
msgstr ""
"The solution has the same overall structure and essential elements of the "
"previous solution, but it's significantly longer and will require a few "
"additional ideas and pieces."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.1.text"
msgstr ""
"In particular, it should still contain something like:\n"
"\n"
"__code0__"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.2.text"
msgstr ""
"What should go inside `range()`? Neither `len(string1)` nor `len(string2)` "
"is good enough."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.3.text"
msgstr "You want a loop iteration for every character in the longer string."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.4.text"
msgstr "That means you need `range(<length of the longest string>)`"

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.5.text"
msgstr ""
"In other words you need to find the biggest of the two values `len(string1)`"
" and `len(string2)`. You've already done an exercise like that."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.6.text"
msgstr ""
"Once you've sorted out `for i in range(...)`, `i` will sometimes be too big "
"to be a valid index for both strings. You will need to check if it's too big"
" before indexing."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.7.text"
msgstr ""
"Remember, the biggest valid index for `string1` is `len(string1) - 1`. "
"`len(string1)` is too big."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.8.text"
msgstr "You will need two `if` statements, one for each string."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.hints.9.text"
msgstr ""
"You will need to set e.g. `char1 = ' '` when `string1[i]` is not valid."

msgid ""
"pages.GettingElementsAtPositionExercises.steps.zip_longest_exercise.text"
msgstr ""
"Incredible!\n"
"\n"
"Your solution probably looks something like this:\n"
"\n"
"__code0__\n"
"\n"
"This doesn't work so well if the strings have different lengths.\n"
"In fact, it goes wrong in different ways depending on whether `string1` or `string2` is longer.\n"
"Your next challenge is to fix this problem by filling in 'missing' characters with spaces.\n"
"\n"
"For example, for:\n"
"\n"
"    __no_auto_translate__\n"
"    string1 = 'Goodbye'\n"
"    string2 = 'World'\n"
"\n"
"output:\n"
"\n"
"    G W\n"
"    o o\n"
"    o r\n"
"    d l\n"
"    b d\n"
"    y\n"
"    e\n"
"\n"
"and for:\n"
"\n"
"    __no_auto_translate__\n"
"    string1 = 'Hello'\n"
"    string2 = 'Elizabeth'\n"
"\n"
"output:\n"
"\n"
"    H E\n"
"    e l\n"
"    l i\n"
"    l z\n"
"    o a\n"
"      b\n"
"      e\n"
"      t\n"
"      h"

msgid "pages.GettingElementsAtPositionExercises.title"
msgstr "Exercises with `range()` and `len()`"

msgid "frontend.are_you_sure"
msgstr "Are you sure?"

msgid "frontend.ask_for_help"
msgstr "Ask for Help"

msgid "frontend.cancel"
msgstr "Cancel"

msgid "frontend.chat_on_slack"
msgstr "Chat on Slack"

msgid "frontend.click_for_error_details"
msgstr "Click for error details"

msgid "frontend.contact_directly"
msgstr "Alternatively, you can contact us directly:"

msgid "frontend.copy_warning"
msgstr ""
"**STOP!**\n"
"\n"
"Try to avoid copy pasting code. You will learn, absorb, and remember better if you type in the code yourself.\n"
"\n"
"When copying is appropriate, there will be a button to click to make it easy. If there's no button, try typing.\n"
"\n"
"Having said that, we're not going to force you. Copy if you really want to."

msgid "frontend.copying_solution_not_allowed"
msgstr "Copying from the hints/solution area is not allowed!"

msgid "frontend.current_page"
msgstr "(current)"

msgid "frontend.description"
msgstr "Description"

msgid "frontend.developer_mode"
msgstr "Developer mode"

msgid "frontend.developer_mode_description"
msgstr "Enables the \"Reverse step\" and \"Skip step\" buttons."

msgid "frontend.did_you_mean"
msgstr "Did you mean..."

msgid "frontend.error_traceback"
msgstr "Error traceback:"

msgid "frontend.feedback"
msgstr "Feedback"

msgid "frontend.feedback_email_placeholder"
msgstr "Email (optional)"

msgid "frontend.get_another_hint"
msgstr "Get another hint"

msgid "frontend.get_hint"
msgstr "Get a hint"

msgid "frontend.give_feedback"
msgstr "Give feedback"

msgid "frontend.give_feedback_instructions"
msgstr ""
"Tell us what you like or don't like! If you're reporting a bug, give a detailed description of the problem:\n"
"\n"
"- What were you doing before and when the problem occurred?\n"
"- What steps can someone take to reproduce it?\n"
"- What do you observe happening, and what do you expect to happen instead?"

msgid "frontend.hidden_solution_instructions"
msgstr ""
"Above is an example solution, but it's hidden. Click the Reveal button "
"repeatedly to reveal the solution bit by bit. Try to stop when you think "
"you've revealed enough and can fill in the remaining gaps yourself. Then "
"type a solution in the editor and run it. Your solution doesn't have to be "
"the same as the one above."

msgid "frontend.hints_progress"
msgstr "Shown ${numHints} of ${totalHints} hints"

msgid "frontend.loading_wait"
msgstr "Loading..."

msgid "frontend.login_or_sign_up"
msgstr "Login / Sign up"

msgid "frontend.next"
msgstr "Next"

msgid "frontend.no"
msgstr "No"

msgid "frontend.ok"
msgstr "OK"

msgid "frontend.open_github_issue"
msgstr "Open an issue on GitHub"

msgid "frontend.output_prediction_correct"
msgstr "Correct!"

msgid "frontend.output_prediction_error_choice"
msgstr "Error"

msgid "frontend.output_prediction_question"
msgstr "What do you think the result will be?"

msgid "frontend.output_prediction_wrong_once"
msgstr "Oops, that's not right. You can try one more time!"

msgid "frontend.output_prediction_wrong_twice"
msgstr "Sorry, wrong answer. Try again next time!"

msgid "frontend.parsons_solution_instructions"
msgstr ""
"Above is an example solution with the lines out of order. You can drag them "
"around to reorder them. Finding a correct order is up to you, and we won't "
"will tell you if you get it right. Experimenting and running partial "
"solutions in the editor may help you figure it out. You still need to type a"
" correct solution into the editor and run it to continue."

msgid "frontend.previous"
msgstr "Previous"

msgid "frontend.question_wizard"
msgstr "Question Wizard"

msgid "frontend.question_wizard_expected_output"
msgstr ""
"Good, now enter the output you expect/want from your program below. What would it show if it worked correctly? If it's not supposed to output anything, then add some `print()` calls to your code so that it would output something useful.\n"
"\n"
"When you're done, click 'Run' again to generate your question."

msgid "frontend.question_wizard_intro"
msgstr ""
"If you need help, there are many sites like [Stack Overflow](https://stackoverflow.com/) and [reddit](https://www.reddit.com/r/learnpython/) where you can ask questions. This is a tool to help you write a good quality question that is likely to get answers.\n"
"\n"
"Enter and run your code on the right. If you don't have any code because you don't know where to get started, I'm afraid this tool can't help you. You can still ask for help, but it might be good to first read [What types of questions should I avoid asking?](https://stackoverflow.com/help/dont-ask)\n"
"\n"
"If your question is about servers (e.g. Django or Flask), web requests, databases, or a package that can't be imported here, then this tool won't work. However, just because your current code *involves* those things, that doesn't mean that's what your question is *about*. If you're having a general Python/programming/logic problem, then extract that problem from the other stuff. Python with Django is still Python. If you can't do that, then read [How to create a Minimal, Reproducible Example](https://stackoverflow.com/help/minimal-reproducible-example) before asking your question."

msgid "frontend.repeated_frames_description"
msgstr "${name} at line ${lineno} (${count} times)"

msgid "frontend.reveal"
msgstr "Reveal"

msgid "frontend.reverse_step"
msgstr "Reverse step"

msgid "frontend.run"
msgstr "Run"

msgid "frontend.send_email_to"
msgstr "Email"

msgid "frontend.settings"
msgstr "Settings"

msgid "frontend.show_shuffled_solution"
msgstr "Show shuffled solution"

msgid "frontend.show_solution"
msgstr "Show solution"

msgid "frontend.show_unscrambled_solution"
msgstr "Show unscrambled solution"

msgid "frontend.sign_out"
msgstr "Sign out"

msgid "frontend.similar_frames_skipped"
msgstr "Similar frames skipped:"

msgid "frontend.skip_step"
msgstr "Skip step"

msgid "frontend.stop"
msgstr "Stop"

msgid "frontend.submit"
msgstr "Submit"

msgid "frontend.table_of_contents"
msgstr "Table of Contents"

msgid "frontend.title"
msgstr "Title"

msgid "frontend.toc_instructions"
msgstr ""
"Below are links to different pages in the course. You can start anywhere and go in any order, and your progress on each page will be recorded.\n"
"\n"
"If you're completely new to programming, or you have doubts, just start at the beginning and click Next as you finish each page."

msgid "frontend.yes"
msgstr "Yes"

msgid "misc_terms.string_spaces_differ"
msgstr ""
"Check that the strings in your code have the correct spaces. For example, "
"`'Hello'` is different from `'Hello '` because of the space at the end."

msgid ""
"pages.NewlinesAndFormatBoard.steps.multi_line_strings_triple_quotes.program"
msgstr ""
"string = \"\"\"First line\n"
"Second line\"\"\"\n"
"print(string)"

msgid "pages.IfAndElse.steps.else_full_stop.hints.0.text"
msgstr "Don't change anything that's already there, just add a bit more code."

msgid "pages.IfAndElse.steps.else_full_stop.hints.1.text"
msgstr ""
"`else` needs to come immediately after the `if` body, with nothing in "
"between."

msgid "pages.IfAndElse.steps.else_full_stop.hints.2.text"
msgstr ""
"`sentence += char` needs to run whether `excited` is `True` or `False`."

msgid "pages.IfAndElse.steps.else_full_stop.hints.3.text"
msgstr ""
"You *could* have a copy of `sentence += char` in both the `if` and `else` "
"blocks, but there's a better way."

msgid "pages.IfAndElse.steps.else_full_stop.hints.4.text"
msgstr "Use `else` to assign a different value to `char`."

msgid "pages.IfAndElse.steps.else_full_stop.hints.5.text"
msgstr ""
"If `excited` is `False`, then `char` should be `'.'` instead of `'!'`."

msgid "frontend.click_to_expand"
msgstr "Click to expand"

msgid "chapters.dictionaries.title"
msgstr "Dictionaries"

msgid "code_bits.\"English: \""
msgstr "\"English: \""

msgid "code_bits.\"French: \""
msgstr "\"French: \""

msgid "code_bits.\"German: \""
msgstr "\"German: \""

msgid "code_bits.'French'"
msgstr "'French'"

msgid "code_bits.'German'"
msgstr "'German'"

msgid "code_bits.'TCATCGCAGGAATCAATGTCCTACCGAATA'"
msgstr "'TCATCGCAGGAATCAATGTCCTACCGAATA'"

msgid "code_bits.'apfel'"
msgstr "'apfel'"

msgid "code_bits.'apple'"
msgstr "'apple'"

msgid "code_bits.'boite'"
msgstr "'boite'"

msgid "code_bits.'box'"
msgstr "'box'"

msgid "code_bits.'cat'"
msgstr "'cat'"

msgid "code_bits.'dog'"
msgstr "'dog'"

msgid "code_bits.'kasten'"
msgstr "'kasten'"

msgid "code_bits.'pomme'"
msgstr "'pomme'"

msgid "code_bits.cart"
msgstr "cart"

msgid "code_bits.f\"---\""
msgstr "f\"---\""

msgid "code_bits.f\"English: {word}\""
msgstr "f\"English: {word}\""

msgid "code_bits.f\"{language}: {translations[language]}\""
msgstr "f\"{language}: {translations[language]}\""

msgid "code_bits.french"
msgstr "french"

msgid "code_bits.german"
msgstr "german"

msgid "code_bits.item"
msgstr "item"

msgid "code_bits.key"
msgstr "key"

msgid "code_bits.language"
msgstr "language"

msgid "code_bits.original"
msgstr "original"

msgid "code_bits.price"
msgstr "price"

msgid "code_bits.prices"
msgstr "prices"

msgid "code_bits.print_words"
msgstr "print_words"

msgid "code_bits.quantities"
msgstr "quantities"

msgid "code_bits.quantity"
msgstr "quantity"

msgid "code_bits.substitute"
msgstr "substitute"

msgid "code_bits.total_cost"
msgstr "total_cost"

msgid "code_bits.translations"
msgstr "translations"

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.hints.0.text"
msgstr ""
"Remember that we previously had `for item in cart` in the function, but "
"`cart` is no longer an argument."

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.hints.1.text"
msgstr ""
"Now `quantities` is the only argument that defines what the customer is "
"buying."

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.hints.2.text"
msgstr ""
"You need to iterate over the keys of `quantities` instead. Remember that "
"'iterate' here means 'loop over' with a `for` loop."

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.hints.3.text"
msgstr "You can use `.keys()`, but you don't have to."

msgid "pages.DictionaryKeysAndValues.steps.cleanup_shopping_cart.text"
msgstr ""
"Now you can use this to modify our function on the previous page to remove the `cart` argument:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.DictionaryKeysAndValues.steps.english_to_french.hints.0.text"
msgstr "You will need to iterate (loop) over the dictionary."

msgid "pages.DictionaryKeysAndValues.steps.english_to_french.hints.1.text"
msgstr ""
"You need to print both the key (English word) and the value (French word) of"
" each dictionary entry."

msgid "pages.DictionaryKeysAndValues.steps.english_to_french.hints.2.text"
msgstr "You can get the value using the key in the same way as always."

msgid "pages.DictionaryKeysAndValues.steps.english_to_french.text"
msgstr ""
"That looks nice! We've fully solved the problem of adding up the total cost.\n"
"\n"
"Coming back to our first example: write a function\n"
"which prints out each word in an English-to-French dictionary and its translation, labeling them with their languages.\n"
"Here's your starting code:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"For example, the last line of code above should print:\n"
"\n"
"    English: apple\n"
"    French: pomme\n"
"    ---\n"
"    English: box\n"
"    French: boite\n"
"    ---"

msgid "pages.DictionaryKeysAndValues.steps.english_to_german.hints.0.text"
msgstr ""
"This is still very similar to the previous exercise, nothing special yet."

msgid "pages.DictionaryKeysAndValues.steps.english_to_german.hints.1.text"
msgstr ""
"You can reuse your previous solution, just add another argument and a tiny "
"bit of code inside."

msgid "pages.DictionaryKeysAndValues.steps.english_to_german.hints.2.text"
msgstr "You now have to print one dictionary key and two dictionary values."

msgid "pages.DictionaryKeysAndValues.steps.english_to_german.text"
msgstr ""
"Great! Now let's add a German dictionary as well:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"That should print:\n"
"\n"
"    English: apple\n"
"    French: pomme\n"
"    German: apfel\n"
"    ---\n"
"    English: box\n"
"    French: boite\n"
"    German: kasten\n"
"    ---\n"
"\n"
"The two dictionaries will always have the same keys, just different values."

msgid "pages.DictionaryKeysAndValues.steps.final_text.text"
msgstr ""
"Congratulations! You've reached the end of the course so far. More is on the"
" way!"

msgid "pages.DictionaryKeysAndValues.steps.introducing_keys.text"
msgstr ""
"Copy this code into the editor:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"Then change `print(quantities)` to `print(quantities.keys())`, and run the whole program."

msgid "pages.DictionaryKeysAndValues.steps.keys_are_iterable.text"
msgstr ""
"The `.keys()` method of `dict` does basically what you'd expect. You can iterate over the value it returns\n"
"just like you'd iterate over a list:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.DictionaryKeysAndValues.steps.keys_are_iterable2.text"
msgstr ""
"Actually, you don't even need `.keys()`. Iterating directly over a dictionary automatically iterates over its keys.\n"
"Sometimes it's nice to write `.keys()` to make your code more readable, but you don't have to.\n"
"Remove the `.keys()` and run the code again."

msgid "pages.DictionaryKeysAndValues.steps.nested_dictionaries.text"
msgstr ""
"Beautiful! There's a pattern emerging here. The two languages could be merged into one big nested dictionary:\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.DictionaryKeysAndValues.title"
msgstr "Iterating over Dictionary Keys"

msgid ""
"pages.IntroducingDictionaries.steps.dict_access.special_messages.bad_french_value.text"
msgstr ""
"Oops, you need to set `french = {'apple': 'pomme', 'box': 'boite'}` before "
"we can continue."

msgid "pages.IntroducingDictionaries.steps.dict_access.text"
msgstr ""
"`french` is a dictionary with two key-value pairs:\n"
"\n"
"- `'apple': 'pomme'` where `'apple'` is the key and `'pomme'` is the value.\n"
"- `'box': 'boite'` where `'box'` is the key and `'boite'` is the value.\n"
"\n"
"Like lists, a comma (`,`) is used to separate items (key-value pairs) from each other. A colon (`:`) separates the keys from the values.\n"
"Note that curly brackets (`{}`) are used to create the dictionary instead of the square brackets (`[]`) used when writing lists.\n"
"\n"
"Remember that with lists, you get values based on their *index*, i.e. their position in the list.\n"
"So if `words = ['apple', 'box']`, then `words[0]` is `'apple'` and `words[1]` is `'box'`.\n"
"Try this in the shell:\n"
"\n"
"__program_indented__"

msgid ""
"pages.IntroducingDictionaries.steps.dict_access2.special_messages.bad_french_value.text"
msgstr ""
"Oops, you need to set `french = {'apple': 'pomme', 'box': 'boite'}` before "
"we can continue."

msgid "pages.IntroducingDictionaries.steps.dict_access2.text"
msgstr ""
"That doesn't work because the position of items in a dictionary usually doesn't matter.\n"
"You don't usually care what's the 2nd or 5th or 100th word of the dictionary,\n"
"you just want to find a specific word like 'apple'. So try that instead:\n"
"\n"
"__program_indented__"

msgid ""
"pages.IntroducingDictionaries.steps.dict_access3.special_messages.bad_french_value.text"
msgstr ""
"Oops, you need to set `french = {'apple': 'pomme', 'box': 'boite'}` before "
"we can continue."

msgid "pages.IntroducingDictionaries.steps.dict_access3.text"
msgstr ""
"That's better!\n"
"\n"
"Now run a similar line in the shell to look up the translation for `'box'`."

msgid ""
"pages.IntroducingDictionaries.steps.dict_access4.special_messages.bad_french_value.text"
msgstr ""
"Oops, you need to set `french = {'apple': 'pomme', 'box': 'boite'}` before "
"we can continue."

msgid "pages.IntroducingDictionaries.steps.dict_access4.text"
msgstr ""
"And now you know both Python and French!\n"
"\n"
"Now let's translate from French to English:\n"
"\n"
"__program_indented__"

msgid "pages.IntroducingDictionaries.steps.final_text.text"
msgstr ""
"Sorry, you can't do that either. You can only look up a key to get its value, not the other way around.\n"
"The dictionary `french` only has 2 keys: `'apple'` and `'box'`. `'pomme'` is a value, not a key.\n"
"We'll soon learn why you can't just look up values directly, and what you can do about it.\n"
"\n"
"Note that both `french[0]` and `french['pomme']` raised the same type of error: a `KeyError`.\n"
"This error means that the provided key (`0` or `'pomme'` in this case) wasn't found in the dictionary.\n"
"It's not that `french[0]` isn't *allowed*, it's just that it means the same thing as always:\n"
"find the value associated with the key `0`. In this case it finds that no such key exists.\n"
"But `0` *could* be a key, because many types of keys are allowed, including strings and numbers."

msgid "pages.IntroducingDictionaries.steps.first_dict.text"
msgstr ""
"We've seen several types: `str`, `int`, `float`, `bool`, and `list`.\n"
"Only one of these types can contain multiple values: `list`.\n"
"Now we're going to learn about another container type: `dict`, short for ***dictionary***.\n"
"\n"
"Think of the familiar kind of dictionary where you look up a word to find its definition or a translation in another language.\n"
"Dictionaries in Python are similar, but more general. You look up a *key* (e.g. a word) to get the associated *value* (e.g. a definition or translation).\n"
"\n"
"For example, here's a little dictionary translating English words to French:\n"
"\n"
"__code0__\n"
"\n"
"Run the line above in the shell."

msgid "pages.IntroducingDictionaries.title"
msgstr "Introducing Dictionaries"

msgid "pages.UsingDictionaries.steps.dna_part1.text"
msgstr ""
"Not bad! But you may have noticed that it looks a bit awkward. Why do we have to specify `'dog'` and `'box'` in both the `cart` and the `quantities`?\n"
"On the next page we'll look at how to loop directly over the keys of a dictionary,\n"
"so we can get rid of the `cart` argument.\n"
"\n"
"But first, let's practice what we've learned a bit more.\n"
"\n"
"[Earlier in the course](#IntroducingElif) we looked at converting one strand of DNA\n"
"into a new strand with matching nucleotides.\n"
"Here's a version of that code using a function. It substitutes each letter in the input `string`\n"
"with a different one.\n"
"\n"
"    __copyable__\n"
"__code0__"

msgid "pages.UsingDictionaries.steps.dna_part2.hints.0.text"
msgstr ""
"This is still very similar to the previous exercises, but with strings "
"instead of numbers."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.1.text"
msgstr "You just have to think about the keys and values of `d`."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.2.text"
msgstr "You need to obtain the correct values to build up a string to return."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.3.text"
msgstr ""
"You can basically replace the whole `if/elif` chain with a single line."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.4.text"
msgstr "That line simply needs to use `d` to get the correct value."

msgid "pages.UsingDictionaries.steps.dna_part2.hints.5.text"
msgstr "Remember that the keys of `d` are the characters in `string`."

msgid "pages.UsingDictionaries.steps.dna_part2.text"
msgstr ""
"Now we can use dictionaries to make this code both shorter and more general so it can be used for other purposes.\n"
"\n"
"Your job is to add another argument to the `substitute` function: a dictionary called `d`.\n"
"The keys of `d` represent characters\n"
"in the first argument `string` that should be replaced by the corresponding values of `d`. For example, `'A': 'T'`\n"
"means that `'A'` should be replaced by `'T'`:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"This version of `substitute` should work for any arguments where all the characters in `string` are keys in `d`.\n"
"No more `if` statements needed!"

msgid "pages.UsingDictionaries.steps.final_text.text"
msgstr ""
"Nice! Here's an example of how this function can also be used to encrypt and decrypt secret messages:\n"
"\n"
"    __copyable__\n"
"    __no_auto_translate__\n"
"    def substitute(string, d):\n"
"        result = \"\"\n"
"        for letter in string:\n"
"            result += d[letter]\n"
"        return result\n"
"\n"
"    plaintext = 'helloworld'\n"
"    encrypted = 'qpeefifmez'\n"
"    letters = {'h': 'q', 'e': 'p', 'l': 'e', 'o': 'f', 'w': 'i', 'r': 'm', 'd': 'z'}\n"
"    reverse = {'q': 'h', 'p': 'e', 'e': 'l', 'f': 'o', 'i': 'w', 'm': 'r', 'z': 'd'}\n"
"    assert_equal(substitute(plaintext, letters), encrypted)\n"
"    assert_equal(substitute(encrypted, reverse), plaintext)\n"
"\n"
"The same function works in both directions, we just need to pass it different dictionaries.\n"
"\n"
"The two dictionaries are almost the same, we just swap around the key and value in each pair.\n"
"So to encrypt, we replace `e` with `p`, and to decrypt we change `p` back to `e`.\n"
"\n"
"Note that `'e'` is both a key and a value in `letters`.\n"
"\n"
"Looking up `letters['e']` means that we're asking about `'e'` as a *key*, so it gives `'p'`.\n"
"Remember, we can't use `letters` to ask which key is associated with `'e'` as a *value*.\n"
"But in this case we can use the other dictionary for that: `reverse['e']` gives `'l'`,\n"
"and `letters['l']` gives `'e'` again.\n"
"\n"
"Soon you'll write a function to create a dictionary like `reverse` automatically,\n"
"i.e. `reverse = swap_keys_values(letters)`."

msgid "pages.UsingDictionaries.steps.shopping_cart1.hints.0.text"
msgstr "Remember that `prices` is a dictionary."

msgid "pages.UsingDictionaries.steps.shopping_cart1.hints.1.text"
msgstr "To access a value in a dictionary, you need a key."

msgid "pages.UsingDictionaries.steps.shopping_cart1.hints.2.text"
msgstr "The keys for `prices` are the items in the `cart`."

msgid "pages.UsingDictionaries.steps.shopping_cart1.text"
msgstr ""
"Let's see dictionaries in a real life problem. Imagine you're building an online shopping website.\n"
"You keep the prices of all your items in a dictionary:\n"
"\n"
"__code0__\n"
"\n"
"Here you can see one reason why looking up values in a dictionary could be a problem.\n"
"What would `prices[100]` be? `'dog'`? `'cat'`? `['dog', 'cat']`?\n"
"The same value can be repeated any number of times in a dictionary.\n"
"On the other hand, keys have to be unique. Imagine if your prices started like this:\n"
"\n"
"__code1__\n"
"\n"
"How much does an apple cost? We know it's `prices['apple']`, but is that `2` or `3`?\n"
"Clearly there should only be one price, so duplicate keys aren't allowed.\n"
"\n"
"Anyway, this is a normal shop where things have one price.\n"
"This normal shop has normal customers with normal shopping lists like `['apple', 'box', 'cat']`.\n"
"And even though your customers have calculators in their pockets, they still expect you to add up all the prices\n"
"yourself and tell them how much this will all cost, because that's what normal shops do.\n"
"\n"
"So let's write a function that does that. Complete the function below, particularly the line `price = ...`\n"
"\n"
"    __copyable__\n"
"__code2__"

msgid "pages.UsingDictionaries.steps.shopping_cart4.hints.0.text"
msgstr "Remember that the keys for `prices` and `quantities` are the same."

msgid "pages.UsingDictionaries.steps.shopping_cart4.hints.1.text"
msgstr "This is very similar to the previous exercise, we're just practicing."

msgid "pages.UsingDictionaries.steps.shopping_cart4.hints.2.text"
msgstr ""
"`price` should be a value from `prices`, and similarly for `quantity`."

msgid "pages.UsingDictionaries.steps.shopping_cart4.hints.3.text"
msgstr "What key should be used to obtain each value?"

msgid "pages.UsingDictionaries.steps.shopping_cart4.text"
msgstr ""
"Perfect! You publish your website and start dreaming about how rich you're going to be.\n"
"\n"
"But soon you get a complaint from a customer who wants to buy 5 million dogs...and 2 boxes to put them in.\n"
"\n"
"Your website allows buying the same items several times, e.g. `total_cost(['box', 'box'], {...})` works,\n"
"but they have to add each item one at a time, and for some reason this customer doesn't want to click\n"
"'Add to Cart' 5 million times. People are so lazy!\n"
"\n"
"Here's the new code for you to fix:\n"
"\n"
"    __copyable__\n"
"__code0__\n"
"\n"
"We've added another parameter called `quantities` to `total_cost`.\n"
"Now `cart` is still a list of strings, but it doesn't have any duplicates.\n"
"`quantities` is a dictionary where the keys are the items in `cart` and the corresponding values are the quantity\n"
"of that item that the customer wants to buy."

msgid "pages.UsingDictionaries.title"
msgstr "Using Dictionaries in Practice"

msgid "frontend.assessment"
msgstr "Assessment"

msgid "frontend.assessment_description"
msgstr ""
"When you run code that doesn't pass the current step, this section will "
"*sometimes* explain what's wrong."

msgid "frontend.exercise_requirement"
msgstr ""
"This step is an exercise. You need to figure out what code will produce the "
"correct result. Many different correct answers are possible."

msgid "frontend.exercise_stdin"
msgstr ""
"Your program needs to receive input from the user via the `input()` "
"function. When it's tested for correctness, different user inputs will be "
"simulated."

msgid "frontend.function_exercise"
msgstr ""
"Define a function starting like this:\n"
"\n"
"${header}\n"
"\n"
"Then fill in the indented body with your implementation.\n"
"\n"
"The function will be called with different arguments to test that it works generally. You can also call the function yourself to test it as you work, but it doesn't affect the assessment."

msgid "frontend.function_exercise_goal"
msgstr "Your function needs to `${print_or_return}` the correct result."

msgid "frontend.hints_and_solution"
msgstr "Hints and Solution"

msgid "frontend.new"
msgstr "New"

msgid "frontend.no_hints_available"
msgstr ""
"This step doesn't have any hints. Try reading the instructions and "
"requirements again. You can still check the solution if you're really stuck."

msgid "frontend.no_input_variables"
msgstr "This exercise has no input variables."

msgid "frontend.non_function_exercise"
msgstr ""
"Your code *must* start by assigning value(s) to input variable(s), e.g:\n"
"\n"
"${inputs}\n"
"\n"
"The values are just examples, you can choose different ones. Your code will be tested automatically with different values to check that it works generally."

msgid "frontend.program_in_text"
msgstr ""
"The exact code that you need to run is shown in the text above, in one "
"piece."

msgid "frontend.requirements"
msgstr "Requirements"

msgid "frontend.requirements_description"
msgstr ""
"You need to run some code according to the instructions above. In case those"
" aren't clear enough, here's some extra clarification:"

msgid "frontend.verbatim"
msgstr ""
"This step has only one correct answer. You must run exactly the correct "
"code, so check your spelling carefully. Only a few kinds of details (such as"
" spaces in certain places) will be ignored, as they don't make any "
"difference to the program."

msgid "misc_terms.which_is_correct"
msgstr "which is correct!"

msgid "pages.AddingStrings.steps.hello_world_space.requirements"
msgstr ""
"Use `+` to add two or more strings together, so that the result is the "
"string `'hello world'`."

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.see_stack_in_birdseye.requirements"
msgstr "Run the same program as above, but with `birdseye`."

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.see_stack_in_pythontutor.requirements"
msgstr "Run the same program as above, but with Python Tutor."

msgid ""
"pages.CallingFunctionsWithinFunctions.steps.see_stack_in_snoop.requirements"
msgstr "Run the same program as above, but with `snoop`."

msgid "pages.DefiningFunctions.steps.how_are_you.requirements"
msgstr ""
"Add `print(\"How are you?\")` after `print(f\"Hello {name}!\")` with the same indentation.\n"
"Keep the two calls to `greet` after the definition as is."

msgid "pages.DefiningFunctions.steps.print_twice_exercise.requirements"
msgstr ""
"Write a program which defines a function called `print_twice` as described "
"above."

msgid "pages.DictionaryKeysAndValues.steps.introducing_keys.requirements"
msgstr "Run `print(quantities.keys())` where `quantities` is a dictionary."

msgid "pages.DictionaryKeysAndValues.steps.keys_are_iterable2.requirements"
msgstr ""
"Run the same code as the previous step, but without `.keys()`. after "
"`quantities`, so the middle line is `for key in quantities:`"

msgid "pages.EqualsVsIs.steps.same_list.requirements"
msgstr ""
"Run the same program as above, but replace the *second* `[1, 2, 3]` with "
"`list1`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.negative_index_concatenation_exercise.requirements"
msgstr ""
"Copy the three lines above, then replace `(insert_one_line_from_above)` with"
" exactly one line from the long list of lines from before. You must choose "
"the correct line, there's only one right answer. Type in the line exactly. "
"Do not replace the `y = ` part, that should still be there just before the "
"line that you type in, on the same line."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.pop_remove_index_subscript_assignment.requirements"
msgstr ""
"Copy the three lines above, then replace `(insert_one_line_from_above)` with"
" exactly one line from the long list just before that. You must choose the "
"correct line, there's only one right answer. Type in the line exactly."

msgid "pages.FunctionsAndMethodsForLists.steps.remove_exercise.requirements"
msgstr ""
"Copy the three lines above, then replace `x.remove(0)` with exactly one line"
" from the long list of lines from before. The line you choose should have "
"the same effect as `x.remove(0)`, so that the program prints `[1, 2, 3]`."

msgid ""
"pages.FunctionsAndMethodsForLists.steps.subscript_assignment_exercise.requirements"
msgstr ""
"Copy the three lines above, then replace `(insert_one_line_from_above)` with"
" exactly one line from the long list in the previous step. You must choose "
"the correct line, there's only one right answer. Type in the line exactly."

msgid "pages.GettingElementsAtPosition.steps.index_error.requirements"
msgstr "Run something like `words[3]` but replace `3` with a bigger number."

msgid "pages.GettingElementsAtPosition.steps.range_len.requirements"
msgstr ""
"Run the same program from the previous step, but replace the second line "
"`indices = [0, 1, 2, 3]` with `indices = range(4)`."

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.list_insert.requirements"
msgstr ""
"Run code similar to the three lines above, but change `nums.append(9)` to the right function/method call\n"
"to put 9 right after the second element (2 in the example `nums = [1, 2, 3, 4, 5]`) instead of at the end.\n"
"There's only one correct answer for what the middle line should be.\n"
"You need to search online to figure out which function/method to use and how to use it."

msgid ""
"pages.HowToFindInformationWithGoogleAndMore.steps.sum_list.requirements"
msgstr ""
"Run code similar to `sum([21, 55, 4, 91, 62, 49])` but replace `sum` with the name of another specific function.\n"
"There's only one correct answer for which function should be used. You need to search online to figure out which one.\n"
"It's a commonly used built-in function in Python."

msgid "pages.IfAndElse.steps.first_if_else_false.requirements"
msgstr ""
"Run the same program from the previous step, but replace `True` with "
"`False`, so that `condition = False`."

msgid "pages.IfAndElse.steps.if_upper_else_lower_false.requirements"
msgstr ""
"Run the same program from the previous step, but replace `True` with "
"`False`, so that `excited = False`."

msgid "pages.IfAndElse.steps.undefined_char.requirements"
msgstr ""
"Copy the program above. Run it as is if you want. Then change `excited = "
"True` to `excited = False` and run it again."

msgid "pages.IntroducingDictionaries.steps.dict_access3.requirements"
msgstr ""
"Run the same code as the previous step (`french['apple']`) in the shell, but"
" replace `'apple'` with `'box'`."

msgid "pages.IntroducingElif.steps.dna_example_with_elif.requirements"
msgstr ""
"Copy the program from the first step on this page, but replace the 4 `if` blocks there with the\n"
"combination of `if` and `elif` blocks here. In other words, replace each of the last three `if`s with\n"
"`elif`, but leave the first `if` alone."

msgid "pages.IntroducingFstrings.steps.introduce_f_strings.requirements"
msgstr ""
"Run the program above, but replace this code inside the `print()`:\n"
"\n"
"__code0__\n"
"\n"
"with:\n"
"\n"
"__code1__"

msgid "pages.IntroducingIfStatements.steps.excited_false_example.requirements"
msgstr ""
"Run the program from the previous step, but replace `True` with `False`, so "
"`excited = False`."

msgid "pages.IntroducingNestedLists.steps.double_subscripting.requirements"
msgstr ""
"Run `print(strings[1][0])` or something similar using `birdseye` to see how "
"it works."

msgid "pages.IntroducingOr.steps.ACommonMistake.requirements"
msgstr ""
"Run the program from the previous step, but replace:\n"
"\n"
"__code0__\n"
"\n"
"with:\n"
"\n"
"__code1__"

msgid "pages.IntroducingOr.steps.FurtherImprovement.requirements"
msgstr ""
"Run the program from the previous step, but replace:\n"
"\n"
"__code0__\n"
"\n"
"with:\n"
"\n"
"__code1__"

msgid "pages.IntroducingOr.steps.ImprovingWithOr.requirements"
msgstr ""
"Copy the program from the top of the page, then change the first four lines "
"of the function to use `or` as suggested."

msgid "pages.IntroducingOr.steps.InspectWithBirdseye.requirements"
msgstr "Run the same code as in the previous step, but with `birdseye`."

msgid "pages.IntroducingTheShell.steps.more_calculation.requirements"
msgstr ""
"Run code in the shell similar to `1 + 2`, but instead of `+`, use `*`, `/`, "
"or `-`."

msgid ""
"pages.LoopingOverNestedLists.steps.nested_list_loop_python_tutor.requirements"
msgstr ""
"Run a single program consisting of the two parts above combined.\n"
"They're separated so that you don't need to type in the `numbers = [...]` part,\n"
"but typing in the nested loop part is best for learning.\n"
"Make sure the indentation is correct."

msgid ""
"pages.LoopingOverNestedLists.steps.nested_list_nested_loop_example.requirements"
msgstr ""
"Run a single program consisting of the two parts above combined.\n"
"They're separated so that you don't need to type in the `numbers = [...]` part,\n"
"but typing in the nested loop part is best for learning.\n"
"Make sure the indentation is correct."

msgid "pages.ModifyingWhileIterating.steps.make_copy.requirements"
msgstr ""
"Run the same program as above, but change the second line:\n"
"\n"
"__code0__\n"
"\n"
"to:\n"
"\n"
"__code1__\n"
"\n"
"i.e. add `.copy()` after `numbers` but before `:`."

msgid "pages.MoreListFunctionsAndMethods.steps.average_exercise.requirements"
msgstr ""
"Copy the three lines above, then replace `(insert_one_line_from_above)` with"
" exactly one line from the long list of lines above. The middle line should "
"still start with `y = `."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.count_in_sorted_sum.requirements"
msgstr ""
"Copy the three lines above, then replace `1 in x` with exactly one line from"
" the long list of lines above. The middle line should still start with `y = "
"`. The line you choose should have the same effect as `1 in x`, so that the "
"program prints `True`."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.second_smallest_in_list_exercise.requirements"
msgstr ""
"Copy the three lines above, then replace `(insert_one_line_from_above)` with"
" exactly one line from the long list of lines above. The middle line should "
"still start with `y = `."

msgid ""
"pages.MoreListFunctionsAndMethods.steps.sum_range_exercise.requirements"
msgstr ""
"Copy the three lines above, then replace `(insert_one_line_from_above)` with"
" exactly one line from the long list of lines above. The middle line should "
"still start with `y = `."

msgid "pages.MoreOnReturn.steps.break_vs_return.requirements"
msgstr ""
"Run the same code as in the previous step, but replace the whole last line "
"of the function (`return letter`) with just `break`."

msgid "pages.NestedListAssignment.steps.nested_assignment_input.requirements"
msgstr ""
"Your function should modify the `board` argument. It doesn't need to "
"`return` or `print` anything."

msgid "pages.OtherComparisonOperators.steps.comparing_strings.requirements"
msgstr "Run any code in the shell using either `<` or `>` on two strings."

msgid ""
"pages.OtherComparisonOperators.steps.introducing_less_than.requirements"
msgstr "Run any code in the shell using either `<` or `>` on two numbers."

msgid ""
"pages.ReturningValuesFromFunctions.steps.quadruple_exercise.requirements"
msgstr ""
"Write a program which defines a function called `quadruple` as described "
"above."

msgid ""
"pages.StoringCalculationsInVariables.steps.sentence_doesnt_change.requirements"
msgstr ""
"Run a program consisting of the four lines in the previous step followed by "
"the two lines here."

msgid "pages.TestingFunctions.steps.complete_quadruple_tests.requirements"
msgstr ""
"Type in the program above.\n"
"Then change the last two lines by adding one argument to each `assert_equal` call to make the tests pass.\n"
"Don't touch the function definitions."

msgid "pages.TestingFunctions.steps.make_tests_fail.requirements"
msgstr ""
"Run the program from the previous step, but replace `x * 2` with `x * 3`. "
"Keep the rest the same."

msgid "pages.TheEqualityOperator.steps.equality_vs_assignment.requirements"
msgstr ""
"Run the program from the previous step, but replace any of the `==` with "
"just `=`."

msgid ""
"pages.UnderstandingProgramsWithSnoop.steps.print_tail_snoop.requirements"
msgstr ""
"Run the same program from the previous step, but use the `snoop` button "
"instead of the 'Run' button. Copy the program again if you might have "
"changed it."

msgid "pages.UsingVariables.steps.name_assign.requirements"
msgstr ""
"Run something similar to `word = 'Hello'`, but replace `word` with "
"`your_name`."

msgid "frontend.error_has_been_reported"
msgstr "The error has been reported."

msgid "frontend.give_feedback_from_menu"
msgstr "Give feedback from the top-left menu."

msgid "frontend.internal_error_start"
msgstr ""
"Oops, something went wrong! ${maybeErrorReported} Here's what you can do:"

msgid "frontend.refresh_and_try_again"
msgstr "Reload/refresh the page and try again."

msgid "frontend.try_running_code_again"
msgstr "Try running the code again."

msgid "frontend.try_using_different_browser"
msgstr "Try using a different browser."

msgid "frontend.assessment_lint"
msgstr "Found the following generic problem(s) in your code:"

msgid "frontend.assessment_passed_tests"
msgstr "On the bright side, your code passed ${num} test(s)!"
